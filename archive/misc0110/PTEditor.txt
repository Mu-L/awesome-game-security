Project Path: arc_misc0110_PTEditor_10kx5nqg

Source Tree:

```txt
arc_misc0110_PTEditor_10kx5nqg
├── LICENSE
├── Makefile
├── README.md
├── debian
│   ├── changelog
│   ├── compat
│   ├── control
│   ├── pteditor-dkms.dkms
│   └── rules
├── demos
│   ├── Makefile
│   ├── clear_bits.c
│   ├── map_pt.c
│   ├── map_pt_manual.c
│   ├── memmap.c
│   ├── nx.c
│   ├── performance.c
│   ├── tlb_test.c
│   ├── uncachable.c
│   └── virt2phys.c
├── doc
│   ├── Doxyfile
│   └── Makefile
├── driver
│   ├── PTEdit
│   │   ├── Driver.c
│   │   ├── PTEdit.inf
│   │   ├── PTEdit.vcxproj
│   │   └── PTEdit.vcxproj.filters
│   ├── PTEdit.sln
│   ├── PTEdit.sys
│   ├── PTEditorLoader
│   │   ├── PTEditorLoader.cpp
│   │   ├── PTEditorLoader.vcxproj
│   │   ├── PTEditorLoader.vcxproj.filters
│   │   └── PTEditorLoader.vcxproj.user
│   └── PTEditorLoader.sln
├── example.c
├── module
│   ├── Makefile
│   ├── pteditor.c
│   └── pteditor.h
├── ptedit.c
├── ptedit.h
├── ptedit_header.h
└── test
    ├── Makefile
    ├── tests.c
    └── utest.h

```

`LICENSE`:

```
MIT License

Copyright (c) 2018 Michael Schwarz

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

`Makefile`:

```
all: pteditor ptedit.o example header tests

header: module/pteditor.c module/pteditor.h ptedit.c ptedit.h
	echo "#pragma once" > ptedit_header.h
	cat module/pteditor.h ptedit.h ptedit.c | \
	sed -e 's/#include ".*"//g' -e "1i // Warning: this file was generated by make. DO NOT EDIT!" | sed 's/extern //g'| sed 's/#define ptedit_fnc/#define ptedit_fnc static/g' >> ptedit_header.h

pteditor: module/pteditor.c
	cd module && make

example: example.c header
	gcc -Wall -Wextra example.c -g -o example

demos: header pteditor
	cd demos && make

tests: header pteditor
	cd test && make

deb:
	dpkg-buildpackage

clean:
	cd module && make clean
	cd demos && make clean
	cd test && make clean
	rm -f example *.o

```

`README.md`:

```md
# PTEditor
![GitHub Actions](https://github.com/misc0110/PTEditor/actions/workflows/ci.yml/badge.svg)

A small library to modify all page-table levels of all processes from user space for x86_64 (Linux and Windows 10) and ARMv8 (Linux).
It also allows to read and program memory types (i.e., PATs on x86 and MAIRs on ARM).

# Installation

The library relies on the `pteditor` kernel module (Linux) or kernel driver (Windows). The kernel part is provided as source code for compilation (Linux and Windows), PPA (Linux), and as pre-built binary (Windows).
The library can be used by linking it to the application (see `example.c`) or as a single header (`ptedit_header.h`) which can be directly included (see the demos). 

### Install from PPA (Linux, recommended)

First, add the public key of the PPA and the PPA URL to the package manager, and update the package manager

    curl -s "https://misc0110.github.io/ppa/KEY.gpg" | sudo tee /etc/apt/trusted.gpg.d/pteditor.asc
    sudo curl -s -o /etc/apt/sources.list.d/misc0110.list "https://misc0110.github.io/ppa/file.list"
    sudo apt update

Then, simply install the kernel module

    sudo apt install pteditor-dkms


### Pre-Built Driver (Windows, recommended)
The repository also contains a pre-built driver for Windows 10 in the `driver` folder. 
To load the driver, you have to first disable secure boot and driver signature enforcement.

#### Temporarily Disable Driver Signature Enforcement
Hold the shift key while clicking on "Restart" in the start menu. This brings up a restart menu, where you can disable driver signature enforcement in "Troubleshoot > Advanced Options > Startup Settings". Press "Restart", and the in the startup settings press "7" or "F7" to disable driver signature enforcement. 
After the PC is started, the driver can be loaded. Keep in mind that the driver signature enforcement is enabled when the PC is rebooted. 

#### Permanently Disable Driver Signature Enforcement
To permanently disable driver signature enforcement, enable Windows test mode by entering 

    bcdedit /set testsigning on

in an administrator command prompt. To disable test mode, run

    bcdedit /set testsigning off

#### Loading the Driver
To load and active the driver, the repository contains a loader in `driver/PTEditorLoader`. Simply run 

    PTEditorLoader.exe
    
as an administrator. To unload the driver, run

    PTEditorLoader.exe --unload

Alternatively, you can also use any other driver-loading tool, e.g., OSRLoader or NoVirusThanks Kernel-Mode Driver Loader. 
    
### Install Kernel Part From Source

#### Linux
Building the kernel module requires the kernel headers of the kernel. On Ubuntu, they can be installed by running

    sudo apt install linux-headers-$(uname -r)

Both the library and the the kernel module can be build by running

    make
    
The resulting kernel module can be loaded using

    sudo insmod module/pteditor.ko
    
#### Windows
The kernel driver for Windows requires Visual Studio with Visual C++, the Windows SDK, and the Windows Driver Kit (WDK) to build. 
Using the Visual Studio project, the driver can then simply be built from Visual Studio. 


# Requirements

The library requires a recent Linux kernel (continuously tested on the current kernel for 20.04 (kernel 5.8), and 22.04 (kernel 5.15 and 6.2)) or Windows 10. 
It supports both x86_64 and ARMv8. 

The library does not rely on any other library. It uses only standard C functionality. 
On Linux, the library does not require root privileges, whereas on Windows it requires administrator privileges. 

# Test

To test whether the kernel part and the library works, the repository contains unit tests. 
The tests are found in the folder `test` and can be compiled with `make` (Linux) or Visual Studio (Windows). 

# Example

The basic functionality (`ptedit_init` and `ptedit_cleanup`) is always required. 
After the initialization, all functions provided by the library can be used. 

For examples see `example.c` or the examples in the `demo` folder.
The `demo` folder contains multiple examples:
* `memmap`: Starting from the root of paging, the demo iterates through all page tables of all levels and dumps the contents of the entries.
* `map_pt`: A Rowhamer exploit simulation, which maps the page table to a user-accessible address for manipulation.
* `uncachable`: This demos manipulates the memory type of a mapping to uncachable and back to cachable.
* `nx`: After setting a function to non-executable, it uses the page tables to make the function executable again.
* `virt2phys`: Converts a virtual to a physical address.
* `performance`: Measures how many addresses can be resolved per second.

# API

 Basic Functionality            | Descriptions
--------------------------------|---------------------------------------------
`int `[`ptedit_init`](#group__BASIC_1gad452cf561308666214c69fc5feb89a1c)`()`            | Initializes (and acquires) PTEditor kernel module
`void `[`ptedit_cleanup`](#group__BASIC_1ga1fc9e84e43f3b38c20ef46b7929603b8)`()`            | Releases PTEditor kernel module
`void `[`ptedit_use_implementation`](#group__BASIC_implementation)`(int implementation)`  | Select the PTEditor implementation to use

 Page tables            | Descriptions
--------------------------------|---------------------------------------------
`ptedit_entry_t `[`ptedit_resolve`](#group__PAGETABLE_1gaa9ddb5d90e97c441c4f85e20500ed718)`(void * address,pid_t pid)`            | Resolves the page-table entries of all levels for a virtual address of a given process.
`void `[`ptedit_update`](#group__PAGETABLE_1gae5343f4a3e4a57cbc9e2c4a29f6e4fa3)`(void * address,pid_t pid,ptedit_entry_t * vm)`            | Updates one or more page-table entries for a virtual address of a given process. The TLB for the given address is flushed after updating the entries.
`void `[`ptedit_pte_set_bit`](#group__PAGETABLE_1ga432b18b744413964e20df39ca5440985)`(void * address,pid_t pid,int bit)`            | Sets a bit directly in the PTE of an address.
`void `[`ptedit_pte_clear_bit`](#group__PAGETABLE_1gac728497512386cf17e9ca6ec31959160)`(void * address,pid_t pid,int bit)`            | Clears a bit directly in the PTE of an address.
`unsigned char `[`ptedit_pte_get_bit`](#group__PAGETABLE_1ga978d010f4278e953bdc84df3adc4eee2)`(void * address,pid_t pid,int bit)`            | Returns the value of a bit directly from the PTE of an address.
`size_t `[`ptedit_pte_get_pfn`](#group__PAGETABLE_1ga323e5f2c138ff70f4ed3ab4e96e6f3e3)`(void * address,pid_t pid)`            | Reads the PFN directly from the PTE of an address.
`void `[`ptedit_pte_set_pfn`](#group__PAGETABLE_1gaa7211a27e72e3a1d3d78fac4dee8bfd3)`(void * address,pid_t pid,size_t pfn)`            | Sets the PFN directly in the PTE of an address.
`TYPE `[`ptedit_cast`](#group__PAGETABLE_cast)`(size_t entry, TYPE)` | Casts a paging structure entry (e.g., page table) to a structure with easy access to its fields


System Info | Descriptions
--------------------------------|---------------------------------------------
`int `[`ptedit_get_pagesize`](#group__SYSTEMINFO_1ga943074fddc99eade63764b599cccc392)`()`            | Returns the default page size of the system

 Page frame numbers (PFN)       | Descriptions
--------------------------------|---------------------------------------------
`size_t `[`ptedit_set_pfn`](#group__PFN_1gabfeaa97dd03aee438ca6c1af01fe4c38)`(size_t entry,size_t pfn)`            | Returns a new page-table entry where the page-frame number (PFN) is replaced by the specified one.
`size_t `[`ptedit_get_pfn`](#group__PFN_1ga7073222a5bf1a7e4fa52823851ccd55c)`(size_t entry)`            | Returns the page-frame number (PFN) of a page-table entry.

 Physical pages       | Descriptions
--------------------------------|---------------------------------------------
`void `[`ptedit_read_physical_page`](#group__PHYSICALPAGE_1gaadee01c80dcb1a6a7523d46840ef72ac)`(size_t pfn,char * buffer)`            | Retrieves the content of a physical page.
`void `[`ptedit_write_physical_page`](#group__PHYSICALPAGE_1gab2ba740cbf618d678b61b57cd7827881)`(size_t pfn,char * content)`            | Replaces the content of a physical page.
`void * `[`ptedit_pmap`](#group__PHYSICALPAGE_pmap)`(size_t physical,size_t length)` | Map a physical address range to the virtual address space.

 Paging       | Descriptions
--------------------------------|---------------------------------------------
`size_t `[`ptedit_get_paging_root`](#group__PAGING_1gafa10370f4fd18023a2fbb5d7e1165913)`(pid_t pid)`            | Returns the root of the paging structure (i.e., CR3 on x86 and TTBR0 on ARM).
`void `[`ptedit_set_paging_root`](#group__PAGING_1ga3beb57ebbd407339c24bdb9c0d9ad406)`(pid_t pid,size_t root)`            | Sets the root of the paging structure (i.e., CR3 on x86 and TTBR0 on ARM).

 TLB/Barriers       | Descriptions
--------------------------------|---------------------------------------------
`void `[`ptedit_invalidate_tlb`](#group__BARRIERS_1gad2d64fa589bc626ba41ccf18c60d159f)`(void * address)`            | Invalidates the TLB entry of current process for a given address on all CPUs.
`void `[`ptedit_invalidate_tlb_pid`](#group__BARRIERS_1gad2d64fa589bc626ba41ccf18c60d159f)`(pid_t pid, void * address)`            | Invalidates the TLB for a given PID and address on all CPUs.
`void `[`ptedit_full_serializing_barrier`](#group__BARRIERS_1ga35efff6b34856596b467ef3a5075adc6)`()`            | A full serializing barrier which stops everything.
`int `[`ptedit_switch_tlb_invalidation`](#group__BARRIERS_1gad2d64fa589bc626ba41ccf18c60d159f)`(int implementation)`            | The implementation to use, either `PTEDITOR_TLB_INVALIDATION_KERNEL` or `PTEDITOR_TLB_INVALIDATION_CUSTOM` (unsupported on x86).

 Memory types (PATs/MAIRs)       | Descriptions
--------------------------------|---------------------------------------------
`size_t `[`ptedit_get_mts`](#group__MTS_1gabc5edcc9f4f7d6dc102885135e70d2a3)`()`            | Reads the value of all memory types (x86 PATs / ARM MAIRs). This is equivalent to reading the MSR 0x277 (x86) / MAIR_EL1 (ARM).
`void `[`ptedit_set_mts`](#group__MTS_1gadfcac191bb1d27970c0182435a0f52ec)`(size_t mts)`            | Programs the value of all memory types (x86 PATs / ARM MAIRs). This is equivalent to writing to the MSR 0x277 (x86) / MAIR_EL1 (ARM) on all CPUs.
`char `[`ptedit_get_mt`](#group__MTS_1gaf44dbabdc9bc0eba6118b77544cd475e)`(unsigned char mt)`            | Reads the value of a specific memory type attribute (PAT/MAIR).
`void `[`ptedit_set_mt`](#group__MTS_1ga27ec8d49e5417d1c5fefe07df5488351)`(unsigned char mt,unsigned char value)`            | Programs the value of a specific memory type attribute (PAT/MAIR).
`unsigned char `[`ptedit_find_mt`](#group__MTS_1ga7b2e13ba66791be9413b3d00e6107ca8)`(unsigned char type)`            | Generates a bitmask of all memory type attributes (PAT/MAIR) which are programmed to the given value.
`int `[`ptedit_find_first_mt`](#group__MTS_1ga12456ca2dfe5cf1fa049af91b51f75c4)`(unsigned char type)`            | Returns the first memory type attribute (PAT/MAIR) which is programmed to the given memory type.
`size_t `[`ptedit_apply_mt`](#group__MTS_1ga8ae0242de0315431c377db0aae5e511e)`(size_t entry,unsigned char mt)`            | Returns a new page-table entry which uses the given memory type (PAT/MAIR).
`unsigned char `[`ptedit_extract_mt`](#group__MTS_1ga14dc1a89a89dfbf7c4def93e616bbd83)`(size_t entry)`            | Returns the memory type (i.e., PAT/MAIR ID) which is used by a page-table entry.
`size_t `[`ptedit_apply_mt_huge`](#group__MTS_1ga8ae0242de0315431c377db0aae5e511e)`(size_t entry,unsigned char mt)`            | Returns a new entry for a huge page which uses the given memory type (PAT/MAIR).
`unsigned char `[`ptedit_extract_mt_huge`](#group__MTS_1ga14dc1a89a89dfbf7c4def93e616bbd83)`(size_t entry)`            | Returns the memory type (i.e., PAT/MAIR ID) which is used by a huge-page entry.
`const char * `[`ptedit_mt_to_string`](#group__MTS_1gab8c7af3fab13d3255239d31bb2e8723f)`(unsigned char mt)`            | Returns a human-readable representation of a memory type (PAT/MAIR value).

 Pretty print       | Descriptions
--------------------------------|---------------------------------------------
`void `[`ptedit_print_entry`](#group__PRETTYPRINT_1ga458b51988f705885bdade4dc9d7b0ca4)`(size_t entry)`            | Pretty prints a page-table entry.
`void `[`ptedit_print_entry_line`](#group__PRETTYPRINT_1ga5d45507efaa51dcb9647e27a2d7bd281)`(size_t entry,int line)`            | Prints a single line of the pretty-print representation of a page-table entry.

## Basic Functionality

### `int `[`ptedit_init`](#group__BASIC_1gad452cf561308666214c69fc5feb89a1c)`()`

Initializes (and acquires) PTEditor kernel module

**Returns**
0 Initialization was successful

**Returns**
-1 Initialization failed

### `void `[`ptedit_cleanup`](#group__BASIC_1ga1fc9e84e43f3b38c20ef46b7929603b8)`()`

Releases PTEditor kernel module

### `void `[`ptedit_use_implementation`](#group__BASIC_implementation)`(int implementation)`  

Select the PTEditor implementation to use

**Parameters**
* `implementation` The implementation to use. Depending on the operating system and architecture, one or more of the following are supported: `PTEDIT_IMPL_KERNEL`, `PTEDIT_IMPL_USER`, `PTEDIT_IMPL_USER_PREAD`. 
  * `PTEDIT_IMPL_KERNEL` uses the kernel functionality to resolve and update page tables (default on Linux).
  * `PTEDIT_IMPL_USER` maps the physical memory to user space and only requires switches to the kernel for flushing the TLB after page-table updates.
  * `PTEDIT_IMPL_USER_PREAD` implements the page walk in user space but relies on the kernel for reading and writing physical addresses (default on Windows). 

## Page tables

### `ptedit_entry_t `[`ptedit_resolve`](#group__PAGETABLE_1gaa9ddb5d90e97c441c4f85e20500ed718)`(void * address,pid_t pid)`

Resolves the page-table entries of all levels for a virtual address of a given process.

**Parameters**
* `address` The virtual address to resolve

* `pid` The pid of the process (0 for own process)

**Returns**
A structure containing the page-table entries of all levels.

### `void `[`ptedit_update`](#group__PAGETABLE_1gae5343f4a3e4a57cbc9e2c4a29f6e4fa3)`(void * address,pid_t pid,ptedit_entry_t * vm)`

Updates one or more page-table entries for a virtual address of a given process. The TLB for the given address is flushed after updating the entries.

**Parameters**
* `address` The virtual address

* `pid` The pid of the process (0 for own process)

* `vm` A structure containing the values for the page-table entries and a bitmask indicating which entries to update

### `void `[`ptedit_pte_set_bit`](#group__PAGETABLE_1ga432b18b744413964e20df39ca5440985)`(void * address,pid_t pid,int bit)`

Sets a bit directly in the PTE of an address.

**Parameters**
* `address` The virtual address

* `pid` The pid of the process (0 for own process)

* `bit` The bit to set (one of PTEDIT_PAGE_BIT_*)

### `void `[`ptedit_pte_clear_bit`](#group__PAGETABLE_1gac728497512386cf17e9ca6ec31959160)`(void * address,pid_t pid,int bit)`

Clears a bit directly in the PTE of an address.

**Parameters**
* `address` The virtual address

* `pid` The pid of the process (0 for own process)

* `bit` The bit to clear (one of PTEDIT_PAGE_BIT_*)

### `unsigned char `[`ptedit_pte_get_bit`](#group__PAGETABLE_1ga978d010f4278e953bdc84df3adc4eee2)`(void * address,pid_t pid,int bit)`

Returns the value of a bit directly from the PTE of an address.

**Parameters**
* `address` The virtual address

* `pid` The pid of the process (0 for own process)

* `bit` The bit to get (one of PTEDIT_PAGE_BIT_*)

**Returns**
The value of the bit (0 or 1)

### `size_t `[`ptedit_pte_get_pfn`](#group__PAGETABLE_1ga323e5f2c138ff70f4ed3ab4e96e6f3e3)`(void * address,pid_t pid)`

Reads the PFN directly from the PTE of an address.

**Parameters**
* `address` The virtual address

* `pid` The pid of the process (0 for own process)

**Returns**
The page-frame number (PFN)

### `void `[`ptedit_pte_set_pfn`](#group__PAGETABLE_1gaa7211a27e72e3a1d3d78fac4dee8bfd3)`(void * address,pid_t pid,size_t pfn)`

Sets the PFN directly in the PTE of an address.

**Parameters**
* `address` The virtual address

* `pid` The pid of the process (0 for own process)

* `pfn` The new page-frame number (PFN)

## `TYPE `[`ptedit_cast`](#group__PAGETABLE_cast)`(size_t entry, TYPE)`

Casts a paging structure entry (e.g., page table) to a structure with easy access to its fields.

**Parameters**
* `entry` The entry to cast

* `type` Data type of struct to cast to, one of `ptedit_pgd_t`, `ptedit_p4d_t`, `ptedut_pud_t`, `ptedit_pmd_t`, `ptedit_pte_t`

**Returns**
A struct of type `type` which has bit-fields for the parts of the corresponding paging structure. 


## System info

### `int `[`ptedit_get_pagesize`](#group__SYSTEMINFO_1ga943074fddc99eade63764b599cccc392)`()`

Returns the default page size of the system

**Returns**
Page size of the system in bytes

## Page frame numbers (PFN)

### `size_t `[`ptedit_set_pfn`](#group__PFN_1gabfeaa97dd03aee438ca6c1af01fe4c38)`(size_t entry,size_t pfn)`

Returns a new page-table entry where the page-frame number (PFN) is replaced by the specified one.

**Parameters**
* `entry` The page-table entry to modify

* `pfn` The new page-frame number (PFN)

**Returns**
A new page-table entry with the given page-frame number

### `size_t `[`ptedit_get_pfn`](#group__PFN_1ga7073222a5bf1a7e4fa52823851ccd55c)`(size_t entry)`

Returns the page-frame number (PFN) of a page-table entry.

**Parameters**
* `entry` The page-table entry to extract the PFN from

**Returns**
The page-frame number

## Physical pages

### `void `[`ptedit_read_physical_page`](#group__PHYSICALPAGE_1gaadee01c80dcb1a6a7523d46840ef72ac)`(size_t pfn,char * buffer)`

Retrieves the content of a physical page.

**Parameters**
* `pfn` The page-frame number (PFN) of the page to read

* `buffer` A buffer which is large enough to hold the content of the page

### `void `[`ptedit_write_physical_page`](#group__PHYSICALPAGE_1gab2ba740cbf618d678b61b57cd7827881)`(size_t pfn,char * content)`

Replaces the content of a physical page.

**Parameters**
* `pfn` The page-frame number (PFN) of the page to update

* `content` A buffer containing the new content of the page (must be the size of a physical page)

### `void * `[`ptedit_pmap`](#group__PHYSICALPAGE_pmap)`(size_t physical,size_t length)`

Map a physical address range to the virtual address space.

**Parameters**
* `physical` The physical address to map

* `length` The length of the physical memory range to map

**Returns**
A virtual address that can be used to access the physical address.

**Note**
This function is not supported on Windows. 

## Paging


### `size_t `[`ptedit_get_paging_root`](#group__PAGING_1gafa10370f4fd18023a2fbb5d7e1165913)`(pid_t pid)`

Returns the root of the paging structure (i.e., CR3 on x86 and TTBR0 on ARM).

**Parameters**
* `pid` The proccess id (0 for own process)

**Returns**
The phyiscal address (not PFN!) of the first page table (i.e., the PGD)

### `void `[`ptedit_set_paging_root`](#group__PAGING_1ga3beb57ebbd407339c24bdb9c0d9ad406)`(pid_t pid,size_t root)`

Sets the root of the paging structure (i.e., CR3 on x86 and TTBR0 on ARM).

**Parameters**
* `pid` The proccess id (0 for own process)

* `root` The physical address (not PFN!) of the first page table (i.e., the PGD)

## TLB/Barriers

### `void `[`ptedit_invalidate_tlb`](#group__BARRIERS_1gad2d64fa589bc626ba41ccf18c60d159f)`(void * address)`

Invalidates the TLB for a given address on all CPUs.

**Parameters**
* `address` The address to invalidate

### `void `[`ptedit_full_serializing_barrier`](#group__BARRIERS_1ga35efff6b34856596b467ef3a5075adc6)`()`

A full serializing barrier which stops everything.

## Memory types (PATs/MAIRs)

### `size_t `[`ptedit_get_mts`](#group__MTS_1gabc5edcc9f4f7d6dc102885135e70d2a3)`()`

Reads the value of all memory types (x86 PATs / ARM MAIRs). This is equivalent to reading the MSR 0x277 (x86) / MAIR_EL1 (ARM).

**Returns**
The memory types in the same format as in the IA32_PAT MSR / MAIR_EL1

### `void `[`ptedit_set_mts`](#group__MTS_1gadfcac191bb1d27970c0182435a0f52ec)`(size_t mts)`

Programs the value of all memory types (x86 PATs / ARM MAIRs). This is equivalent to writing to the MSR 0x277 (x86) / MAIR_EL1 (ARM) on all CPUs.

**Parameters**
* `mts` The memory types in the same format as in the IA32_PAT MSR / MAIR_EL1

### `char `[`ptedit_get_mt`](#group__MTS_1gaf44dbabdc9bc0eba6118b77544cd475e)`(unsigned char mt)`

Reads the value of a specific memory type attribute (PAT/MAIR).

**Parameters**
* `mt` The PAT/MAIR ID (from 0 to 7)

**Returns**
The PAT/MAIR value (can be one of PTEDIT_MT_*)

### `void `[`ptedit_set_mt`](#group__MTS_1ga27ec8d49e5417d1c5fefe07df5488351)`(unsigned char mt,unsigned char value)`

Programs the value of a specific memory type attribute (PAT/MAIR).

**Parameters**
* `mt` The PAT/MAIR ID (from 0 to 7)

* `value` The PAT/MAIR value (can be one of PTEDIT_MT_*)

### `unsigned char `[`ptedit_find_mt`](#group__MTS_1ga7b2e13ba66791be9413b3d00e6107ca8)`(unsigned char type)`

Generates a bitmask of all memory type attributes (PAT/MAIR) which are programmed to the given value.

**Parameters**
* `type` A memory type, i.e., PAT/MAIR value (one of PTEDIT_MT_*)

**Returns**
A bitmask where a set bit indicates that the corresponding PAT/MAIR has the given type

### `int `[`ptedit_find_first_mt`](#group__MTS_1ga12456ca2dfe5cf1fa049af91b51f75c4)`(unsigned char type)`

Returns the first memory type attribute (PAT/MAIR) which is programmed to the given memory type.

**Parameters**
* `type` A memory type, i.e., PAT/MAIR value (one of PTEDIT_MT_*)

**Returns**
A PAT/MAIR ID, or -1 if no PAT/MAIR of this type was found

### `size_t `[`ptedit_apply_mt`](#group__MTS_1ga8ae0242de0315431c377db0aae5e511e)`(size_t entry,unsigned char mt)`

Returns a new page-table entry which uses the given memory type (PAT/MAIR).

**Parameters**
* `entry` A page-table entry

* `mt` A PAT/MAIR ID (between 0 and 7)

**Returns**
A new page-table entry with the given memory type (PAT/MAIR)

### `unsigned char `[`ptedit_extract_mt`](#group__MTS_1ga14dc1a89a89dfbf7c4def93e616bbd83)`(size_t entry)`

Returns the memory type (i.e., PAT/MAIR ID) which is used by a page-table entry.

**Parameters**
* `entry` A page-table entry

**Returns**
A PAT/MAIR ID (between 0 and 7)

### `size_t `[`ptedit_apply_mt_huge`](#group__MTS_1ga8ae0242de0315431c377db0aae5e511e)`(size_t entry,unsigned char mt)`

Returns a new entry for a huge page which uses the given memory type (PAT/MAIR).

**Parameters**
* `entry` A page-table entry

* `mt` A PAT/MAIR ID (between 0 and 7)

**Returns**
A new page-table entry with the given memory type (PAT/MAIR)

### `unsigned char `[`ptedit_extract_mt`](#group__MTS_1ga14dc1a89a89dfbf7c4def93e616bbd83)`(size_t entry)`

Returns the memory type (i.e., PAT/MAIR ID) which is used by a huge-page entry.

**Parameters**
* `entry` A page-table entry

**Returns**
A PAT/MAIR ID (between 0 and 7)

### `const char * `[`ptedit_mt_to_string`](#group__MTS_1gab8c7af3fab13d3255239d31bb2e8723f)`(unsigned char mt)`

Returns a human-readable representation of a memory type (PAT/MAIR value).

**Parameters**
* `mt` A memory type (PAT/MAIR value, e.g., one of PTEDIT_MT_*)

**Returns**
A human-readable representation of the memory type

## Pretty print

### `void `[`ptedit_print_entry`](#group__PRETTYPRINT_1ga458b51988f705885bdade4dc9d7b0ca4)`(size_t entry)`

Pretty prints a page-table entry.

**Parameters**
* `entry` A page-table entry

### `void `[`ptedit_print_entry_line`](#group__PRETTYPRINT_1ga5d45507efaa51dcb9647e27a2d7bd281)`(size_t entry,int line)`

Prints a single line of the pretty-print representation of a page-table entry.

**Parameters**
* `entry` A page-table entry

* `line` The line to print (0 to 3)

# Use in Academic Papers

* [Efficient and Generic Microarchitectural Hash-Function Recovery](https://misc0110.net/files/hash_recovery_sp24.pdf) by Gerlach, Schwarz, Faroß, Schwarz (IEEE S&P 2024)
* [Downfall: Exploiting Speculative Data Gathering](https://www.usenix.org/system/files/usenixsecurity23-moghimi.pdf) by Moghimi (USENIX Security 2023)
* [Collide+Power: Leaking Inaccessible Data with Software-based Power Side Channels](https://misc0110.net/files/collidepower_sec23.pdf) by Kogler, Juffinger, Giner, Gerlach, Schwarzl, Schwarz, Gruss, Mangard (USENIX Security 2023)
* [(M)WAIT for It: Bridging the Gap between Microarchitectural and Architectural Side Channels](https://misc0110.net/files/mwait_sec23.pdf) by Zhang, Kim, Weber, Schwarz (USENIX Security 2023)
* [Indirect Meltdown: Building Novel Side-Channel Attacks from Transient Execution Attacks]() by Weber, Thomas, Gerlach, Zhang, Schwarz (ESORICS 2023)
* [Layered Binary Templating](https://gruss.cc/files/lbta.pdf) by Schwarzl, Kraft, Gruss (ACNS 2023)
* [ÆPIC Leak: Architecturally Leaking Uninitialized Data from the Microarchitecture](https://misc0110.net/files/aepicleak_sec22.pdf) by Borrello, Kogler, Schwarzl, Lipp, Gruss, Schwarz (USENIX Security 2022)
* [Finding and Exploiting CPU Features using MSR Templating](https://misc0110.net/files/msrtemplate_sp22.pdf) by Kogler, Weber, Haubenwallner, Lipp, Gruss, Schwarz (IEEE S&P 2022)
* [Half-Double: Hammering From the Next Row Over](https://andreaskogler.com/papers/halfdouble.pdf) by Kogler, Juffinger, Qazi, Kim, Lipp, Boichat, Shiu, Nissler, Gruss (USENIX Security 2022)
* [AMD Prefetch Attacks through Power and Time](https://misc0110.net/files/amd_prefetch_sec22.pdf) by Lipp, Gruss, Schwarz (USENIX Security 2022)
* [Repurposing Segmentation as a Practical LVI-NULL Mitigation in SGX](https://misc0110.net/files/lvi_null_sec22.pdf) by Giner, Kogler, Canella, Schwarz, Gruss (USENIX Security 2022)
* [Rapid Prototyping for Microarchitectural Attacks](https://misc0110.net/files/rapid_prototyping_sec22.pdf) by Easdon, Schwarz, Schwarzl, Gruss (USENIX Security 2022)
* [SGXDump: A Repeatable Code-Reuse Attack for Extracting SGX Enclave Memory](https://doi.org/10.3390/app12157655) by Yoon, Lee (Applied Sciences, 2022)
* [SAM: A Mechanism to Facilitate Smear-Aware Forensic Analysis of Volatile System Memory](https://www.tandfonline.com/doi/abs/10.1080/19361610.2022.2161972) by Parida, Nath, Das (Journal of Applied Security Research, 2022)
* [Protected Functions: User Space Privileged Function Calls](https://link.springer.com/chapter/10.1007/978-3-031-21867-5_8) by Moti, Salkhordeh, Brinkmann (ARCS 2022)
* [Systematic Analysis of Programming Languages and Their Execution Environments for Spectre Attacks](https://sahnaseredini.github.io/files/icissp22_spectre_naseredini.pdf) by Naseredini, Gast, Schwarzl, Bernardo, Amel Smajic, Canella, Berger, Gruss (ICISSP 2021)
* [Domain Page-Table Isolation](https://arxiv.org/pdf/2111.10876.pdf) by Canella, Kogler, Giner, Gruss, Schwarz (arXiv 2021)
* [PLATYPUS: Software-based Power Side-Channel Attacks on x86](https://misc0110.net/files/platypus.pdf) by Lipp, Kogler, Oswald, Schwarz, Easdon, Canella, Gruss (IEEE S&P 2021)
* [Speculative Dereferencing of Registers: Reviving Foreshadow](https://misc0110.net/files/specderef.pdf) by Schwarzl, Schuster, Schwarz, Gruss (FC 2021)
* [Understanding TEE Containers, Easy to Use? Hard to Trust](https://arxiv.org/pdf/2109.01923) by Liu, Chen, Wang, Li, Zhang, Wang, Tang (arXiv 2021)
* [Simurgh: A Fully Decentralized and Secure NVMM User Space File System](https://dl.acm.org/doi/pdf/10.1145/3458817.3476180) by Moti, Schimmelpfennig, Salkhordeh, Klopp, Cortes, Rückert, Brinkmann (ACM SC 2021)
* [Improving Address Translation Performance in Virtualized Multi-Tenant Systems](https://era.ed.ac.uk/bitstream/handle/1842/38624/Margaritov2021.pdf) by Margaritov (PhD Thesis 2021)
* [How Trusted Execution Environments Fuel Research on Microarchitectural Attacks](https://misc0110.net/files/tee_uarch.pdf) by Schwarz and Gruss (IEEE Security & Privacy 2020)
* [LVI: Hijacking Transient Execution through Microarchitectural Load Value Injection](https://misc0110.net/files/lvi.pdf) by Van Bulck, Moghimi, Schwarz, Lipp, Minkin, Genkin, Yarom, Sunar, Gruss, Piessens (IEEE S&P 2020)
* [Data Sampling on MDS-resistant 10th Generation Intel Core (Ice Lake)](https://moghimi.org/papers/techreport2020-IceLakeMDS.pdf) by Moghimi (arXiv 2020)
* [Medusa: Microarchitectural Data Leakage via Automated Attack Synthesis](https://misc0110.net/files/medusa.pdf) by Moghimi, Lipp, Sunar, Schwarz (USENIX Security 2020)
* [KASLR: Break It, Fix It, Repeat](https://misc0110.net/files/kaslrbfr.pdf) by Canella, Schwarz, Haubenwallner, Schwarzl, Gruss (AsiaCCS 2020)
* [JackHammer: Efficient Rowhammer on Heterogeneous FPGA-CPU Platforms](https://tches.iacr.org/index.php/TCHES/article/view/8587/8154) by Weissman, Tiemann, Moghimi, Custodio, Eisenbarth, Sunar (TCHES 2020)
* [ConTExT: A Generic Approach for Mitigating Spectre](https://misc0110.net/files/context.pdf) by Schwarz, Lipp, Canella, Schilling, Kargl, Gruss (NDSS 2020)
* [ZombieLoad: Cross-Privilege-Boundary Data Sampling](https://misc0110.net/files/zombieload.pdf) by Schwarz, Lipp, Moghimi, Van Bulck, Stecklina, Prescher, Gruss (CCS 2019)
* [Fallout: Leaking Data on Meltdown-resistant CPUs](https://misc0110.net/files/fallout.pdf) by Canella, Genkin, Giner, Gruss, Lipp, Minkin, Moghimi, Piessens, Schwarz, Sunar, Van Bulck, Yarom (CCS 2019)
* [A Systematic Evaluation of Transient Execution Attacks and Defenses](https://misc0110.net/files/transient_execution_attacks.pdf) by Canella, Van Bulck, Schwarz, Lipp, von Berg, Ortner, Piessens, Evtyushkin, Gruss (USENIX Security 2019)



```

`debian/changelog`:

```
pteditor-dkms (0.7) bionic; urgency=medium

  * Fixes for kernel 6.5 and newer

pteditor-dkms (0.6) bionic; urgency=medium

  * Fixes for kernel 6.2
  * Fixes for multiple inclusions

pteditor-dkms (0.5) bionic; urgency=medium

  * Allow multiple inclusions of the header
  * Fixes for Microsoft Azure
  * Fixed locking
  * Fixes for TLB invalidation

pteditor-dkms (0.4.3) bionic; urgency=medium

  * Fixed handling of 2MB large pages

 -- Michael Schwarz <michael.schwarz91@gmail.com>  Fri, 18 Jun 2021 11:34:56 +0100

pteditor-dkms (0.4.2) bionic; urgency=medium

  * Fixes for Ubuntu 20.10

 -- Michael Schwarz <michael.schwarz91@gmail.com>  Tue, 17 Nov 2020 20:04:58 +0100

pteditor-dkms (0.4.1) bionic; urgency=medium

  * Fixes for Ubuntu minimal cloud image

 -- Michael Schwarz <michael.schwarz91@gmail.com>  Mon, 26 Oct 2020 09:46:37 +0100

pteditor-dkms (0.4) bionic; urgency=medium

  * Fixes for several kernel versions, fixed C warnings, and added C++ compatibility

 -- Michael Schwarz <michael.schwarz91@gmail.com>  Sat, 17 Oct 2020 23:28:14 +0100

pteditor-dkms (0.3.4) bionic; urgency=medium

  * Updated for kernel 5.9

 -- Michael Schwarz <michael.schwarz91@gmail.com>  Wed, 30 Sep 2020 08:34:24 +0100

pteditor-dkms (0.3.3) bionic; urgency=medium

  * Updated for kernel 5.8

 -- Michael Schwarz <michael.schwarz91@gmail.com>  Wed, 09 Sep 2020 11:02:11 +0100

pteditor-dkms (0.3.2) bionic; urgency=medium

  * Updated for kernel 5.7

 -- Michael Schwarz <michael.schwarz91@gmail.com>  Fri, 28 Aug 2020 08:43:50 +0100

pteditor-dkms (0.3.1) bionic; urgency=medium

  * Updated for kernel 5.6

 -- Michael Schwarz <michael.schwarz91@gmail.com>  Thu, 14 Apr 2020 21:36:16 +0100

pteditor-dkms (0.2) bionic; urgency=medium

  * Initial package.

 -- Michael Schwarz <michael.schwarz91@gmail.com>  Sun, 29 Mar 2020 17:10:02 +0100

```

`debian/compat`:

```
9 

```

`debian/control`:

```
Source: pteditor-dkms
Maintainer: Michael Schwarz <michael.schwarz91@gmail.com>
Build-Depends: debhelper (>= 9), dkms

Package: pteditor-dkms
Architecture: all
Depends: ${misc:Depends}
Description: DKMS source for PTEditor

```

`debian/pteditor-dkms.dkms`:

```dkms
PACKAGE_NAME="pteditor"
PACKAGE_VERSION="#MODULE_VERSION#"
BUILT_MODULE_NAME[0]="$PACKAGE_NAME"
DEST_MODULE_LOCATION[0]="/updates/dkms"
AUTOINSTALL="YES"
REMAKE_INITRD="YES" 

```

`debian/rules`:

```
#!/usr/bin/make -f

include /usr/share/dpkg/pkg-info.mk

%:
	dh $@ --with dkms

override_dh_install:
	dh_install module/* usr/src/pteditor-$(DEB_VERSION_UPSTREAM)/

override_dh_dkms:
	dh_dkms -V $(DEB_VERSION_UPSTREAM)

override_dh_auto_configure:
override_dh_auto_build:
override_dh_auto_test:
override_dh_auto_install:
override_dh_auto_clean: 

```

`demos/Makefile`:

```
SRC=$(wildcard *.c)
BIN=$(SRC:.c=)

all: $(BIN)
% : %.c
	gcc $< -o $@
	
clean:
	rm -f $(BIN) *.o

```

`demos/clear_bits.c`:

```c
#include <stdio.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

#include "../ptedit_header.h"


int main(int argc, char** argv)
{
  if (ptedit_init()) {
      printf("Error: Could not initalize PTEditor, did you load the kernel module?\n");
      return 1;
  }
  
  unsigned char* addr = (unsigned char*) mmap(NULL,2*1024*1024, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
  memset(addr,0x42,2*1024*1024);
  
  ptedit_entry_t entry = ptedit_resolve(addr, 0);
  ptedit_pte_clear_bit(addr, 0, PTEDIT_PAGE_BIT_ACCESSED);
  entry = ptedit_resolve(addr, 0);
  ptedit_print_entry(entry.pte);
  ptedit_print_entry(entry.pmd);
  ptedit_print_entry(entry.pud);
  ptedit_pte_set_bit(addr, 0, PTEDIT_PAGE_BIT_ACCESSED);
  entry = ptedit_resolve(addr, 0);
  ptedit_print_entry(entry.pte);
  ptedit_print_entry(entry.pmd);
  ptedit_print_entry(entry.pud);

  //set accessed bit of pd entry
  size_t address_pfn = ptedit_get_pfn(entry.pd);
  ptedit_pte_set_bit(addr, 0, PTEDIT_PAGE_BIT_ACCESSED);
  munmap(addr,4096);

  ptedit_cleanup();

  return 0;
}

```

`demos/map_pt.c`:

```c
#include <memory.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>

#include "../ptedit_header.h"

#define COLOR_RED "\x1b[31m"
#define COLOR_GREEN "\x1b[32m"
#define COLOR_YELLOW "\x1b[33m"
#define COLOR_RESET "\x1b[0m"

#define TAG_OK COLOR_GREEN "[+]" COLOR_RESET " "
#define TAG_FAIL COLOR_RED "[-]" COLOR_RESET " "
#define TAG_PROGRESS COLOR_YELLOW "[~]" COLOR_RESET " "

int main(int argc, char *argv[]) {
  char *pt;
  char *target = mmap(0, 4096, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  char *secret = mmap(0, 4096, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);

  memset(target, 'B', 4096);
  memset(secret, 'S', 4096);

  if (ptedit_init()) {
    printf(TAG_FAIL "Error: Could not initalize PTEditor, did you load the kernel module?\n");
    return 1;
  }

  ptedit_entry_t secret_entry = ptedit_resolve(secret, 0);

  /* "target" uses the manipulated page-table entry */
  ptedit_entry_t target_entry = ptedit_resolve(target, 0);
  ptedit_print_entry(target_entry.pte);

  /* "pt" should map the page table corresponding to "target" */
  size_t pt_pfn = ptedit_cast(target_entry.pmd, ptedit_pmd_t).pfn;
  pt = ptedit_pmap(pt_pfn * ptedit_get_pagesize(), ptedit_get_pagesize());
  printf(TAG_PROGRESS "PT mapped at %p\n", pt);
  
  /* "target" entry is bits 12 to 20 of "target" virtual address */
  size_t entry = (((size_t)target) >> 12) & 0x1ff;
  printf(TAG_PROGRESS "Entry: %zd\n", entry);
  size_t *mapped_entry = ((size_t *)pt) + entry;

  /* "mapped_entry" is a user-space-accessible pointer to the PTE of "target" */
  if (*mapped_entry != target_entry.pte) {
    printf(TAG_FAIL "Something went wrong...\n");
  } else {
    printf(TAG_OK "Worked!\n");
  }

  /* let "target" point to "secret" */
  *mapped_entry = ptedit_set_pfn(*mapped_entry, ptedit_get_pfn(secret_entry.pte));
  ptedit_invalidate_tlb(target);

  printf(TAG_PROGRESS "Target[0]: %c\n", *target);
  if (*target == 'S') {
    printf(TAG_OK "Success!\n");
  } else {
    printf(TAG_FAIL "Fail!\n");
  }

  /* reset "target" entry */
  *mapped_entry = target_entry.pte;

  ptedit_cleanup();

  printf(TAG_OK "Done\n");
}

```

`demos/map_pt_manual.c`:

```c
#include <memory.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/mman.h>

#include "../ptedit_header.h"

#define COLOR_RED "\x1b[31m"
#define COLOR_GREEN "\x1b[32m"
#define COLOR_YELLOW "\x1b[33m"
#define COLOR_RESET "\x1b[0m"

#define TAG_OK COLOR_GREEN "[+]" COLOR_RESET " "
#define TAG_FAIL COLOR_RED "[-]" COLOR_RESET " "
#define TAG_PROGRESS COLOR_YELLOW "[~]" COLOR_RESET " "

int main(int argc, char *argv[]) {
  char *pt = mmap(0, 4096, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  char *target = mmap(0, 4096, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  char *secret = mmap(0, 4096, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);

  memset(pt, 'A', 4096);
  memset(target, 'B', 4096);
  memset(secret, 'S', 4096);

  if (ptedit_init()) {
    printf(TAG_FAIL "Error: Could not initalize PTEditor, did you load the kernel module?\n");
    return 1;
  }

  ptedit_entry_t secret_entry = ptedit_resolve(secret, 0);

  /* "target" uses the manipulated page-table entry */
  ptedit_entry_t target_entry = ptedit_resolve(target, 0);
  ptedit_print_entry(target_entry.pte);

  /* "pt" should map the page table corresponding to "target" */
  ptedit_entry_t pt_entry = ptedit_resolve(pt, 0);
  size_t old_pte = pt_entry.pte;

  /* -> set page-table PFN of "pt" to page-directory PFN of "target" */
  pt_entry.pte = ptedit_set_pfn(pt_entry.pte, ptedit_get_pfn(target_entry.pmd));

  pt_entry.valid = PTEDIT_VALID_MASK_PTE;
  ptedit_update(pt, 0, &pt_entry);

  /* "target" entry is bits 12 to 20 of "target" virtual address */
  size_t entry = (((size_t)target) >> 12) & 0x1ff;
  printf(TAG_PROGRESS "Entry: %zd\n", entry);
  size_t *mapped_entry = ((size_t *)pt) + entry;

  /* "mapped_entry" is a user-space-accessible pointer to the PTE of "target" */
  if (*mapped_entry != target_entry.pte) {
    printf(TAG_FAIL "Something went wrong...\n");
  } else {
    printf(TAG_OK "Worked!\n");
  }

  /* let "target" point to "secret" */
  *mapped_entry = ptedit_set_pfn(*mapped_entry, ptedit_get_pfn(secret_entry.pte));
  ptedit_invalidate_tlb(target);

  printf(TAG_PROGRESS "Target[0]: %c\n", *target);
  if (*target == 'S') {
    printf(TAG_OK "Success!\n");
  } else {
    printf(TAG_FAIL "Fail!\n");
  }

  /* reset "target" entry */
  *mapped_entry = target_entry.pte;

  /* reset mapping */
  pt_entry.pte = old_pte;
  pt_entry.valid = PTEDIT_VALID_MASK_PTE;
  ptedit_update(pt, 0, &pt_entry);

  ptedit_cleanup();

  printf(TAG_OK "Done\n");
}

```

`demos/memmap.c`:

```c
#include <stdio.h>

#include "../ptedit_header.h"

int is_present(size_t entry) {
#if defined(__i386__) || defined(__x86_64__)
  return entry & (1ull << PTEDIT_PAGE_BIT_PRESENT);
#elif defined(__aarch64__)
  return (entry & 3) == 3;
#endif
}

int is_normal_page(size_t entry) {
#if defined(__i386__) || defined(__x86_64__)
  return !(entry & (1ull << PTEDIT_PAGE_BIT_PSE));
#elif defined(__aarch64__)
  return 1;
#endif
}

#if defined(__i386__) || defined(__x86_64__)
#define FIRST_LEVEL_ENTRIES 256 // only 256, because upper half is kernel
#elif defined(__aarch64__)
#define FIRST_LEVEL_ENTRIES 512
#endif

void dump(int do_dump, size_t entry, char *type) {
  if (do_dump) {
    for (int i = 0; i < 4; i++) {
      printf("%s", type);
      ptedit_print_entry_line(entry, i);
    }
  }
}

int main(int argc, char *argv[]) {
  if (ptedit_init()) {
    printf("Error: Could not initalize PTEditor, did you load the kernel module?\n");
    return 1;
  }

  int dump_entry = 1;
  size_t pid = 0;
  if (argc >= 2) {
    pid = atoi(argv[1]);
  }

  printf("Dumping PID %zd\n", pid);

  size_t root = ptedit_get_paging_root(pid);
  size_t pagesize = ptedit_get_pagesize();
  size_t pml4[pagesize / sizeof(size_t)], pdpt[pagesize / sizeof(size_t)],
      pd[pagesize / sizeof(size_t)], pt[pagesize / sizeof(size_t)];

  ptedit_read_physical_page(root / pagesize, (char *)pml4);

  int pml4i, pdpti, pdi, pti;
  size_t mem_usage = 0;

  /* Iterate through PML4 entries */
  for (pml4i = 0; pml4i < FIRST_LEVEL_ENTRIES; pml4i++) {
    size_t pml4_entry = pml4[pml4i];
    if (!is_present(pml4_entry))
      continue;
    dump(dump_entry, pml4_entry, "");

#if defined(__i386__) || defined(__x86_64__)
    /* Iterate through PDPT entries */
    ptedit_read_physical_page(ptedit_get_pfn(pml4_entry), (char *)pdpt);
    for (pdpti = 0; pdpti < 512; pdpti++) {
      size_t pdpt_entry = pdpt[pdpti];
      if (!is_present(pdpt_entry))
        continue;
      dump(dump_entry, pdpt_entry, "PDPT");
#elif defined(__aarch64__)
      size_t pdpt_entry = pml4_entry;
#endif

      /* Iterate through PD entries */
      ptedit_read_physical_page(ptedit_get_pfn(pdpt_entry), (char *)pd);
      for (pdi = 0; pdi < 512; pdi++) {
        size_t pd_entry = pd[pdi];
        if (!is_present(pd_entry))
          continue;
        dump(dump_entry, pd_entry, "    PD  ");

        /* Normal 4kb page */
        if (is_normal_page(pd_entry)) {
          /* Iterate through PT entries */
          ptedit_read_physical_page(ptedit_get_pfn(pd_entry), (char *)pt);
          for (pti = 0; pti < 512; pti++) {
            size_t pt_entry = pt[pti];
            if (!is_present(pt_entry))
              continue;
            dump(dump_entry, pt_entry, "        PT  ");
#if defined(__i386__) || defined(__x86_64__)
            printf("            -> %zx\n", ((size_t)pti << 12) | ((size_t)pdi << 21) | ((size_t)pdpti << 30) | ((size_t)pml4i << 39));
#elif defined(__aarch64__)
            printf("            -> %zx\n", ((size_t)pti << 12) | ((size_t)pdi << 21) | ((size_t)pml4i << 30));
#endif
            mem_usage += 4096;
          }
        } else {
          /* Large 2MB page (no PT) */
          printf("        -> %zx\n", ((size_t)pdi << 21) | ((size_t)pdpti << 30) | ((size_t)pml4i << 39));
          mem_usage += 2 * 1024 * 1024;
        }
      }
#if defined(__i386__) || defined(__x86_64__)
    }
#endif
  }

  printf("Used memory: %zd KB\n", mem_usage / 1024);

  ptedit_cleanup();
}

```

`demos/nx.c`:

```c
#include <stdio.h>
#include <sys/mman.h>
#include <sys/wait.h>

#include "../ptedit_header.h"

#define NOP16                                                                  \
  asm volatile("nop\nnop\nnop\nnop\nnop\nnop\nnop\nnop\nnop\nnop\nnop\nnop\nn" \
               "op\nnop\nnop\nnop\n");
#define NOP256                                                                 \
  NOP16 NOP16 NOP16 NOP16 NOP16 NOP16 NOP16 NOP16 NOP16 NOP16 NOP16 NOP16      \
      NOP16 NOP16 NOP16 NOP16
#define NOP4K                                                                  \
  NOP256 NOP256 NOP256 NOP256 NOP256 NOP256 NOP256 NOP256 NOP256 NOP256 NOP256 \
      NOP256 NOP256 NOP256 NOP256 NOP256

#define COLOR_RED "\x1b[31m"
#define COLOR_GREEN "\x1b[32m"
#define COLOR_YELLOW "\x1b[33m"
#define COLOR_RESET "\x1b[0m"

#define TAG_OK COLOR_GREEN "[+]" COLOR_RESET " "
#define TAG_FAIL COLOR_RED "[-]" COLOR_RESET " "
#define TAG_PROGRESS COLOR_YELLOW "[~]" COLOR_RESET " "

void nx_function() {
  NOP4K
  printf("Hello\n");
  NOP4K
}

#if defined(__i386__) || defined(__x86_64__)
#define NX_BIT PTEDIT_PAGE_BIT_NX
#elif defined(__aarch64__)
#define NX_BIT PTEDIT_PAGE_BIT_XN
#endif



int main(int argc, char *argv[]) {
  /* Get 4kb-aligned pointer to function */
  void *nx_function_aligned = (void *)((((size_t)nx_function) + 4096) & ~0xfff);

  printf(TAG_PROGRESS "Expect 'Hello': ");
  nx_function();

  /* Make function non-executable (calling it now leads to crash) */
  mprotect(nx_function_aligned, 4096, PROT_READ);

  pid_t pid = fork();

  if (pid) {
    /* parent process */
    if (ptedit_init()) {
      printf(TAG_FAIL "Error: Could not initalize PTEditor, did you load the kernel module?\n");
      return 1;
    }

    /* wait for child to access the function s.t. it has its own copy (-> copy
     * on write) */
    sleep(1);

    /* verify that child's copy is non-executable */
    printf(TAG_PROGRESS "Child entry should have NX bit set\n");

    if (ptedit_pte_get_bit(nx_function_aligned, pid, NX_BIT)) {
      printf(TAG_OK "Child mapping is non-executable\n");
    } else {
      printf(TAG_FAIL "Child mapping is executable\n");
    }

    /* clear the non-executable (NX) bit and update child's page-table entry */
    printf(TAG_PROGRESS "Clearing child's NX bit...\n");
    ptedit_pte_clear_bit(nx_function_aligned, pid, NX_BIT);

    printf(TAG_PROGRESS "Check NX bit of child\n");

    if (ptedit_pte_get_bit(nx_function_aligned, pid, NX_BIT)) {
      printf(TAG_FAIL "Child mapping is still non-executable\n");
    } else {
      printf(TAG_OK "Child mapping is executable\n");
    }

    /* verify that own page-tabel entry is still non-executable */
    printf(TAG_OK "Own entry should have NX bit set\n");

    if (ptedit_pte_get_bit(nx_function_aligned, 0, NX_BIT)) {
      printf(TAG_OK "Own mapping is non-executable\n");
    } else {
      printf(TAG_FAIL "Own mapping is executable\n");
    }

    ptedit_cleanup();

    /* wait for child */
    int status = 0;
    waitpid(pid, &status, 0);
    if (WIFEXITED(status)) {
      printf(TAG_OK "Success\n");
    } else {
      printf(TAG_FAIL "Fail\n");
    }
    printf(TAG_OK "Done\n");
  } else {
    // child
    if (*(unsigned char *)nx_function_aligned) {
      printf(TAG_OK "Function is mapped\n");
    } else {
      printf(TAG_FAIL "Function is not mapped in child!\n");
    }
    sleep(2);
    printf(TAG_PROGRESS "Executing previously non-executable function\n");
    nx_function();
    printf(TAG_OK "Child exited normally!\n");
  }
}

```

`demos/performance.c`:

```c
#include <stdio.h>
#include <stdint.h>
#include <memory.h>

#include "../ptedit_header.h"

#define COLOR_RED "\x1b[31m"
#define COLOR_GREEN "\x1b[32m"
#define COLOR_YELLOW "\x1b[33m"
#define COLOR_RESET "\x1b[0m"

#define TAG_OK COLOR_GREEN "[+]" COLOR_RESET " "
#define TAG_FAIL COLOR_RED "[-]" COLOR_RESET " "
#define TAG_PROGRESS COLOR_YELLOW "[~]" COLOR_RESET " "

unsigned long target;


uint64_t rdtsc() {
#if defined(__i386__) || defined(__x86_64__)
  uint64_t a, d;
  asm volatile("mfence");
  asm volatile("rdtsc" : "=a"(a), "=d"(d));
  a = (d << 32) | a;
  asm volatile("mfence");
  return a;
#elif defined(__aarch64__)
#include <time.h>
  struct timespec t1;
  clock_gettime(CLOCK_MONOTONIC, &t1);
  return t1.tv_sec * 1000 * 1000 * 1000ULL + t1.tv_nsec;
#endif
}

#define REPEAT 10000

int is_same(ptedit_entry_t* e1, ptedit_entry_t* e2) {
    int diff = 0;
    if((e1->valid & PTEDIT_VALID_MASK_PGD) && (e2->valid & PTEDIT_VALID_MASK_PGD)) {
        diff |= e1->pgd ^ e2->pgd;
    }
    if((e1->valid & PTEDIT_VALID_MASK_P4D) && (e2->valid & PTEDIT_VALID_MASK_P4D)) {
        diff |= e1->p4d ^ e2->p4d;
    }    
    if((e1->valid & PTEDIT_VALID_MASK_PUD) && (e2->valid & PTEDIT_VALID_MASK_PUD)) {
        diff |= e1->pud ^ e2->pud;
    }
    if((e1->valid & PTEDIT_VALID_MASK_PMD) && (e2->valid & PTEDIT_VALID_MASK_PMD)) {
        diff |= e1->pmd ^ e2->pmd;
    }
    if((e1->valid & PTEDIT_VALID_MASK_PTE) && (e2->valid & PTEDIT_VALID_MASK_PTE)) {
        diff |= e1->pte ^ e2->pte;
    }
    return !diff;
}

int main(int argc, char *argv[]) {
    if (ptedit_init()) {
      printf(TAG_FAIL "Error: Could not initalize PTEditor, did you load the kernel module?\n");
      return 1;
    }

    target = 'X';
    size_t phys = 0;

    int i;
    ptedit_entry_t entry, entry_us;
    uint64_t start, stop;
    
    ptedit_use_implementation(PTEDIT_IMPL_KERNEL);
    start = rdtsc();
    for(i = 0; i < REPEAT; i++) {
        entry = ptedit_resolve(&target, 0);
    }
    stop = rdtsc();
    printf(TAG_OK "Kernel implementation takes " COLOR_YELLOW "%d" COLOR_RESET " cycles/resolve\n", (int)((stop - start) / REPEAT));
    
    ptedit_use_implementation(PTEDIT_IMPL_USER);
    start = rdtsc();
    for(i = 0; i < REPEAT; i++) {
        entry_us = ptedit_resolve(&target, 0);
    }
    stop = rdtsc();
    printf(TAG_OK "User implementation takes " COLOR_YELLOW "%d" COLOR_RESET " cycles/resolve\n", (int)((stop - start) / REPEAT));

    if(!is_same(&entry, &entry_us)) {
        printf(TAG_FAIL "Kernel and user-space resolver do not agree!\n");
        ptedit_print_entry_t(entry);
        ptedit_print_entry_t(entry_us);
    }
    
    ptedit_use_implementation(PTEDIT_IMPL_USER_PREAD);
    start = rdtsc();
    for(i = 0; i < REPEAT; i++) {
        entry_us = ptedit_resolve(&target, 0);
    }
    stop = rdtsc();
    printf(TAG_OK "User (pread) implementation takes " COLOR_YELLOW "%d" COLOR_RESET " cycles/resolve\n", (int)((stop - start) / REPEAT));

    if(!is_same(&entry, &entry_us)) {
        printf(TAG_FAIL "Kernel and user-space resolver do not agree!\n");
        ptedit_print_entry_t(entry);
        ptedit_print_entry_t(entry_us);
    }
    
    
    ptedit_cleanup();

    printf(TAG_OK "Done\n");
}

```

`demos/tlb_test.c`:

```c
#include <stdio.h>
#include <stdint.h>
#include <memory.h>

#include "../ptedit_header.h"

#define COLOR_RED "\x1b[31m"
#define COLOR_GREEN "\x1b[32m"
#define COLOR_YELLOW "\x1b[33m"
#define COLOR_RESET "\x1b[0m"

#define TAG_OK COLOR_GREEN "[+]" COLOR_RESET " "
#define TAG_FAIL COLOR_RED "[-]" COLOR_RESET " "
#define TAG_PROGRESS COLOR_YELLOW "[~]" COLOR_RESET " "

#define REPEAT 10000

uint64_t rdtsc() {
#if defined(__i386__) || defined(__x86_64__)
  uint64_t a, d;
  asm volatile("mfence");
  asm volatile("rdtsc" : "=a"(a), "=d"(d));
  a = (d << 32) | a;
  asm volatile("mfence");
  return a;
#elif defined(__aarch64__)
#include <time.h>
  struct timespec t1;
  clock_gettime(CLOCK_MONOTONIC, &t1);
  return t1.tv_sec * 1000 * 1000 * 1000ULL + t1.tv_nsec;
#endif
}

void maccess(void *p) { asm volatile("movq (%0), %%rax\n" : : "c"(p) : "rax"); }

int main(int argc, char *argv[]) {
    unsigned long target = 'X';
    if (ptedit_init()) {
      printf(TAG_FAIL "Error: Could not initalize PTEditor, did you load the kernel module?\n");
      return 1;
    }

    printf(TAG_OK "Setting TLB invalidation method to kernel version\n");
    ptedit_switch_tlb_invalidation(PTEDITOR_TLB_INVALIDATION_KERNEL);

    size_t total = 0;
    for(int i=0; i<REPEAT; i++) {
        maccess(&target);
        size_t start = rdtsc();
        ioctl(ptedit_fd, PTEDITOR_IOCTL_CMD_INVALIDATE_TLB, (size_t)&target);
        total += rdtsc() - start;
    }
    printf(TAG_OK "TLB invalidation: %f\n", ((float)total)/REPEAT);

    printf(TAG_OK "Setting TLB invalidation method to kernel version\n");
    ptedit_switch_tlb_invalidation(PTEDITOR_TLB_INVALIDATION_CUSTOM);

    for(int i=0; i<REPEAT; i++) {
        maccess(&target);
        size_t start = rdtsc();
        ioctl(ptedit_fd, PTEDITOR_IOCTL_CMD_INVALIDATE_TLB, (size_t)&target);
        total += rdtsc() - start;
    }
    printf(TAG_OK "TLB invalidation: %f\n", ((float)total)/REPEAT);

    ptedit_cleanup();

    printf(TAG_OK "Done\n");
}

```

`demos/uncachable.c`:

```c
#include <memory.h>
#include <stdint.h>
#include <stdio.h>
#include <sys/mman.h>

#include "../ptedit_header.h"

#ifndef MAP_HUGE_2MB
#if defined(LINUX)
#include <linux/mman.h>
#endif
#ifndef MAP_HUGE_2MB
#define MAP_HUGE_2MB (21 << 26)
#endif
#endif

#define COLOR_RED "\x1b[31m"
#define COLOR_GREEN "\x1b[32m"
#define COLOR_YELLOW "\x1b[33m"
#define COLOR_RESET "\x1b[0m"

#define TAG_OK COLOR_GREEN "[+]" COLOR_RESET " "
#define TAG_FAIL COLOR_RED "[-]" COLOR_RESET " "
#define TAG_PROGRESS COLOR_YELLOW "[~]" COLOR_RESET " "

#define MEASUREMENTS 1000000

// ---------------------------------------------------------------------------
void dump_mts() {
  size_t mts = ptedit_get_mts();
  printf("MTs (raw): %zx\n", mts);
  int i;
  for (i = 0; i < 8; i++) {
    printf("MT%d: %d -> %s\n", i, ptedit_get_mt(i),
           ptedit_mt_to_string(ptedit_get_mt(i)));
  }
}

#if defined(__i386__) || defined(__x86_64__)
// ---------------------------------------------------------------------------
uint64_t rdtsc() {
  uint64_t a, d;
  asm volatile("mfence");
  asm volatile("rdtsc" : "=a"(a), "=d"(d));
  a = (d << 32) | a;
  asm volatile("mfence");
  return a;
}

// ---------------------------------------------------------------------------
void flush(void *p) { asm volatile("clflush 0(%0)\n" : : "c"(p) : "rax"); }

// ---------------------------------------------------------------------------
void maccess(void *p) { asm volatile("movq (%0), %%rax\n" : : "c"(p) : "rax"); }

// ---------------------------------------------------------------------------
void mfence() { asm volatile("mfence"); }
#elif defined(__aarch64__)
#include <time.h>
// ---------------------------------------------------------------------------
uint64_t rdtsc() {
#if 1
  struct timespec t1;
  clock_gettime(CLOCK_MONOTONIC, &t1);
  return t1.tv_sec * 1000 * 1000 * 1000ULL + t1.tv_nsec;
#else
  uint64_t result = 0;

  asm volatile("DSB SY");
  asm volatile("ISB");
  asm volatile("MRS %0, PMCCNTR_EL0" : "=r"(result));
  asm volatile("DSB SY");
  asm volatile("ISB");

  return result;
#endif
}

// ---------------------------------------------------------------------------
void flush(void *p) {
  asm volatile("DC CIVAC, %0" ::"r"(p));
  asm volatile("DSB ISH");
  asm volatile("ISB");
}

// ---------------------------------------------------------------------------
void maccess(void *p) {
  volatile uint32_t value;
  asm volatile("LDR %0, [%1]\n\t" : "=r"(value) : "r"(p));
  asm volatile("DSB ISH");
}

// ---------------------------------------------------------------------------
void mfence() { asm volatile("DSB ISH"); }
#endif

// ---------------------------------------------------------------------------
int access_time(void *ptr) {
  uint64_t start = 0, end = 0, sum = 0;

  for (int i = 0; i < MEASUREMENTS; i++) {
    start = rdtsc();
    maccess(ptr);
    end = rdtsc();
    sum += end - start;
  }

  return (int)(sum / MEASUREMENTS);
}

// ---------------------------------------------------------------------------
int main() {
  char *pt = mmap(0, 4096, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  memset(pt, 'A', 4096);

  if (ptedit_init()) {
    printf(TAG_FAIL "Error: Could not initalize PTEditor, did you load the kernel module?\n");
    return 1;
  }

  ptedit_entry_t entry = ptedit_resolve(pt, 0);
  ptedit_print_entry(entry.pte);
  printf(TAG_OK "Mapping is %s\n", ptedit_mt_to_string(ptedit_get_mt(ptedit_extract_mt(entry.pte))));

  flush(pt);
  printf(TAG_PROGRESS "Average access time: " COLOR_YELLOW "%d" COLOR_RESET " cycles\n", access_time(pt));

  dump_mts();

  int uc_mt = ptedit_find_first_mt(PTEDIT_MT_UC);
  if (uc_mt != -1) {
    printf(TAG_OK "%d MTs for UC (first is MT%d)\n", __builtin_popcount(ptedit_find_mt(PTEDIT_MT_UC)), uc_mt);
  } else {
    printf(TAG_FAIL "No UC MT available!\n");
    goto error;
  }

  entry.pte = ptedit_apply_mt(entry.pte, uc_mt);
  entry.valid = PTEDIT_VALID_MASK_PTE;
  ptedit_update(pt, 0, &entry);

  printf(TAG_OK "Mapping should now be uncachable\n");

  flush(pt);
  printf(TAG_PROGRESS "Average access time: " COLOR_YELLOW "%d" COLOR_RESET " cycles\n", access_time(pt));

  int wb_mt = ptedit_find_first_mt(PTEDIT_MT_WB);
  if (wb_mt != -1) {
    printf(TAG_OK "%d MTs for WB (first is MT%d)\n", __builtin_popcount(ptedit_find_mt(PTEDIT_MT_WB)), wb_mt);
  } else {
    printf(TAG_FAIL "No WB MT available!\n");
    goto error;
  }

  entry.pte = ptedit_apply_mt(entry.pte, wb_mt);
  entry.valid = PTEDIT_VALID_MASK_PTE;
  ptedit_update(pt, 0, &entry);

  printf(TAG_OK "Mapping should now be cachable again\n");

  flush(pt);
  printf(TAG_PROGRESS "Average access time: " COLOR_YELLOW "%d" COLOR_RESET " cycles\n", access_time(pt));

  char* huge_page = mmap(0, (2*1024*1024), PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS|MAP_POPULATE|MAP_HUGETLB|MAP_HUGE_2MB, -1, 0);
  if (huge_page != MAP_FAILED) {
    printf(TAG_OK "Allocated huge page\n");

    ptedit_entry_t huge_entry = ptedit_resolve(huge_page, 0);
    ptedit_print_entry_t(huge_entry);
    unsigned char mt = ptedit_extract_mt_huge(huge_entry.pmd);
    printf(TAG_OK "Mapping is %s\n", ptedit_mt_to_string(ptedit_get_mt(mt)));
    size_t original_pmd = huge_entry.pmd;

    flush(huge_page);
    printf(TAG_PROGRESS "Average access time: " COLOR_YELLOW "%d" COLOR_RESET " cycles\n", access_time(huge_page));

    huge_entry.pmd = ptedit_apply_mt_huge(huge_entry.pmd, uc_mt);
    huge_entry.valid = PTEDIT_VALID_MASK_PMD;
    ptedit_update(huge_page, 0, &huge_entry);

    printf(TAG_OK "Mapping should now be uncachable\n");

    flush(huge_page);
    printf(TAG_PROGRESS "Average access time: " COLOR_YELLOW "%d" COLOR_RESET " cycles\n", access_time(huge_page));

    huge_entry.pmd = original_pmd;
    huge_entry.valid = PTEDIT_VALID_MASK_PMD;
    ptedit_update(huge_page, 0, &huge_entry);

    printf(TAG_OK "Mapping should now be cachable again\n");

    flush(huge_page);
    printf(TAG_PROGRESS "Average access time: " COLOR_YELLOW "%d" COLOR_RESET " cycles\n", access_time(huge_page));

    munmap(huge_page, (2*1024*1024));
  } else {
    printf(TAG_FAIL "Note: Could not allocate huge page.\n");
  }

error:
  ptedit_cleanup();
  printf(TAG_OK "Done\n");
}

```

`demos/virt2phys.c`:

```c
#include <stdio.h>

#include "../ptedit_header.h"

#define COLOR_RED "\x1b[31m"
#define COLOR_GREEN "\x1b[32m"
#define COLOR_YELLOW "\x1b[33m"
#define COLOR_RESET "\x1b[0m"

#define TAG_OK COLOR_GREEN "[+]" COLOR_RESET " "
#define TAG_FAIL COLOR_RED "[-]" COLOR_RESET " "
#define TAG_PROGRESS COLOR_YELLOW "[~]" COLOR_RESET " "

unsigned long target;

int is_normal_page(size_t entry) {
#if defined(__i386__) || defined(__x86_64__)
  return !(entry & (1ull << PTEDIT_PAGE_BIT_PSE));
#elif defined(__aarch64__)
  return 1;
#endif
}

int main(int argc, char *argv[]) {
    if (ptedit_init()) {
      printf(TAG_FAIL "Error: Could not initalize PTEditor, did you load the kernel module?\n");
      return 1;
    }

    target = 'X';
    size_t phys = 0;

    ptedit_entry_t entry = ptedit_resolve(&target, 0);

    if(is_normal_page(entry.pd)) {
        printf(TAG_PROGRESS "Page is 4KB\n");
        ptedit_print_entry(entry.pte);
        phys = (ptedit_get_pfn(entry.pte) << 12) | (((size_t)&target) & 0xfff);
    } else {
        printf(TAG_PROGRESS "Page is 2MB\n");
        ptedit_print_entry(entry.pd);
        phys = (ptedit_get_pfn(entry.pd) << 12) | (((size_t)&target) & 0x1fffff);
    }

    printf(TAG_OK "Virtual address: %p\n", &target);
    printf(TAG_OK "Physical address: 0x%zx\n", phys);

    ptedit_cleanup();

    printf(TAG_OK "Done\n");
}

```

`doc/Doxyfile`:

```
# See LICENSE file for license and copyright information

# General information
PROJECT_NAME          = PTEdit
OUTPUT_DIRECTORY      = ./doxygen/
OUTPUT_LANGUAGE       = English
TAB_SIZE              = 2
EXTRACT_ALL           = NO
OPTIMIZE_OUTPUT_FOR_C = YES
DOXYFILE_ENCODING     = UTF-8
TYPEDEF_HIDES_STRUCT  = YES

# Warning and progress messages
QUIET                = YES
WARNINGS             = YES
WARN_IF_UNDOCUMENTED = YES

# Input files
INPUT         = ../
FILE_PATTERNS = ptedit.h
RECURSIVE     = YES

# Output files
GENERATE_HTML  = YES
GENERATE_LATEX = NO
GENERATE_RTF   = NO
GENERATE_XML   = YES

```

`doc/Makefile`:

```
all:
	doxygen
	moxygen doxygen/xml
	sed -i s/Summary/API/g api.md
	sed -i 's/public //g' api.md
	sed -i 's/#### `/### `/g' api.md
	sed -i 's/#### Returns/**Returns**/g' api.md
	sed -i 's/#### Parameters/**Parameters**/g' api.md


clean:
	rm -rf api.md doxygen
```

`driver/PTEdit.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.29926.136
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "PTEdit", "PTEdit\PTEdit.vcxproj", "{04DCF770-AB2F-42EC-A9EE-BF44C47445C2}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{04DCF770-AB2F-42EC-A9EE-BF44C47445C2}.Debug|ARM.ActiveCfg = Debug|ARM
		{04DCF770-AB2F-42EC-A9EE-BF44C47445C2}.Debug|ARM.Build.0 = Debug|ARM
		{04DCF770-AB2F-42EC-A9EE-BF44C47445C2}.Debug|ARM.Deploy.0 = Debug|ARM
		{04DCF770-AB2F-42EC-A9EE-BF44C47445C2}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{04DCF770-AB2F-42EC-A9EE-BF44C47445C2}.Debug|ARM64.Build.0 = Debug|ARM64
		{04DCF770-AB2F-42EC-A9EE-BF44C47445C2}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{04DCF770-AB2F-42EC-A9EE-BF44C47445C2}.Debug|x64.ActiveCfg = Debug|x64
		{04DCF770-AB2F-42EC-A9EE-BF44C47445C2}.Debug|x64.Build.0 = Debug|x64
		{04DCF770-AB2F-42EC-A9EE-BF44C47445C2}.Debug|x64.Deploy.0 = Debug|x64
		{04DCF770-AB2F-42EC-A9EE-BF44C47445C2}.Debug|x86.ActiveCfg = Debug|x64
		{04DCF770-AB2F-42EC-A9EE-BF44C47445C2}.Debug|x86.Build.0 = Debug|x64
		{04DCF770-AB2F-42EC-A9EE-BF44C47445C2}.Debug|x86.Deploy.0 = Debug|x64
		{04DCF770-AB2F-42EC-A9EE-BF44C47445C2}.Release|ARM.ActiveCfg = Release|ARM
		{04DCF770-AB2F-42EC-A9EE-BF44C47445C2}.Release|ARM.Build.0 = Release|ARM
		{04DCF770-AB2F-42EC-A9EE-BF44C47445C2}.Release|ARM.Deploy.0 = Release|ARM
		{04DCF770-AB2F-42EC-A9EE-BF44C47445C2}.Release|ARM64.ActiveCfg = Release|ARM64
		{04DCF770-AB2F-42EC-A9EE-BF44C47445C2}.Release|ARM64.Build.0 = Release|ARM64
		{04DCF770-AB2F-42EC-A9EE-BF44C47445C2}.Release|ARM64.Deploy.0 = Release|ARM64
		{04DCF770-AB2F-42EC-A9EE-BF44C47445C2}.Release|x64.ActiveCfg = Release|x64
		{04DCF770-AB2F-42EC-A9EE-BF44C47445C2}.Release|x64.Build.0 = Release|x64
		{04DCF770-AB2F-42EC-A9EE-BF44C47445C2}.Release|x64.Deploy.0 = Release|x64
		{04DCF770-AB2F-42EC-A9EE-BF44C47445C2}.Release|x86.ActiveCfg = Release|Win32
		{04DCF770-AB2F-42EC-A9EE-BF44C47445C2}.Release|x86.Build.0 = Release|Win32
		{04DCF770-AB2F-42EC-A9EE-BF44C47445C2}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {D596A4A2-AB28-4713-A87B-201196B373DA}
	EndGlobalSection
EndGlobal

```

`driver/PTEdit/Driver.c`:

```c
#include "ntifs.h"
#include "ntddk.h"

#define PTEDITOR_READ_PAGE CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define PTEDITOR_WRITE_PAGE CTL_CODE(FILE_DEVICE_UNKNOWN, 0x802, METHOD_BUFFERED, FILE_READ_DATA)
#define PTEDITOR_GET_CR3 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x803, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define PTEDITOR_SET_CR3 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x807, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define PTEDITOR_FLUSH_TLB CTL_CODE(FILE_DEVICE_UNKNOWN, 0x804, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define PTEDITOR_READ_PHYS_VAL CTL_CODE(FILE_DEVICE_UNKNOWN, 0x805, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define PTEDITOR_WRITE_PHYS_VAL CTL_CODE(FILE_DEVICE_UNKNOWN, 0x806, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define PTEDITOR_SET_PAT CTL_CODE(FILE_DEVICE_UNKNOWN, 0x808, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define PTEDITOR_GET_PAT CTL_CODE(FILE_DEVICE_UNKNOWN, 0x809, METHOD_BUFFERED, FILE_ANY_ACCESS)

UNICODE_STRING DeviceName = RTL_CONSTANT_STRING(L"\\Device\\PTEditor");
UNICODE_STRING SymLinkName = RTL_CONSTANT_STRING(L"\\??\\PTEditorLink");

PDEVICE_OBJECT DeviceObject = NULL;

#define IA32_PAT 0x277

#define TAG_INFO "[PTEditor:Info] "
#define TAG_WARN "[PTEditor:Warning] "
#define TAG_ERROR "[PTEditor:ERROR] "

VOID Unload(_In_ PDRIVER_OBJECT DriverObject) {
    UNREFERENCED_PARAMETER(DriverObject);

    IoDeleteSymbolicLink(&SymLinkName);
    IoDeleteDevice(DeviceObject);

    DbgPrint(TAG_INFO "PTEditor unloaded\r\n");
}

__pragma(pack(push, 1))
typedef struct {
    char content[4096];
    size_t paddr;
} PageContent;
__pragma(pack(pop))

static ULONG_PTR invalidate_tlb(ULONG_PTR addr) {
    __invlpg((void*)addr);
    return (ULONG_PTR)NULL;
}

static ULONG_PTR set_pat(ULONG_PTR pat) {
    __writemsr(IA32_PAT, pat);
    return (ULONG_PTR)NULL;
}

NTSTATUS DispatchDeviceCtl(PDEVICE_OBJECT DevObject, PIRP Irp) {
    UNREFERENCED_PARAMETER(DevObject);

    PIO_STACK_LOCATION irpsp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status = STATUS_SUCCESS;
    ULONG returnLength = 0;
    PVOID buffer = Irp->AssociatedIrp.SystemBuffer;
    PEPROCESS Process;
    SIZE_T transferred;
    MM_COPY_ADDRESS mem;
    PageContent* content;
    PHYSICAL_ADDRESS pa;
    SIZE_T val;
    PVOID vaddr;

    switch (irpsp->Parameters.DeviceIoControl.IoControlCode) {
    case PTEDITOR_WRITE_PAGE:
        content = (PageContent*)buffer;
        DbgPrint(TAG_INFO "write page %zx\r\n", content->paddr);
        pa.QuadPart = content->paddr;
        vaddr = MmGetVirtualForPhysical(pa);
        mem.VirtualAddress = (PVOID)(content->content);
        DbgPrint(TAG_INFO " virtual address to write to: %zx\r\n", vaddr);
        if (vaddr) {
            MmCopyMemory(vaddr, mem, 4096, MM_COPY_MEMORY_VIRTUAL, &transferred);
        }
        else {
            DbgPrint(TAG_WARN " could not write to page!\r\n");
        }
        returnLength = 0;
        break;
    case PTEDITOR_READ_PAGE:
        DbgPrint(TAG_INFO "read page %zx\r\n", *(SIZE_T*)buffer);
        mem.PhysicalAddress = *(PHYSICAL_ADDRESS*)buffer;
        MmCopyMemory(buffer, mem, 4096, MM_COPY_MEMORY_PHYSICAL, &transferred);
        returnLength = 4096;
        break;
    case PTEDITOR_GET_CR3:
        DbgPrint(TAG_INFO "get CR3 for %zx\r\n", *((SIZE_T*)buffer));
        if(PsLookupProcessByProcessId((HANDLE)(*((PHANDLE)buffer)), &Process) == STATUS_SUCCESS) {
            KAPC_STATE apcState;
            KeStackAttachProcess(Process, &apcState);
            SIZE_T cr3 = __readcr3();
            KeUnstackDetachProcess(&apcState);
            DbgPrint(TAG_INFO " -> CR3: %zx\r\n", cr3);
            *((SIZE_T*)buffer) = cr3;
        }
        else {
            DbgPrint(TAG_WARN "could not find process!\r\n");
            *((SIZE_T*)buffer) = 0;
        }
        returnLength = sizeof(SIZE_T);
        break;
    case PTEDITOR_SET_CR3:
        DbgPrint(TAG_INFO "set CR3 for %zx\r\n", *((SIZE_T*)buffer));
        if(PsLookupProcessByProcessId((HANDLE)(*((PHANDLE)buffer)), &Process) == STATUS_SUCCESS) {
            KAPC_STATE apcState;
            KeStackAttachProcess(Process, &apcState);
            __writecr3(*(((SIZE_T*)buffer) + 1));
            KeUnstackDetachProcess(&apcState);
            DbgPrint(TAG_INFO " -> new CR3: %zx\r\n", *(((SIZE_T*)buffer) + 1));
        }
        else {
            DbgPrint(TAG_WARN "could not find process!\r\n");
        }
        returnLength = 0;
    case PTEDITOR_FLUSH_TLB:
        DbgPrint(TAG_INFO "flush TLB for %zx\r\n", *((SIZE_T*)buffer));
        KeIpiGenericCall(invalidate_tlb, (ULONG_PTR)(*(SIZE_T*)buffer));
        returnLength = 0;
        break;
    case PTEDITOR_READ_PHYS_VAL:
        DbgPrint(TAG_INFO "read physical value %zx\r\n", *(SIZE_T*)buffer);
        mem.PhysicalAddress = *(PHYSICAL_ADDRESS*)buffer;
        MmCopyMemory(buffer, mem, sizeof(SIZE_T), MM_COPY_MEMORY_PHYSICAL, &transferred);
        returnLength = sizeof(SIZE_T);
        break;
    case PTEDITOR_WRITE_PHYS_VAL:
        val = *(((SIZE_T*)buffer) + 1);
        DbgPrint(TAG_INFO "write physical value %zx to %zx\r\n", val, *(SIZE_T*)buffer);
        pa.QuadPart = *(SIZE_T*)buffer;
        vaddr = MmGetVirtualForPhysical(pa);
        if (vaddr) {
            *(SIZE_T*)vaddr = val;
        }
        else {
            DbgPrint(TAG_WARN "could not write to address!\r\n");
        }
        returnLength = 0;
        break;
    case PTEDITOR_GET_PAT:
        *(SIZE_T*)buffer = __readmsr(IA32_PAT); 
        returnLength = sizeof(SIZE_T);
        break;
    case PTEDITOR_SET_PAT:
        KeIpiGenericCall(set_pat, (ULONG_PTR)(*(SIZE_T*)buffer));
        returnLength = 0;
        break;
    default:
        status = STATUS_INVALID_PARAMETER;
        break;
    }

    Irp->IoStatus.Information = returnLength;
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}

NTSTATUS DispatchPassThru(PDEVICE_OBJECT DevObject, PIRP Irp) {
    UNREFERENCED_PARAMETER(DevObject);

    PIO_STACK_LOCATION irpsp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status = STATUS_SUCCESS;

    switch (irpsp->MajorFunction) {
    case IRP_MJ_CREATE:
        DbgPrint(TAG_INFO "PTEditor create\r\n");
        break;
    case IRP_MJ_CLOSE:
        DbgPrint(TAG_INFO "PTeditor close\r\n");
        break;
    case IRP_MJ_CLEANUP:
        DbgPrint(TAG_INFO "No application uses PTeditor anymore\r\n");
        break;
    default:
        DbgPrint(TAG_WARN "Invalid major function %d\r\n", irpsp->MajorFunction);
        status = STATUS_INVALID_PARAMETER;
        break;
    }

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}


NTSTATUS DriverEntry(_In_ PDRIVER_OBJECT  DriverObject, _In_ PUNICODE_STRING RegistryPath) {
    UNREFERENCED_PARAMETER(RegistryPath);
    int i;

    DriverObject->DriverUnload = Unload;

    DbgPrint(TAG_INFO "Initializing PTEditor!\r\n");

    NTSTATUS status;

    status = IoCreateDevice(DriverObject, 0, &DeviceName, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &DeviceObject);
    if (!NT_SUCCESS(status)) {
        DbgPrint(TAG_ERROR "Failed to create PTEditor device\r\n");
        return status;
    }

    status = IoCreateSymbolicLink(&SymLinkName, &DeviceName);
    if (!NT_SUCCESS(status)) {
        DbgPrint(TAG_ERROR "Failed to create symbolic link for PTEditor\r\n");
        IoDeleteDevice(DeviceObject);
        return status;
    }

    for (i = 0; i < IRP_MJ_MAXIMUM_FUNCTION; i++) {
        DriverObject->MajorFunction[i] = DispatchPassThru;
    }

    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = DispatchDeviceCtl;

    DbgPrint(TAG_INFO "PTEditor successfully loaded\r\n");

    return status;
}

```

`driver/PTEdit/PTEdit.inf`:

```inf
;
; PTEdit.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=PTEdit.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages

[DestinationDirs]
DefaultDestDir = 12
PTEdit_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
PTEdit.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%PTEdit.DeviceDesc%=PTEdit_Device, Root\PTEdit ; TODO: edit hw-id

[PTEdit_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
PTEdit.sys

;-------------- Service installation
[PTEdit_Device.NT.Services]
AddService = PTEdit,%SPSVCINST_ASSOCSERVICE%, PTEdit_Service_Inst

; -------------- PTEdit driver install sections
[PTEdit_Service_Inst]
DisplayName    = %PTEdit.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\PTEdit.sys

;
;--- PTEdit_Device Coinstaller installation ------
;

[PTEdit_Device.NT.CoInstallers]
AddReg=PTEdit_Device_CoInstaller_AddReg
CopyFiles=PTEdit_Device_CoInstaller_CopyFiles

[PTEdit_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[PTEdit_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[PTEdit_Device.NT.Wdf]
KmdfService =  PTEdit, PTEdit_wdfsect
[PTEdit_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="Michael Schwarz"
ClassName="Samples" ; TODO: edit ClassName
DiskName = "PTEdit Installation Disk"
PTEdit.DeviceDesc = "PTEdit Device"
PTEdit.SVCDESC = "PTEdit Service"

```

`driver/PTEdit/PTEdit.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Driver.c" />
  </ItemGroup>
  <ItemGroup>
    <Inf Include="PTEdit.inf" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{04DCF770-AB2F-42EC-A9EE-BF44C47445C2}</ProjectGuid>
    <TemplateGuid>{497e31cb-056b-4f31-abb8-447fd55ee5a5}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>PTEdit</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WppEnabled>false</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <ClCompile>
      <WppEnabled>true</WppEnabled>
      <WppRecorderEnabled>true</WppRecorderEnabled>
      <WppScanConfigurationData Condition="'%(ClCompile.ScanConfigurationData)' == ''">trace.h</WppScanConfigurationData>
      <WppKernelMode>true</WppKernelMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`driver/PTEdit/PTEdit.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="PTEdit.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Driver.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`driver/PTEditorLoader.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.29926.136
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "PTEditorLoader", "PTEditorLoader\PTEditorLoader.vcxproj", "{06D3BF53-16B4-453B-9186-188471DEEE1E}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{06D3BF53-16B4-453B-9186-188471DEEE1E}.Debug|x64.ActiveCfg = Debug|x64
		{06D3BF53-16B4-453B-9186-188471DEEE1E}.Debug|x64.Build.0 = Debug|x64
		{06D3BF53-16B4-453B-9186-188471DEEE1E}.Debug|x86.ActiveCfg = Debug|Win32
		{06D3BF53-16B4-453B-9186-188471DEEE1E}.Debug|x86.Build.0 = Debug|Win32
		{06D3BF53-16B4-453B-9186-188471DEEE1E}.Release|x64.ActiveCfg = Release|x64
		{06D3BF53-16B4-453B-9186-188471DEEE1E}.Release|x64.Build.0 = Release|x64
		{06D3BF53-16B4-453B-9186-188471DEEE1E}.Release|x86.ActiveCfg = Release|Win32
		{06D3BF53-16B4-453B-9186-188471DEEE1E}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {DB6C340A-AE48-45F6-A642-22A49548761A}
	EndGlobalSection
EndGlobal

```

`driver/PTEditorLoader/PTEditorLoader.cpp`:

```cpp
#include <iostream>
#include <windows.h>
#pragma comment(lib,"advapi32.lib")

#define PTEDITOR_DEVICE_NAME L"PTEditorLink"
#define PTEDITOR_DEVICE_PATH L"\\\\.\\" PTEDITOR_DEVICE_NAME

#define DRIVER_NAME L"PTEdit.sys"
#define SERVICE_NAME L"PTEditor"

int main(int argc, char* argv[])
{
    SC_HANDLE hSCManager;
    SC_HANDLE hService = NULL;
    SERVICE_STATUS ss;
    WCHAR driverPath[1024];
    int unload = 0;

    if (argc >= 2 && !strcmp(argv[1], "--unload")) unload = 1;

    HANDLE fd = CreateFile(DRIVER_NAME, GENERIC_READ, 0, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
    if (fd == INVALID_HANDLE_VALUE) {
        printf("[-] Could not find driver PTEdit.sys in current directory\n");
        return 1;
    }
    else {
        CloseHandle(fd);
        GetFullPathName(DRIVER_NAME, sizeof(driverPath) / sizeof(driverPath[0]) - 1, driverPath, NULL);
    }
    printf("[+] Found driver: %ws\n", driverPath);

    // check if driver is loaded
    fd = CreateFile(PTEDITOR_DEVICE_PATH, GENERIC_ALL, 0, 0, OPEN_EXISTING, FILE_ATTRIBUTE_SYSTEM, 0);
    if (fd == INVALID_HANDLE_VALUE && unload) {
        printf("[-] Could not unload driver, driver is not loaded\n");
        return 1;
    }
    if (fd != INVALID_HANDLE_VALUE) {
        CloseHandle(fd);
        if (!unload) {
            printf("[+] PTEditor driver is already loaded. To unload the driver, run %s --unload\n", argv[0]);
            return 0;
        }
    }

    hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE);

    if (unload) {
        printf("[+] Unload PTEditor driver\n");
    }
    else {
        printf("[+] Load PTEditor driver\n");
    }

    if (hSCManager)
    {
        if (!unload) {
            printf("[+] Creating service\n");
        }
        else {
            printf("[+] Connecting to service\n");
        }

        hService = CreateService(hSCManager, SERVICE_NAME,
            L"PTEditor Driver",
            SERVICE_START | DELETE | SERVICE_STOP,
            SERVICE_KERNEL_DRIVER,
            SERVICE_DEMAND_START,
            SERVICE_ERROR_IGNORE,
            driverPath,
            NULL, NULL, NULL, NULL, NULL);

        if (!hService)
        {
            printf("[+] Service not running, try to open service\n");
            hService = OpenService(hSCManager, SERVICE_NAME,
                SERVICE_START | DELETE | SERVICE_STOP);
        }

        if (hService)
        {
            if (!unload) {
                printf("[+] Starting service\n");
                StartService(hService, 0, NULL);
            }
            else {
                printf("[+] Stopping service\n");
                ControlService(hService, SERVICE_CONTROL_STOP, &ss);
                DeleteService(hService);
            }
            CloseServiceHandle(hService);
        }
        CloseServiceHandle(hSCManager);
    }
    return 0;
}

```

`driver/PTEditorLoader/PTEditorLoader.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{06D3BF53-16B4-453B-9186-188471DEEE1E}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>PTEditorLoader</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>Static</UseOfMfc>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="PTEditorLoader.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`driver/PTEditorLoader/PTEditorLoader.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="PTEditorLoader.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`driver/PTEditorLoader/PTEditorLoader.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`example.c`:

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/fcntl.h>
#include <sys/mman.h>
#include <memory.h>
#include <unistd.h>

#define COLOR_RED     "\x1b[31m"
#define COLOR_GREEN   "\x1b[32m"
#define COLOR_YELLOW  "\x1b[33m"
#define COLOR_RESET   "\x1b[0m"

#define TAG_OK COLOR_GREEN "[+]" COLOR_RESET " "
#define TAG_FAIL COLOR_RED "[-]" COLOR_RESET " "
#define TAG_PROGRESS COLOR_YELLOW "[~]" COLOR_RESET " "


#include "ptedit_header.h"


int main(int argc, char *argv[]) {
  size_t address_pfn, target_pfn;
  (void)argc;
  (void)argv;

  if(ptedit_init()) {
    printf(TAG_FAIL "Could not initialize ptedit (did you load the kernel module?)\n");
    return 1;
  }

//   ptedit_use_implementation(PTEDIT_IMPL_KERNEL);

  char page[ptedit_get_pagesize()];

  void *address = mmap(0, 4096, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  memset(address, 'A', 4096);

  void *target = mmap(0, 4096, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  memset(target, 'B', 4096);

  printf(TAG_OK "address @ " COLOR_YELLOW "%p" COLOR_RESET "\n", address);
  printf(TAG_OK "target @ " COLOR_YELLOW "%p" COLOR_RESET "\n", target);

  ptedit_entry_t vm = ptedit_resolve(address, 0);
  if(vm.pgd == 0) {
    printf(TAG_FAIL "Could not resolve PTs\n");
    goto error;
  }
  ptedit_print_entry_t(vm);
  printf(TAG_PROGRESS "PTE PFN %zx\n", (size_t)(ptedit_cast(vm.pte, ptedit_pte_t).pfn));

  printf(TAG_PROGRESS "address[0] = " COLOR_YELLOW "%c" COLOR_RESET"\n", *(volatile char*)address);
  if(*(volatile char*)address == 'A') {
      printf(TAG_OK "OK!\n");
  } else {
      printf(TAG_FAIL "Fail!\n");
  }

  printf(TAG_OK "Set PFN of address to PFN of target\n");


  // get current pfn of "access"
  address_pfn = ptedit_get_pfn(vm.pte);
  target_pfn = ptedit_pte_get_pfn(target, 0);
  // update to pfn of "target"
  vm.pte = ptedit_set_pfn(vm.pte, target_pfn);

  // update only PTE
  vm.valid = PTEDIT_VALID_MASK_PTE;
  ptedit_update(address, 0, &vm);

  printf(TAG_OK "address[0] = " COLOR_YELLOW "%c" COLOR_RESET "\n", *(volatile char*)address);
  if(*(volatile char*)address == 'B') {
      printf(TAG_OK "OK!\n");
  } else {
      printf(TAG_FAIL "Fail!\n");
  }

  printf(TAG_OK "Reading physical page of address\n");
  ptedit_read_physical_page(address_pfn, page);

  printf(TAG_OK "old address[0] (via physical page) = " COLOR_YELLOW "%c" COLOR_RESET "\n", page[0]);
  if(page[0] == 'A') {
      printf(TAG_OK "OK!\n");
  } else {
      printf(TAG_FAIL "Fail!\n");
  }

  printf(TAG_OK "Mapping physical address %zx to new virtual address\n", address_pfn * ptedit_get_pagesize());
  char* new_addr = ptedit_pmap(address_pfn * ptedit_get_pagesize(), ptedit_get_pagesize());
  printf(TAG_PROGRESS "mapped to virtual address %p\n", new_addr);

  printf(TAG_OK "old address[0] (via pmap) = " COLOR_YELLOW "%c" COLOR_RESET "\n", new_addr[0]);
  if(new_addr[0] == 'A') {
      printf(TAG_OK "OK!\n");
  } else {
      printf(TAG_FAIL "Fail!\n");
  }


  printf(TAG_OK "Overwriting physical page of target with " COLOR_YELLOW "C" COLOR_RESET "s\n");
  memset(page, 'C', ptedit_get_pagesize());
  ptedit_write_physical_page(target_pfn, page);

  ptedit_full_serializing_barrier();

  printf(TAG_OK "address[0] = " COLOR_YELLOW "%c" COLOR_RESET "\n", *(volatile char*)address);
  if(*(volatile char*)address == 'C') {
      printf(TAG_OK "OK!\n");
  } else {
      printf(TAG_FAIL "Fail!\n");
  }

  printf(TAG_OK "Resetting PFN of address\n");
  ptedit_pte_set_pfn(address, 0, address_pfn);

error:
  munmap(address, 4096);
  munmap(target, 4096);

  ptedit_cleanup();

  return 0;
}

```

`module/Makefile`:

```
KERNEL ?= $(shell uname -r)
obj-m += pteditor.o
ccflags-y += -Wno-unused-result -I/usr/src/linux-headers-${KERNEL}/include/linux/ -DCC_USING_FENTRY
all:
	make -C /lib/modules/${KERNEL}/build M=$(PWD) modules
clean:
	make -C /lib/modules/${KERNEL}/build M=$(PWD) clean

```

`module/pteditor.c`:

```c
#include <linux/mm_types.h>
#include <asm/tlbflush.h>
#include <asm/uaccess.h>
#include <asm/io.h>
#include <linux/fs.h>
#include <linux/fs.h>
#include <linux/kallsyms.h>
#include <linux/miscdevice.h>
#include <linux/mm.h>
#include <linux/module.h>
#include <linux/version.h>
#include <linux/ptrace.h>
#include <linux/proc_fs.h>
#include <linux/kprobes.h>

#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 8, 0)
#include <linux/mmap_lock.h>
#endif

//#ifdef CONFIG_PAGE_TABLE_ISOLATION
//pgd_t __attribute__((weak)) __pti_set_user_pgtbl(pgd_t *pgdp, pgd_t pgd);
//#endif

static int real_page_size = 4096, real_page_shift = 12;

#include "pteditor.h"

MODULE_AUTHOR("Michael Schwarz");
MODULE_DESCRIPTION("Device to play around with paging structures");
MODULE_LICENSE("GPL");

#if defined(__aarch64__)
#include <linux/hugetlb.h>

#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 0)
typedef pgdval_t p4dval_t;
#endif

void __attribute__((weak)) set_swapper_pgd(pgd_t* pgdp, pgd_t pgd) {}
pgd_t __attribute__((weak)) swapper_pg_dir[PTRS_PER_PGD];

static inline pte_t native_make_pte(pteval_t val)
{
  return __pte(val);
}

static inline pgd_t native_make_pgd(pgdval_t val)
{
  return __pgd(val);
}

static inline pmd_t native_make_pmd(pmdval_t val)
{
  return __pmd(val);
}

static inline pud_t native_make_pud(pudval_t val)
{
  return __pud(val);
}
#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 0)

static inline p4d_t native_make_p4d(p4dval_t val)
{
  return __p4d(val);
}
#endif

static inline pteval_t native_pte_val(pte_t pte)
{
  return pte_val(pte);
}

static inline int pud_large(pud_t pud) {
#ifdef __PAGETABLE_PMD_FOLDED 
    return pud_val(pud) && !(pud_val(pud) & PUD_TABLE_BIT);
#else
    return 0;
#endif
}

static inline int pmd_large(pmd_t pmd) {
#ifdef __PAGETABLE_PMD_FOLDED
    return pmd_val(pmd) && !(pmd_val(pmd) & PMD_TABLE_BIT)
#else
    return 0;
#endif
}
#endif

#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 0)
#define from_user raw_copy_from_user
#define to_user raw_copy_to_user
#else
#define from_user copy_from_user
#define to_user copy_to_user
#endif

#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 6, 0)
#define pud_leaf pud_large
#define pmd_leaf pmd_large
#endif

#ifdef pr_fmt
#undef pr_fmt
#endif
#define pr_fmt(fmt) "[pteditor-module] " fmt

#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 7, 0)
#define KPROBE_KALLSYMS_LOOKUP 1
typedef unsigned long (*kallsyms_lookup_name_t)(const char *name);
kallsyms_lookup_name_t kallsyms_lookup_name_func;
#define kallsyms_lookup_name kallsyms_lookup_name_func

static struct kprobe kp = {
    .symbol_name = "kallsyms_lookup_name"
};
#endif

typedef struct {
    size_t pid;
    pgd_t *pgd;
#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 0)
    p4d_t *p4d;
#else
    size_t *p4d;
#endif
    pud_t *pud;
    pmd_t *pmd;
    pte_t *pte;
    size_t valid;
} vm_t;

static bool device_busy = false;
static bool mm_is_locked = false;

void (*invalidate_tlb)(pid_t, void*);
void (*flush_tlb_mm_range_func)(struct mm_struct*, unsigned long, unsigned long, unsigned int, bool);
void (*native_write_cr4_func)(unsigned long);
static struct mm_struct* get_mm(size_t);

static int device_open(struct inode *inode, struct file *file) {
  /* Check if device is busy */
  if (device_busy == true) {
    return -EBUSY;
  }

  device_busy = true;

  return 0;
}

static int device_release(struct inode *inode, struct file *file) {
  /* Unlock module */
  device_busy = false;

  return 0;
}

static void
_invalidate_tlb(void *addr) {
#if defined(__i386__) || defined(__x86_64__)
  // this should be unreachable
  pr_crit("This architecture does no longer support custom TLB invalidation!\n");
#elif defined(__aarch64__)
  asm volatile ("dsb ishst");
  asm volatile ("tlbi vmalle1is");
  asm volatile ("dsb ish");
  asm volatile ("isb");
#endif
}

static void
invalidate_tlb_custom(pid_t pid, void* addr) {
  on_each_cpu(_invalidate_tlb, addr, 1);
}

#if defined(__aarch64__)
typedef struct tlb_page_s {
  struct vm_area_struct* vma;
  unsigned long addr;
} tlb_page_t;

void _flush_tlb_page_smp(void* info) {
  tlb_page_t* tlb_page = (tlb_page_t*) info;
  flush_tlb_page(tlb_page->vma, tlb_page->addr);
}
#endif

static void
invalidate_tlb_kernel(pid_t pid, void* addr) {
#if defined(__i386__) || defined(__x86_64__)
  struct mm_struct* mm = get_mm(pid);
  if (!mm) return; // process might have already been killed
  flush_tlb_mm_range_func(mm, (unsigned long) addr, (unsigned long) addr + real_page_size, real_page_shift, false);
#elif defined(__aarch64__)
  struct vm_area_struct *vma = find_vma(current->mm, (unsigned long)addr);
  tlb_page_t tlb_page;
  if (unlikely(vma == NULL || (unsigned long)addr < vma->vm_start)) {
    return;
  }
  tlb_page.vma = vma;
  tlb_page.addr = (unsigned long)addr;
  on_each_cpu(_flush_tlb_page_smp, &tlb_page, 1);
#endif
}

static void _set_pat(void* _pat) {
#if defined(__i386__) || defined(__x86_64__)
    int low, high;
    size_t pat = (size_t)_pat;
    low = pat & 0xffffffff;
    high = (pat >> 32) & 0xffffffff;
    asm volatile("wrmsr" : : "a"(low), "d"(high), "c"(0x277));
#elif defined(__aarch64__)
    size_t pat = (size_t)_pat;
    asm volatile ("msr mair_el1, %0\n" : : "r"(pat));
#endif
}

static void set_pat(size_t pat) {
    on_each_cpu(_set_pat, (void*) pat, 1);
}

static struct mm_struct* get_mm(size_t pid) {
  struct task_struct *task;
  struct pid* vpid;

  /* Find mm */
  task = current;
  if(pid != 0) {
    vpid = find_vpid(pid);
    if(!vpid) return NULL;
    task = pid_task(vpid, PIDTYPE_PID);
    if(!task) return NULL;
  }
  if(task->mm) {
      return task->mm;
  } else {
      return task->active_mm;
  }
  return NULL;
}

static int resolve_vm(size_t addr, vm_t* entry, int lock) {
  struct mm_struct *mm;

  if(!entry) return 1;
  entry->pud = NULL;
  entry->pmd = NULL;
  entry->pgd = NULL;
  entry->pte = NULL;
  entry->p4d = NULL;
  entry->valid = 0;

  mm = get_mm(entry->pid);
  if(!mm) {
      return 1;
  }

  /* Lock mm */
#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 8, 0)
  if(lock) mmap_read_lock(mm);
#else
  if(lock) down_read(&mm->mmap_sem);
#endif

  /* Return PGD (page global directory) entry */
  entry->pgd = pgd_offset(mm, addr);
  if (pgd_none(*(entry->pgd)) || pgd_bad(*(entry->pgd))) {
      entry->pgd = NULL;
      goto error_out;
  }
  entry->valid |= PTEDIT_VALID_MASK_PGD;


#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 0)
  /* Return p4d offset */
  entry->p4d = p4d_offset(entry->pgd, addr);
  if (p4d_none(*(entry->p4d)) || p4d_bad(*(entry->p4d))) {
    entry->p4d = NULL;
    goto error_out;
  }
  entry->valid |= PTEDIT_VALID_MASK_P4D;

  /* Get offset of PUD (page upper directory) */
  entry->pud = pud_offset(entry->p4d, addr);
  if (pud_none(*(entry->pud))) {
    entry->pud = NULL;
    goto error_out;
  }
  entry->valid |= PTEDIT_VALID_MASK_PUD;
#else
  /* Get offset of PUD (page upper directory) */
  entry->pud = pud_offset(entry->pgd, addr);
  if (pud_none(*(entry->pud))) {
    entry->pud = NULL;
    goto error_out;
  }
  entry->valid |= PTEDIT_VALID_MASK_PUD;
#endif


  /* Get offset of PMD (page middle directory) */
  entry->pmd = pmd_offset(entry->pud, addr);
  if (pmd_none(*(entry->pmd)) || pud_leaf(*(entry->pud))) {
    entry->pmd = NULL;
    goto error_out;
  }
  entry->valid |= PTEDIT_VALID_MASK_PMD;

  /* Map PTE (page table entry) */
#if LINUX_VERSION_CODE < KERNEL_VERSION(6, 5, 0)
  entry->pte = pte_offset_map(entry->pmd, addr);
#else
  entry->pte = pte_offset_kernel(entry->pmd, addr);
#endif
  if (entry->pte == NULL || pmd_leaf(*(entry->pmd))) {
    entry->pte = NULL;
    goto error_out;
  }
  entry->valid |= PTEDIT_VALID_MASK_PTE;

  /* Unmap PTE, fine on x86 and ARM64 -> unmap is NOP */
  pte_unmap(entry->pte);

  /* Unlock mm */
#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 8, 0)
  if(lock) mmap_read_unlock(mm);
#else
  if(lock) up_read(&mm->mmap_sem);
#endif

  return 0;

error_out:

  /* Unlock mm */
#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 8, 0)
  if(lock) mmap_read_unlock(mm);
#else
  if(lock) up_read(&mm->mmap_sem);
#endif

  return 1;
}


static int update_vm(ptedit_entry_t* new_entry, int lock) {
  vm_t old_entry;
  size_t addr = new_entry->vaddr;
  struct mm_struct *mm = get_mm(new_entry->pid);
  if(!mm) return 1;

  old_entry.pid = new_entry->pid;

  /* Lock mm */
#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 8, 0)
  if(lock) mmap_write_lock(mm);
#else
  if(lock) down_write(&mm->mmap_sem);
#endif

  resolve_vm(addr, &old_entry, 0);

  /* Update entries */
  if((old_entry.valid & PTEDIT_VALID_MASK_PGD) && (new_entry->valid & PTEDIT_VALID_MASK_PGD)) {
      pr_warn("Updating PGD\n");
      set_pgd(old_entry.pgd, native_make_pgd(new_entry->pgd));
  }

#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 0)
  if((old_entry.valid & PTEDIT_VALID_MASK_P4D) && (new_entry->valid & PTEDIT_VALID_MASK_P4D)) {
      pr_warn("Updating P4D\n");
      set_p4d(old_entry.p4d, native_make_p4d(new_entry->p4d));
  }
#endif

  if((old_entry.valid & PTEDIT_VALID_MASK_PUD) && (new_entry->valid & PTEDIT_VALID_MASK_PUD)) {
      pr_warn("Updating PUD\n");
      set_pud(old_entry.pud, native_make_pud(new_entry->pud));
  }

  if((old_entry.valid & PTEDIT_VALID_MASK_PMD) && (new_entry->valid & PTEDIT_VALID_MASK_PMD)) {
      pr_warn("Updating PMD\n");
      set_pmd(old_entry.pmd, native_make_pmd(new_entry->pmd));
  }

  if((old_entry.valid & PTEDIT_VALID_MASK_PTE) && (new_entry->valid & PTEDIT_VALID_MASK_PTE)) {
      pr_warn("Updating PTE\n");
      set_pte(old_entry.pte, native_make_pte(new_entry->pte));
  }

  invalidate_tlb(old_entry.pid, (void*) addr);

  /* Unlock mm */
#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 8, 0)
  if(lock) mmap_write_unlock(mm);
#else
  if(lock) up_write(&mm->mmap_sem);
#endif

  return 0;
}


static void vm_to_user(ptedit_entry_t* user, vm_t* vm) {
#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 0)
#if CONFIG_PGTABLE_LEVELS > 4
    if(vm->p4d) user->p4d = (vm->p4d)->p4d;
#else
#if !defined(__ARCH_HAS_5LEVEL_HACK)
    if(vm->p4d) user->p4d = (vm->p4d)->pgd.pgd;
#else
    if(vm->p4d) user->p4d = (vm->p4d)->pgd;    
#endif
#endif
#endif
#if defined(__i386__) || defined(__x86_64__)
    if(vm->pgd) user->pgd = (vm->pgd)->pgd;
    if(vm->pmd) user->pmd = (vm->pmd)->pmd;
    if(vm->pud) user->pud = (vm->pud)->pud;
    if(vm->pte) user->pte = (vm->pte)->pte;
#elif defined(__aarch64__)
    if(vm->pgd) user->pgd = pgd_val(*(vm->pgd));
    if(vm->pmd) user->pmd = pmd_val(*(vm->pmd));
    if(vm->pud) user->pud = pud_val(*(vm->pud));
    if(vm->pte) user->pte = pte_val(*(vm->pte));
#endif
    user->valid = vm->valid;
}


static long device_ioctl(struct file *file, unsigned int ioctl_num, unsigned long ioctl_param) {
  switch (ioctl_num) {
    case PTEDITOR_IOCTL_CMD_VM_RESOLVE:
    {
        ptedit_entry_t vm_user;
        vm_t vm;
        (void)from_user(&vm_user, (void*)ioctl_param, sizeof(vm_user));
        vm.pid = vm_user.pid;
        resolve_vm(vm_user.vaddr, &vm, !mm_is_locked);
        vm_to_user(&vm_user, &vm);
        (void)to_user((void*)ioctl_param, &vm_user, sizeof(vm_user));
        return 0;
    }
    case PTEDITOR_IOCTL_CMD_VM_UPDATE:
    {
        ptedit_entry_t vm_user;
        (void)from_user(&vm_user, (void*)ioctl_param, sizeof(vm_user));
        update_vm(&vm_user, !mm_is_locked);
        return 0;
    }
    case PTEDITOR_IOCTL_CMD_VM_LOCK:
    {
        struct mm_struct *mm = current->active_mm;
        if(mm_is_locked) {
            pr_warn("VM is already locked\n");
            return -1;
        }
#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 8, 0)
        mmap_write_lock(mm);
        mmap_read_lock(mm);
#else
        down_write(&mm->mmap_sem);
        down_read(&mm->mmap_sem);
#endif
        mm_is_locked = true;
        return 0;
    }
    case PTEDITOR_IOCTL_CMD_VM_UNLOCK:
    {
        struct mm_struct *mm = current->active_mm;
        if(!mm_is_locked) {
            pr_warn("VM is not locked\n");
            return -1;
        }
#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 8, 0)
        mmap_write_unlock(mm);
        mmap_read_unlock(mm);
#else
        up_write(&mm->mmap_sem);
        up_read(&mm->mmap_sem);
#endif
        mm_is_locked = false;
        return 0;
    }
    case PTEDITOR_IOCTL_CMD_READ_PAGE:
    {
        ptedit_page_t page;
        (void)from_user(&page, (void*)ioctl_param, sizeof(page));
        to_user(page.buffer, phys_to_virt(page.pfn * real_page_size), real_page_size);
        return 0;
    }
    case PTEDITOR_IOCTL_CMD_WRITE_PAGE:
    {
        ptedit_page_t page;
        (void)from_user(&page, (void*)ioctl_param, sizeof(page));
        (void)from_user(phys_to_virt(page.pfn * real_page_size), page.buffer, real_page_size);
        return 0;
    }
    case PTEDITOR_IOCTL_CMD_GET_ROOT:
    {
        struct mm_struct *mm;
        ptedit_paging_t paging;

        (void)from_user(&paging, (void*)ioctl_param, sizeof(paging));
        mm = get_mm(paging.pid);

#if defined(__aarch64__)
        if(!mm || (mm && !mm->pgd)) {
            // M1 Asahi Linux workaround with the limitation that it only works for the current process
            asm volatile("mrs %0, ttbr0_el1" : "=r" (paging.root));
            paging.root &= ~1;
            (void)to_user((void*)ioctl_param, &paging, sizeof(paging));
            return 0;
        }
#endif

        if(!mm) return 1;
#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 8, 0)
        if(!mm_is_locked) mmap_read_lock(mm);
#else
        if(!mm_is_locked) down_read(&mm->mmap_sem);
#endif
        paging.root = virt_to_phys(mm->pgd);
#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 8, 0)
        if(!mm_is_locked) mmap_read_unlock(mm);
#else
        if(!mm_is_locked) up_read(&mm->mmap_sem);
#endif
        (void)to_user((void*)ioctl_param, &paging, sizeof(paging));
        return 0;
    }
    case PTEDITOR_IOCTL_CMD_SET_ROOT:
    {
        struct mm_struct *mm;
        ptedit_paging_t paging = {0};

        (void)from_user(&paging, (void*)ioctl_param, sizeof(paging));
        mm = get_mm(paging.pid);
        if(!mm) return 1;
#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 8, 0)
        if(!mm_is_locked) mmap_write_lock(mm);
#else
        if(!mm_is_locked) down_write(&mm->mmap_sem);
#endif
        mm->pgd = (pgd_t*)phys_to_virt(paging.root);
#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 8, 0)
        if(!mm_is_locked) mmap_write_unlock(mm);
#else
        if(!mm_is_locked) up_write(&mm->mmap_sem);
#endif
        return 0;
    }
    case PTEDITOR_IOCTL_CMD_GET_PAGESIZE:
        return real_page_size;
    case PTEDITOR_IOCTL_CMD_INVALIDATE_TLB_PID:
    {
        ptedit_invalidate_tlb_args_t args;
        (void)from_user(&args, (void*)ioctl_param, sizeof(args));
        invalidate_tlb(args.pid, args.address);
        return 0;
    }
    case PTEDITOR_IOCTL_CMD_INVALIDATE_TLB:
    {
        // this is implemented as its own call to stay backwards compatible
        // even in case a user uses the old ioctl calls
        invalidate_tlb(task_pid_nr(current), (void*) ioctl_param);
        return 0;
    }
    case PTEDITOR_IOCTL_CMD_GET_PAT:
    {
#if defined(__i386__) || defined(__x86_64__)
        int low, high;
        size_t pat;
        asm volatile("rdmsr" : "=a"(low), "=d"(high) : "c"(0x277));
        pat = low | (((size_t)high) << 32);
        (void)to_user((void*)ioctl_param, &pat, sizeof(pat));
        return 0;
#elif defined(__aarch64__)
        uint64_t value;
        asm volatile ("mrs %0, mair_el1\n" : "=r"(value));
        (void)to_user((void*)ioctl_param, &value, sizeof(value));
        return 0;
#endif
    }
    case PTEDITOR_IOCTL_CMD_SET_PAT:
    {
        set_pat(ioctl_param);
        return 0;
    }
    case PTEDITOR_IOCTL_CMD_SWITCH_TLB_INVALIDATION:
    {
      if((int)ioctl_param != PTEDITOR_TLB_INVALIDATION_KERNEL && (int)ioctl_param != PTEDITOR_TLB_INVALIDATION_CUSTOM)
        return -1;
#if defined(__i386__) || defined(__x86_64__)
      if((int)ioctl_param == PTEDITOR_TLB_INVALIDATION_CUSTOM) {
        pr_warn("Custom TLB invalidation is not supported on this CPU! Request ignored.");
        return 0;
      }
#endif
      invalidate_tlb = ((int)ioctl_param == PTEDITOR_TLB_INVALIDATION_KERNEL) ? invalidate_tlb_kernel : invalidate_tlb_custom;
      return 0;
    }

    default:
        return -1;
  }

  return 0;
}

static struct file_operations f_ops = {.owner = THIS_MODULE,
                                       .unlocked_ioctl = device_ioctl,
                                       .open = device_open,
                                       .release = device_release};

static struct miscdevice misc_dev = {
    .minor = MISC_DYNAMIC_MINOR,
    .name = PTEDITOR_DEVICE_NAME,
    .fops = &f_ops,
    .mode = S_IRWXUGO,
};

#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0)
static struct proc_ops umem_ops = {
#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 7, 0)
  .proc_flags = 0,
#endif
  .proc_open = NULL,
  .proc_read = NULL,
  .proc_write = NULL,
  .proc_lseek = NULL,
  .proc_release = NULL,
  .proc_poll = NULL,
  .proc_ioctl = NULL,
#ifdef CONFIG_COMPAT
  .proc_compat_ioctl = NULL,
#endif
  .proc_mmap = NULL,
  .proc_get_unmapped_area = NULL,
};
#define OP_lseek lseek
#define OPCAT(a, b) a ## b
#define OPS(o) OPCAT(umem_ops.proc_, o)
#else
static struct file_operations umem_ops = {.owner = THIS_MODULE};
#define OP_lseek llseek
#define OPS(o) umem_ops.o
#endif

static int open_umem(struct inode *inode, struct file *filp) { return 0; }
static int has_umem = 0;

static const char *devmem_hook = "devmem_is_allowed";


static int devmem_bypass(struct kretprobe_instance *p, struct pt_regs *regs) {
#if defined(__aarch64__)
  if (regs->regs[0] == 0) {
    regs->regs[0] = 1;
  }
#else
  if (regs->ax == 0) {
    regs->ax = 1;
  }
#endif
  return 0;
}

static struct kretprobe probe_devmem = {.handler = devmem_bypass, .maxactive = 20};

static int __init pteditor_init(void) {
  int r;
#if defined(__aarch64__)
  uint64_t tcr_el1;
#endif

#ifdef KPROBE_KALLSYMS_LOOKUP
    register_kprobe(&kp);
    kallsyms_lookup_name = (kallsyms_lookup_name_t) kp.addr;
    unregister_kprobe(&kp);

    if(!unlikely(kallsyms_lookup_name)) {
      pr_alert("Could not retrieve kallsyms_lookup_name address\n");
      return -ENXIO;
    }
#endif

  /* Register device */
  r = misc_register(&misc_dev);
  if (r != 0) {
    pr_alert("Failed registering device with %d\n", r);
    return -ENXIO;
  }

#if defined(__i386__) || defined(__x86_64__)
  flush_tlb_mm_range_func = (void *) kallsyms_lookup_name("flush_tlb_mm_range");
  if(!flush_tlb_mm_range_func) {
    pr_alert("Could not retrieve flush_tlb_mm_range function\n");
    return -ENXIO;
  }
#endif
  // we use the kernel TLB invalidation function by default as it's more reliable
  invalidate_tlb = invalidate_tlb_kernel;
  
#if defined(__aarch64__)
  asm volatile("mrs %0, tcr_el1" : "=r" (tcr_el1));
  switch((tcr_el1 >> 14) & 3) {
      case 1:
          // 64k pages
          real_page_size = 64 * 1024;
          real_page_shift = 16;
          break;
      case 2:
          // 16k pages
          real_page_size = 16 * 1024;
          real_page_shift = 14;
          break;
      default:
          break;
  }
#endif

  probe_devmem.kp.symbol_name = devmem_hook;

  if (register_kretprobe(&probe_devmem) < 0) {
    pr_alert("Could not bypass /dev/mem restriction\n");
  } else {
    pr_info("/dev/mem is now superuser read-/writable\n");
  }

  OPS(OP_lseek) = (void*)kallsyms_lookup_name("memory_lseek");
  OPS(read) = (void*)kallsyms_lookup_name("read_mem");
  OPS(write) = (void*)kallsyms_lookup_name("write_mem");
  OPS(mmap) = (void*)kallsyms_lookup_name("mmap_mem");
  OPS(open) = open_umem;

  if (!OPS(OP_lseek) || !OPS(read) || !OPS(write) ||
      !OPS(mmap) || !OPS(open)) {
    pr_alert("Could not create unprivileged memory access\n");
  } else {
    proc_create("umem", 0666, NULL, &umem_ops);
    pr_info("Unprivileged memory access via /proc/umem set up\n");
    has_umem = 1;
  }
  pr_info("Loaded.\n");

  return 0;
}

static void __exit pteditor_exit(void) {
  misc_deregister(&misc_dev);
  
  unregister_kretprobe(&probe_devmem);

  if (has_umem) {
    pr_info("Remove unprivileged memory access\n");
    remove_proc_entry("umem", NULL);
  }
  pr_info("Removed.\n");
}

module_init(pteditor_init);
module_exit(pteditor_exit);

```

`module/pteditor.h`:

```h
/* See LICENSE file for license and copyright information */

#ifndef PTEDITOR_MODULE_H
#define PTEDITOR_MODULE_H

#if defined(__linux__) || defined(__linux) || defined(__unix__) || defined(LINUX) || defined(UNIX)
#define LINUX
#endif
#if defined(_WIN32) || defined(_WIN64) || defined(__MINGW32__) || defined(__CYGWIN__)
#define WINDOWS
#undef LINUX
#endif


#if defined(LINUX)
#define PTEDITOR_DEVICE_NAME "pteditor"
#define PTEDITOR_DEVICE_PATH "/dev/" PTEDITOR_DEVICE_NAME
#else
#define PTEDITOR_DEVICE_NAME L"PTEditorLink"
#define PTEDITOR_DEVICE_PATH L"\\\\.\\" PTEDITOR_DEVICE_NAME
#endif

/**
 * Structure containing the page-table entries of all levels.
 * The Linux names are aliased with the Intel names.
 */
typedef struct {
    /** Process ID */
    size_t pid;
    /** Virtual address */
    size_t vaddr;

    /** Page global directory / Page map level 5 */
    union {
        size_t pgd;
        size_t pml5;
    };
    /** Page directory 4 / Page map level 4 */
    union {
        size_t p4d;
        size_t pml4;
    };
    /** Page upper directory / Page directory pointer table */
    union {
        size_t pud;
        size_t pdpt;
    };
    /** Page middle directory / Page directory */
    union {
        size_t pmd;
        size_t pd;
    };
    /** Page table entry */
    size_t pte;
    /** Bitmask indicating which entries are valid/should be updated */
    size_t valid;
} ptedit_entry_t;

/**
 * Structure to read/write physical pages
 */
#if defined(LINUX)
typedef struct {
    /** Page-frame number */
    size_t pfn;
    /** Virtual address */
    size_t vaddr;
    /** Page size */
    size_t size;
    /** Page content */
    unsigned char* buffer;
} ptedit_page_t;
#else
__pragma(pack(push, 1))
typedef struct {
    char content[4096];
    size_t paddr;
} ptedit_page_t;
__pragma(pack(pop))
#endif


/**
 * Structure to get/set the root of paging
 */
typedef struct {
    /** Process id */
    size_t pid;
    /** Physical address of paging root */
    size_t root;
} ptedit_paging_t;

/**
 * Structure to hold the arguments for TLB invalidation
 */
typedef struct {
    pid_t pid;
    void* address;
} ptedit_invalidate_tlb_args_t;

#define PTEDIT_VALID_MASK_PGD (1<<0)
#define PTEDIT_VALID_MASK_P4D (1<<1)
#define PTEDIT_VALID_MASK_PUD (1<<2)
#define PTEDIT_VALID_MASK_PMD (1<<3)
#define PTEDIT_VALID_MASK_PTE (1<<4)

#define PTEDITOR_TLB_INVALIDATION_KERNEL 0
#define PTEDITOR_TLB_INVALIDATION_CUSTOM 1

#if defined(LINUX)
#define PTEDITOR_IOCTL_MAGIC_NUMBER (long)0x3d17

#define PTEDITOR_IOCTL_CMD_VM_RESOLVE \
  _IOR(PTEDITOR_IOCTL_MAGIC_NUMBER, 1, size_t)

#define PTEDITOR_IOCTL_CMD_VM_UPDATE \
  _IOR(PTEDITOR_IOCTL_MAGIC_NUMBER, 2, size_t)

#define PTEDITOR_IOCTL_CMD_VM_LOCK \
  _IOR(PTEDITOR_IOCTL_MAGIC_NUMBER, 3, size_t)

#define PTEDITOR_IOCTL_CMD_VM_UNLOCK \
  _IOR(PTEDITOR_IOCTL_MAGIC_NUMBER, 4, size_t)

#define PTEDITOR_IOCTL_CMD_READ_PAGE \
  _IOR(PTEDITOR_IOCTL_MAGIC_NUMBER, 5, size_t)

#define PTEDITOR_IOCTL_CMD_WRITE_PAGE \
  _IOR(PTEDITOR_IOCTL_MAGIC_NUMBER, 6, size_t)

#define PTEDITOR_IOCTL_CMD_GET_ROOT \
  _IOR(PTEDITOR_IOCTL_MAGIC_NUMBER, 7, size_t)

#define PTEDITOR_IOCTL_CMD_SET_ROOT \
  _IOR(PTEDITOR_IOCTL_MAGIC_NUMBER, 8, size_t)

#define PTEDITOR_IOCTL_CMD_GET_PAGESIZE \
  _IOR(PTEDITOR_IOCTL_MAGIC_NUMBER, 9, size_t)

#define PTEDITOR_IOCTL_CMD_INVALIDATE_TLB \
  _IOR(PTEDITOR_IOCTL_MAGIC_NUMBER, 10, size_t)

#define PTEDITOR_IOCTL_CMD_GET_PAT \
  _IOR(PTEDITOR_IOCTL_MAGIC_NUMBER, 11, size_t)

#define PTEDITOR_IOCTL_CMD_SET_PAT \
  _IOR(PTEDITOR_IOCTL_MAGIC_NUMBER, 12, size_t)

#define PTEDITOR_IOCTL_CMD_SWITCH_TLB_INVALIDATION \
  _IOR(PTEDITOR_IOCTL_MAGIC_NUMBER, 13, size_t)

#define PTEDITOR_IOCTL_CMD_INVALIDATE_TLB_PID \
  _IOR(PTEDITOR_IOCTL_MAGIC_NUMBER, 14, size_t)
#else
#define PTEDITOR_READ_PAGE CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define PTEDITOR_WRITE_PAGE CTL_CODE(FILE_DEVICE_UNKNOWN, 0x802, METHOD_BUFFERED, FILE_READ_DATA)
#define PTEDITOR_GET_CR3 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x803, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define PTEDITOR_FLUSH_TLB CTL_CODE(FILE_DEVICE_UNKNOWN, 0x804, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define PTEDITOR_READ_PHYS_VAL CTL_CODE(FILE_DEVICE_UNKNOWN, 0x805, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define PTEDITOR_WRITE_PHYS_VAL CTL_CODE(FILE_DEVICE_UNKNOWN, 0x806, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define PTEDITOR_SET_CR3 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x807, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define PTEDITOR_SET_PAT CTL_CODE(FILE_DEVICE_UNKNOWN, 0x808, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define PTEDITOR_GET_PAT CTL_CODE(FILE_DEVICE_UNKNOWN, 0x809, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif

#endif // PTEDITOR_MODULE_H

```

`ptedit.c`:

```c
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <string.h>
#include "module/pteditor.h"
#include "ptedit.h"
#if defined(LINUX)
#include <sys/ioctl.h>
#include <unistd.h>
#include <sys/mman.h>
#else
#include <Windows.h>
#endif

#if defined(LINUX)
#define PTEDIT_COLOR_RED     "\x1b[31m"
#define PTEDIT_COLOR_GREEN   "\x1b[32m"
#define PTEDIT_COLOR_RESET   "\x1b[0m"
#else
#define PTEDIT_COLOR_RED     ""
#define PTEDIT_COLOR_GREEN   ""
#define PTEDIT_COLOR_RESET   ""
#endif

#if defined(WINDOWS)
#define NO_WINDOWS_SUPPORT fprintf(stderr, PTEDIT_COLOR_RED "[-]" PTEDIT_COLOR_RESET "Error: %s not supported on Windows", __func__);
#endif

#if defined(WINDOWS)
static HANDLE ptedit_fd;
#else
static int ptedit_fd;
#endif
static int ptedit_umem;
static int ptedit_pagesize;
static size_t ptedit_pfn_multiply = 4096;
static size_t ptedit_entry_size = sizeof(size_t);
static size_t ptedit_paging_root;
static unsigned char* ptedit_vmem;

typedef struct {
    int has_pgd, has_p4d, has_pud, has_pmd, has_pt;
    int pgd_entries, p4d_entries, pud_entries, pmd_entries, pt_entries;
    int page_offset;
} ptedit_paging_definition_t;

static ptedit_paging_definition_t ptedit_paging_definition;


// ---------------------------------------------------------------------------
ptedit_fnc ptedit_resolve_t ptedit_resolve;
ptedit_fnc ptedit_update_t ptedit_update;


// ---------------------------------------------------------------------------
ptedit_fnc ptedit_entry_t ptedit_resolve_kernel(void* address, pid_t pid) {
    ptedit_entry_t vm;
    memset(&vm, 0, sizeof(vm));
    vm.vaddr = (size_t)address;
    vm.pid = (size_t)pid;
#if defined(LINUX)
    ioctl(ptedit_fd, PTEDITOR_IOCTL_CMD_VM_RESOLVE, (size_t)&vm);
#else
    NO_WINDOWS_SUPPORT;
#endif
    return vm;
}

// ---------------------------------------------------------------------------
typedef size_t(*ptedit_phys_read_t)(size_t);
typedef void(*ptedit_phys_write_t)(size_t, size_t);

// ---------------------------------------------------------------------------
static inline size_t ptedit_phys_read_map(size_t address) {
    return *(size_t*)(ptedit_vmem + address);
}

// ---------------------------------------------------------------------------
static inline void ptedit_phys_write_map(size_t address, size_t value) {
    *(size_t*)(ptedit_vmem + address) = value;
}

// ---------------------------------------------------------------------------
static inline size_t ptedit_phys_read_pread(size_t address) {
    size_t val = 0;
#if defined(LINUX)
    if (pread(ptedit_umem, &val, sizeof(size_t), address) == -1) {
      return val;
    }
#else
    ULONG returnLength;
    DeviceIoControl(ptedit_fd, PTEDITOR_READ_PHYS_VAL, (LPVOID)&address, sizeof(address), (LPVOID)&val, sizeof(val), &returnLength, 0);
#endif
    return val;
}

// ---------------------------------------------------------------------------
static inline void ptedit_phys_write_pwrite(size_t address, size_t value) {
#if defined(LINUX)
    if (pwrite(ptedit_umem, &value, sizeof(size_t), address) == -1) {
      return;
    }
#else
    ULONG returnLength;
    size_t info[2];
    info[0] = address;
    info[1] = value;
    DeviceIoControl(ptedit_fd, PTEDITOR_WRITE_PHYS_VAL, (LPVOID)&info, sizeof(info), (LPVOID)&info, sizeof(info), &returnLength, 0);
#endif
}

// ---------------------------------------------------------------------------
static ptedit_entry_t ptedit_resolve_user_ext(void* address, pid_t pid, ptedit_phys_read_t deref) {
    size_t root = (pid == 0) ? ptedit_paging_root : ptedit_get_paging_root(pid);
    root = root & ~1;

    int pgdi, p4di, pudi, pmdi, pti;
    size_t addr = (size_t)address;
    pgdi = (addr >> (ptedit_paging_definition.page_offset
        + ptedit_paging_definition.pt_entries
        + ptedit_paging_definition.pmd_entries
        + ptedit_paging_definition.pud_entries
        + ptedit_paging_definition.p4d_entries)) % (1ull << ptedit_paging_definition.pgd_entries);
    p4di = (addr >> (ptedit_paging_definition.page_offset
        + ptedit_paging_definition.pt_entries
        + ptedit_paging_definition.pmd_entries
        + ptedit_paging_definition.pud_entries)) % (1ull << ptedit_paging_definition.p4d_entries);
    pudi = (addr >> (ptedit_paging_definition.page_offset
        + ptedit_paging_definition.pt_entries
        + ptedit_paging_definition.pmd_entries)) % (1ull << ptedit_paging_definition.pud_entries);
    pmdi = (addr >> (ptedit_paging_definition.page_offset
        + ptedit_paging_definition.pt_entries)) % (1ull << ptedit_paging_definition.pmd_entries);
    pti = (addr >> ptedit_paging_definition.page_offset) % (1ull << ptedit_paging_definition.pt_entries);

    ptedit_entry_t resolved;
    memset(&resolved, 0, sizeof(resolved));
    resolved.vaddr = (size_t)address;
    resolved.pid = (size_t)pid;
    resolved.valid = 0;
    
    if(!root) return resolved;

    size_t pgd_entry, p4d_entry, pud_entry, pmd_entry, pt_entry;

    //     printf("%zx + CR3(%zx) + PGDI(%zx) * 8 = %zx\n", ptedit_vmem, root, pgdi, ptedit_vmem + root + pgdi * ptedit_entry_size);
    pgd_entry = deref(root + pgdi * ptedit_entry_size);
    if (ptedit_cast(pgd_entry, ptedit_pgd_t).present != PTEDIT_PAGE_PRESENT) {
        return resolved;
    }
    resolved.pgd = pgd_entry;
    resolved.valid |= PTEDIT_VALID_MASK_PGD;
    if (ptedit_paging_definition.has_p4d) {
        size_t pfn = (size_t)(ptedit_cast(pgd_entry, ptedit_pgd_t).pfn);
        p4d_entry = deref(pfn * ptedit_pfn_multiply + p4di * ptedit_entry_size);
        resolved.valid |= PTEDIT_VALID_MASK_P4D;
    }
    else {
        p4d_entry = pgd_entry;
    }
    resolved.p4d = p4d_entry;

    if (ptedit_cast(p4d_entry, ptedit_p4d_t).present != PTEDIT_PAGE_PRESENT) {
        return resolved;
    }


    if (ptedit_paging_definition.has_pud) {
        size_t pfn = (size_t)(ptedit_cast(p4d_entry, ptedit_p4d_t).pfn);
        pud_entry = deref(pfn * ptedit_pfn_multiply + pudi * ptedit_entry_size);
        resolved.valid |= PTEDIT_VALID_MASK_PUD;
    }
    else {
        pud_entry = p4d_entry;
    }
    resolved.pud = pud_entry;

    if (ptedit_cast(pud_entry, ptedit_pud_t).present != PTEDIT_PAGE_PRESENT) {
        return resolved;
    }

    if (ptedit_paging_definition.has_pmd) {
        size_t pfn = (size_t)(ptedit_cast(pud_entry, ptedit_pud_t).pfn);
        pmd_entry = deref(pfn * ptedit_pfn_multiply + pmdi * ptedit_entry_size);
        resolved.valid |= PTEDIT_VALID_MASK_PMD;
    }
    else {
        pmd_entry = pud_entry;
    }
    resolved.pmd = pmd_entry;

    if (ptedit_cast(pmd_entry, ptedit_pmd_t).present != PTEDIT_PAGE_PRESENT) {
        return resolved;
    }

#if defined(__i386__) || defined(__x86_64__) || defined(_WIN64)
    if (!ptedit_cast(pmd_entry, ptedit_pmd_t).size) {
#endif
        // normal 4kb page
        size_t pfn = (size_t)(ptedit_cast(pmd_entry, ptedit_pmd_t).pfn);
        pt_entry = deref(pfn * ptedit_pfn_multiply + pti * ptedit_entry_size); //pt[pti];
        resolved.pte = pt_entry;
        resolved.valid |= PTEDIT_VALID_MASK_PTE;
        if (ptedit_cast(pt_entry, ptedit_pte_t).present != PTEDIT_PAGE_PRESENT) {
            return resolved;
        }
#if defined(__i386__) || defined(__x86_64__) || defined(_WIN64)
    }
#endif
    return resolved;
}


// ---------------------------------------------------------------------------
static ptedit_entry_t ptedit_resolve_user(void* address, pid_t pid) {
    return ptedit_resolve_user_ext(address, pid, ptedit_phys_read_pread);
}


// ---------------------------------------------------------------------------
static ptedit_entry_t ptedit_resolve_user_map(void* address, pid_t pid) {
    return ptedit_resolve_user_ext(address, pid, ptedit_phys_read_map);
}


// ---------------------------------------------------------------------------
ptedit_fnc void ptedit_update_kernel(void* address, pid_t pid, ptedit_entry_t* vm) {
    vm->vaddr = (size_t)address;
    vm->pid = (size_t)pid;
#if defined(LINUX)
    ioctl(ptedit_fd, PTEDITOR_IOCTL_CMD_VM_UPDATE, (size_t)vm);
#else 
    NO_WINDOWS_SUPPORT
#endif
}

// ---------------------------------------------------------------------------
ptedit_fnc void ptedit_update_user_ext(void* address, pid_t pid, ptedit_entry_t* vm, ptedit_phys_write_t pset) {
    ptedit_entry_t current = ptedit_resolve(address, pid);
    size_t root = (pid == 0) ? ptedit_paging_root : ptedit_get_paging_root(pid);
    root = root & ~1;

    if(!root) return;
    
    size_t pgdi, p4di, pudi, pmdi, pti;
    size_t addr = (size_t)address;
    pgdi = (addr >> (ptedit_paging_definition.page_offset
        + ptedit_paging_definition.pt_entries
        + ptedit_paging_definition.pmd_entries
        + ptedit_paging_definition.pud_entries
        + ptedit_paging_definition.p4d_entries)) % (1ull << ptedit_paging_definition.pgd_entries);
    p4di = (addr >> (ptedit_paging_definition.page_offset
        + ptedit_paging_definition.pt_entries
        + ptedit_paging_definition.pmd_entries
        + ptedit_paging_definition.pud_entries)) % (1ull << ptedit_paging_definition.p4d_entries);
    pudi = (addr >> (ptedit_paging_definition.page_offset
        + ptedit_paging_definition.pt_entries
        + ptedit_paging_definition.pmd_entries)) % (1ull << ptedit_paging_definition.pud_entries);
    pmdi = (addr >> (ptedit_paging_definition.page_offset
        + ptedit_paging_definition.pt_entries)) % (1ull << ptedit_paging_definition.pmd_entries);
    pti = (addr >> ptedit_paging_definition.page_offset) % (1ull << ptedit_paging_definition.pt_entries);

    if ((vm->valid & PTEDIT_VALID_MASK_PTE) && (current.valid & PTEDIT_VALID_MASK_PTE)) {
        pset((size_t)ptedit_cast(current.pmd, ptedit_pmd_t).pfn * ptedit_pfn_multiply + pti * ptedit_entry_size, vm->pte);
    }
    if ((vm->valid & PTEDIT_VALID_MASK_PMD) && (current.valid & PTEDIT_VALID_MASK_PMD) && ptedit_paging_definition.has_pmd) {
        pset((size_t)ptedit_cast(current.pud, ptedit_pud_t).pfn * ptedit_pfn_multiply + pmdi * ptedit_entry_size, vm->pmd);
    }
    if ((vm->valid & PTEDIT_VALID_MASK_PUD) && (current.valid & PTEDIT_VALID_MASK_PUD) && ptedit_paging_definition.has_pud) {
        pset((size_t)ptedit_cast(current.p4d, ptedit_p4d_t).pfn * ptedit_pfn_multiply + pudi * ptedit_entry_size, vm->pud);
    }
    if ((vm->valid & PTEDIT_VALID_MASK_P4D) && (current.valid & PTEDIT_VALID_MASK_P4D) && ptedit_paging_definition.has_p4d) {
        pset((size_t)ptedit_cast(current.pgd, ptedit_pgd_t).pfn * ptedit_pfn_multiply + p4di * ptedit_entry_size, vm->p4d);
    }
    if ((vm->valid & PTEDIT_VALID_MASK_PGD) && (current.valid & PTEDIT_VALID_MASK_PGD) && ptedit_paging_definition.has_pgd) {
        pset(root + pgdi * ptedit_entry_size, vm->pgd);
    }

    ptedit_invalidate_tlb_pid(pid, address);
}

// ---------------------------------------------------------------------------
static void ptedit_update_user(void* address, pid_t pid, ptedit_entry_t* vm) {
    ptedit_update_user_ext(address, pid, vm, ptedit_phys_write_pwrite);
    ptedit_invalidate_tlb_pid(pid, address);
}


// ---------------------------------------------------------------------------
static void ptedit_update_user_map(void* address, pid_t pid, ptedit_entry_t* vm) {
    ptedit_update_user_ext(address, pid, vm, ptedit_phys_write_map);
    ptedit_invalidate_tlb_pid(pid, address);
}

// ---------------------------------------------------------------------------
ptedit_fnc void* ptedit_pmap(size_t physical, size_t length) {
#if defined(LINUX)
    char* m = (char*)mmap(0, length + (physical % ptedit_pagesize), PROT_READ | PROT_WRITE, MAP_SHARED, ptedit_umem, ((size_t)(physical / ptedit_pagesize)) * ptedit_pagesize);
    return m + (physical % ptedit_pagesize);
#else
    NO_WINDOWS_SUPPORT;
    return NULL;
#endif
}

// ---------------------------------------------------------------------------
ptedit_fnc size_t ptedit_set_pfn(size_t pte, size_t pfn) {
#if defined(__i386__) || defined(__x86_64__) || defined(_WIN64)
    pte &= ~(((1ull << 40) - 1) << 12);
#elif defined(__aarch64__)
    pte &= ~(((1ull << 36) - 1) << 12);
#endif
    pte |= pfn << 12;
    return pte;
}


// ---------------------------------------------------------------------------
ptedit_fnc size_t ptedit_get_pfn(size_t pte) {
#if defined(__i386__) || defined(__x86_64__) || defined(_WIN64)
    return (pte & (((1ull << 40) - 1) << 12)) >> 12;
#elif defined(__aarch64__)
    return (pte & (((1ull << 36) - 1) << 12)) >> 12;
#endif
}


// ---------------------------------------------------------------------------
#define PTEDIT_B(val, bit) (!!((val) & (1ull << (bit))))

#define PEDIT_PRINT_B(fmt, bit)                                                \
  if ((bit)) {                                                                 \
    printf(PTEDIT_COLOR_GREEN);                                                       \
    printf((fmt), (bit));                                                      \
    printf(PTEDIT_COLOR_RESET);                                                       \
  } else {                                                                     \
    printf((fmt), (bit));                                                      \
  }                                                                            \
  printf("|");


// ---------------------------------------------------------------------------
ptedit_fnc void ptedit_print_entry_line(size_t entry, int line) {
#if defined(__i386__) || defined(__x86_64__) || defined(_WIN64)
    if (line == 0 || line == 3) printf("+--+------------------+-+-+-+-+-+-+-+-+--+--+-+-+-+\n");
    if (line == 1) printf("|NX|       PFN        |H|?|?|?|G|S|D|A|UC|WT|U|W|P|\n");
    if (line == 2) {
        printf("|");
        PEDIT_PRINT_B(" %d", PTEDIT_B(entry, PTEDIT_PAGE_BIT_NX));
        printf(" %16p |", (void*)((entry >> 12) & ((1ull << 40) - 1)));
        PEDIT_PRINT_B("%d", PTEDIT_B(entry, PTEDIT_PAGE_BIT_PAT_LARGE));
        PEDIT_PRINT_B("%d", PTEDIT_B(entry, PTEDIT_PAGE_BIT_SOFTW3));
        PEDIT_PRINT_B("%d", PTEDIT_B(entry, PTEDIT_PAGE_BIT_SOFTW2));
        PEDIT_PRINT_B("%d", PTEDIT_B(entry, PTEDIT_PAGE_BIT_SOFTW1));
        PEDIT_PRINT_B("%d", PTEDIT_B(entry, PTEDIT_PAGE_BIT_GLOBAL));
        PEDIT_PRINT_B("%d", PTEDIT_B(entry, PTEDIT_PAGE_BIT_PSE));
        PEDIT_PRINT_B("%d", PTEDIT_B(entry, PTEDIT_PAGE_BIT_DIRTY));
        PEDIT_PRINT_B("%d", PTEDIT_B(entry, PTEDIT_PAGE_BIT_ACCESSED));
        PEDIT_PRINT_B(" %d", PTEDIT_B(entry, PTEDIT_PAGE_BIT_PCD));
        PEDIT_PRINT_B(" %d", PTEDIT_B(entry, PTEDIT_PAGE_BIT_PWT));
        PEDIT_PRINT_B("%d", PTEDIT_B(entry, PTEDIT_PAGE_BIT_USER));
        PEDIT_PRINT_B("%d", PTEDIT_B(entry, PTEDIT_PAGE_BIT_RW));
        PEDIT_PRINT_B("%d", PTEDIT_B(entry, PTEDIT_PAGE_BIT_PRESENT));
        printf("\n");
    }
#elif defined(__aarch64__)
    if (line == 0 || line == 3) {
        printf("+--+--+--+---+-+--+------------------+--+-+-+-+--+---+-+\n");
    }
    if (line == 1) {
        printf("| ?| ?|XN|PXN|C| ?|        PFN       |NG|A|S|P|NS|MAI|T|\n");
    }
    if (line == 2) {
        printf("|");
        PEDIT_PRINT_B("%2d", (PTEDIT_B(entry, 63) << 4) | (PTEDIT_B(entry, 62) << 3) | (PTEDIT_B(entry, 61) << 2) | (PTEDIT_B(entry, 60) << 1) | PTEDIT_B(entry, 59));
        PEDIT_PRINT_B("%2d", (PTEDIT_B(entry, 58) << 3) | (PTEDIT_B(entry, 57) << 2) | (PTEDIT_B(entry, 56) << 1) | PTEDIT_B(entry, 55));
        PEDIT_PRINT_B(" %d", PTEDIT_B(entry, 54));
        PEDIT_PRINT_B(" %d ", PTEDIT_B(entry, 53));
        PEDIT_PRINT_B("%d", PTEDIT_B(entry, 52));
        PEDIT_PRINT_B("%2d", (PTEDIT_B(entry, 51) << 3) | (PTEDIT_B(entry, 50) << 2) | (PTEDIT_B(entry, 49) << 1) | PTEDIT_B(entry, 48));
        printf(" %16p |", (void*)((entry >> 12) & ((1ull << 36) - 1)));
        PEDIT_PRINT_B(" %d", PTEDIT_B(entry, 11));
        PEDIT_PRINT_B("%d", PTEDIT_B(entry, 10));
        PEDIT_PRINT_B("%d", (PTEDIT_B(entry, 9) << 1) | PTEDIT_B(entry, 8));
        PEDIT_PRINT_B("%d", (PTEDIT_B(entry, 7) << 1) | PTEDIT_B(entry, 6));
        PEDIT_PRINT_B(" %d", PTEDIT_B(entry, 5));
        PEDIT_PRINT_B(" %d ", (PTEDIT_B(entry, 4) << 2) | (PTEDIT_B(entry, 3) << 1) | PTEDIT_B(entry, 2));
        PEDIT_PRINT_B("%d", (PTEDIT_B(entry, 1) << 1) | PTEDIT_B(entry, 0));
        printf("\n");
    }
#endif
}


// ---------------------------------------------------------------------------
ptedit_fnc void ptedit_print_entry(size_t entry) {
    int i = 0;
    for (i = 0; i < 4; i++) {
        ptedit_print_entry_line(entry, i);
    }
}

// ---------------------------------------------------------------------------
ptedit_fnc void ptedit_print_entry_t(ptedit_entry_t entry) {
    if (entry.valid & PTEDIT_VALID_MASK_PGD) {
        printf("PGD of address\n");
        ptedit_print_entry(entry.pgd);
    }
    if (entry.valid & PTEDIT_VALID_MASK_P4D) {
        printf("P4D of address\n");
        ptedit_print_entry(entry.p4d);
    }
    if (entry.valid & PTEDIT_VALID_MASK_PUD) {
        printf("PUD of address\n");
        ptedit_print_entry(entry.pud);
    }
    if (entry.valid & PTEDIT_VALID_MASK_PMD) {
        printf("PMD of address\n");
        ptedit_print_entry(entry.pmd);
    }
    if (entry.valid & PTEDIT_VALID_MASK_PTE) {
        printf("PTE of address\n");
        ptedit_print_entry(entry.pte);
    }
}

// ---------------------------------------------------------------------------
ptedit_fnc int ptedit_init() {
#if defined(LINUX)
    ptedit_fd = open(PTEDITOR_DEVICE_PATH, O_RDONLY);
    if (ptedit_fd < 0) {
        fprintf(stderr, PTEDIT_COLOR_RED "[-]" PTEDIT_COLOR_RESET "Error: Could not open PTEditor device: %s\n", PTEDITOR_DEVICE_PATH);
        return -1;
    }
#if !defined(__aarch64__)
    ptedit_umem = open("/proc/umem", O_RDWR);
#else
    ptedit_umem = 0;
#endif
#else
    ptedit_fd = CreateFile(PTEDITOR_DEVICE_PATH, GENERIC_ALL, 0, 0, OPEN_EXISTING, FILE_ATTRIBUTE_SYSTEM, 0);
    if (ptedit_fd == INVALID_HANDLE_VALUE) {
        fprintf(stderr, PTEDIT_COLOR_RED "[-]" PTEDIT_COLOR_RESET "Error: Could not open PTEditor device: %ws\n", PTEDITOR_DEVICE_PATH);
        return -1;
    }
    ptedit_umem = 0;
#endif
#if defined(LINUX)
    ptedit_use_implementation(PTEDIT_IMPL_KERNEL);
#elif defined(WINDOWS)
    ptedit_use_implementation(PTEDIT_IMPL_USER_PREAD);
#endif
    //   }
#if defined(LINUX)
    ptedit_pagesize = getpagesize();
#else
    ptedit_pagesize = ptedit_get_pagesize();
#endif

#if defined(__i386__) || defined(__x86_64__) || defined(_WIN64)
    ptedit_paging_definition.has_pgd = 1;
    ptedit_paging_definition.has_p4d = 0;
    ptedit_paging_definition.has_pud = 1;
    ptedit_paging_definition.has_pmd = 1;
    ptedit_paging_definition.has_pt = 1;
    ptedit_paging_definition.pgd_entries = 9;
    ptedit_paging_definition.p4d_entries = 0;
    ptedit_paging_definition.pud_entries = 9;
    ptedit_paging_definition.pmd_entries = 9;
    ptedit_paging_definition.pt_entries = 9;
    ptedit_paging_definition.page_offset = 12;
#elif defined(__aarch64__)
    if(ptedit_get_pagesize() == 16384) {
        ptedit_paging_definition.has_pgd = 1;
        ptedit_paging_definition.has_p4d = 0;
        ptedit_paging_definition.has_pud = 1;
        ptedit_paging_definition.has_pmd = 1;
        ptedit_paging_definition.has_pt = 1;
        ptedit_paging_definition.pgd_entries = 11;
        ptedit_paging_definition.p4d_entries = 0;
        ptedit_paging_definition.pud_entries = 11;
        ptedit_paging_definition.pmd_entries = 11;
        ptedit_paging_definition.pt_entries = 11;
        ptedit_paging_definition.page_offset = 14;
        ptedit_use_implementation(PTEDIT_IMPL_USER_PREAD); // M1 workaround
    } else {
        ptedit_paging_definition.has_pgd = 1;
        ptedit_paging_definition.has_p4d = 0;
        ptedit_paging_definition.has_pud = 0;
        ptedit_paging_definition.has_pmd = 1;
        ptedit_paging_definition.has_pt = 1;
        ptedit_paging_definition.pgd_entries = 9;
        ptedit_paging_definition.p4d_entries = 0;
        ptedit_paging_definition.pud_entries = 0;
        ptedit_paging_definition.pmd_entries = 9;
        ptedit_paging_definition.pt_entries = 9;
        ptedit_paging_definition.page_offset = 12;
    }
#endif
    return 0;
}


// ---------------------------------------------------------------------------
ptedit_fnc void ptedit_cleanup() {
#if defined(LINUX)
    if (ptedit_fd >= 0) {
        close(ptedit_fd);
    }
    if (ptedit_umem > 0) {
        close(ptedit_umem);
    }
#else
    CloseHandle(ptedit_fd);
#endif
}


// ---------------------------------------------------------------------------
ptedit_fnc void ptedit_use_implementation(int implementation) {
    if (implementation == PTEDIT_IMPL_KERNEL) {
#if defined(LINUX)
        ptedit_resolve = ptedit_resolve_kernel;
        ptedit_update = ptedit_update_kernel;
#else
        fprintf(stderr, PTEDIT_COLOR_RED "[-]" PTEDIT_COLOR_RESET "Error: PTEditor implementation not supported on Windows");
#endif
    }
    else if (implementation == PTEDIT_IMPL_USER_PREAD) {
        ptedit_resolve = ptedit_resolve_user;
        ptedit_update = ptedit_update_user;
        ptedit_paging_root = ptedit_get_paging_root(0);
    }
    else if (implementation == PTEDIT_IMPL_USER) {
#if defined(LINUX)
        ptedit_resolve = ptedit_resolve_user_map;
        ptedit_update = ptedit_update_user_map;
        ptedit_paging_root = ptedit_get_paging_root(0);
        if (!ptedit_vmem) {
            ptedit_vmem = (unsigned char*)mmap(NULL, 32ull << 30ull, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_NORESERVE, ptedit_umem, 0);
            fprintf(stderr, PTEDIT_COLOR_GREEN "[+]" PTEDIT_COLOR_RESET " Mapped physical memory to %p\n", ptedit_vmem);
        }
#else
        fprintf(stderr, PTEDIT_COLOR_RED "[-]" PTEDIT_COLOR_RESET "Error: PTEditor implementation not supported on Windows");
#endif
    }
    else {
        fprintf(stderr, PTEDIT_COLOR_RED "[-]" PTEDIT_COLOR_RESET " Error: PTEditor implementation not supported!\n");
    }
}


// ---------------------------------------------------------------------------
ptedit_fnc int ptedit_get_pagesize() {
#if defined(LINUX)
    return (int)ioctl(ptedit_fd, PTEDITOR_IOCTL_CMD_GET_PAGESIZE, 0);
#else
    SYSTEM_INFO sysinfo;
    GetSystemInfo(&sysinfo);
    return sysinfo.dwPageSize;
#endif
}


// ---------------------------------------------------------------------------
ptedit_fnc void ptedit_read_physical_page(size_t pfn, char* buffer) {
#if defined(LINUX)
    if (ptedit_umem > 0) {
        if (pread(ptedit_umem, buffer, ptedit_pagesize, pfn * ptedit_pagesize) == -1) {
          return;
        }
    }
    else {
        ptedit_page_t page;
        page.buffer = (unsigned char*)buffer;
        page.pfn = pfn;
        ioctl(ptedit_fd, PTEDITOR_IOCTL_CMD_READ_PAGE, (size_t)&page);
    }
#else
    DWORD returnLength;
    pfn *= ptedit_pagesize;
    DeviceIoControl(ptedit_fd, PTEDITOR_READ_PAGE, (LPVOID)&pfn, sizeof(pfn), (LPVOID)buffer, 4096, &returnLength, 0);
#endif
}


// ---------------------------------------------------------------------------
ptedit_fnc void ptedit_write_physical_page(size_t pfn, char* content) {
#if defined(LINUX)
    if (ptedit_umem > 0) {
        if (pwrite(ptedit_umem, content, ptedit_pagesize, pfn * ptedit_pagesize) == -1) {
          return;
        }
    }
    else {
        ptedit_page_t page;
        page.buffer = (unsigned char*)content;
        page.pfn = pfn;
        ioctl(ptedit_fd, PTEDITOR_IOCTL_CMD_WRITE_PAGE, (size_t)&page);
    }
#else
    DWORD returnLength;
    ptedit_page_t page;
    if (ptedit_pagesize != 4096) {
        fprintf(stderr, PTEDIT_COLOR_RED "[-]" PTEDIT_COLOR_RESET "Error: page sizes other than 4096 not supported on Windows");
        return;
    }
    page.paddr = pfn * ptedit_pagesize;
    memcpy(page.content, content, ptedit_pagesize);
    DeviceIoControl(ptedit_fd, PTEDITOR_WRITE_PAGE, (LPVOID)&page, sizeof(ptedit_page_t), (LPVOID)&page, sizeof(ptedit_page_t), &returnLength, 0);
#endif
}


// ---------------------------------------------------------------------------
size_t ptedit_get_paging_root(pid_t pid) {
#if defined(LINUX)
    ptedit_paging_t cr3;
    cr3.pid = (size_t)pid;
    cr3.root = 0;
    ioctl(ptedit_fd, PTEDITOR_IOCTL_CMD_GET_ROOT, (size_t)&cr3);
    return cr3.root;
#else
    size_t cr3 = 0;
    DWORD returnLength;
    if(!pid) pid = GetCurrentProcessId();
    DeviceIoControl(ptedit_fd, PTEDITOR_GET_CR3, (LPVOID)&pid, sizeof(pid), (LPVOID)&cr3, sizeof(cr3), &returnLength, 0);
    return (cr3 & ~0xfff);
#endif
}


// ---------------------------------------------------------------------------
void ptedit_set_paging_root(pid_t pid, size_t root) {
    ptedit_paging_t cr3;
    cr3.pid = (size_t)pid;
    cr3.root = root; 
#if defined(LINUX)
    ioctl(ptedit_fd, PTEDITOR_IOCTL_CMD_SET_ROOT, (size_t)&cr3);
#else
    DWORD returnLength;
    if (!pid) pid = GetCurrentProcessId();
    size_t info[2];
    info[0] = pid;
    info[1] = root;
    DeviceIoControl(ptedit_fd, PTEDITOR_SET_CR3, (LPVOID)info, sizeof(info), (LPVOID)info, sizeof(info), &returnLength, 0);
#endif
}

// ---------------------------------------------------------------------------
ptedit_fnc void ptedit_invalidate_tlb_pid(pid_t pid, void* address) {
#if defined(LINUX)
    ptedit_invalidate_tlb_args_t args;
    args.pid = pid;
    args.address = address;
    ioctl(ptedit_fd, PTEDITOR_IOCTL_CMD_INVALIDATE_TLB_PID, (size_t)&args, pid);
#else
    size_t vaddr = (size_t)address;
    DWORD returnLength;
    DeviceIoControl(ptedit_fd, PTEDITOR_FLUSH_TLB, (LPVOID)&vaddr, sizeof(vaddr), (LPVOID)&vaddr, sizeof(vaddr), &returnLength, 0);
#endif
}

// ---------------------------------------------------------------------------
ptedit_fnc void ptedit_invalidate_tlb(void* address) {
    // we do not directly call ptedit_invalidate_tlb_pid to ensure that the old
    // API is still working (for backwards compatibility)
#if defined(LINUX)
    ioctl(ptedit_fd, PTEDITOR_IOCTL_CMD_INVALIDATE_TLB, (size_t)address);
#else
    size_t vaddr = (size_t)address;
    DWORD returnLength;
    DeviceIoControl(ptedit_fd, PTEDITOR_FLUSH_TLB, (LPVOID)&vaddr, sizeof(vaddr), (LPVOID)&vaddr, sizeof(vaddr), &returnLength, 0);
#endif
}

// ---------------------------------------------------------------------------
ptedit_fnc int ptedit_switch_tlb_invalidation(int implementation) {
#if defined(LINUX)
    return (int) ioctl(ptedit_fd, PTEDITOR_IOCTL_CMD_SWITCH_TLB_INVALIDATION, (size_t) implementation);
#else
    NO_WINDOWS_SUPPORT
#endif
}


// ---------------------------------------------------------------------------
ptedit_fnc size_t ptedit_get_mts() {
    size_t mt = 0;
#if defined(LINUX)
    ioctl(ptedit_fd, PTEDITOR_IOCTL_CMD_GET_PAT, (size_t)&mt);
#else
    DWORD returnLength;
    DeviceIoControl(ptedit_fd, PTEDITOR_GET_PAT, (LPVOID)&mt, sizeof(mt), (LPVOID)&mt, sizeof(mt), &returnLength, 0);
#endif
    return mt;
}


// ---------------------------------------------------------------------------
ptedit_fnc char ptedit_get_mt(unsigned char mt) {
    size_t mts = ptedit_get_mts();
#if defined(__i386__) || defined(__x86_64__) || defined(_WIN64)
    return ((mts >> (mt * 8)) & 7);
#elif defined(__aarch64__)
    return ((mts >> (mt * 8)) & 0xff);
#endif
}


// ---------------------------------------------------------------------------
const char* ptedit_mt_to_string(unsigned char mt) {
#if defined(__i386__) || defined(__x86_64__) || defined(_WIN64)
    const char* mts[] = { "UC", "WC", "Rsvd", "Rsvd", "WT", "WP", "WB", "UC-", "Rsvd" };
    if (mt <= 7) return mts[mt];
    return NULL;
#elif defined(__aarch64__)
    static char mts[16];
    int i;
    mts[0] = 0;
    for (i = 0; i < 2; i++) {
        strcat(mts, i == 0 ? "I" : "O");
        if ((mt & 0xf) == ((mt >> 4) & 0xf)) strcpy(mts, "");
        switch ((mt >> (i * 4)) & 0xf) {
        case 0:
            strcat(mts, "DM");
            break;
        case 1: /* Fall through */
        case 2: /* Fall through */
        case 3:
            strcat(mts, "WT");
            break;
        case 4:
            strcat(mts, "UC");
            break;
        case 5: /* Fall through */
        case 6: /* Fall through */
        case 7:
            strcat(mts, "WB");
            break;
        case 8: /* Fall through */
        case 9: /* Fall through */
        case 10: /* Fall through */
        case 11:
            strcat(mts, "WT");
            break;
        case 12: /* Fall through */
        case 13: /* Fall through */
        case 14: /* Fall through */
        case 15:
            strcat(mts, "WB");
        }
    }
    return mts;
#endif
}


// ---------------------------------------------------------------------------
ptedit_fnc void ptedit_set_mts(size_t mts) {
#if defined(LINUX)
    ioctl(ptedit_fd, PTEDITOR_IOCTL_CMD_SET_PAT, mts);
#else
    DWORD returnLength;
    DeviceIoControl(ptedit_fd, PTEDITOR_GET_PAT, (LPVOID)&mts, sizeof(mts), (LPVOID)&mts, sizeof(mts), &returnLength, 0);
#endif
}


// ---------------------------------------------------------------------------
ptedit_fnc void ptedit_set_mt(unsigned char mt, unsigned char value) {
    size_t mts = ptedit_get_mts();
#if defined(__i386__) || defined(__x86_64__) || defined(_WIN64)
    mts &= ~(7 << (mt * 8));
#elif defined(__aarch64__)
    mts &= ~(0xff << (mt * 8));
#endif
    mts |= ((size_t)value << (mt * 8));
    ptedit_set_mts(mts);
}


// ---------------------------------------------------------------------------
ptedit_fnc unsigned char ptedit_find_mt(unsigned char type) {
    size_t mts = ptedit_get_mts();
    unsigned char found = 0;
    int i;
    for (i = 0; i < 8; i++) {
#if defined(__i386__) || defined(__x86_64__) || defined(_WIN64)
        if (((mts >> (i * 8)) & 7) == type) found |= (1 << i);
#elif defined(__aarch64__)
        if (((mts >> (i * 8)) & 0xff) == type) {
            found |= (1 << i);
        }
        else {
            unsigned char plow, phigh;
            plow = (mts >> (i * 8)) & 0xf;
            phigh = ((mts >> (i * 8)) >> 4) & 0xf;
            if ((plow == phigh) && (plow == type)) {
                found |= (1 << i);
            }
        }
#endif
    }
    return found;
}


// ---------------------------------------------------------------------------
int ptedit_find_first_mt(unsigned char type) {
#if defined(LINUX)
    return __builtin_ffs(ptedit_find_mt(type)) - 1;
#else
    DWORD index = 0;
    if (BitScanForward64(&index, ptedit_find_mt(type))) {
        return index;
    }
    else {
        return -1;
    }
#endif
}


// ---------------------------------------------------------------------------
ptedit_fnc size_t ptedit_apply_mt(size_t entry, unsigned char mt) {
#if defined(__i386__) || defined(__x86_64__) || defined(_WIN64)
    entry &= ~((1ull << PTEDIT_PAGE_BIT_PWT) | (1ull << PTEDIT_PAGE_BIT_PCD) | (1ull << PTEDIT_PAGE_BIT_PAT));
    if (mt & 1) entry |= (1ull << PTEDIT_PAGE_BIT_PWT);
    if (mt & 2) entry |= (1ull << PTEDIT_PAGE_BIT_PCD);
    if (mt & 4) entry |= (1ull << PTEDIT_PAGE_BIT_PAT);
#elif defined(__aarch64__)
    entry &= ~0x1c;
    entry |= (mt & 7) << 2;
#endif
    return entry;
}

// ---------------------------------------------------------------------------
size_t ptedit_apply_mt_huge(size_t entry, unsigned char mt) {
#if defined(__i386__) || defined(__x86_64__) || defined(_WIN64)
    entry &= ~((1ull << PTEDIT_PAGE_BIT_PWT) | (1ull << PTEDIT_PAGE_BIT_PCD) | (1ull << PTEDIT_PAGE_BIT_PAT_LARGE));
    if (mt & 1) entry |= (1ull << PTEDIT_PAGE_BIT_PWT);
    if (mt & 2) entry |= (1ull << PTEDIT_PAGE_BIT_PCD);
    if (mt & 4) entry |= (1ull << PTEDIT_PAGE_BIT_PAT_LARGE);
#elif defined(__aarch64__)
    entry &= ~0x1c;
    entry |= (mt & 7) << 2;
#endif
    return entry;
}

// ---------------------------------------------------------------------------
ptedit_fnc unsigned char ptedit_extract_mt(size_t entry) {
#if defined(__i386__) || defined(__x86_64__) || defined(_WIN64)
    return (!!(entry & (1ull << PTEDIT_PAGE_BIT_PWT))) | ((!!(entry & (1ull << PTEDIT_PAGE_BIT_PCD))) << 1) | ((!!(entry & (1ull << PTEDIT_PAGE_BIT_PAT))) << 2);
#elif defined(__aarch64__)
    return (entry >> 2) & 7;
#endif
}

// ---------------------------------------------------------------------------
unsigned char ptedit_extract_mt_huge(size_t entry) {
#if defined(__i386__) || defined(__x86_64__) || defined(_WIN64)
    return (!!(entry & (1ull << PTEDIT_PAGE_BIT_PWT))) | ((!!(entry & (1ull << PTEDIT_PAGE_BIT_PCD))) << 1) | ((!!(entry & (1ull << PTEDIT_PAGE_BIT_PAT_LARGE))) << 2);
#elif defined(__aarch64__)
    return (entry >> 2) & 7;
#endif
}

// ---------------------------------------------------------------------------
ptedit_fnc void ptedit_full_serializing_barrier() {
#if defined(__i386__) || defined(__x86_64__) || defined(_WIN64)
#if defined(LINUX)
    asm volatile("mfence\nlfence\n" ::: "memory");
#else
    MemoryBarrier();
#endif
#elif defined(__aarch64__)
    asm volatile("DSB SY");
    asm volatile("DSB ISH");
    asm volatile("ISB");
#endif
    ptedit_set_paging_root(0, ptedit_get_paging_root(0));
#if defined(__i386__) || defined(__x86_64__) || defined(_WIN64)
#if defined(LINUX)
    asm volatile("mfence\nlfence\n" ::: "memory");
#else 
    MemoryBarrier();
#endif
#elif defined(__aarch64__)
    asm volatile("ISB");
    asm volatile("DSB ISH");
    asm volatile("DSB SY");
#endif
}


// ---------------------------------------------------------------------------
ptedit_fnc void ptedit_pte_set_bit(void* address, pid_t pid, int bit) {
    ptedit_entry_t vm = ptedit_resolve(address, pid);
    if (!(vm.valid & PTEDIT_VALID_MASK_PTE)) return;
    vm.pte |= (1ull << bit);
    vm.valid = PTEDIT_VALID_MASK_PTE;
    ptedit_update(address, pid, &vm);
}

// ---------------------------------------------------------------------------
ptedit_fnc void ptedit_pte_clear_bit(void* address, pid_t pid, int bit) {
    ptedit_entry_t vm = ptedit_resolve(address, pid);
    if (!(vm.valid & PTEDIT_VALID_MASK_PTE)) return;
    vm.pte &= ~(1ull << bit);
    vm.valid = PTEDIT_VALID_MASK_PTE;
    ptedit_update(address, pid, &vm);
}

// ---------------------------------------------------------------------------
ptedit_fnc unsigned char ptedit_pte_get_bit(void* address, pid_t pid, int bit) {
    ptedit_entry_t vm = ptedit_resolve(address, pid);
    return !!(vm.pte & (1ull << bit));
}

// ---------------------------------------------------------------------------
ptedit_fnc size_t ptedit_pte_get_pfn(void* address, pid_t pid) {
    ptedit_entry_t vm = ptedit_resolve(address, pid);
    if (!(vm.valid & PTEDIT_VALID_MASK_PTE)) return 0;
    else return ptedit_get_pfn(vm.pte);
}

// ---------------------------------------------------------------------------
ptedit_fnc void ptedit_pte_set_pfn(void* address, pid_t pid, size_t pfn) {
    ptedit_entry_t vm = ptedit_resolve(address, pid);
    if (!(vm.valid & PTEDIT_VALID_MASK_PTE)) return;
    vm.pte = ptedit_set_pfn(vm.pte, pfn);
    vm.valid = PTEDIT_VALID_MASK_PTE;
    ptedit_update(address, pid, &vm);
}

```

`ptedit.h`:

```h
/** @file */

#ifndef _PTEDITOR_H_
#define _PTEDITOR_H_

#ifdef __cplusplus
extern "C" {
#endif

#define ptedit_fnc

#include "module/pteditor.h"
#include <sys/types.h>

#if defined(WINDOWS)
typedef size_t pid_t;
#endif

/**
 * The implementation of PTEditor to use
 *
 * @defgroup PTEDITOR_IMPLEMENTATION PTEditor Implementation
 *
 * @{
 */

 /** Use the kernel to resolve and update paging structures */
#define PTEDIT_IMPL_KERNEL       0
/** Use the user-space implemenation to resolve and update paging structures, using pread to read from the memory mapping */
#define PTEDIT_IMPL_USER_PREAD   1
/** Use the user-space implemenation that maps the physical memory into user space to resolve and update paging structures */
#define PTEDIT_IMPL_USER         2

/**
 * The bits in a page-table entry
 *
 * @defgroup PAGETABLE_BITS Page Table Bits
 *
 * @{
 *
 */

#if defined(__i386__) || defined(__x86_64__) || defined(_WIN64)

 /** Page is present */
#define PTEDIT_PAGE_BIT_PRESENT 0
/** Page is writeable */
#define PTEDIT_PAGE_BIT_RW 1
/** Page is userspace addressable */
#define PTEDIT_PAGE_BIT_USER 2
/** Page write through */
#define PTEDIT_PAGE_BIT_PWT 3
/** Page cache disabled */
#define PTEDIT_PAGE_BIT_PCD 4
/** Page was accessed (raised by CPU) */
#define PTEDIT_PAGE_BIT_ACCESSED 5
/** Page was written to (raised by CPU) */
#define PTEDIT_PAGE_BIT_DIRTY 6
/** 4 MB (or 2MB) page */
#define PTEDIT_PAGE_BIT_PSE 7
/** PAT (only on 4KB pages) */
#define PTEDIT_PAGE_BIT_PAT 7
/** Global TLB entry PPro+ */
#define PTEDIT_PAGE_BIT_GLOBAL 8
/** Available for programmer */
#define PTEDIT_PAGE_BIT_SOFTW1 9
/** Available for programmer */
#define PTEDIT_PAGE_BIT_SOFTW2 10
/** Available for programmer */
#define PTEDIT_PAGE_BIT_SOFTW3 11
/** PAT (on 2MB or 1GB pages) */
#define PTEDIT_PAGE_BIT_PAT_LARGE 12
/** Available for programmer */
#define PTEDIT_PAGE_BIT_SOFTW4 58
/** Protection Keys, bit 1/4 */
#define PTEDIT_PAGE_BIT_PKEY_BIT0 59
/** Protection Keys, bit 2/4 */
#define PTEDIT_PAGE_BIT_PKEY_BIT1 60
/** Protection Keys, bit 3/4 */
#define PTEDIT_PAGE_BIT_PKEY_BIT2 61
/** Protection Keys, bit 4/4 */
#define PTEDIT_PAGE_BIT_PKEY_BIT3 62
/** No execute: only valid after cpuid check */
#define PTEDIT_PAGE_BIT_NX 63

#elif defined(__aarch64__)

 /** Entry type 1/2 */
#define PTEDIT_PAGE_BIT_TYPE_BIT0 0
/** Entry type 1/2 */
#define PTEDIT_PAGE_BIT_TYPE_BIT1 1
/** Memory attribute index 1/3 */
#define PTEDIT_PAGE_BIT_MAIR_BIT0 2
/** Memory attribute index 2/3 */
#define PTEDIT_PAGE_BIT_MAIR_BIT1 3
/** Memory attribute index 3/3 */
#define PTEDIT_PAGE_BIT_MAIR_BIT2 4
/** Page is non-secure */
#define PTEDIT_PAGE_BIT_NON_SECURE 5
/** Page permissions 1/2 */
#define PTEDIT_PAGE_BIT_PERMISSION_BIT0 6
/** Page permissions 2/2 */
#define PTEDIT_PAGE_BIT_PERMISSION_BIT1 7
/** Shareability domain 1/2 */
#define PTEDIT_PAGE_BIT_SHARE_BIT0 8
/** Shareability domain 2/2 */
#define PTEDIT_PAGE_BIT_SHARE_BIT1 9
/** Page was accessed (raised by CPU) */
#define PTEDIT_PAGE_BIT_ACCESSED 10
/** Page is not global */
#define PTEDIT_PAGE_BIT_NOT_GLOBAL 11
/** Contiguous */
#define PTEDIT_PAGE_BIT_CONTIGUOUS 52
/** Privileged execute never */
#define PTEDIT_PAGE_BIT_PXN 53
/** Execute never */
#define PTEDIT_PAGE_BIT_XN 54
/** Available for programmer */
#define PTEDIT_PAGE_BIT_SOFTW1 55
/** Available for programmer */
#define PTEDIT_PAGE_BIT_SOFTW2 56
/** Available for programmer */
#define PTEDIT_PAGE_BIT_SOFTW3 57
/** Available for programmer */
#define PTEDIT_PAGE_BIT_SOFTW4 58
/** Available for programmer */
#define PTEDIT_PAGE_BIT_SOFTW5 59
/** Available for programmer */
#define PTEDIT_PAGE_BIT_SOFTW6 60
/** Available for programmer */
#define PTEDIT_PAGE_BIT_SOFTW7 61
/** Available for programmer */
#define PTEDIT_PAGE_BIT_SOFTW8 62
/** Available for programmer */
#define PTEDIT_PAGE_BIT_SOFTW9 63

#endif
/** @} */

/**
 * The memory types (PAT/MAIR)values
 *
 * @defgroup MEMORY_TYPES Memory Types (PAT/MAIR values)
 *
 * @{
 */
#if defined(__i386__) || defined(__x86_64__) || defined(_WIN64)

 /** Strong uncachable (nothing is cached) */
#define PTEDIT_MT_UC      0
/** Write combining (consecuite writes are combined in a WC buffer and then written once) */
#define PTEDIT_MT_WC      1
/** Write through (read accesses are cached, write access are written to cache and memory) */
#define PTEDIT_MT_WT      4
/** Write protected (only read access is cached) */
#define PTEDIT_MT_WP      5
/** Write back (read and write accesses are cached) */
#define PTEDIT_MT_WB      6
/** Uncachable (as UC, but can be changed to WC through MTRRs) */
#define PTEDIT_MT_UCMINUS 7

#elif defined(__aarch64__)

 /** Strong uncachable (nothing is cached) */
#define PTEDIT_MT_UC      0x44
/** Write through (read accesses are cached, write access are written to cache and memory) */
#define PTEDIT_MT_WT      0xbb
/** Write back (read and write accesses are cached) */
#define PTEDIT_MT_WB      0xff

#endif
/** @} */


/**
 * Basic functionality required in every program
 *
 * @defgroup BASIC Basic Functionality
 *
 * @{
 */

 /**
  * Initializes (and acquires) PTEditor kernel module
  *
  * @return 0 Initialization was successful
  * @return -1 Initialization failed
  */
ptedit_fnc int ptedit_init();

/**
 * Releases PTEditor kernel module
 *
 */
ptedit_fnc void ptedit_cleanup();

/**
 * Switch between kernel and user-space implementation
 *
 * @param[in] implementation The implementation to use, either PTEDIT_IMPL_KERNEL, PTEDIT_IMPL_USER, or PTEDIT_IMPL_USER_PREAD
 *
 */
ptedit_fnc void ptedit_use_implementation(int implementation);

/** @} */




/**
 * Functions to read and write page tables
 *
 * @defgroup PAGETABLE Page tables
 *
 * @{
 */

typedef ptedit_entry_t(*ptedit_resolve_t)(void*, pid_t);
typedef void (*ptedit_update_t)(void*, pid_t, ptedit_entry_t*);


/**
 * Resolves the page-table entries of all levels for a virtual address of a given process.
 *
 * @param[in] address The virtual address to resolve
 * @param[in] pid The pid of the process (0 for own process)
 *
 * @return A structure containing the page-table entries of all levels.
 */
extern ptedit_fnc ptedit_resolve_t ptedit_resolve;

/**
 * Updates one or more page-table entries for a virtual address of a given process.
 * The TLB for the given address is flushed after updating the entries.
 *
 * @param[in] address The virtual address
 * @param[in] pid The pid of the process (0 for own process)
 * @param[in] vm A structure containing the values for the page-table entries and a bitmask indicating which entries to update
 *
 */
extern ptedit_fnc ptedit_update_t ptedit_update;

/**
 * Sets a bit directly in the PTE of an address.
 *
 * @param[in] address The virtual address
 * @param[in] pid The pid of the process (0 for own process)
 * @param[in] bit The bit to set (one of PTEDIT_PAGE_BIT_*)
 *
 */
ptedit_fnc void ptedit_pte_set_bit(void* address, pid_t pid, int bit);

/**
 * Clears a bit directly in the PTE of an address.
 *
 * @param[in] address The virtual address
 * @param[in] pid The pid of the process (0 for own process)
 * @param[in] bit The bit to clear (one of PTEDIT_PAGE_BIT_*)
 *
 */
ptedit_fnc void ptedit_pte_clear_bit(void* address, pid_t pid, int bit);

/**
 * Returns the value of a bit directly from the PTE of an address.
 *
 * @param[in] address The virtual address
 * @param[in] pid The pid of the process (0 for own process)
 * @param[in] bit The bit to get (one of PTEDIT_PAGE_BIT_*)
 *
 * @return The value of the bit (0 or 1)
 *
 */
ptedit_fnc unsigned char ptedit_pte_get_bit(void* address, pid_t pid, int bit);

/**
 * Reads the PFN directly from the PTE of an address.
 *
 * @param[in] address The virtual address
 * @param[in] pid The pid of the process (0 for own process)
 *
 * @return The page-frame number (PFN)
 *
 */
ptedit_fnc size_t ptedit_pte_get_pfn(void* address, pid_t pid);

/**
 * Sets the PFN directly in the PTE of an address.
 *
 * @param[in] address The virtual address
 * @param[in] pid The pid of the process (0 for own process)
 * @param[in] pfn The new page-frame number (PFN)
 *
 */
ptedit_fnc void ptedit_pte_set_pfn(void* address, pid_t pid, size_t pfn);


#if defined(__i386__) || defined(__x86_64__) || defined(_WIN64)
#define PTEDIT_PAGE_PRESENT 1

/**
 * Struct to access the fields of the PGD
 */
#pragma pack(push,1)
typedef struct {
    size_t present : 1;
    size_t writeable : 1;
    size_t user_access : 1;
    size_t write_through : 1;
    size_t cache_disabled : 1;
    size_t accessed : 1;
    size_t ignored_3 : 1;
    size_t size : 1;
    size_t ignored_2 : 4;
    size_t pfn : 28;
    size_t reserved_1 : 12;
    size_t ignored_1 : 11;
    size_t execution_disabled : 1;
} ptedit_pgd_t;
#pragma pack(pop)


/**
 * Struct to access the fields of the P4D
 */
typedef ptedit_pgd_t ptedit_p4d_t;


/**
 * Struct to access the fields of the PUD
 */
typedef ptedit_pgd_t ptedit_pud_t;


/**
 * Struct to access the fields of the PMD
 */
typedef ptedit_pgd_t ptedit_pmd_t;


/**
 * Struct to access the fields of the PMD when mapping a  large page (2MB)
 */
#pragma pack(push,1)
typedef struct {
    size_t present : 1;
    size_t writeable : 1;
    size_t user_access : 1;
    size_t write_through : 1;
    size_t cache_disabled : 1;
    size_t accessed : 1;
    size_t dirty : 1;
    size_t size : 1;
    size_t global : 1;
    size_t ignored_2 : 3;
    size_t pat : 1;
    size_t reserved_2 : 8;
    size_t pfn : 19;
    size_t reserved_1 : 12;
    size_t ignored_1 : 11;
    size_t execution_disabled : 1;
} ptedit_pmd_large_t;
#pragma pack(pop)

/**
 * Struct to access the fields of the PTE
 */
#pragma pack(push,1)
typedef struct {
    size_t present : 1;
    size_t writeable : 1;
    size_t user_access : 1;
    size_t write_through : 1;
    size_t cache_disabled : 1;
    size_t accessed : 1;
    size_t dirty : 1;
    size_t size : 1;
    size_t global : 1;
    size_t ignored_2 : 3;
    size_t pfn : 28;
    size_t reserved_1 : 12;
    size_t ignored_1 : 11;
    size_t execution_disabled : 1;
} ptedit_pte_t;
#pragma pack(pop)


#elif defined(__aarch64__)
#define PTEDIT_PAGE_PRESENT 3


/**
 * Struct to access the fields of the PGD
 */
typedef struct {
    size_t present : 2;
    size_t ignored_1 : 10;
    size_t pfn : 36;
    size_t reserved : 4;
    size_t ignored_2 : 7;
    size_t pxn_table : 1;
    size_t xn_table : 1;
    size_t ap_table : 2;
    size_t ns_table : 1;
}__attribute__((__packed__)) ptedit_pgd_t;


/**
 * Struct to access the fields of the P4D
 */
typedef ptedit_pgd_t ptedit_p4d_t;


/**
 * Struct to access the fields of the PUD
 */
typedef ptedit_pgd_t ptedit_pud_t;


/**
 * Struct to access the fields of the PMD
 */
typedef ptedit_pgd_t ptedit_pmd_t;


/**
 * Struct to access the fields of the PGD when mapping a large page
 */
typedef struct {
    size_t present : 2;
    size_t memory_attributes_index : 3;
    size_t non_secure : 1;
    size_t access_permissions : 2;
    size_t shareability_field : 2;
    size_t access_flag : 1;
    size_t not_global : 1;
    size_t reserved_1 : 18;
    size_t pfn : 18;
    size_t reserved_2 : 4;
    size_t contiguous : 1;
    size_t privileged_execute_never : 1;
    size_t execute_never : 1;
    size_t ingored_1 : 4;
    size_t ignored_2 : 5;
}__attribute__((__packed__)) ptedit_pgd_large_t;


/**
 * Struct to access the fields of the PMD when mapping a large page
 */
typedef struct {
    size_t present : 2;
    size_t memory_attributes_index : 3;
    size_t non_secure : 1;
    size_t access_permissions : 2;
    size_t shareability_field : 2;
    size_t access_flag : 1;
    size_t not_global : 1;
    size_t reserved_1 : 9;
    size_t pfn : 27;
    size_t reserved_2 : 4;
    size_t contiguous : 1;
    size_t privileged_execute_never : 1;
    size_t execute_never : 1;
    size_t ingored_1 : 4;
    size_t ignored_2 : 5;
}__attribute__((__packed__)) ptedit_pmd_large_t;


/**
 * Struct to access the fields of the PTE
 */
typedef struct {
    size_t present : 2;
    size_t memory_attributes_index : 3;
    size_t non_secure : 1;
    size_t access_permissions : 2;
    size_t shareability_field : 2;
    size_t access_flag : 1;
    size_t not_global : 1;
    size_t pfn : 36;
    size_t reserved_1 : 4;
    size_t contiguous : 1;
    size_t privileged_execute_never : 1;
    size_t execute_never : 1;
    size_t ingored_1 : 4;
    size_t ignored_2 : 5;
}__attribute__((__packed__)) ptedit_pte_t;
#endif

/**
 * Casts a paging structure entry (e.g., page table) to a structure with easy access to its fields
 *
 * @param[in] v Entry to Cast
 * @param[in] type Data type of struct to cast to, e.g., ptedit_pte_t
 *
 * @return Struct of type "type" with easily accessible fields
 */
#define ptedit_cast(v, type) (*((type*)(&(v))))

 /** @} */



 /**
  * General system info
  *
  * @defgroup SYSTEMINFO System info
  *
  * @{
  */

  /**
   * Returns the default page size of the system
   *
   * @return Page size of the system in bytes
   */
ptedit_fnc int ptedit_get_pagesize();

/** @} */



/**
 * Get and set page frame numbers
 *
 * @defgroup PFN Page frame numbers (PFN)
 *
 * @{
 */

 /**
  * Returns a new page-table entry where the page-frame number (PFN) is replaced by the specified one.
  *
  * @param[in] entry The page-table entry to modify
  * @param[in] pfn The new page-frame number (PFN)
  *
  * @return A new page-table entry with the given page-frame number
  */
ptedit_fnc size_t ptedit_set_pfn(size_t entry, size_t pfn);

/**
 * Returns the page-frame number (PFN) of a page-table entry.
 *
 * @param[in] entry The page-table entry to extract the PFN from
 *
 * @return The page-frame number
 */
ptedit_fnc size_t ptedit_get_pfn(size_t entry);

/** @} */




/**
 * Reading and writing of physical pages
 *
 * @defgroup PHYSICALPAGE Physical pages
 *
 * @{
 */

 /**
  * Retrieves the content of a physical page.
  *
  * @param[in] pfn The page-frame number (PFN) of the page to read
  * @param[out] buffer A buffer which is large enough to hold the content of the page
  *
  */
ptedit_fnc void ptedit_read_physical_page(size_t pfn, char* buffer);

/**
 * Replaces the content of a physical page.
 *
 * @param[in] pfn The page-frame number (PFN) of the page to update
 * @param[in] content A buffer containing the new content of the page (must be the size of a physical page)
 *
 */
ptedit_fnc void ptedit_write_physical_page(size_t pfn, char* content);

/**
 * Map a physical address range.
 *
 * @param[in] physical The physical address to map
 * @param[in] length The length of the physical memory range to map
 *
 * @return A virtual address that can be used to access the physical range
 */
ptedit_fnc void* ptedit_pmap(size_t physical, size_t length);

/** @} */




/**
 * Read and modify the root of paging structure
 *
 * @defgroup PAGING Paging
 *
 * @{
 */

 /**
  * Returns the root of the paging structure (i.e., CR3 on x86 and TTBR0 on ARM).
  *
  * @param[in] pid The proccess id (0 for own process)
  *
  * @return The phyiscal address (not PFN!) of the first page table (i.e., the PGD)
  *
  */
ptedit_fnc size_t ptedit_get_paging_root(pid_t pid);

/**
 * Sets the root of the paging structure (i.e., CR3 on x86 and TTBR0 on ARM).
 *
 * @param[in] pid The proccess id (0 for own process)
 * @param[in] root The physical address (not PFN!) of the first page table (i.e., the PGD)
 *
 */
ptedit_fnc void ptedit_set_paging_root(pid_t pid, size_t root);

/** @} */


/**
 * Invalidations and barriers
 *
 * @defgroup BARRIERS TLB/Barriers
 *
 * @{
 */

 /**
  * Invalidates the TLB for a given address (belonging to the current process) on all CPUs.
  *
  * @param[in] address The address to invalidate
  *
  */
ptedit_fnc void ptedit_invalidate_tlb(void* address);

 /**
  * Invalidates the TLB for a given address (belonging to the specified pid) on all CPUs.
  *
  * @param[in] address The address to invalidate
  *
  */
ptedit_fnc void ptedit_invalidate_tlb_pid(pid_t pid, void* address);

 /**
  * Change the method used for flushing the TLB (either kernel or custom function)
  *
  * @param[in] implementation The implementation to use, either PTEDITOR_TLB_INVALIDATION_KERNEL or PTEDITOR_TLB_INVALIDATION_CUSTOM
  *
  * @return 0 on success, -1 on failure
  */
ptedit_fnc int ptedit_switch_tlb_invalidation(int implementation);

/**
 * A full serializing barrier which stops everything.
 *
 */
ptedit_fnc void ptedit_full_serializing_barrier();

/** @} */



/**
 * Memory types (x86 PATs / ARM MAIR)
 *
 * @defgroup MTS Memory types (PATs / MAIR)
 *
 * @{
 */

 /**
  * Reads the value of all memory types (x86 PATs / ARM MAIRs). This is equivalent to reading the MSR 0x277 (x86) / MAIR_EL1 (ARM).
  *
  * @return The memory types in the same format as in the IA32_PAT MSR / MAIR_EL1
  *
  */
ptedit_fnc size_t ptedit_get_mts();

/**
 * Programs the value of all memory types (x86 PATs / ARM MAIRs). This is equivalent to writing to the MSR 0x277 (x86) / MAIR_EL1 (ARM) on all CPUs.
 *
 * @param[in] mts The memory types in the same format as in the IA32_PAT MSR / MAIR_EL1
 *
 */
ptedit_fnc void ptedit_set_mts(size_t mts);

/**
 * Reads the value of a specific memory type attribute (PAT/MAIR).
 *
 * @param[in] mt The PAT/MAIR ID (from 0 to 7)
 *
 * @return The PAT/MAIR value (can be one of PTEDIT_MT_*)
 *
 */
ptedit_fnc char ptedit_get_mt(unsigned char mt);

/**
 * Programs the value of a specific memory type attribute (PAT/MAIR).
 *
 * @param[in] mt The PAT/MAIR ID (from 0 to 7)
 * @param[in] value The PAT/MAIR value (can be one of PTEDIT_MT_*)
 *
 */
ptedit_fnc void ptedit_set_mt(unsigned char mt, unsigned char value);

/**
 * Generates a bitmask of all memory type attributes (PAT/MAIR) which are programmed to the given value.
 *
 * @param[in] type A memory type, i.e., PAT/MAIR value (one of PTEDIT_MT_*)
 *
 * @return A bitmask where a set bit indicates that the corresponding PAT/MAIR has the given type
 *
 */
ptedit_fnc unsigned char ptedit_find_mt(unsigned char type);

/**
 * Returns the first memory type attribute (PAT/MAIR) which is programmed to the given memory type.
 *
 * @param[in] type A memory type, i.e., PAT/MAIR value (one of PTEDIT_MT_*)
 *
 * @return A PAT/MAIR ID, or -1 if no PAT/MAIR of this type was found
 *
 */
ptedit_fnc int ptedit_find_first_mt(unsigned char type);

/**
 * Returns a new page-table entry which uses the given memory type (PAT/MAIR).
 *
 * @param[in] entry A page-table entry
 * @param[in] mt A PAT/MAIR ID (between 0 and 7)
 *
 * @return A new page-table entry with the given memory type (PAT/MAIR)
 *
 */
ptedit_fnc size_t ptedit_apply_mt(size_t entry, unsigned char mt);

/**
 * Returns a new page-table entry which uses the given memory type (PAT/MAIR).
 * In contrast to ptedit_apply_mt, this function requires the underlying page to
 * be a huge page.
 * 
 * @param[in] entry A page-table entry
 * @param[in] mt A PAT/MAIR ID (between 0 and 7)
 *
 * @return A new page-table entry with the given memory type (PAT/MAIR)
 *
 */
ptedit_fnc size_t ptedit_apply_mt_huge(size_t entry, unsigned char mt);

/**
 * Returns the memory type (i.e., PAT/MAIR ID) which is used by a page-table entry.
 *
 * @param[in] entry A page-table entry
 *
 * @return A PAT/MAIR ID (between 0 and 7)
 *
 */
ptedit_fnc unsigned char ptedit_extract_mt(size_t entry);

/**
 * Returns the memory type (i.e., PAT/MAIR ID) which is used by a page-table entry.
 * In contrast to ptedit_extract_mt, this function requires the underlying page to
 * be a huge page.
 *
 * @param[in] entry A page-table entry
 *
 * @return A PAT/MAIR ID (between 0 and 7)
 *
 */
ptedit_fnc unsigned char ptedit_extract_mt_huge(size_t entry);

/**
 * Returns a human-readable representation of a memory type (PAT/MAIR value).
 *
 * @param[in] mt A memory type (PAT/MAIR value, e.g., one of PTEDIT_MT_*)
 *
 * @return A human-readable representation of the memory type
 *
 */
ptedit_fnc const char* ptedit_mt_to_string(unsigned char mt);

/** @} */



/**
 * Pretty print
 *
 * @defgroup PRETTYPRINT Pretty print
 *
 * @{
 */

 /**
  * Pretty prints a ptedit_entry_t struct.
  *
  * @param[in] entry A ptedit_entry_t struct
  *
  */
ptedit_fnc void ptedit_print_entry_t(ptedit_entry_t entry);

/**
 * Pretty prints a page-table entry.
 *
 * @param[in] entry A page-table entry
 *
 */
ptedit_fnc void ptedit_print_entry(size_t entry);

/**
 * Prints a single line of the pretty-print representation of a page-table entry.
 *
 * @param[in] entry A page-table entry
 * @param[in] line The line to print (0 to 3)
 *
 */
ptedit_fnc void ptedit_print_entry_line(size_t entry, int line);

/** @} */

#ifdef __cplusplus
}
#endif

#endif

```

`ptedit_header.h`:

```h
#pragma once
// Warning: this file was generated by make. DO NOT EDIT!
/* See LICENSE file for license and copyright information */

#ifndef PTEDITOR_MODULE_H
#define PTEDITOR_MODULE_H

#if defined(__linux__) || defined(__linux) || defined(__unix__) || defined(LINUX) || defined(UNIX)
#define LINUX
#endif
#if defined(_WIN32) || defined(_WIN64) || defined(__MINGW32__) || defined(__CYGWIN__)
#define WINDOWS
#undef LINUX
#endif


#if defined(LINUX)
#define PTEDITOR_DEVICE_NAME "pteditor"
#define PTEDITOR_DEVICE_PATH "/dev/" PTEDITOR_DEVICE_NAME
#else
#define PTEDITOR_DEVICE_NAME L"PTEditorLink"
#define PTEDITOR_DEVICE_PATH L"\\\\.\\" PTEDITOR_DEVICE_NAME
#endif

/**
 * Structure containing the page-table entries of all levels.
 * The Linux names are aliased with the Intel names.
 */
typedef struct {
    /** Process ID */
    size_t pid;
    /** Virtual address */
    size_t vaddr;

    /** Page global directory / Page map level 5 */
    union {
        size_t pgd;
        size_t pml5;
    };
    /** Page directory 4 / Page map level 4 */
    union {
        size_t p4d;
        size_t pml4;
    };
    /** Page upper directory / Page directory pointer table */
    union {
        size_t pud;
        size_t pdpt;
    };
    /** Page middle directory / Page directory */
    union {
        size_t pmd;
        size_t pd;
    };
    /** Page table entry */
    size_t pte;
    /** Bitmask indicating which entries are valid/should be updated */
    size_t valid;
} ptedit_entry_t;

/**
 * Structure to read/write physical pages
 */
#if defined(LINUX)
typedef struct {
    /** Page-frame number */
    size_t pfn;
    /** Virtual address */
    size_t vaddr;
    /** Page size */
    size_t size;
    /** Page content */
    unsigned char* buffer;
} ptedit_page_t;
#else
__pragma(pack(push, 1))
typedef struct {
    char content[4096];
    size_t paddr;
} ptedit_page_t;
__pragma(pack(pop))
#endif


/**
 * Structure to get/set the root of paging
 */
typedef struct {
    /** Process id */
    size_t pid;
    /** Physical address of paging root */
    size_t root;
} ptedit_paging_t;

/**
 * Structure to hold the arguments for TLB invalidation
 */
typedef struct {
    pid_t pid;
    void* address;
} ptedit_invalidate_tlb_args_t;

#define PTEDIT_VALID_MASK_PGD (1<<0)
#define PTEDIT_VALID_MASK_P4D (1<<1)
#define PTEDIT_VALID_MASK_PUD (1<<2)
#define PTEDIT_VALID_MASK_PMD (1<<3)
#define PTEDIT_VALID_MASK_PTE (1<<4)

#define PTEDITOR_TLB_INVALIDATION_KERNEL 0
#define PTEDITOR_TLB_INVALIDATION_CUSTOM 1

#if defined(LINUX)
#define PTEDITOR_IOCTL_MAGIC_NUMBER (long)0x3d17

#define PTEDITOR_IOCTL_CMD_VM_RESOLVE \
  _IOR(PTEDITOR_IOCTL_MAGIC_NUMBER, 1, size_t)

#define PTEDITOR_IOCTL_CMD_VM_UPDATE \
  _IOR(PTEDITOR_IOCTL_MAGIC_NUMBER, 2, size_t)

#define PTEDITOR_IOCTL_CMD_VM_LOCK \
  _IOR(PTEDITOR_IOCTL_MAGIC_NUMBER, 3, size_t)

#define PTEDITOR_IOCTL_CMD_VM_UNLOCK \
  _IOR(PTEDITOR_IOCTL_MAGIC_NUMBER, 4, size_t)

#define PTEDITOR_IOCTL_CMD_READ_PAGE \
  _IOR(PTEDITOR_IOCTL_MAGIC_NUMBER, 5, size_t)

#define PTEDITOR_IOCTL_CMD_WRITE_PAGE \
  _IOR(PTEDITOR_IOCTL_MAGIC_NUMBER, 6, size_t)

#define PTEDITOR_IOCTL_CMD_GET_ROOT \
  _IOR(PTEDITOR_IOCTL_MAGIC_NUMBER, 7, size_t)

#define PTEDITOR_IOCTL_CMD_SET_ROOT \
  _IOR(PTEDITOR_IOCTL_MAGIC_NUMBER, 8, size_t)

#define PTEDITOR_IOCTL_CMD_GET_PAGESIZE \
  _IOR(PTEDITOR_IOCTL_MAGIC_NUMBER, 9, size_t)

#define PTEDITOR_IOCTL_CMD_INVALIDATE_TLB \
  _IOR(PTEDITOR_IOCTL_MAGIC_NUMBER, 10, size_t)

#define PTEDITOR_IOCTL_CMD_GET_PAT \
  _IOR(PTEDITOR_IOCTL_MAGIC_NUMBER, 11, size_t)

#define PTEDITOR_IOCTL_CMD_SET_PAT \
  _IOR(PTEDITOR_IOCTL_MAGIC_NUMBER, 12, size_t)

#define PTEDITOR_IOCTL_CMD_SWITCH_TLB_INVALIDATION \
  _IOR(PTEDITOR_IOCTL_MAGIC_NUMBER, 13, size_t)

#define PTEDITOR_IOCTL_CMD_INVALIDATE_TLB_PID \
  _IOR(PTEDITOR_IOCTL_MAGIC_NUMBER, 14, size_t)
#else
#define PTEDITOR_READ_PAGE CTL_CODE(FILE_DEVICE_UNKNOWN, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define PTEDITOR_WRITE_PAGE CTL_CODE(FILE_DEVICE_UNKNOWN, 0x802, METHOD_BUFFERED, FILE_READ_DATA)
#define PTEDITOR_GET_CR3 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x803, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define PTEDITOR_FLUSH_TLB CTL_CODE(FILE_DEVICE_UNKNOWN, 0x804, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define PTEDITOR_READ_PHYS_VAL CTL_CODE(FILE_DEVICE_UNKNOWN, 0x805, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define PTEDITOR_WRITE_PHYS_VAL CTL_CODE(FILE_DEVICE_UNKNOWN, 0x806, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define PTEDITOR_SET_CR3 CTL_CODE(FILE_DEVICE_UNKNOWN, 0x807, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define PTEDITOR_SET_PAT CTL_CODE(FILE_DEVICE_UNKNOWN, 0x808, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define PTEDITOR_GET_PAT CTL_CODE(FILE_DEVICE_UNKNOWN, 0x809, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif

#endif // PTEDITOR_MODULE_H
/** @file */

#ifndef _PTEDITOR_H_
#define _PTEDITOR_H_

#ifdef __cplusplus
"C" {
#endif

#define ptedit_fnc static


#include <sys/types.h>

#if defined(WINDOWS)
typedef size_t pid_t;
#endif

/**
 * The implementation of PTEditor to use
 *
 * @defgroup PTEDITOR_IMPLEMENTATION PTEditor Implementation
 *
 * @{
 */

 /** Use the kernel to resolve and update paging structures */
#define PTEDIT_IMPL_KERNEL       0
/** Use the user-space implemenation to resolve and update paging structures, using pread to read from the memory mapping */
#define PTEDIT_IMPL_USER_PREAD   1
/** Use the user-space implemenation that maps the physical memory into user space to resolve and update paging structures */
#define PTEDIT_IMPL_USER         2

/**
 * The bits in a page-table entry
 *
 * @defgroup PAGETABLE_BITS Page Table Bits
 *
 * @{
 *
 */

#if defined(__i386__) || defined(__x86_64__) || defined(_WIN64)

 /** Page is present */
#define PTEDIT_PAGE_BIT_PRESENT 0
/** Page is writeable */
#define PTEDIT_PAGE_BIT_RW 1
/** Page is userspace addressable */
#define PTEDIT_PAGE_BIT_USER 2
/** Page write through */
#define PTEDIT_PAGE_BIT_PWT 3
/** Page cache disabled */
#define PTEDIT_PAGE_BIT_PCD 4
/** Page was accessed (raised by CPU) */
#define PTEDIT_PAGE_BIT_ACCESSED 5
/** Page was written to (raised by CPU) */
#define PTEDIT_PAGE_BIT_DIRTY 6
/** 4 MB (or 2MB) page */
#define PTEDIT_PAGE_BIT_PSE 7
/** PAT (only on 4KB pages) */
#define PTEDIT_PAGE_BIT_PAT 7
/** Global TLB entry PPro+ */
#define PTEDIT_PAGE_BIT_GLOBAL 8
/** Available for programmer */
#define PTEDIT_PAGE_BIT_SOFTW1 9
/** Available for programmer */
#define PTEDIT_PAGE_BIT_SOFTW2 10
/** Available for programmer */
#define PTEDIT_PAGE_BIT_SOFTW3 11
/** PAT (on 2MB or 1GB pages) */
#define PTEDIT_PAGE_BIT_PAT_LARGE 12
/** Available for programmer */
#define PTEDIT_PAGE_BIT_SOFTW4 58
/** Protection Keys, bit 1/4 */
#define PTEDIT_PAGE_BIT_PKEY_BIT0 59
/** Protection Keys, bit 2/4 */
#define PTEDIT_PAGE_BIT_PKEY_BIT1 60
/** Protection Keys, bit 3/4 */
#define PTEDIT_PAGE_BIT_PKEY_BIT2 61
/** Protection Keys, bit 4/4 */
#define PTEDIT_PAGE_BIT_PKEY_BIT3 62
/** No execute: only valid after cpuid check */
#define PTEDIT_PAGE_BIT_NX 63

#elif defined(__aarch64__)

 /** Entry type 1/2 */
#define PTEDIT_PAGE_BIT_TYPE_BIT0 0
/** Entry type 1/2 */
#define PTEDIT_PAGE_BIT_TYPE_BIT1 1
/** Memory attribute index 1/3 */
#define PTEDIT_PAGE_BIT_MAIR_BIT0 2
/** Memory attribute index 2/3 */
#define PTEDIT_PAGE_BIT_MAIR_BIT1 3
/** Memory attribute index 3/3 */
#define PTEDIT_PAGE_BIT_MAIR_BIT2 4
/** Page is non-secure */
#define PTEDIT_PAGE_BIT_NON_SECURE 5
/** Page permissions 1/2 */
#define PTEDIT_PAGE_BIT_PERMISSION_BIT0 6
/** Page permissions 2/2 */
#define PTEDIT_PAGE_BIT_PERMISSION_BIT1 7
/** Shareability domain 1/2 */
#define PTEDIT_PAGE_BIT_SHARE_BIT0 8
/** Shareability domain 2/2 */
#define PTEDIT_PAGE_BIT_SHARE_BIT1 9
/** Page was accessed (raised by CPU) */
#define PTEDIT_PAGE_BIT_ACCESSED 10
/** Page is not global */
#define PTEDIT_PAGE_BIT_NOT_GLOBAL 11
/** Contiguous */
#define PTEDIT_PAGE_BIT_CONTIGUOUS 52
/** Privileged execute never */
#define PTEDIT_PAGE_BIT_PXN 53
/** Execute never */
#define PTEDIT_PAGE_BIT_XN 54
/** Available for programmer */
#define PTEDIT_PAGE_BIT_SOFTW1 55
/** Available for programmer */
#define PTEDIT_PAGE_BIT_SOFTW2 56
/** Available for programmer */
#define PTEDIT_PAGE_BIT_SOFTW3 57
/** Available for programmer */
#define PTEDIT_PAGE_BIT_SOFTW4 58
/** Available for programmer */
#define PTEDIT_PAGE_BIT_SOFTW5 59
/** Available for programmer */
#define PTEDIT_PAGE_BIT_SOFTW6 60
/** Available for programmer */
#define PTEDIT_PAGE_BIT_SOFTW7 61
/** Available for programmer */
#define PTEDIT_PAGE_BIT_SOFTW8 62
/** Available for programmer */
#define PTEDIT_PAGE_BIT_SOFTW9 63

#endif
/** @} */

/**
 * The memory types (PAT/MAIR)values
 *
 * @defgroup MEMORY_TYPES Memory Types (PAT/MAIR values)
 *
 * @{
 */
#if defined(__i386__) || defined(__x86_64__) || defined(_WIN64)

 /** Strong uncachable (nothing is cached) */
#define PTEDIT_MT_UC      0
/** Write combining (consecuite writes are combined in a WC buffer and then written once) */
#define PTEDIT_MT_WC      1
/** Write through (read accesses are cached, write access are written to cache and memory) */
#define PTEDIT_MT_WT      4
/** Write protected (only read access is cached) */
#define PTEDIT_MT_WP      5
/** Write back (read and write accesses are cached) */
#define PTEDIT_MT_WB      6
/** Uncachable (as UC, but can be changed to WC through MTRRs) */
#define PTEDIT_MT_UCMINUS 7

#elif defined(__aarch64__)

 /** Strong uncachable (nothing is cached) */
#define PTEDIT_MT_UC      0x44
/** Write through (read accesses are cached, write access are written to cache and memory) */
#define PTEDIT_MT_WT      0xbb
/** Write back (read and write accesses are cached) */
#define PTEDIT_MT_WB      0xff

#endif
/** @} */


/**
 * Basic functionality required in every program
 *
 * @defgroup BASIC Basic Functionality
 *
 * @{
 */

 /**
  * Initializes (and acquires) PTEditor kernel module
  *
  * @return 0 Initialization was successful
  * @return -1 Initialization failed
  */
ptedit_fnc int ptedit_init();

/**
 * Releases PTEditor kernel module
 *
 */
ptedit_fnc void ptedit_cleanup();

/**
 * Switch between kernel and user-space implementation
 *
 * @param[in] implementation The implementation to use, either PTEDIT_IMPL_KERNEL, PTEDIT_IMPL_USER, or PTEDIT_IMPL_USER_PREAD
 *
 */
ptedit_fnc void ptedit_use_implementation(int implementation);

/** @} */




/**
 * Functions to read and write page tables
 *
 * @defgroup PAGETABLE Page tables
 *
 * @{
 */

typedef ptedit_entry_t(*ptedit_resolve_t)(void*, pid_t);
typedef void (*ptedit_update_t)(void*, pid_t, ptedit_entry_t*);


/**
 * Resolves the page-table entries of all levels for a virtual address of a given process.
 *
 * @param[in] address The virtual address to resolve
 * @param[in] pid The pid of the process (0 for own process)
 *
 * @return A structure containing the page-table entries of all levels.
 */
ptedit_fnc ptedit_resolve_t ptedit_resolve;

/**
 * Updates one or more page-table entries for a virtual address of a given process.
 * The TLB for the given address is flushed after updating the entries.
 *
 * @param[in] address The virtual address
 * @param[in] pid The pid of the process (0 for own process)
 * @param[in] vm A structure containing the values for the page-table entries and a bitmask indicating which entries to update
 *
 */
ptedit_fnc ptedit_update_t ptedit_update;

/**
 * Sets a bit directly in the PTE of an address.
 *
 * @param[in] address The virtual address
 * @param[in] pid The pid of the process (0 for own process)
 * @param[in] bit The bit to set (one of PTEDIT_PAGE_BIT_*)
 *
 */
ptedit_fnc void ptedit_pte_set_bit(void* address, pid_t pid, int bit);

/**
 * Clears a bit directly in the PTE of an address.
 *
 * @param[in] address The virtual address
 * @param[in] pid The pid of the process (0 for own process)
 * @param[in] bit The bit to clear (one of PTEDIT_PAGE_BIT_*)
 *
 */
ptedit_fnc void ptedit_pte_clear_bit(void* address, pid_t pid, int bit);

/**
 * Returns the value of a bit directly from the PTE of an address.
 *
 * @param[in] address The virtual address
 * @param[in] pid The pid of the process (0 for own process)
 * @param[in] bit The bit to get (one of PTEDIT_PAGE_BIT_*)
 *
 * @return The value of the bit (0 or 1)
 *
 */
ptedit_fnc unsigned char ptedit_pte_get_bit(void* address, pid_t pid, int bit);

/**
 * Reads the PFN directly from the PTE of an address.
 *
 * @param[in] address The virtual address
 * @param[in] pid The pid of the process (0 for own process)
 *
 * @return The page-frame number (PFN)
 *
 */
ptedit_fnc size_t ptedit_pte_get_pfn(void* address, pid_t pid);

/**
 * Sets the PFN directly in the PTE of an address.
 *
 * @param[in] address The virtual address
 * @param[in] pid The pid of the process (0 for own process)
 * @param[in] pfn The new page-frame number (PFN)
 *
 */
ptedit_fnc void ptedit_pte_set_pfn(void* address, pid_t pid, size_t pfn);


#if defined(__i386__) || defined(__x86_64__) || defined(_WIN64)
#define PTEDIT_PAGE_PRESENT 1

/**
 * Struct to access the fields of the PGD
 */
#pragma pack(push,1)
typedef struct {
    size_t present : 1;
    size_t writeable : 1;
    size_t user_access : 1;
    size_t write_through : 1;
    size_t cache_disabled : 1;
    size_t accessed : 1;
    size_t ignored_3 : 1;
    size_t size : 1;
    size_t ignored_2 : 4;
    size_t pfn : 28;
    size_t reserved_1 : 12;
    size_t ignored_1 : 11;
    size_t execution_disabled : 1;
} ptedit_pgd_t;
#pragma pack(pop)


/**
 * Struct to access the fields of the P4D
 */
typedef ptedit_pgd_t ptedit_p4d_t;


/**
 * Struct to access the fields of the PUD
 */
typedef ptedit_pgd_t ptedit_pud_t;


/**
 * Struct to access the fields of the PMD
 */
typedef ptedit_pgd_t ptedit_pmd_t;


/**
 * Struct to access the fields of the PMD when mapping a  large page (2MB)
 */
#pragma pack(push,1)
typedef struct {
    size_t present : 1;
    size_t writeable : 1;
    size_t user_access : 1;
    size_t write_through : 1;
    size_t cache_disabled : 1;
    size_t accessed : 1;
    size_t dirty : 1;
    size_t size : 1;
    size_t global : 1;
    size_t ignored_2 : 3;
    size_t pat : 1;
    size_t reserved_2 : 8;
    size_t pfn : 19;
    size_t reserved_1 : 12;
    size_t ignored_1 : 11;
    size_t execution_disabled : 1;
} ptedit_pmd_large_t;
#pragma pack(pop)

/**
 * Struct to access the fields of the PTE
 */
#pragma pack(push,1)
typedef struct {
    size_t present : 1;
    size_t writeable : 1;
    size_t user_access : 1;
    size_t write_through : 1;
    size_t cache_disabled : 1;
    size_t accessed : 1;
    size_t dirty : 1;
    size_t size : 1;
    size_t global : 1;
    size_t ignored_2 : 3;
    size_t pfn : 28;
    size_t reserved_1 : 12;
    size_t ignored_1 : 11;
    size_t execution_disabled : 1;
} ptedit_pte_t;
#pragma pack(pop)


#elif defined(__aarch64__)
#define PTEDIT_PAGE_PRESENT 3


/**
 * Struct to access the fields of the PGD
 */
typedef struct {
    size_t present : 2;
    size_t ignored_1 : 10;
    size_t pfn : 36;
    size_t reserved : 4;
    size_t ignored_2 : 7;
    size_t pxn_table : 1;
    size_t xn_table : 1;
    size_t ap_table : 2;
    size_t ns_table : 1;
}__attribute__((__packed__)) ptedit_pgd_t;


/**
 * Struct to access the fields of the P4D
 */
typedef ptedit_pgd_t ptedit_p4d_t;


/**
 * Struct to access the fields of the PUD
 */
typedef ptedit_pgd_t ptedit_pud_t;


/**
 * Struct to access the fields of the PMD
 */
typedef ptedit_pgd_t ptedit_pmd_t;


/**
 * Struct to access the fields of the PGD when mapping a large page
 */
typedef struct {
    size_t present : 2;
    size_t memory_attributes_index : 3;
    size_t non_secure : 1;
    size_t access_permissions : 2;
    size_t shareability_field : 2;
    size_t access_flag : 1;
    size_t not_global : 1;
    size_t reserved_1 : 18;
    size_t pfn : 18;
    size_t reserved_2 : 4;
    size_t contiguous : 1;
    size_t privileged_execute_never : 1;
    size_t execute_never : 1;
    size_t ingored_1 : 4;
    size_t ignored_2 : 5;
}__attribute__((__packed__)) ptedit_pgd_large_t;


/**
 * Struct to access the fields of the PMD when mapping a large page
 */
typedef struct {
    size_t present : 2;
    size_t memory_attributes_index : 3;
    size_t non_secure : 1;
    size_t access_permissions : 2;
    size_t shareability_field : 2;
    size_t access_flag : 1;
    size_t not_global : 1;
    size_t reserved_1 : 9;
    size_t pfn : 27;
    size_t reserved_2 : 4;
    size_t contiguous : 1;
    size_t privileged_execute_never : 1;
    size_t execute_never : 1;
    size_t ingored_1 : 4;
    size_t ignored_2 : 5;
}__attribute__((__packed__)) ptedit_pmd_large_t;


/**
 * Struct to access the fields of the PTE
 */
typedef struct {
    size_t present : 2;
    size_t memory_attributes_index : 3;
    size_t non_secure : 1;
    size_t access_permissions : 2;
    size_t shareability_field : 2;
    size_t access_flag : 1;
    size_t not_global : 1;
    size_t pfn : 36;
    size_t reserved_1 : 4;
    size_t contiguous : 1;
    size_t privileged_execute_never : 1;
    size_t execute_never : 1;
    size_t ingored_1 : 4;
    size_t ignored_2 : 5;
}__attribute__((__packed__)) ptedit_pte_t;
#endif

/**
 * Casts a paging structure entry (e.g., page table) to a structure with easy access to its fields
 *
 * @param[in] v Entry to Cast
 * @param[in] type Data type of struct to cast to, e.g., ptedit_pte_t
 *
 * @return Struct of type "type" with easily accessible fields
 */
#define ptedit_cast(v, type) (*((type*)(&(v))))

 /** @} */



 /**
  * General system info
  *
  * @defgroup SYSTEMINFO System info
  *
  * @{
  */

  /**
   * Returns the default page size of the system
   *
   * @return Page size of the system in bytes
   */
ptedit_fnc int ptedit_get_pagesize();

/** @} */



/**
 * Get and set page frame numbers
 *
 * @defgroup PFN Page frame numbers (PFN)
 *
 * @{
 */

 /**
  * Returns a new page-table entry where the page-frame number (PFN) is replaced by the specified one.
  *
  * @param[in] entry The page-table entry to modify
  * @param[in] pfn The new page-frame number (PFN)
  *
  * @return A new page-table entry with the given page-frame number
  */
ptedit_fnc size_t ptedit_set_pfn(size_t entry, size_t pfn);

/**
 * Returns the page-frame number (PFN) of a page-table entry.
 *
 * @param[in] entry The page-table entry to extract the PFN from
 *
 * @return The page-frame number
 */
ptedit_fnc size_t ptedit_get_pfn(size_t entry);

/** @} */




/**
 * Reading and writing of physical pages
 *
 * @defgroup PHYSICALPAGE Physical pages
 *
 * @{
 */

 /**
  * Retrieves the content of a physical page.
  *
  * @param[in] pfn The page-frame number (PFN) of the page to read
  * @param[out] buffer A buffer which is large enough to hold the content of the page
  *
  */
ptedit_fnc void ptedit_read_physical_page(size_t pfn, char* buffer);

/**
 * Replaces the content of a physical page.
 *
 * @param[in] pfn The page-frame number (PFN) of the page to update
 * @param[in] content A buffer containing the new content of the page (must be the size of a physical page)
 *
 */
ptedit_fnc void ptedit_write_physical_page(size_t pfn, char* content);

/**
 * Map a physical address range.
 *
 * @param[in] physical The physical address to map
 * @param[in] length The length of the physical memory range to map
 *
 * @return A virtual address that can be used to access the physical range
 */
ptedit_fnc void* ptedit_pmap(size_t physical, size_t length);

/** @} */




/**
 * Read and modify the root of paging structure
 *
 * @defgroup PAGING Paging
 *
 * @{
 */

 /**
  * Returns the root of the paging structure (i.e., CR3 on x86 and TTBR0 on ARM).
  *
  * @param[in] pid The proccess id (0 for own process)
  *
  * @return The phyiscal address (not PFN!) of the first page table (i.e., the PGD)
  *
  */
ptedit_fnc size_t ptedit_get_paging_root(pid_t pid);

/**
 * Sets the root of the paging structure (i.e., CR3 on x86 and TTBR0 on ARM).
 *
 * @param[in] pid The proccess id (0 for own process)
 * @param[in] root The physical address (not PFN!) of the first page table (i.e., the PGD)
 *
 */
ptedit_fnc void ptedit_set_paging_root(pid_t pid, size_t root);

/** @} */


/**
 * Invalidations and barriers
 *
 * @defgroup BARRIERS TLB/Barriers
 *
 * @{
 */

 /**
  * Invalidates the TLB for a given address (belonging to the current process) on all CPUs.
  *
  * @param[in] address The address to invalidate
  *
  */
ptedit_fnc void ptedit_invalidate_tlb(void* address);

 /**
  * Invalidates the TLB for a given address (belonging to the specified pid) on all CPUs.
  *
  * @param[in] address The address to invalidate
  *
  */
ptedit_fnc void ptedit_invalidate_tlb_pid(pid_t pid, void* address);

 /**
  * Change the method used for flushing the TLB (either kernel or custom function)
  *
  * @param[in] implementation The implementation to use, either PTEDITOR_TLB_INVALIDATION_KERNEL or PTEDITOR_TLB_INVALIDATION_CUSTOM
  *
  * @return 0 on success, -1 on failure
  */
ptedit_fnc int ptedit_switch_tlb_invalidation(int implementation);

/**
 * A full serializing barrier which stops everything.
 *
 */
ptedit_fnc void ptedit_full_serializing_barrier();

/** @} */



/**
 * Memory types (x86 PATs / ARM MAIR)
 *
 * @defgroup MTS Memory types (PATs / MAIR)
 *
 * @{
 */

 /**
  * Reads the value of all memory types (x86 PATs / ARM MAIRs). This is equivalent to reading the MSR 0x277 (x86) / MAIR_EL1 (ARM).
  *
  * @return The memory types in the same format as in the IA32_PAT MSR / MAIR_EL1
  *
  */
ptedit_fnc size_t ptedit_get_mts();

/**
 * Programs the value of all memory types (x86 PATs / ARM MAIRs). This is equivalent to writing to the MSR 0x277 (x86) / MAIR_EL1 (ARM) on all CPUs.
 *
 * @param[in] mts The memory types in the same format as in the IA32_PAT MSR / MAIR_EL1
 *
 */
ptedit_fnc void ptedit_set_mts(size_t mts);

/**
 * Reads the value of a specific memory type attribute (PAT/MAIR).
 *
 * @param[in] mt The PAT/MAIR ID (from 0 to 7)
 *
 * @return The PAT/MAIR value (can be one of PTEDIT_MT_*)
 *
 */
ptedit_fnc char ptedit_get_mt(unsigned char mt);

/**
 * Programs the value of a specific memory type attribute (PAT/MAIR).
 *
 * @param[in] mt The PAT/MAIR ID (from 0 to 7)
 * @param[in] value The PAT/MAIR value (can be one of PTEDIT_MT_*)
 *
 */
ptedit_fnc void ptedit_set_mt(unsigned char mt, unsigned char value);

/**
 * Generates a bitmask of all memory type attributes (PAT/MAIR) which are programmed to the given value.
 *
 * @param[in] type A memory type, i.e., PAT/MAIR value (one of PTEDIT_MT_*)
 *
 * @return A bitmask where a set bit indicates that the corresponding PAT/MAIR has the given type
 *
 */
ptedit_fnc unsigned char ptedit_find_mt(unsigned char type);

/**
 * Returns the first memory type attribute (PAT/MAIR) which is programmed to the given memory type.
 *
 * @param[in] type A memory type, i.e., PAT/MAIR value (one of PTEDIT_MT_*)
 *
 * @return A PAT/MAIR ID, or -1 if no PAT/MAIR of this type was found
 *
 */
ptedit_fnc int ptedit_find_first_mt(unsigned char type);

/**
 * Returns a new page-table entry which uses the given memory type (PAT/MAIR).
 *
 * @param[in] entry A page-table entry
 * @param[in] mt A PAT/MAIR ID (between 0 and 7)
 *
 * @return A new page-table entry with the given memory type (PAT/MAIR)
 *
 */
ptedit_fnc size_t ptedit_apply_mt(size_t entry, unsigned char mt);

/**
 * Returns a new page-table entry which uses the given memory type (PAT/MAIR).
 * In contrast to ptedit_apply_mt, this function requires the underlying page to
 * be a huge page.
 * 
 * @param[in] entry A page-table entry
 * @param[in] mt A PAT/MAIR ID (between 0 and 7)
 *
 * @return A new page-table entry with the given memory type (PAT/MAIR)
 *
 */
ptedit_fnc size_t ptedit_apply_mt_huge(size_t entry, unsigned char mt);

/**
 * Returns the memory type (i.e., PAT/MAIR ID) which is used by a page-table entry.
 *
 * @param[in] entry A page-table entry
 *
 * @return A PAT/MAIR ID (between 0 and 7)
 *
 */
ptedit_fnc unsigned char ptedit_extract_mt(size_t entry);

/**
 * Returns the memory type (i.e., PAT/MAIR ID) which is used by a page-table entry.
 * In contrast to ptedit_extract_mt, this function requires the underlying page to
 * be a huge page.
 *
 * @param[in] entry A page-table entry
 *
 * @return A PAT/MAIR ID (between 0 and 7)
 *
 */
ptedit_fnc unsigned char ptedit_extract_mt_huge(size_t entry);

/**
 * Returns a human-readable representation of a memory type (PAT/MAIR value).
 *
 * @param[in] mt A memory type (PAT/MAIR value, e.g., one of PTEDIT_MT_*)
 *
 * @return A human-readable representation of the memory type
 *
 */
ptedit_fnc const char* ptedit_mt_to_string(unsigned char mt);

/** @} */



/**
 * Pretty print
 *
 * @defgroup PRETTYPRINT Pretty print
 *
 * @{
 */

 /**
  * Pretty prints a ptedit_entry_t struct.
  *
  * @param[in] entry A ptedit_entry_t struct
  *
  */
ptedit_fnc void ptedit_print_entry_t(ptedit_entry_t entry);

/**
 * Pretty prints a page-table entry.
 *
 * @param[in] entry A page-table entry
 *
 */
ptedit_fnc void ptedit_print_entry(size_t entry);

/**
 * Prints a single line of the pretty-print representation of a page-table entry.
 *
 * @param[in] entry A page-table entry
 * @param[in] line The line to print (0 to 3)
 *
 */
ptedit_fnc void ptedit_print_entry_line(size_t entry, int line);

/** @} */

#ifdef __cplusplus
}
#endif

#endif
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <string.h>


#if defined(LINUX)
#include <sys/ioctl.h>
#include <unistd.h>
#include <sys/mman.h>
#else
#include <Windows.h>
#endif

#if defined(LINUX)
#define PTEDIT_COLOR_RED     "\x1b[31m"
#define PTEDIT_COLOR_GREEN   "\x1b[32m"
#define PTEDIT_COLOR_RESET   "\x1b[0m"
#else
#define PTEDIT_COLOR_RED     ""
#define PTEDIT_COLOR_GREEN   ""
#define PTEDIT_COLOR_RESET   ""
#endif

#if defined(WINDOWS)
#define NO_WINDOWS_SUPPORT fprintf(stderr, PTEDIT_COLOR_RED "[-]" PTEDIT_COLOR_RESET "Error: %s not supported on Windows", __func__);
#endif

#if defined(WINDOWS)
static HANDLE ptedit_fd;
#else
static int ptedit_fd;
#endif
static int ptedit_umem;
static int ptedit_pagesize;
static size_t ptedit_pfn_multiply = 4096;
static size_t ptedit_entry_size = sizeof(size_t);
static size_t ptedit_paging_root;
static unsigned char* ptedit_vmem;

typedef struct {
    int has_pgd, has_p4d, has_pud, has_pmd, has_pt;
    int pgd_entries, p4d_entries, pud_entries, pmd_entries, pt_entries;
    int page_offset;
} ptedit_paging_definition_t;

static ptedit_paging_definition_t ptedit_paging_definition;


// ---------------------------------------------------------------------------
ptedit_fnc ptedit_resolve_t ptedit_resolve;
ptedit_fnc ptedit_update_t ptedit_update;


// ---------------------------------------------------------------------------
ptedit_fnc ptedit_entry_t ptedit_resolve_kernel(void* address, pid_t pid) {
    ptedit_entry_t vm;
    memset(&vm, 0, sizeof(vm));
    vm.vaddr = (size_t)address;
    vm.pid = (size_t)pid;
#if defined(LINUX)
    ioctl(ptedit_fd, PTEDITOR_IOCTL_CMD_VM_RESOLVE, (size_t)&vm);
#else
    NO_WINDOWS_SUPPORT;
#endif
    return vm;
}

// ---------------------------------------------------------------------------
typedef size_t(*ptedit_phys_read_t)(size_t);
typedef void(*ptedit_phys_write_t)(size_t, size_t);

// ---------------------------------------------------------------------------
static inline size_t ptedit_phys_read_map(size_t address) {
    return *(size_t*)(ptedit_vmem + address);
}

// ---------------------------------------------------------------------------
static inline void ptedit_phys_write_map(size_t address, size_t value) {
    *(size_t*)(ptedit_vmem + address) = value;
}

// ---------------------------------------------------------------------------
static inline size_t ptedit_phys_read_pread(size_t address) {
    size_t val = 0;
#if defined(LINUX)
    if (pread(ptedit_umem, &val, sizeof(size_t), address) == -1) {
      return val;
    }
#else
    ULONG returnLength;
    DeviceIoControl(ptedit_fd, PTEDITOR_READ_PHYS_VAL, (LPVOID)&address, sizeof(address), (LPVOID)&val, sizeof(val), &returnLength, 0);
#endif
    return val;
}

// ---------------------------------------------------------------------------
static inline void ptedit_phys_write_pwrite(size_t address, size_t value) {
#if defined(LINUX)
    if (pwrite(ptedit_umem, &value, sizeof(size_t), address) == -1) {
      return;
    }
#else
    ULONG returnLength;
    size_t info[2];
    info[0] = address;
    info[1] = value;
    DeviceIoControl(ptedit_fd, PTEDITOR_WRITE_PHYS_VAL, (LPVOID)&info, sizeof(info), (LPVOID)&info, sizeof(info), &returnLength, 0);
#endif
}

// ---------------------------------------------------------------------------
static ptedit_entry_t ptedit_resolve_user_ext(void* address, pid_t pid, ptedit_phys_read_t deref) {
    size_t root = (pid == 0) ? ptedit_paging_root : ptedit_get_paging_root(pid);
    root = root & ~1;

    int pgdi, p4di, pudi, pmdi, pti;
    size_t addr = (size_t)address;
    pgdi = (addr >> (ptedit_paging_definition.page_offset
        + ptedit_paging_definition.pt_entries
        + ptedit_paging_definition.pmd_entries
        + ptedit_paging_definition.pud_entries
        + ptedit_paging_definition.p4d_entries)) % (1ull << ptedit_paging_definition.pgd_entries);
    p4di = (addr >> (ptedit_paging_definition.page_offset
        + ptedit_paging_definition.pt_entries
        + ptedit_paging_definition.pmd_entries
        + ptedit_paging_definition.pud_entries)) % (1ull << ptedit_paging_definition.p4d_entries);
    pudi = (addr >> (ptedit_paging_definition.page_offset
        + ptedit_paging_definition.pt_entries
        + ptedit_paging_definition.pmd_entries)) % (1ull << ptedit_paging_definition.pud_entries);
    pmdi = (addr >> (ptedit_paging_definition.page_offset
        + ptedit_paging_definition.pt_entries)) % (1ull << ptedit_paging_definition.pmd_entries);
    pti = (addr >> ptedit_paging_definition.page_offset) % (1ull << ptedit_paging_definition.pt_entries);

    ptedit_entry_t resolved;
    memset(&resolved, 0, sizeof(resolved));
    resolved.vaddr = (size_t)address;
    resolved.pid = (size_t)pid;
    resolved.valid = 0;
    
    if(!root) return resolved;

    size_t pgd_entry, p4d_entry, pud_entry, pmd_entry, pt_entry;

    //     printf("%zx + CR3(%zx) + PGDI(%zx) * 8 = %zx\n", ptedit_vmem, root, pgdi, ptedit_vmem + root + pgdi * ptedit_entry_size);
    pgd_entry = deref(root + pgdi * ptedit_entry_size);
    if (ptedit_cast(pgd_entry, ptedit_pgd_t).present != PTEDIT_PAGE_PRESENT) {
        return resolved;
    }
    resolved.pgd = pgd_entry;
    resolved.valid |= PTEDIT_VALID_MASK_PGD;
    if (ptedit_paging_definition.has_p4d) {
        size_t pfn = (size_t)(ptedit_cast(pgd_entry, ptedit_pgd_t).pfn);
        p4d_entry = deref(pfn * ptedit_pfn_multiply + p4di * ptedit_entry_size);
        resolved.valid |= PTEDIT_VALID_MASK_P4D;
    }
    else {
        p4d_entry = pgd_entry;
    }
    resolved.p4d = p4d_entry;

    if (ptedit_cast(p4d_entry, ptedit_p4d_t).present != PTEDIT_PAGE_PRESENT) {
        return resolved;
    }


    if (ptedit_paging_definition.has_pud) {
        size_t pfn = (size_t)(ptedit_cast(p4d_entry, ptedit_p4d_t).pfn);
        pud_entry = deref(pfn * ptedit_pfn_multiply + pudi * ptedit_entry_size);
        resolved.valid |= PTEDIT_VALID_MASK_PUD;
    }
    else {
        pud_entry = p4d_entry;
    }
    resolved.pud = pud_entry;

    if (ptedit_cast(pud_entry, ptedit_pud_t).present != PTEDIT_PAGE_PRESENT) {
        return resolved;
    }

    if (ptedit_paging_definition.has_pmd) {
        size_t pfn = (size_t)(ptedit_cast(pud_entry, ptedit_pud_t).pfn);
        pmd_entry = deref(pfn * ptedit_pfn_multiply + pmdi * ptedit_entry_size);
        resolved.valid |= PTEDIT_VALID_MASK_PMD;
    }
    else {
        pmd_entry = pud_entry;
    }
    resolved.pmd = pmd_entry;

    if (ptedit_cast(pmd_entry, ptedit_pmd_t).present != PTEDIT_PAGE_PRESENT) {
        return resolved;
    }

#if defined(__i386__) || defined(__x86_64__) || defined(_WIN64)
    if (!ptedit_cast(pmd_entry, ptedit_pmd_t).size) {
#endif
        // normal 4kb page
        size_t pfn = (size_t)(ptedit_cast(pmd_entry, ptedit_pmd_t).pfn);
        pt_entry = deref(pfn * ptedit_pfn_multiply + pti * ptedit_entry_size); //pt[pti];
        resolved.pte = pt_entry;
        resolved.valid |= PTEDIT_VALID_MASK_PTE;
        if (ptedit_cast(pt_entry, ptedit_pte_t).present != PTEDIT_PAGE_PRESENT) {
            return resolved;
        }
#if defined(__i386__) || defined(__x86_64__) || defined(_WIN64)
    }
#endif
    return resolved;
}


// ---------------------------------------------------------------------------
static ptedit_entry_t ptedit_resolve_user(void* address, pid_t pid) {
    return ptedit_resolve_user_ext(address, pid, ptedit_phys_read_pread);
}


// ---------------------------------------------------------------------------
static ptedit_entry_t ptedit_resolve_user_map(void* address, pid_t pid) {
    return ptedit_resolve_user_ext(address, pid, ptedit_phys_read_map);
}


// ---------------------------------------------------------------------------
ptedit_fnc void ptedit_update_kernel(void* address, pid_t pid, ptedit_entry_t* vm) {
    vm->vaddr = (size_t)address;
    vm->pid = (size_t)pid;
#if defined(LINUX)
    ioctl(ptedit_fd, PTEDITOR_IOCTL_CMD_VM_UPDATE, (size_t)vm);
#else 
    NO_WINDOWS_SUPPORT
#endif
}

// ---------------------------------------------------------------------------
ptedit_fnc void ptedit_update_user_ext(void* address, pid_t pid, ptedit_entry_t* vm, ptedit_phys_write_t pset) {
    ptedit_entry_t current = ptedit_resolve(address, pid);
    size_t root = (pid == 0) ? ptedit_paging_root : ptedit_get_paging_root(pid);
    root = root & ~1;

    if(!root) return;
    
    size_t pgdi, p4di, pudi, pmdi, pti;
    size_t addr = (size_t)address;
    pgdi = (addr >> (ptedit_paging_definition.page_offset
        + ptedit_paging_definition.pt_entries
        + ptedit_paging_definition.pmd_entries
        + ptedit_paging_definition.pud_entries
        + ptedit_paging_definition.p4d_entries)) % (1ull << ptedit_paging_definition.pgd_entries);
    p4di = (addr >> (ptedit_paging_definition.page_offset
        + ptedit_paging_definition.pt_entries
        + ptedit_paging_definition.pmd_entries
        + ptedit_paging_definition.pud_entries)) % (1ull << ptedit_paging_definition.p4d_entries);
    pudi = (addr >> (ptedit_paging_definition.page_offset
        + ptedit_paging_definition.pt_entries
        + ptedit_paging_definition.pmd_entries)) % (1ull << ptedit_paging_definition.pud_entries);
    pmdi = (addr >> (ptedit_paging_definition.page_offset
        + ptedit_paging_definition.pt_entries)) % (1ull << ptedit_paging_definition.pmd_entries);
    pti = (addr >> ptedit_paging_definition.page_offset) % (1ull << ptedit_paging_definition.pt_entries);

    if ((vm->valid & PTEDIT_VALID_MASK_PTE) && (current.valid & PTEDIT_VALID_MASK_PTE)) {
        pset((size_t)ptedit_cast(current.pmd, ptedit_pmd_t).pfn * ptedit_pfn_multiply + pti * ptedit_entry_size, vm->pte);
    }
    if ((vm->valid & PTEDIT_VALID_MASK_PMD) && (current.valid & PTEDIT_VALID_MASK_PMD) && ptedit_paging_definition.has_pmd) {
        pset((size_t)ptedit_cast(current.pud, ptedit_pud_t).pfn * ptedit_pfn_multiply + pmdi * ptedit_entry_size, vm->pmd);
    }
    if ((vm->valid & PTEDIT_VALID_MASK_PUD) && (current.valid & PTEDIT_VALID_MASK_PUD) && ptedit_paging_definition.has_pud) {
        pset((size_t)ptedit_cast(current.p4d, ptedit_p4d_t).pfn * ptedit_pfn_multiply + pudi * ptedit_entry_size, vm->pud);
    }
    if ((vm->valid & PTEDIT_VALID_MASK_P4D) && (current.valid & PTEDIT_VALID_MASK_P4D) && ptedit_paging_definition.has_p4d) {
        pset((size_t)ptedit_cast(current.pgd, ptedit_pgd_t).pfn * ptedit_pfn_multiply + p4di * ptedit_entry_size, vm->p4d);
    }
    if ((vm->valid & PTEDIT_VALID_MASK_PGD) && (current.valid & PTEDIT_VALID_MASK_PGD) && ptedit_paging_definition.has_pgd) {
        pset(root + pgdi * ptedit_entry_size, vm->pgd);
    }

    ptedit_invalidate_tlb_pid(pid, address);
}

// ---------------------------------------------------------------------------
static void ptedit_update_user(void* address, pid_t pid, ptedit_entry_t* vm) {
    ptedit_update_user_ext(address, pid, vm, ptedit_phys_write_pwrite);
    ptedit_invalidate_tlb_pid(pid, address);
}


// ---------------------------------------------------------------------------
static void ptedit_update_user_map(void* address, pid_t pid, ptedit_entry_t* vm) {
    ptedit_update_user_ext(address, pid, vm, ptedit_phys_write_map);
    ptedit_invalidate_tlb_pid(pid, address);
}

// ---------------------------------------------------------------------------
ptedit_fnc void* ptedit_pmap(size_t physical, size_t length) {
#if defined(LINUX)
    char* m = (char*)mmap(0, length + (physical % ptedit_pagesize), PROT_READ | PROT_WRITE, MAP_SHARED, ptedit_umem, ((size_t)(physical / ptedit_pagesize)) * ptedit_pagesize);
    return m + (physical % ptedit_pagesize);
#else
    NO_WINDOWS_SUPPORT;
    return NULL;
#endif
}

// ---------------------------------------------------------------------------
ptedit_fnc size_t ptedit_set_pfn(size_t pte, size_t pfn) {
#if defined(__i386__) || defined(__x86_64__) || defined(_WIN64)
    pte &= ~(((1ull << 40) - 1) << 12);
#elif defined(__aarch64__)
    pte &= ~(((1ull << 36) - 1) << 12);
#endif
    pte |= pfn << 12;
    return pte;
}


// ---------------------------------------------------------------------------
ptedit_fnc size_t ptedit_get_pfn(size_t pte) {
#if defined(__i386__) || defined(__x86_64__) || defined(_WIN64)
    return (pte & (((1ull << 40) - 1) << 12)) >> 12;
#elif defined(__aarch64__)
    return (pte & (((1ull << 36) - 1) << 12)) >> 12;
#endif
}


// ---------------------------------------------------------------------------
#define PTEDIT_B(val, bit) (!!((val) & (1ull << (bit))))

#define PEDIT_PRINT_B(fmt, bit)                                                \
  if ((bit)) {                                                                 \
    printf(PTEDIT_COLOR_GREEN);                                                       \
    printf((fmt), (bit));                                                      \
    printf(PTEDIT_COLOR_RESET);                                                       \
  } else {                                                                     \
    printf((fmt), (bit));                                                      \
  }                                                                            \
  printf("|");


// ---------------------------------------------------------------------------
ptedit_fnc void ptedit_print_entry_line(size_t entry, int line) {
#if defined(__i386__) || defined(__x86_64__) || defined(_WIN64)
    if (line == 0 || line == 3) printf("+--+------------------+-+-+-+-+-+-+-+-+--+--+-+-+-+\n");
    if (line == 1) printf("|NX|       PFN        |H|?|?|?|G|S|D|A|UC|WT|U|W|P|\n");
    if (line == 2) {
        printf("|");
        PEDIT_PRINT_B(" %d", PTEDIT_B(entry, PTEDIT_PAGE_BIT_NX));
        printf(" %16p |", (void*)((entry >> 12) & ((1ull << 40) - 1)));
        PEDIT_PRINT_B("%d", PTEDIT_B(entry, PTEDIT_PAGE_BIT_PAT_LARGE));
        PEDIT_PRINT_B("%d", PTEDIT_B(entry, PTEDIT_PAGE_BIT_SOFTW3));
        PEDIT_PRINT_B("%d", PTEDIT_B(entry, PTEDIT_PAGE_BIT_SOFTW2));
        PEDIT_PRINT_B("%d", PTEDIT_B(entry, PTEDIT_PAGE_BIT_SOFTW1));
        PEDIT_PRINT_B("%d", PTEDIT_B(entry, PTEDIT_PAGE_BIT_GLOBAL));
        PEDIT_PRINT_B("%d", PTEDIT_B(entry, PTEDIT_PAGE_BIT_PSE));
        PEDIT_PRINT_B("%d", PTEDIT_B(entry, PTEDIT_PAGE_BIT_DIRTY));
        PEDIT_PRINT_B("%d", PTEDIT_B(entry, PTEDIT_PAGE_BIT_ACCESSED));
        PEDIT_PRINT_B(" %d", PTEDIT_B(entry, PTEDIT_PAGE_BIT_PCD));
        PEDIT_PRINT_B(" %d", PTEDIT_B(entry, PTEDIT_PAGE_BIT_PWT));
        PEDIT_PRINT_B("%d", PTEDIT_B(entry, PTEDIT_PAGE_BIT_USER));
        PEDIT_PRINT_B("%d", PTEDIT_B(entry, PTEDIT_PAGE_BIT_RW));
        PEDIT_PRINT_B("%d", PTEDIT_B(entry, PTEDIT_PAGE_BIT_PRESENT));
        printf("\n");
    }
#elif defined(__aarch64__)
    if (line == 0 || line == 3) {
        printf("+--+--+--+---+-+--+------------------+--+-+-+-+--+---+-+\n");
    }
    if (line == 1) {
        printf("| ?| ?|XN|PXN|C| ?|        PFN       |NG|A|S|P|NS|MAI|T|\n");
    }
    if (line == 2) {
        printf("|");
        PEDIT_PRINT_B("%2d", (PTEDIT_B(entry, 63) << 4) | (PTEDIT_B(entry, 62) << 3) | (PTEDIT_B(entry, 61) << 2) | (PTEDIT_B(entry, 60) << 1) | PTEDIT_B(entry, 59));
        PEDIT_PRINT_B("%2d", (PTEDIT_B(entry, 58) << 3) | (PTEDIT_B(entry, 57) << 2) | (PTEDIT_B(entry, 56) << 1) | PTEDIT_B(entry, 55));
        PEDIT_PRINT_B(" %d", PTEDIT_B(entry, 54));
        PEDIT_PRINT_B(" %d ", PTEDIT_B(entry, 53));
        PEDIT_PRINT_B("%d", PTEDIT_B(entry, 52));
        PEDIT_PRINT_B("%2d", (PTEDIT_B(entry, 51) << 3) | (PTEDIT_B(entry, 50) << 2) | (PTEDIT_B(entry, 49) << 1) | PTEDIT_B(entry, 48));
        printf(" %16p |", (void*)((entry >> 12) & ((1ull << 36) - 1)));
        PEDIT_PRINT_B(" %d", PTEDIT_B(entry, 11));
        PEDIT_PRINT_B("%d", PTEDIT_B(entry, 10));
        PEDIT_PRINT_B("%d", (PTEDIT_B(entry, 9) << 1) | PTEDIT_B(entry, 8));
        PEDIT_PRINT_B("%d", (PTEDIT_B(entry, 7) << 1) | PTEDIT_B(entry, 6));
        PEDIT_PRINT_B(" %d", PTEDIT_B(entry, 5));
        PEDIT_PRINT_B(" %d ", (PTEDIT_B(entry, 4) << 2) | (PTEDIT_B(entry, 3) << 1) | PTEDIT_B(entry, 2));
        PEDIT_PRINT_B("%d", (PTEDIT_B(entry, 1) << 1) | PTEDIT_B(entry, 0));
        printf("\n");
    }
#endif
}


// ---------------------------------------------------------------------------
ptedit_fnc void ptedit_print_entry(size_t entry) {
    int i = 0;
    for (i = 0; i < 4; i++) {
        ptedit_print_entry_line(entry, i);
    }
}

// ---------------------------------------------------------------------------
ptedit_fnc void ptedit_print_entry_t(ptedit_entry_t entry) {
    if (entry.valid & PTEDIT_VALID_MASK_PGD) {
        printf("PGD of address\n");
        ptedit_print_entry(entry.pgd);
    }
    if (entry.valid & PTEDIT_VALID_MASK_P4D) {
        printf("P4D of address\n");
        ptedit_print_entry(entry.p4d);
    }
    if (entry.valid & PTEDIT_VALID_MASK_PUD) {
        printf("PUD of address\n");
        ptedit_print_entry(entry.pud);
    }
    if (entry.valid & PTEDIT_VALID_MASK_PMD) {
        printf("PMD of address\n");
        ptedit_print_entry(entry.pmd);
    }
    if (entry.valid & PTEDIT_VALID_MASK_PTE) {
        printf("PTE of address\n");
        ptedit_print_entry(entry.pte);
    }
}

// ---------------------------------------------------------------------------
ptedit_fnc int ptedit_init() {
#if defined(LINUX)
    ptedit_fd = open(PTEDITOR_DEVICE_PATH, O_RDONLY);
    if (ptedit_fd < 0) {
        fprintf(stderr, PTEDIT_COLOR_RED "[-]" PTEDIT_COLOR_RESET "Error: Could not open PTEditor device: %s\n", PTEDITOR_DEVICE_PATH);
        return -1;
    }
#if !defined(__aarch64__)
    ptedit_umem = open("/proc/umem", O_RDWR);
#else
    ptedit_umem = 0;
#endif
#else
    ptedit_fd = CreateFile(PTEDITOR_DEVICE_PATH, GENERIC_ALL, 0, 0, OPEN_EXISTING, FILE_ATTRIBUTE_SYSTEM, 0);
    if (ptedit_fd == INVALID_HANDLE_VALUE) {
        fprintf(stderr, PTEDIT_COLOR_RED "[-]" PTEDIT_COLOR_RESET "Error: Could not open PTEditor device: %ws\n", PTEDITOR_DEVICE_PATH);
        return -1;
    }
    ptedit_umem = 0;
#endif
#if defined(LINUX)
    ptedit_use_implementation(PTEDIT_IMPL_KERNEL);
#elif defined(WINDOWS)
    ptedit_use_implementation(PTEDIT_IMPL_USER_PREAD);
#endif
    //   }
#if defined(LINUX)
    ptedit_pagesize = getpagesize();
#else
    ptedit_pagesize = ptedit_get_pagesize();
#endif

#if defined(__i386__) || defined(__x86_64__) || defined(_WIN64)
    ptedit_paging_definition.has_pgd = 1;
    ptedit_paging_definition.has_p4d = 0;
    ptedit_paging_definition.has_pud = 1;
    ptedit_paging_definition.has_pmd = 1;
    ptedit_paging_definition.has_pt = 1;
    ptedit_paging_definition.pgd_entries = 9;
    ptedit_paging_definition.p4d_entries = 0;
    ptedit_paging_definition.pud_entries = 9;
    ptedit_paging_definition.pmd_entries = 9;
    ptedit_paging_definition.pt_entries = 9;
    ptedit_paging_definition.page_offset = 12;
#elif defined(__aarch64__)
    if(ptedit_get_pagesize() == 16384) {
        ptedit_paging_definition.has_pgd = 1;
        ptedit_paging_definition.has_p4d = 0;
        ptedit_paging_definition.has_pud = 1;
        ptedit_paging_definition.has_pmd = 1;
        ptedit_paging_definition.has_pt = 1;
        ptedit_paging_definition.pgd_entries = 11;
        ptedit_paging_definition.p4d_entries = 0;
        ptedit_paging_definition.pud_entries = 11;
        ptedit_paging_definition.pmd_entries = 11;
        ptedit_paging_definition.pt_entries = 11;
        ptedit_paging_definition.page_offset = 14;
        ptedit_use_implementation(PTEDIT_IMPL_USER_PREAD); // M1 workaround
    } else {
        ptedit_paging_definition.has_pgd = 1;
        ptedit_paging_definition.has_p4d = 0;
        ptedit_paging_definition.has_pud = 0;
        ptedit_paging_definition.has_pmd = 1;
        ptedit_paging_definition.has_pt = 1;
        ptedit_paging_definition.pgd_entries = 9;
        ptedit_paging_definition.p4d_entries = 0;
        ptedit_paging_definition.pud_entries = 0;
        ptedit_paging_definition.pmd_entries = 9;
        ptedit_paging_definition.pt_entries = 9;
        ptedit_paging_definition.page_offset = 12;
    }
#endif
    return 0;
}


// ---------------------------------------------------------------------------
ptedit_fnc void ptedit_cleanup() {
#if defined(LINUX)
    if (ptedit_fd >= 0) {
        close(ptedit_fd);
    }
    if (ptedit_umem > 0) {
        close(ptedit_umem);
    }
#else
    CloseHandle(ptedit_fd);
#endif
}


// ---------------------------------------------------------------------------
ptedit_fnc void ptedit_use_implementation(int implementation) {
    if (implementation == PTEDIT_IMPL_KERNEL) {
#if defined(LINUX)
        ptedit_resolve = ptedit_resolve_kernel;
        ptedit_update = ptedit_update_kernel;
#else
        fprintf(stderr, PTEDIT_COLOR_RED "[-]" PTEDIT_COLOR_RESET "Error: PTEditor implementation not supported on Windows");
#endif
    }
    else if (implementation == PTEDIT_IMPL_USER_PREAD) {
        ptedit_resolve = ptedit_resolve_user;
        ptedit_update = ptedit_update_user;
        ptedit_paging_root = ptedit_get_paging_root(0);
    }
    else if (implementation == PTEDIT_IMPL_USER) {
#if defined(LINUX)
        ptedit_resolve = ptedit_resolve_user_map;
        ptedit_update = ptedit_update_user_map;
        ptedit_paging_root = ptedit_get_paging_root(0);
        if (!ptedit_vmem) {
            ptedit_vmem = (unsigned char*)mmap(NULL, 32ull << 30ull, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_NORESERVE, ptedit_umem, 0);
            fprintf(stderr, PTEDIT_COLOR_GREEN "[+]" PTEDIT_COLOR_RESET " Mapped physical memory to %p\n", ptedit_vmem);
        }
#else
        fprintf(stderr, PTEDIT_COLOR_RED "[-]" PTEDIT_COLOR_RESET "Error: PTEditor implementation not supported on Windows");
#endif
    }
    else {
        fprintf(stderr, PTEDIT_COLOR_RED "[-]" PTEDIT_COLOR_RESET " Error: PTEditor implementation not supported!\n");
    }
}


// ---------------------------------------------------------------------------
ptedit_fnc int ptedit_get_pagesize() {
#if defined(LINUX)
    return (int)ioctl(ptedit_fd, PTEDITOR_IOCTL_CMD_GET_PAGESIZE, 0);
#else
    SYSTEM_INFO sysinfo;
    GetSystemInfo(&sysinfo);
    return sysinfo.dwPageSize;
#endif
}


// ---------------------------------------------------------------------------
ptedit_fnc void ptedit_read_physical_page(size_t pfn, char* buffer) {
#if defined(LINUX)
    if (ptedit_umem > 0) {
        if (pread(ptedit_umem, buffer, ptedit_pagesize, pfn * ptedit_pagesize) == -1) {
          return;
        }
    }
    else {
        ptedit_page_t page;
        page.buffer = (unsigned char*)buffer;
        page.pfn = pfn;
        ioctl(ptedit_fd, PTEDITOR_IOCTL_CMD_READ_PAGE, (size_t)&page);
    }
#else
    DWORD returnLength;
    pfn *= ptedit_pagesize;
    DeviceIoControl(ptedit_fd, PTEDITOR_READ_PAGE, (LPVOID)&pfn, sizeof(pfn), (LPVOID)buffer, 4096, &returnLength, 0);
#endif
}


// ---------------------------------------------------------------------------
ptedit_fnc void ptedit_write_physical_page(size_t pfn, char* content) {
#if defined(LINUX)
    if (ptedit_umem > 0) {
        if (pwrite(ptedit_umem, content, ptedit_pagesize, pfn * ptedit_pagesize) == -1) {
          return;
        }
    }
    else {
        ptedit_page_t page;
        page.buffer = (unsigned char*)content;
        page.pfn = pfn;
        ioctl(ptedit_fd, PTEDITOR_IOCTL_CMD_WRITE_PAGE, (size_t)&page);
    }
#else
    DWORD returnLength;
    ptedit_page_t page;
    if (ptedit_pagesize != 4096) {
        fprintf(stderr, PTEDIT_COLOR_RED "[-]" PTEDIT_COLOR_RESET "Error: page sizes other than 4096 not supported on Windows");
        return;
    }
    page.paddr = pfn * ptedit_pagesize;
    memcpy(page.content, content, ptedit_pagesize);
    DeviceIoControl(ptedit_fd, PTEDITOR_WRITE_PAGE, (LPVOID)&page, sizeof(ptedit_page_t), (LPVOID)&page, sizeof(ptedit_page_t), &returnLength, 0);
#endif
}


// ---------------------------------------------------------------------------
size_t ptedit_get_paging_root(pid_t pid) {
#if defined(LINUX)
    ptedit_paging_t cr3;
    cr3.pid = (size_t)pid;
    cr3.root = 0;
    ioctl(ptedit_fd, PTEDITOR_IOCTL_CMD_GET_ROOT, (size_t)&cr3);
    return cr3.root;
#else
    size_t cr3 = 0;
    DWORD returnLength;
    if(!pid) pid = GetCurrentProcessId();
    DeviceIoControl(ptedit_fd, PTEDITOR_GET_CR3, (LPVOID)&pid, sizeof(pid), (LPVOID)&cr3, sizeof(cr3), &returnLength, 0);
    return (cr3 & ~0xfff);
#endif
}


// ---------------------------------------------------------------------------
void ptedit_set_paging_root(pid_t pid, size_t root) {
    ptedit_paging_t cr3;
    cr3.pid = (size_t)pid;
    cr3.root = root; 
#if defined(LINUX)
    ioctl(ptedit_fd, PTEDITOR_IOCTL_CMD_SET_ROOT, (size_t)&cr3);
#else
    DWORD returnLength;
    if (!pid) pid = GetCurrentProcessId();
    size_t info[2];
    info[0] = pid;
    info[1] = root;
    DeviceIoControl(ptedit_fd, PTEDITOR_SET_CR3, (LPVOID)info, sizeof(info), (LPVOID)info, sizeof(info), &returnLength, 0);
#endif
}

// ---------------------------------------------------------------------------
ptedit_fnc void ptedit_invalidate_tlb_pid(pid_t pid, void* address) {
#if defined(LINUX)
    ptedit_invalidate_tlb_args_t args;
    args.pid = pid;
    args.address = address;
    ioctl(ptedit_fd, PTEDITOR_IOCTL_CMD_INVALIDATE_TLB_PID, (size_t)&args, pid);
#else
    size_t vaddr = (size_t)address;
    DWORD returnLength;
    DeviceIoControl(ptedit_fd, PTEDITOR_FLUSH_TLB, (LPVOID)&vaddr, sizeof(vaddr), (LPVOID)&vaddr, sizeof(vaddr), &returnLength, 0);
#endif
}

// ---------------------------------------------------------------------------
ptedit_fnc void ptedit_invalidate_tlb(void* address) {
    // we do not directly call ptedit_invalidate_tlb_pid to ensure that the old
    // API is still working (for backwards compatibility)
#if defined(LINUX)
    ioctl(ptedit_fd, PTEDITOR_IOCTL_CMD_INVALIDATE_TLB, (size_t)address);
#else
    size_t vaddr = (size_t)address;
    DWORD returnLength;
    DeviceIoControl(ptedit_fd, PTEDITOR_FLUSH_TLB, (LPVOID)&vaddr, sizeof(vaddr), (LPVOID)&vaddr, sizeof(vaddr), &returnLength, 0);
#endif
}

// ---------------------------------------------------------------------------
ptedit_fnc int ptedit_switch_tlb_invalidation(int implementation) {
#if defined(LINUX)
    return (int) ioctl(ptedit_fd, PTEDITOR_IOCTL_CMD_SWITCH_TLB_INVALIDATION, (size_t) implementation);
#else
    NO_WINDOWS_SUPPORT
#endif
}


// ---------------------------------------------------------------------------
ptedit_fnc size_t ptedit_get_mts() {
    size_t mt = 0;
#if defined(LINUX)
    ioctl(ptedit_fd, PTEDITOR_IOCTL_CMD_GET_PAT, (size_t)&mt);
#else
    DWORD returnLength;
    DeviceIoControl(ptedit_fd, PTEDITOR_GET_PAT, (LPVOID)&mt, sizeof(mt), (LPVOID)&mt, sizeof(mt), &returnLength, 0);
#endif
    return mt;
}


// ---------------------------------------------------------------------------
ptedit_fnc char ptedit_get_mt(unsigned char mt) {
    size_t mts = ptedit_get_mts();
#if defined(__i386__) || defined(__x86_64__) || defined(_WIN64)
    return ((mts >> (mt * 8)) & 7);
#elif defined(__aarch64__)
    return ((mts >> (mt * 8)) & 0xff);
#endif
}


// ---------------------------------------------------------------------------
const char* ptedit_mt_to_string(unsigned char mt) {
#if defined(__i386__) || defined(__x86_64__) || defined(_WIN64)
    const char* mts[] = { "UC", "WC", "Rsvd", "Rsvd", "WT", "WP", "WB", "UC-", "Rsvd" };
    if (mt <= 7) return mts[mt];
    return NULL;
#elif defined(__aarch64__)
    static char mts[16];
    int i;
    mts[0] = 0;
    for (i = 0; i < 2; i++) {
        strcat(mts, i == 0 ? "I" : "O");
        if ((mt & 0xf) == ((mt >> 4) & 0xf)) strcpy(mts, "");
        switch ((mt >> (i * 4)) & 0xf) {
        case 0:
            strcat(mts, "DM");
            break;
        case 1: /* Fall through */
        case 2: /* Fall through */
        case 3:
            strcat(mts, "WT");
            break;
        case 4:
            strcat(mts, "UC");
            break;
        case 5: /* Fall through */
        case 6: /* Fall through */
        case 7:
            strcat(mts, "WB");
            break;
        case 8: /* Fall through */
        case 9: /* Fall through */
        case 10: /* Fall through */
        case 11:
            strcat(mts, "WT");
            break;
        case 12: /* Fall through */
        case 13: /* Fall through */
        case 14: /* Fall through */
        case 15:
            strcat(mts, "WB");
        }
    }
    return mts;
#endif
}


// ---------------------------------------------------------------------------
ptedit_fnc void ptedit_set_mts(size_t mts) {
#if defined(LINUX)
    ioctl(ptedit_fd, PTEDITOR_IOCTL_CMD_SET_PAT, mts);
#else
    DWORD returnLength;
    DeviceIoControl(ptedit_fd, PTEDITOR_GET_PAT, (LPVOID)&mts, sizeof(mts), (LPVOID)&mts, sizeof(mts), &returnLength, 0);
#endif
}


// ---------------------------------------------------------------------------
ptedit_fnc void ptedit_set_mt(unsigned char mt, unsigned char value) {
    size_t mts = ptedit_get_mts();
#if defined(__i386__) || defined(__x86_64__) || defined(_WIN64)
    mts &= ~(7 << (mt * 8));
#elif defined(__aarch64__)
    mts &= ~(0xff << (mt * 8));
#endif
    mts |= ((size_t)value << (mt * 8));
    ptedit_set_mts(mts);
}


// ---------------------------------------------------------------------------
ptedit_fnc unsigned char ptedit_find_mt(unsigned char type) {
    size_t mts = ptedit_get_mts();
    unsigned char found = 0;
    int i;
    for (i = 0; i < 8; i++) {
#if defined(__i386__) || defined(__x86_64__) || defined(_WIN64)
        if (((mts >> (i * 8)) & 7) == type) found |= (1 << i);
#elif defined(__aarch64__)
        if (((mts >> (i * 8)) & 0xff) == type) {
            found |= (1 << i);
        }
        else {
            unsigned char plow, phigh;
            plow = (mts >> (i * 8)) & 0xf;
            phigh = ((mts >> (i * 8)) >> 4) & 0xf;
            if ((plow == phigh) && (plow == type)) {
                found |= (1 << i);
            }
        }
#endif
    }
    return found;
}


// ---------------------------------------------------------------------------
int ptedit_find_first_mt(unsigned char type) {
#if defined(LINUX)
    return __builtin_ffs(ptedit_find_mt(type)) - 1;
#else
    DWORD index = 0;
    if (BitScanForward64(&index, ptedit_find_mt(type))) {
        return index;
    }
    else {
        return -1;
    }
#endif
}


// ---------------------------------------------------------------------------
ptedit_fnc size_t ptedit_apply_mt(size_t entry, unsigned char mt) {
#if defined(__i386__) || defined(__x86_64__) || defined(_WIN64)
    entry &= ~((1ull << PTEDIT_PAGE_BIT_PWT) | (1ull << PTEDIT_PAGE_BIT_PCD) | (1ull << PTEDIT_PAGE_BIT_PAT));
    if (mt & 1) entry |= (1ull << PTEDIT_PAGE_BIT_PWT);
    if (mt & 2) entry |= (1ull << PTEDIT_PAGE_BIT_PCD);
    if (mt & 4) entry |= (1ull << PTEDIT_PAGE_BIT_PAT);
#elif defined(__aarch64__)
    entry &= ~0x1c;
    entry |= (mt & 7) << 2;
#endif
    return entry;
}

// ---------------------------------------------------------------------------
size_t ptedit_apply_mt_huge(size_t entry, unsigned char mt) {
#if defined(__i386__) || defined(__x86_64__) || defined(_WIN64)
    entry &= ~((1ull << PTEDIT_PAGE_BIT_PWT) | (1ull << PTEDIT_PAGE_BIT_PCD) | (1ull << PTEDIT_PAGE_BIT_PAT_LARGE));
    if (mt & 1) entry |= (1ull << PTEDIT_PAGE_BIT_PWT);
    if (mt & 2) entry |= (1ull << PTEDIT_PAGE_BIT_PCD);
    if (mt & 4) entry |= (1ull << PTEDIT_PAGE_BIT_PAT_LARGE);
#elif defined(__aarch64__)
    entry &= ~0x1c;
    entry |= (mt & 7) << 2;
#endif
    return entry;
}

// ---------------------------------------------------------------------------
ptedit_fnc unsigned char ptedit_extract_mt(size_t entry) {
#if defined(__i386__) || defined(__x86_64__) || defined(_WIN64)
    return (!!(entry & (1ull << PTEDIT_PAGE_BIT_PWT))) | ((!!(entry & (1ull << PTEDIT_PAGE_BIT_PCD))) << 1) | ((!!(entry & (1ull << PTEDIT_PAGE_BIT_PAT))) << 2);
#elif defined(__aarch64__)
    return (entry >> 2) & 7;
#endif
}

// ---------------------------------------------------------------------------
unsigned char ptedit_extract_mt_huge(size_t entry) {
#if defined(__i386__) || defined(__x86_64__) || defined(_WIN64)
    return (!!(entry & (1ull << PTEDIT_PAGE_BIT_PWT))) | ((!!(entry & (1ull << PTEDIT_PAGE_BIT_PCD))) << 1) | ((!!(entry & (1ull << PTEDIT_PAGE_BIT_PAT_LARGE))) << 2);
#elif defined(__aarch64__)
    return (entry >> 2) & 7;
#endif
}

// ---------------------------------------------------------------------------
ptedit_fnc void ptedit_full_serializing_barrier() {
#if defined(__i386__) || defined(__x86_64__) || defined(_WIN64)
#if defined(LINUX)
    asm volatile("mfence\nlfence\n" ::: "memory");
#else
    MemoryBarrier();
#endif
#elif defined(__aarch64__)
    asm volatile("DSB SY");
    asm volatile("DSB ISH");
    asm volatile("ISB");
#endif
    ptedit_set_paging_root(0, ptedit_get_paging_root(0));
#if defined(__i386__) || defined(__x86_64__) || defined(_WIN64)
#if defined(LINUX)
    asm volatile("mfence\nlfence\n" ::: "memory");
#else 
    MemoryBarrier();
#endif
#elif defined(__aarch64__)
    asm volatile("ISB");
    asm volatile("DSB ISH");
    asm volatile("DSB SY");
#endif
}


// ---------------------------------------------------------------------------
ptedit_fnc void ptedit_pte_set_bit(void* address, pid_t pid, int bit) {
    ptedit_entry_t vm = ptedit_resolve(address, pid);
    if (!(vm.valid & PTEDIT_VALID_MASK_PTE)) return;
    vm.pte |= (1ull << bit);
    vm.valid = PTEDIT_VALID_MASK_PTE;
    ptedit_update(address, pid, &vm);
}

// ---------------------------------------------------------------------------
ptedit_fnc void ptedit_pte_clear_bit(void* address, pid_t pid, int bit) {
    ptedit_entry_t vm = ptedit_resolve(address, pid);
    if (!(vm.valid & PTEDIT_VALID_MASK_PTE)) return;
    vm.pte &= ~(1ull << bit);
    vm.valid = PTEDIT_VALID_MASK_PTE;
    ptedit_update(address, pid, &vm);
}

// ---------------------------------------------------------------------------
ptedit_fnc unsigned char ptedit_pte_get_bit(void* address, pid_t pid, int bit) {
    ptedit_entry_t vm = ptedit_resolve(address, pid);
    return !!(vm.pte & (1ull << bit));
}

// ---------------------------------------------------------------------------
ptedit_fnc size_t ptedit_pte_get_pfn(void* address, pid_t pid) {
    ptedit_entry_t vm = ptedit_resolve(address, pid);
    if (!(vm.valid & PTEDIT_VALID_MASK_PTE)) return 0;
    else return ptedit_get_pfn(vm.pte);
}

// ---------------------------------------------------------------------------
ptedit_fnc void ptedit_pte_set_pfn(void* address, pid_t pid, size_t pfn) {
    ptedit_entry_t vm = ptedit_resolve(address, pid);
    if (!(vm.valid & PTEDIT_VALID_MASK_PTE)) return;
    vm.pte = ptedit_set_pfn(vm.pte, pfn);
    vm.valid = PTEDIT_VALID_MASK_PTE;
    ptedit_update(address, pid, &vm);
}

```

`test/Makefile`:

```
all: tests

tests: tests.c utest.h ../ptedit_header.h
	gcc -Os tests.c -std=gnu99 -o tests -fsanitize=address

clean:
	rm -f tests
	

```

`test/tests.c`:

```c
#include "utest.h"
#include "../ptedit_header.h"
#include <time.h>
#include <stdlib.h>

UTEST_STATE();

#if defined(LINUX)
#define PAGE_ALIGN_CHAR char __attribute__((aligned(4096)))
#else
#define PAGE_ALIGN_CHAR __declspec(align(4096)) char
#endif

#if defined(__i386__) || defined(__x86_64__)
void flush(void *p) { asm volatile("clflush 0(%0)\n" : : "c"(p) : "rax"); }
#elif defined(__aarch64__)
void flush(void *p) {
  asm volatile("DC CIVAC, %0" ::"r"(p));
  asm volatile("DSB ISH");
  asm volatile("ISB");
}
#endif

#ifndef MAP_HUGE_2MB
#if defined(LINUX)
#include <linux/mman.h>
#endif
#ifndef MAP_HUGE_2MB
#define MAP_HUGE_2MB (21 << 26)
#endif
#endif

PAGE_ALIGN_CHAR page1[4096];
PAGE_ALIGN_CHAR page2[4096];
PAGE_ALIGN_CHAR scratch[4096];
PAGE_ALIGN_CHAR accessor[4096];

// =========================================================================
//                             Helper functions
// =========================================================================

#if defined(LINUX)
size_t hrtime() {
  struct timespec t1;
  clock_gettime(CLOCK_MONOTONIC, &t1);
  return t1.tv_sec * 1000 * 1000 * 1000ULL + t1.tv_nsec;
}
#else
size_t hrtime() {
    __int64 wintime; 
    GetSystemTimePreciseAsFileTime((FILETIME*)&wintime);
    return wintime;
}
#endif

typedef void (*access_time_callback_t)(void*);

size_t access_time_ext(void *ptr, size_t MEASUREMENTS, access_time_callback_t cb) {
  size_t start = 0, end = 0, sum = 0;

  for (int i = 0; i < MEASUREMENTS; i++) {
    start = hrtime();
    *((volatile size_t*)ptr);
    end = hrtime();
    sum += (end - start);
    if(cb) cb(ptr);
  }

  return (size_t) (10 * sum / MEASUREMENTS);
}

size_t access_time(void *ptr) {
  return access_time_ext(ptr, 1000000, NULL);
}

int entry_equal(ptedit_entry_t* e1, ptedit_entry_t* e2) {
    int diff = 0;
    if((e1->valid & PTEDIT_VALID_MASK_PGD) && (e2->valid & PTEDIT_VALID_MASK_PGD)) {
        diff |= e1->pgd ^ e2->pgd;
    }
    if((e1->valid & PTEDIT_VALID_MASK_P4D) && (e2->valid & PTEDIT_VALID_MASK_P4D)) {
        diff |= e1->p4d ^ e2->p4d;
    }    
    if((e1->valid & PTEDIT_VALID_MASK_PUD) && (e2->valid & PTEDIT_VALID_MASK_PUD)) {
        diff |= e1->pud ^ e2->pud;
    }
    if((e1->valid & PTEDIT_VALID_MASK_PMD) && (e2->valid & PTEDIT_VALID_MASK_PMD)) {
        diff |= e1->pmd ^ e2->pmd;
    }
    if((e1->valid & PTEDIT_VALID_MASK_PTE) && (e2->valid & PTEDIT_VALID_MASK_PTE)) {
        diff |= e1->pte ^ e2->pte;
    }
    return !diff;
}

// =========================================================================
//                             Resolving addresses
// =========================================================================


UTEST(resolve, resolve_basic) {
    ptedit_entry_t vm = ptedit_resolve(page1, 0);
    ASSERT_TRUE(vm.pgd);
    ASSERT_TRUE(vm.pte);
    ASSERT_TRUE(vm.valid & PTEDIT_VALID_MASK_PTE);
    ASSERT_TRUE(vm.valid & PTEDIT_VALID_MASK_PGD);    
}

UTEST(resolve, resolve_valid_mask) {
    ptedit_entry_t vm = ptedit_resolve(page1, 0);
    if(vm.valid & PTEDIT_VALID_MASK_PGD) ASSERT_TRUE(vm.pgd);
    if(vm.valid & PTEDIT_VALID_MASK_P4D) ASSERT_TRUE(vm.p4d);
    if(vm.valid & PTEDIT_VALID_MASK_PMD) ASSERT_TRUE(vm.pmd);
    if(vm.valid & PTEDIT_VALID_MASK_PUD) ASSERT_TRUE(vm.pud);
    if(vm.valid & PTEDIT_VALID_MASK_PTE) ASSERT_TRUE(vm.pte);
}

UTEST(resolve, resolve_deterministic) {
    ptedit_entry_t vm1 = ptedit_resolve(page1, 0);
    ptedit_entry_t vm2 = ptedit_resolve(page1, 0);
    ASSERT_TRUE(entry_equal(&vm1, &vm2));
}

UTEST(resolve, resolve_different) {
    ptedit_entry_t vm1 = ptedit_resolve(page1, 0);
    ptedit_entry_t vm2 = ptedit_resolve(page2, 0);
    ASSERT_FALSE(entry_equal(&vm1, &vm2));
}

UTEST(resolve, resolve_invalid) {
    ptedit_entry_t vm1 = ptedit_resolve(0, 0);
    ASSERT_FALSE(vm1.valid & PTEDIT_VALID_MASK_PTE);
}

UTEST(resolve, resolve_invalid_pid) {
    ptedit_entry_t vm1 = ptedit_resolve(page1, -1);
    ASSERT_FALSE(vm1.valid);
}

UTEST(resolve, resolve_page_offset) {
    ptedit_entry_t vm1 = ptedit_resolve(page1, 0);
    ptedit_entry_t vm2 = ptedit_resolve(page1 + 1, 0);
    vm1.vaddr = vm2.vaddr = 0;
    ASSERT_TRUE(entry_equal(&vm1, &vm2));
    ptedit_entry_t vm3 = ptedit_resolve(page1 + 1024, 0);
    vm1.vaddr = vm3.vaddr = 0;
    ASSERT_TRUE(entry_equal(&vm1, &vm3));
    ptedit_entry_t vm4 = ptedit_resolve(page1 + 4095, 0);
    vm1.vaddr = vm4.vaddr = 0;
    ASSERT_TRUE(entry_equal(&vm1, &vm4));
}


// =========================================================================
//                             Updating addresses
// =========================================================================

UTEST(update, nop) {
    ptedit_entry_t vm1 = ptedit_resolve(scratch, 0);
    ASSERT_TRUE(vm1.valid);
    size_t valid = vm1.valid;
    vm1.valid = 0;
    ptedit_update(scratch, 0, &vm1);
    vm1.valid = valid;
    ptedit_entry_t vm2 = ptedit_resolve(scratch, 0);
    ASSERT_TRUE(entry_equal(&vm1, &vm2));
}

UTEST(update, pte_nop) {
    ptedit_entry_t vm1 = ptedit_resolve(scratch, 0);
    ASSERT_TRUE(vm1.valid);
    size_t valid = vm1.valid;
    vm1.valid = PTEDIT_VALID_MASK_PTE;
    ptedit_update(scratch, 0, &vm1);
    vm1.valid = valid;
    ptedit_entry_t vm2 = ptedit_resolve(scratch, 0);
    ASSERT_TRUE(entry_equal(&vm1, &vm2));
}

UTEST(update, new_pte) {
    ptedit_entry_t vm = ptedit_resolve(scratch, 0);
    ptedit_entry_t vm1 = ptedit_resolve(scratch, 0);
    ASSERT_TRUE(vm1.valid);
    size_t pte = vm1.pte;
    vm1.pte = ptedit_set_pfn(vm1.pte, 0x1234);
    vm1.valid = PTEDIT_VALID_MASK_PTE;
    ptedit_update(scratch, 0, &vm1);
    
    ptedit_entry_t check = ptedit_resolve(scratch, 0);
    ASSERT_NE((size_t)ptedit_cast(check.pte, ptedit_pte_t).pfn, ptedit_get_pfn(pte));
    ASSERT_EQ((size_t)ptedit_cast(check.pte, ptedit_pte_t).pfn, 0x1234);
    
    vm1.valid = PTEDIT_VALID_MASK_PTE;
    vm1.pte = pte;
    ptedit_update(scratch, 0, &vm1);
    
    ptedit_entry_t vm2 = ptedit_resolve(scratch, 0);
    ASSERT_TRUE(entry_equal(&vm, &vm2));
}

// =========================================================================
//                                  PTEs
// =========================================================================

UTEST(pte, get_pfn) {
    ptedit_entry_t vm = ptedit_resolve(page1, 0);
    ASSERT_EQ(ptedit_get_pfn(vm.pte), (size_t)ptedit_cast(vm.pte, ptedit_pte_t).pfn);
}

UTEST(pte, get_pte_pfn) {
    ptedit_entry_t vm = ptedit_resolve(page1, 0);
    ASSERT_EQ(ptedit_pte_get_pfn(page1, 0), (size_t)ptedit_cast(vm.pte, ptedit_pte_t).pfn);
}

UTEST(pte, get_pte_pfn_invalid) {
    ASSERT_FALSE(ptedit_pte_get_pfn(0, 0));
}

UTEST(pte, pte_present) {
    ptedit_entry_t vm = ptedit_resolve(page1, 0);
    ASSERT_EQ((size_t)ptedit_cast(vm.pte, ptedit_pte_t).present, PTEDIT_PAGE_PRESENT);
}

UTEST(pte, pte_set_pfn_basic) {
    size_t entry = 0;
    ASSERT_EQ(entry, ptedit_set_pfn(entry, 0));
    ASSERT_NE(entry, ptedit_set_pfn(entry, 1));
    ASSERT_EQ(entry, ptedit_set_pfn(ptedit_set_pfn(entry, 1234), 0));
    ASSERT_GT(ptedit_set_pfn(entry, 2), ptedit_set_pfn(entry, 1));
    entry = (size_t)-1;
    ASSERT_NE(0, ptedit_set_pfn(entry, 0));
}

UTEST(pte, pte_set_pfn) {
    ASSERT_TRUE(accessor[0] == 2);
    size_t accessor_pfn = ptedit_pte_get_pfn(accessor, 0);
    ASSERT_TRUE(accessor_pfn);
    size_t page1_pfn = ptedit_pte_get_pfn(page1, 0);
    ASSERT_TRUE(page1_pfn);
    size_t page2_pfn = ptedit_pte_get_pfn(page2, 0);
    ASSERT_TRUE(page2_pfn);
    ptedit_pte_set_pfn(accessor, 0, page1_pfn);
    ASSERT_TRUE(accessor[0] == 0);
    ptedit_pte_set_pfn(accessor, 0, page2_pfn);
    ASSERT_TRUE(accessor[0] == 1);
    ptedit_pte_set_pfn(accessor, 0, accessor_pfn);
    ASSERT_TRUE(accessor[0] == 2);
}


// =========================================================================
//                             Physical Pages
// =========================================================================

UTEST(page, read) {
    char buffer[4096];
    size_t pfn = ptedit_pte_get_pfn(page1, 0);
    ASSERT_TRUE(pfn);
    ptedit_read_physical_page(pfn, buffer);
    ASSERT_TRUE(!memcmp(buffer, page1, sizeof(buffer)));
    pfn = ptedit_pte_get_pfn(page2, 0);
    ASSERT_TRUE(pfn);
    ptedit_read_physical_page(pfn, buffer);
    ASSERT_TRUE(!memcmp(buffer, page2, sizeof(buffer)));
}

UTEST(page, write) {
    char buffer[4096];
    size_t pfn = ptedit_pte_get_pfn(scratch, 0);
    ASSERT_TRUE(pfn);
    ptedit_write_physical_page(pfn, page1);
    ptedit_read_physical_page(pfn, buffer);
    ASSERT_TRUE(!memcmp(page1, buffer, sizeof(buffer)));
    ptedit_write_physical_page(pfn, page2);
    ptedit_read_physical_page(pfn, buffer);
    ASSERT_TRUE(!memcmp(page2, buffer, sizeof(buffer)));
}

// =========================================================================
//                                Paging
// =========================================================================

UTEST(paging, get_root) {
    size_t root = ptedit_get_paging_root(0);
    ASSERT_TRUE(root);
}

UTEST(paging, get_root_deterministic) {
    size_t root = ptedit_get_paging_root(0);
    ASSERT_TRUE(root);
    size_t root_check = ptedit_get_paging_root(0);
    ASSERT_EQ(root, root_check);   
}

UTEST(paging, get_root_invalid_pid) {
    size_t root = ptedit_get_paging_root(-1);
    ASSERT_FALSE(root);
}

UTEST(paging, root_page_aligned) {
    size_t root = ptedit_get_paging_root(0);
    ASSERT_TRUE(root);
    ASSERT_FALSE(root % ptedit_get_pagesize());
}

UTEST(paging, correct_root) {
    size_t buffer[4096 / sizeof(size_t)];
    size_t root = ptedit_get_paging_root(0);
    ptedit_read_physical_page(root / ptedit_get_pagesize(), (char*)buffer);
    ptedit_entry_t vm = ptedit_resolve(0, 0);
    ASSERT_EQ(vm.pgd, buffer[0]);
}

// =========================================================================
//                               Memory Types
// =========================================================================

UTEST(memtype, get) {
    ASSERT_TRUE(ptedit_get_mts());
}

UTEST(memtype, get_deterministic) {
    ASSERT_EQ(ptedit_get_mts(), ptedit_get_mts());
}

UTEST(memtype, uncachable) {
    ASSERT_NE(ptedit_find_first_mt(PTEDIT_MT_UC), -1);
}

UTEST(memtype, writeback) {
    ASSERT_NE(ptedit_find_first_mt(PTEDIT_MT_WB), -1);
}

UTEST(memtype, apply) {
    size_t entry = 0;
    ASSERT_NE(ptedit_apply_mt(entry, 1), entry);
    ASSERT_EQ(ptedit_apply_mt(entry, 0), entry);
}

UTEST(memtype, apply_huge) {
    size_t entry = 0;
    ASSERT_NE(ptedit_apply_mt_huge(entry, 1), entry);
    ASSERT_EQ(ptedit_apply_mt_huge(entry, 0), entry);
}

UTEST(memtype, extract) {
    ASSERT_TRUE(ptedit_extract_mt(ptedit_apply_mt(0, 5)) == 5);
    ASSERT_TRUE(ptedit_extract_mt(ptedit_apply_mt((size_t)-1, 2)) == 2);
}

UTEST(memtype, extract_huge) {
    ASSERT_TRUE(ptedit_extract_mt_huge(ptedit_apply_mt_huge(0, 5)) == 5);
    ASSERT_TRUE(ptedit_extract_mt_huge(ptedit_apply_mt_huge((size_t)-1, 2)) == 2);
}

UTEST(memtype, uncachable_access_time) {
    if(getenv("TRAVISCI")) {
        ASSERT_TRUE(1);
    } else {
        int uc_mt = ptedit_find_first_mt(PTEDIT_MT_UC);
        ASSERT_NE(uc_mt, -1);
        int wb_mt = ptedit_find_first_mt(PTEDIT_MT_WB);
        ASSERT_NE(wb_mt, -1);
        
        flush(scratch);
        size_t before = access_time(scratch);
        
        ptedit_entry_t entry = ptedit_resolve(scratch, 0);
        size_t pte = entry.pte;
        ASSERT_TRUE(entry.valid);
        ASSERT_TRUE(entry.pte);
        entry.pte = ptedit_apply_mt(entry.pte, uc_mt);
        entry.valid = PTEDIT_VALID_MASK_PTE;
        ptedit_update(scratch, 0, &entry);   
        
        flush(scratch);
        size_t uc = access_time(scratch);
        
        entry.pte = pte;
        entry.valid = PTEDIT_VALID_MASK_PTE;
        ptedit_update(scratch, 0, &entry);   
        
        size_t after = access_time(scratch);

        ASSERT_LT(after + 5, uc);
        ASSERT_LT(before + 5, uc);
    }
}

UTEST(memtype, uncachable_huge_page_access_time) {
    if(getenv("TRAVISCI")) {
        ASSERT_TRUE(1);
    } else {
        char* huge_page = mmap(0, (2*1024*1024), PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS|MAP_POPULATE|MAP_HUGETLB|MAP_HUGE_2MB, -1, 0);
        if (huge_page != MAP_FAILED) {
          int uc_mt = ptedit_find_first_mt(PTEDIT_MT_UC);
          ASSERT_NE(uc_mt, -1);
          int wb_mt = ptedit_find_first_mt(PTEDIT_MT_WB);
          ASSERT_NE(wb_mt, -1);

          flush(huge_page);
          size_t before = access_time(huge_page);
          
          ptedit_entry_t entry = ptedit_resolve(huge_page, 0);
          size_t pmd = entry.pmd;
          ASSERT_TRUE(entry.valid);
          ASSERT_TRUE(entry.pmd);

          entry.pmd = ptedit_apply_mt_huge(entry.pmd, uc_mt);
          entry.valid = PTEDIT_VALID_MASK_PMD;
          ptedit_update(huge_page, 0, &entry);   
          
          flush(huge_page);
          size_t uc = access_time(huge_page);
          
          entry.pmd = pmd;
          entry.valid = PTEDIT_VALID_MASK_PMD;
          ptedit_update(huge_page, 0, &entry);   
          
          size_t after = access_time(huge_page);

          munmap(huge_page, (2*1024*1024));

          ASSERT_LT(after + 5, uc);
          ASSERT_LT(before + 5, uc);
        } else {
          fprintf(stdout, "Note: Could not allocate huge page.\n");
        }
    }
}

// =========================================================================
//                               TLB
// =========================================================================

UTEST(tlb, invalid_tlb_invalidate_method) {
    int ret = ptedit_switch_tlb_invalidation(3);
    ASSERT_TRUE(ret);
}

UTEST(tlb, valid_tlb_invalidate_method) {
    int ret = ptedit_switch_tlb_invalidation(PTEDITOR_TLB_INVALIDATION_KERNEL);
    ASSERT_FALSE(ret);
}

UTEST(tlb, access_time_kernel_tlb_flush) {
    ptedit_switch_tlb_invalidation(PTEDITOR_TLB_INVALIDATION_KERNEL);
    int flushed = access_time_ext(scratch, 100, ptedit_invalidate_tlb);
    int normal = access_time_ext(scratch, 100, NULL);
    ASSERT_GT(flushed, normal);
}

// custom TLB invalidation is not supported on all CPUs
#if !(defined(__i386__) || defined(__x86_64__))
UTEST(tlb, access_time_custom_tlb_flush) {
    ptedit_switch_tlb_invalidation(PTEDITOR_TLB_INVALIDATION_CUSTOM);
    int flushed = access_time_ext(scratch, 100, ptedit_invalidate_tlb);
    int normal = access_time_ext(scratch, 100, NULL);
    ASSERT_GT(flushed, normal);
}
#endif

int main(int argc, const char *const argv[]) {
    if(ptedit_init()) {
        printf("Could not initialize PTEditor, did you load the kernel module?\n");
        return 1;
    }
    memset(scratch, 0, sizeof(scratch));
    memset(page1, 0, sizeof(page1));
    memset(page2, 1, sizeof(page2));
    memset(accessor, 2, sizeof(accessor));
    
//     ptedit_use_implementation(PTEDIT_IMPL_USER_PREAD);
    
    int result = utest_main(argc, argv);
    
    ptedit_cleanup();
    return result;
}

```

`test/utest.h`:

```h
/*
   The latest version of this library is available on GitHub;
   https://github.com/sheredom/utest.h
*/

/*
   This is free and unencumbered software released into the public domain.

   Anyone is free to copy, modify, publish, use, compile, sell, or
   distribute this software, either in source code form or as a compiled
   binary, for any purpose, commercial or non-commercial, and by any
   means.

   In jurisdictions that recognize copyright laws, the author or authors
   of this software dedicate any and all copyright interest in the
   software to the public domain. We make this dedication for the benefit
   of the public at large and to the detriment of our heirs and
   successors. We intend this dedication to be an overt act of
   relinquishment in perpetuity of all present and future rights to this
   software under copyright law.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
   IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
   OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
   ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
   OTHER DEALINGS IN THE SOFTWARE.

   For more information, please refer to <http://unlicense.org/>
*/

#ifndef SHEREDOM_UTEST_H_INCLUDED
#define SHEREDOM_UTEST_H_INCLUDED

#ifdef _MSC_VER
/*
   Disable warning about not inlining 'inline' functions.
   TODO: We'll fix this later by not using fprintf within our macros, and
   instead use snprintf to a realloc'ed buffer.
*/
#pragma warning(disable : 4710)

/*
   Disable warning about inlining functions that are not marked 'inline'.
   TODO: add a UTEST_NOINLINE onto the macro generated functions to fix this.
*/
#pragma warning(disable : 4711)
#pragma warning(push, 1)
#endif

#if defined(_MSC_VER)
typedef __int64 utest_int64_t;
typedef unsigned __int64 utest_uint64_t;
#else
#include <stdint.h>
typedef int64_t utest_int64_t;
typedef uint64_t utest_uint64_t;
#endif

#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#if defined(_MSC_VER)
#pragma warning(pop)
#endif

#if defined(_MSC_VER)
#if defined(_M_IX86)
#define _X86_
#endif

#if defined(_M_AMD64)
#define _AMD64_
#endif

#pragma warning(push, 1)
#include <windef.h>
#include <winbase.h>
#pragma warning(pop)

#elif defined(__linux__)

/*
   slightly obscure include here - we need to include glibc's features.h, but
   we don't want to just include a header that might not be defined for other
   c libraries like musl. Instead we include limits.h, which we know on all
   glibc distributions includes features.h
*/
#include <limits.h>

#if defined(__GLIBC__) && defined(__GLIBC_MINOR__)
#include <time.h>

#if ((2 < __GLIBC__) || ((2 == __GLIBC__) && (17 <= __GLIBC_MINOR__)))
/* glibc is version 2.17 or above, so we can just use clock_gettime */
#define UTEST_USE_CLOCKGETTIME
#else
#include <sys/syscall.h>
#include <unistd.h>
#endif
#endif

#elif defined(__APPLE__)
#include <mach/mach_time.h>
#endif

#if defined(_MSC_VER)
#define UTEST_PRId64 "I64d"
#define UTEST_PRIu64 "I64u"
#define UTEST_INLINE __forceinline

#pragma section(".CRT$XCU", read)
#define UTEST_INITIALIZER(f)                                                   \
  static void __cdecl f(void);                                                 \
  __declspec(allocate(".CRT$XCU")) void(__cdecl * f##_)(void) = f;             \
  static void __cdecl f(void)
#else
#if defined(__linux__)
#if defined(__clang__)
#if __has_warning("-Wreserved-id-macro")
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#endif

#define __STDC_FORMAT_MACROS 1

#if defined(__clang__)
#if __has_warning("-Wreserved-id-macro")
#pragma clang diagnostic pop
#endif
#endif
#endif

#include <inttypes.h>

#define UTEST_PRId64 PRId64
#define UTEST_PRIu64 PRIu64
#define UTEST_INLINE inline

#define UTEST_INITIALIZER(f)                                                   \
  static void f(void) __attribute__((constructor));                            \
  static void f(void)
#endif

#if defined(__cplusplus)
#define UTEST_CAST(type, x) static_cast<type>(x)
#define UTEST_PTR_CAST(type, x) reinterpret_cast<type>(x)
#define UTEST_EXTERN extern "C"
#define UTEST_NULL NULL
#else
#define UTEST_CAST(type, x) ((type)x)
#define UTEST_PTR_CAST(type, x) ((type)x)
#define UTEST_EXTERN extern
#define UTEST_NULL 0
#endif

#ifdef _MSC_VER
/*
    io.h contains definitions for some structures with natural padding. This is
    uninteresting, but for some reason MSVC's behaviour is to warn about
    including this system header. That *is* interesting
*/
#pragma warning(disable : 4820)
#pragma warning(push, 1)
#include <io.h>
#pragma warning(pop)
#define UTEST_COLOUR_OUTPUT() (_isatty(_fileno(stdout)))
#else
#include <unistd.h>
#define UTEST_COLOUR_OUTPUT() (isatty(STDOUT_FILENO))
#endif

static UTEST_INLINE utest_int64_t utest_ns(void) {
#ifdef _MSC_VER
  LARGE_INTEGER counter;
  LARGE_INTEGER frequency;
  QueryPerformanceCounter(&counter);
  QueryPerformanceFrequency(&frequency);
  return UTEST_CAST(utest_int64_t,
                    (counter.QuadPart * 1000000000) / frequency.QuadPart);
#elif defined(__linux)
  struct timespec ts;
  const clockid_t cid = CLOCK_REALTIME;
#if defined(UTEST_USE_CLOCKGETTIME)
  clock_gettime(cid, &ts);
#else
  syscall(SYS_clock_gettime, cid, &ts);
#endif
  return UTEST_CAST(utest_int64_t, ts.tv_sec) * 1000 * 1000 * 1000 + ts.tv_nsec;
#elif __APPLE__
  return UTEST_CAST(utest_int64_t, mach_absolute_time());
#endif
}

typedef void (*utest_testcase_t)(int *, size_t);

struct utest_test_state_s {
  utest_testcase_t func;
  size_t index;
  char *name;
};

struct utest_state_s {
  struct utest_test_state_s *tests;
  size_t tests_length;
  FILE *output;
};

/* extern to the global state utest needs to execute */
UTEST_EXTERN struct utest_state_s utest_state;

#if defined(_MSC_VER)
#define UTEST_WEAK __forceinline
#else
#define UTEST_WEAK __attribute__((weak))
#endif

#if defined(_MSC_VER)
#define UTEST_UNUSED
#else
#define UTEST_UNUSED __attribute__((unused))
#endif

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wvariadic-macros"
#pragma clang diagnostic ignored "-Wc++98-compat-pedantic"
#endif
#define UTEST_PRINTF(...)                                                      \
  if (utest_state.output) {                                                    \
    fprintf(utest_state.output, __VA_ARGS__);                                  \
  }                                                                            \
  printf(__VA_ARGS__)
#ifdef __clang__
#pragma clang diagnostic pop
#endif

#ifdef _MSC_VER
#define UTEST_SNPRINTF(BUFFER, N, ...) _snprintf_s(BUFFER, N, N, __VA_ARGS__)
#else
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wvariadic-macros"
#pragma clang diagnostic ignored "-Wc++98-compat-pedantic"
#endif
#define UTEST_SNPRINTF(...) snprintf(__VA_ARGS__)
#ifdef __clang__
#pragma clang diagnostic pop
#endif
#endif

#if defined(__cplusplus)
/* if we are using c++ we can use overloaded methods (its in the language) */
#define UTEST_OVERLOADABLE
#elif defined(__clang__)
/* otherwise, if we are using clang with c - use the overloadable attribute */
#define UTEST_OVERLOADABLE __attribute__((overloadable))
#endif

#if defined(UTEST_OVERLOADABLE)
UTEST_WEAK UTEST_OVERLOADABLE void utest_type_printer(float f);
UTEST_WEAK UTEST_OVERLOADABLE void utest_type_printer(float f) {
  UTEST_PRINTF("%f", UTEST_CAST(double, f));
}

UTEST_WEAK UTEST_OVERLOADABLE void utest_type_printer(double d);
UTEST_WEAK UTEST_OVERLOADABLE void utest_type_printer(double d) {
  UTEST_PRINTF("%f", d);
}

UTEST_WEAK UTEST_OVERLOADABLE void utest_type_printer(long double d);
UTEST_WEAK UTEST_OVERLOADABLE void utest_type_printer(long double d) {
  UTEST_PRINTF("%Lf", d);
}

UTEST_WEAK UTEST_OVERLOADABLE void utest_type_printer(int i);
UTEST_WEAK UTEST_OVERLOADABLE void utest_type_printer(int i) {
  UTEST_PRINTF("%d", i);
}

UTEST_WEAK UTEST_OVERLOADABLE void utest_type_printer(unsigned int i);
UTEST_WEAK UTEST_OVERLOADABLE void utest_type_printer(unsigned int i) {
  UTEST_PRINTF("%u", i);
}

UTEST_WEAK UTEST_OVERLOADABLE void utest_type_printer(long int i);
UTEST_WEAK UTEST_OVERLOADABLE void utest_type_printer(long int i) {
  UTEST_PRINTF("%ld", i);
}

UTEST_WEAK UTEST_OVERLOADABLE void utest_type_printer(long unsigned int i);
UTEST_WEAK UTEST_OVERLOADABLE void utest_type_printer(long unsigned int i) {
  UTEST_PRINTF("%lu", i);
}

UTEST_WEAK UTEST_OVERLOADABLE void utest_type_printer(const void *p);
UTEST_WEAK UTEST_OVERLOADABLE void utest_type_printer(const void *p) {
  UTEST_PRINTF("%p", p);
}

/*
   long long is a c++11 extension
*/
#if defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) ||              \
    defined(__cplusplus) && (__cplusplus >= 201103L)

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wc++98-compat-pedantic"
#endif

UTEST_WEAK UTEST_OVERLOADABLE void utest_type_printer(long long int i);
UTEST_WEAK UTEST_OVERLOADABLE void utest_type_printer(long long int i) {
  UTEST_PRINTF("%lld", i);
}

UTEST_WEAK UTEST_OVERLOADABLE void utest_type_printer(long long unsigned int i);
UTEST_WEAK UTEST_OVERLOADABLE void
utest_type_printer(long long unsigned int i) {
  UTEST_PRINTF("%llu", i);
}

#ifdef __clang__
#pragma clang diagnostic pop
#endif

#endif
#elif defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L)
#define utest_type_printer(val)                                                \
  UTEST_PRINTF(_Generic((val), int                                             \
                        : "%d", long                                           \
                        : "%ld", long long                                     \
                        : "%lld", unsigned                                     \
                        : "%u", unsigned long                                  \
                        : "%lu", unsigned long long                            \
                        : "%llu", float                                        \
                        : "%f", double                                         \
                        : "%f", long double                                    \
                        : "%Lf", default                                       \
                        : _Generic((val - val), ptrdiff_t                      \
                                   : "%p", default                             \
                                   : "undef")),                                \
               (val))
#else
/*
   we don't have the ability to print the values we got, so we create a macro
   to tell our users we can't do anything fancy
*/
#define utest_type_printer(...) UTEST_PRINTF("undef")
#endif

#if defined(__cplusplus) && (__cplusplus >= 201103L)
#define UTEST_AUTO(x) auto
#elif !defined(__cplusplus)

#if defined(__clang__)
/* clang-format off */
/* had to disable clang-format here because it malforms the pragmas */
#define UTEST_AUTO(x)                                                          \
  _Pragma("clang diagnostic push")                                             \
      _Pragma("clang diagnostic ignored \"-Wgnu-auto-type\"") __auto_type      \
          _Pragma("clang diagnostic pop")
/* clang-format on */
#else
#define UTEST_AUTO(x) __auto_type
#endif

#else
#define UTEST_AUTO(x) typeof(x + 0)
#endif

#if defined(__clang__)
#define UTEST_EXPECT(x, y, cond)                                               \
  {                                                                            \
    _Pragma("clang diagnostic push")                                           \
        _Pragma("clang diagnostic ignored \"-Wlanguage-extension-token\"")     \
            _Pragma("clang diagnostic ignored \"-Wc++98-compat-pedantic\"")    \
                _Pragma("clang diagnostic ignored \"-Wfloat-equal\"")          \
                        UTEST_AUTO(x) xEval = (x);                             \
    UTEST_AUTO(y) yEval = (y);                                                 \
    if (!((xEval)cond(yEval))) {                                               \
      _Pragma("clang diagnostic pop")                                          \
          UTEST_PRINTF("%s:%u: Failure\n", __FILE__, __LINE__);                \
      UTEST_PRINTF("  Expected : ");                                           \
      utest_type_printer(xEval);                                               \
      UTEST_PRINTF("\n");                                                      \
      UTEST_PRINTF("    Actual : ");                                           \
      utest_type_printer(yEval);                                               \
      UTEST_PRINTF("\n");                                                      \
      *utest_result = 1;                                                       \
    }                                                                          \
  }
#elif defined(__GNUC__)
#define UTEST_EXPECT(x, y, cond)                                               \
  {                                                                            \
    UTEST_AUTO(x) xEval = (x);                                                 \
    UTEST_AUTO(y) yEval = (y);                                                 \
    if (!((xEval)cond(yEval))) {                                               \
      UTEST_PRINTF("%s:%u: Failure\n", __FILE__, __LINE__);                    \
      UTEST_PRINTF("  Expected : ");                                           \
      utest_type_printer(xEval);                                               \
      UTEST_PRINTF("\n");                                                      \
      UTEST_PRINTF("    Actual : ");                                           \
      utest_type_printer(yEval);                                               \
      UTEST_PRINTF("\n");                                                      \
      *utest_result = 1;                                                       \
    }                                                                          \
  }
#else
#define UTEST_EXPECT(x, y, cond)                                               \
  {                                                                            \
    if (!((x)cond(y))) {                                                       \
      UTEST_PRINTF("%s:%u: Failure\n", __FILE__, __LINE__);                    \
      *utest_result = 1;                                                       \
    }                                                                          \
  }
#endif

#define EXPECT_TRUE(x)                                                         \
  if (!(x)) {                                                                  \
    UTEST_PRINTF("%s:%u: Failure\n", __FILE__, __LINE__);                      \
    UTEST_PRINTF("  Expected : true\n");                                       \
    UTEST_PRINTF("    Actual : %s\n", (x) ? "true" : "false");                 \
    *utest_result = 1;                                                         \
  }

#define EXPECT_FALSE(x)                                                        \
  if (x) {                                                                     \
    UTEST_PRINTF("%s:%u: Failure\n", __FILE__, __LINE__);                      \
    UTEST_PRINTF("  Expected : false\n");                                      \
    UTEST_PRINTF("    Actual : %s\n", (x) ? "true" : "false");                 \
    *utest_result = 1;                                                         \
  }

#define EXPECT_EQ(x, y) UTEST_EXPECT(x, y, ==)
#define EXPECT_NE(x, y) UTEST_EXPECT(x, y, !=)
#define EXPECT_LT(x, y) UTEST_EXPECT(x, y, <)
#define EXPECT_LE(x, y) UTEST_EXPECT(x, y, <=)
#define EXPECT_GT(x, y) UTEST_EXPECT(x, y, >)
#define EXPECT_GE(x, y) UTEST_EXPECT(x, y, >=)

#define EXPECT_STREQ(x, y)                                                     \
  if (0 != strcmp(x, y)) {                                                     \
    UTEST_PRINTF("%s:%u: Failure\n", __FILE__, __LINE__);                      \
    UTEST_PRINTF("  Expected : \"%s\"\n", x);                                  \
    UTEST_PRINTF("    Actual : \"%s\"\n", y);                                  \
    *utest_result = 1;                                                         \
  }

#define EXPECT_STRNE(x, y)                                                     \
  if (0 == strcmp(x, y)) {                                                     \
    UTEST_PRINTF("%s:%u: Failure\n", __FILE__, __LINE__);                      \
    UTEST_PRINTF("  Expected : \"%s\"\n", x);                                  \
    UTEST_PRINTF("    Actual : \"%s\"\n", y);                                  \
    *utest_result = 1;                                                         \
  }

#if defined(__clang__)
#define UTEST_ASSERT(x, y, cond)                                               \
  {                                                                            \
    _Pragma("clang diagnostic push")                                           \
        _Pragma("clang diagnostic ignored \"-Wlanguage-extension-token\"")     \
            _Pragma("clang diagnostic ignored \"-Wc++98-compat-pedantic\"")    \
                _Pragma("clang diagnostic ignored \"-Wfloat-equal\"")          \
                        UTEST_AUTO(x) xEval = (x);                             \
    UTEST_AUTO(y) yEval = (y);                                                 \
    if (!((xEval)cond(yEval))) {                                               \
      _Pragma("clang diagnostic pop")                                          \
          UTEST_PRINTF("%s:%u: Failure\n", __FILE__, __LINE__);                \
      UTEST_PRINTF("  Expected : ");                                           \
      utest_type_printer(xEval);                                               \
      UTEST_PRINTF("\n");                                                      \
      UTEST_PRINTF("    Actual : ");                                           \
      utest_type_printer(yEval);                                               \
      UTEST_PRINTF("\n");                                                      \
      *utest_result = 1;                                                       \
      return;                                                                  \
    }                                                                          \
  }
#elif defined(__GNUC__)
#define UTEST_ASSERT(x, y, cond)                                               \
  {                                                                            \
    UTEST_AUTO(x) xEval = (x);                                                 \
    UTEST_AUTO(y) yEval = (y);                                                 \
    if (!((xEval)cond(yEval))) {                                               \
      UTEST_PRINTF("%s:%u: Failure\n", __FILE__, __LINE__);                    \
      UTEST_PRINTF("  Expected : ");                                           \
      utest_type_printer(xEval);                                               \
      UTEST_PRINTF("\n");                                                      \
      UTEST_PRINTF("    Actual : ");                                           \
      utest_type_printer(yEval);                                               \
      UTEST_PRINTF("\n");                                                      \
      *utest_result = 1;                                                       \
      return;                                                                  \
    }                                                                          \
  }
#else
#define UTEST_ASSERT(x, y, cond)                                               \
  {                                                                            \
    if (!((x)cond(y))) {                                                       \
      UTEST_PRINTF("%s:%u: Failure\n", __FILE__, __LINE__);                    \
      *utest_result = 1;                                                       \
      return;                                                                  \
    }                                                                          \
  }
#endif

#define ASSERT_TRUE(x)                                                         \
  if (!(x)) {                                                                  \
    UTEST_PRINTF("%s:%u: Failure\n", __FILE__, __LINE__);                      \
    UTEST_PRINTF("  Expected : true\n");                                       \
    UTEST_PRINTF("    Actual : %s\n", (x) ? "true" : "false");                 \
    *utest_result = 1;                                                         \
    return;                                                                    \
  }

#define ASSERT_FALSE(x)                                                        \
  if (x) {                                                                     \
    UTEST_PRINTF("%s:%u: Failure\n", __FILE__, __LINE__);                      \
    UTEST_PRINTF("  Expected : false\n");                                      \
    UTEST_PRINTF("    Actual : %s\n", (x) ? "true" : "false");                 \
    *utest_result = 1;                                                         \
    return;                                                                    \
  }

#define ASSERT_EQ(x, y) UTEST_ASSERT(x, y, ==)
#define ASSERT_NE(x, y) UTEST_ASSERT(x, y, !=)
#define ASSERT_LT(x, y) UTEST_ASSERT(x, y, <)
#define ASSERT_LE(x, y) UTEST_ASSERT(x, y, <=)
#define ASSERT_GT(x, y) UTEST_ASSERT(x, y, >)
#define ASSERT_GE(x, y) UTEST_ASSERT(x, y, >=)

#define ASSERT_STREQ(x, y)                                                     \
  EXPECT_STREQ(x, y);                                                          \
  if (0 != strcmp(x, y)) {                                                     \
    UTEST_PRINTF("%s:%u: Failure\n", __FILE__, __LINE__);                      \
    UTEST_PRINTF("  Expected : \"%s\"\n", x);                                  \
    UTEST_PRINTF("    Actual : \"%s\"\n", y);                                  \
    *utest_result = 1;                                                         \
    return;                                                                    \
  }

#define ASSERT_STRNE(x, y)                                                     \
  EXPECT_STRNE(x, y);                                                          \
  if (0 == strcmp(x, y)) {                                                     \
    UTEST_PRINTF("%s:%u: Failure\n", __FILE__, __LINE__);                      \
    UTEST_PRINTF("  Expected : \"%s\"\n", x);                                  \
    UTEST_PRINTF("    Actual : \"%s\"\n", y);                                  \
    *utest_result = 1;                                                         \
    return;                                                                    \
  }

#define UTEST(SET, NAME)                                                       \
  UTEST_EXTERN struct utest_state_s utest_state;                               \
  static void utest_run_##SET##_##NAME(int *utest_result);                     \
  static void utest_##SET##_##NAME(int *utest_result, size_t utest_index) {    \
    (void)utest_index;                                                         \
    utest_run_##SET##_##NAME(utest_result);                                    \
  }                                                                            \
  UTEST_INITIALIZER(utest_register_##SET##_##NAME) {                           \
    const size_t index = utest_state.tests_length++;                           \
    const char *name_part = #SET "." #NAME;                                    \
    const size_t name_size = strlen(name_part) + 1;                            \
    char *name = UTEST_PTR_CAST(char *, malloc(name_size));                    \
    utest_state.tests =                                                        \
        UTEST_PTR_CAST(struct utest_test_state_s *,                            \
                       realloc(UTEST_PTR_CAST(void *, utest_state.tests),      \
                               sizeof(struct utest_test_state_s) *             \
                                   utest_state.tests_length));                 \
    utest_state.tests[index].func = &utest_##SET##_##NAME;                     \
    utest_state.tests[index].name = name;                                      \
    UTEST_SNPRINTF(name, name_size, "%s", name_part);                          \
  }                                                                            \
  void utest_run_##SET##_##NAME(int *utest_result)

#define UTEST_F_SETUP(FIXTURE)                                                 \
  static void utest_f_setup_##FIXTURE(int *utest_result,                       \
                                      struct FIXTURE *utest_fixture)

#define UTEST_F_TEARDOWN(FIXTURE)                                              \
  static void utest_f_teardown_##FIXTURE(int *utest_result,                    \
                                         struct FIXTURE *utest_fixture)

#define UTEST_F(FIXTURE, NAME)                                                 \
  UTEST_EXTERN struct utest_state_s utest_state;                               \
  static void utest_f_setup_##FIXTURE(int *, struct FIXTURE *);                \
  static void utest_f_teardown_##FIXTURE(int *, struct FIXTURE *);             \
  static void utest_run_##FIXTURE##_##NAME(int *, struct FIXTURE *);           \
  static void utest_f_##FIXTURE##_##NAME(int *utest_result,                    \
                                         size_t utest_index) {                 \
    struct FIXTURE fixture;                                                    \
    (void)utest_index;                                                         \
    memset(&fixture, 0, sizeof(fixture));                                      \
    utest_f_setup_##FIXTURE(utest_result, &fixture);                           \
    if (0 != *utest_result) {                                                  \
      return;                                                                  \
    }                                                                          \
    utest_run_##FIXTURE##_##NAME(utest_result, &fixture);                      \
    utest_f_teardown_##FIXTURE(utest_result, &fixture);                        \
  }                                                                            \
  UTEST_INITIALIZER(utest_register_##FIXTURE##_##NAME) {                       \
    const size_t index = utest_state.tests_length++;                           \
    const char *name_part = #FIXTURE "." #NAME;                                \
    const size_t name_size = strlen(name_part) + 1;                            \
    char *name = UTEST_PTR_CAST(char *, malloc(name_size));                    \
    utest_state.tests =                                                        \
        UTEST_PTR_CAST(struct utest_test_state_s *,                            \
                       realloc(UTEST_PTR_CAST(void *, utest_state.tests),      \
                               sizeof(struct utest_test_state_s) *             \
                                   utest_state.tests_length));                 \
    utest_state.tests[index].func = &utest_f_##FIXTURE##_##NAME;               \
    utest_state.tests[index].name = name;                                      \
    UTEST_SNPRINTF(name, name_size, "%s", name_part);                          \
  }                                                                            \
  void utest_run_##FIXTURE##_##NAME(int *utest_result,                         \
                                    struct FIXTURE *utest_fixture)

#define UTEST_I_SETUP(FIXTURE)                                                 \
  static void utest_i_setup_##FIXTURE(                                         \
      int *utest_result, struct FIXTURE *utest_fixture, size_t utest_index)

#define UTEST_I_TEARDOWN(FIXTURE)                                              \
  static void utest_i_teardown_##FIXTURE(                                      \
      int *utest_result, struct FIXTURE *utest_fixture, size_t utest_index)

#define UTEST_I(FIXTURE, NAME, INDEX)                                          \
  UTEST_EXTERN struct utest_state_s utest_state;                               \
  static void utest_run_##FIXTURE##_##NAME##_##INDEX(int *, struct FIXTURE *); \
  static void utest_i_##FIXTURE##_##NAME##_##INDEX(int *utest_result,          \
                                                   size_t index) {             \
    struct FIXTURE fixture;                                                    \
    memset(&fixture, 0, sizeof(fixture));                                      \
    utest_i_setup_##FIXTURE(utest_result, &fixture, index);                    \
    if (0 != *utest_result) {                                                  \
      return;                                                                  \
    }                                                                          \
    utest_run_##FIXTURE##_##NAME##_##INDEX(utest_result, &fixture);            \
    utest_i_teardown_##FIXTURE(utest_result, &fixture, index);                 \
  }                                                                            \
  UTEST_INITIALIZER(utest_register_##FIXTURE##_##NAME##_##INDEX) {             \
    size_t i;                                                                  \
    utest_uint64_t iUp;                                                        \
    for (i = 0; i < (INDEX); i++) {                                            \
      const size_t index = utest_state.tests_length++;                         \
      const char *name_part = #FIXTURE "." #NAME;                              \
      const size_t name_size = strlen(name_part) + 32;                         \
      char *name = UTEST_PTR_CAST(char *, malloc(name_size));                  \
      utest_state.tests =                                                      \
          UTEST_PTR_CAST(struct utest_test_state_s *,                          \
                         realloc(UTEST_PTR_CAST(void *, utest_state.tests),    \
                                 sizeof(struct utest_test_state_s) *           \
                                     utest_state.tests_length));               \
      utest_state.tests[index].func = &utest_i_##FIXTURE##_##NAME##_##INDEX;   \
      utest_state.tests[index].index = i;                                      \
      utest_state.tests[index].name = name;                                    \
      iUp = UTEST_CAST(utest_uint64_t, i);                                     \
      UTEST_SNPRINTF(name, name_size, "%s/%" UTEST_PRIu64, name_part, iUp);    \
    }                                                                          \
  }                                                                            \
  void utest_run_##FIXTURE##_##NAME##_##INDEX(int *utest_result,               \
                                              struct FIXTURE *utest_fixture)

UTEST_WEAK
int utest_should_filter_test(const char *filter, const char *testcase);
UTEST_WEAK int utest_should_filter_test(const char *filter,
                                        const char *testcase) {
  if (filter) {
    const char *filter_cur = filter;
    const char *testcase_cur = testcase;
    const char *filter_wildcard = UTEST_NULL;

    while (('\0' != *filter_cur) && ('\0' != *testcase_cur)) {
      if ('*' == *filter_cur) {
        /* store the position of the wildcard */
        filter_wildcard = filter_cur;

        /* skip the wildcard character */
        filter_cur++;

        while (('\0' != *filter_cur) && ('\0' != *testcase_cur)) {
          if ('*' == *filter_cur) {
            /*
               we found another wildcard (filter is something like *foo*) so we
               exit the current loop, and return to the parent loop to handle
               the wildcard case
            */
            break;
          } else if (*filter_cur != *testcase_cur) {
            /* otherwise our filter didn't match, so reset it */
            filter_cur = filter_wildcard;
          }

          /* move testcase along */
          testcase_cur++;

          /* move filter along */
          filter_cur++;
        }

        if (('\0' == *filter_cur) && ('\0' == *testcase_cur)) {
          return 0;
        }

        /* if the testcase has been exhausted, we don't have a match! */
        if ('\0' == *testcase_cur) {
          return 1;
        }
      } else {
        if (*testcase_cur != *filter_cur) {
          /* test case doesn't match filter */
          return 1;
        } else {
          /* move our filter and testcase forward */
          testcase_cur++;
          filter_cur++;
        }
      }
    }

    if (('\0' != *filter_cur) ||
        (('\0' != *testcase_cur) &&
         ((filter == filter_cur) || ('*' != filter_cur[-1])))) {
      /* we have a mismatch! */
      return 1;
    }
  }

  return 0;
}

static UTEST_INLINE int utest_strncmp(const char *a, const char *b, size_t n) {
  /* strncmp breaks on Wall / Werror on gcc/clang, so we avoid using it */
  unsigned i;

  for (i = 0; i < n; i++) {
    if (a[i] < b[i]) {
      return -1;
    } else if (a[i] > b[i]) {
      return 1;
    }
  }

  return 0;
}

static UTEST_INLINE FILE *utest_fopen(const char *filename, const char *mode) {
#ifdef _MSC_VER
  FILE *file;
  if (0 == fopen_s(&file, filename, mode)) {
    return file;
  } else {
    return 0;
  }
#else
  return fopen(filename, mode);
#endif
}

UTEST_WEAK int utest_main(int argc, const char *const argv[]);
UTEST_WEAK int utest_main(int argc, const char *const argv[]) {
  utest_uint64_t failed = 0;
  size_t index = 0;
  size_t *failed_testcases = UTEST_NULL;
  size_t failed_testcases_length = 0;
  const char *filter = UTEST_NULL;
  utest_uint64_t ran_tests = 0;

  enum colours { RESET, GREEN, RED };

  const int use_colours = UTEST_COLOUR_OUTPUT();
  const char *colours[] = {"\033[0m", "\033[32m", "\033[31m"};
  if (!use_colours) {
    for (index = 0; index < sizeof colours / sizeof colours[0]; index++) {
      colours[index] = "";
    }
  }
  /* loop through all arguments looking for our options */
  for (index = 1; index < UTEST_CAST(size_t, argc); index++) {
    /* Informational switches */
    const char help_str[] = "--help";
    const char list_str[] = "--list-tests";
    /* Test config switches */
    const char filter_str[] = "--filter=";
    const char output_str[] = "--output=";

    if (0 == utest_strncmp(argv[index], help_str, strlen(help_str))) {
      printf("utest.h - the single file unit testing solution for C/C++!\n"
             "Command line Options:\n"
             "  --help            Show this message and exit.\n"
             "  --filter=<filter> Filter the test cases to run (EG. MyTest*.a "
             "would run MyTestCase.a but not MyTestCase.b).\n"
             "  --list-tests      List testnames, one per line. Output names "
             "can be passed to --filter.\n"
             "  --output=<output> Output an xunit XML file to the file "
             "specified in <output>.\n");
      goto cleanup;
    } else if (0 ==
               utest_strncmp(argv[index], filter_str, strlen(filter_str))) {
      /* user wants to filter what test cases run! */
      filter = argv[index] + strlen(filter_str);
    } else if (0 ==
               utest_strncmp(argv[index], output_str, strlen(output_str))) {
      utest_state.output = utest_fopen(argv[index] + strlen(output_str), "w+");
    } else if (0 == utest_strncmp(argv[index], list_str, strlen(list_str))) {
      for (index = 0; index < utest_state.tests_length; index++) {
        UTEST_PRINTF("%s\n", utest_state.tests[index].name);
      }
      /* when printing the test list, don't actually run the tests */
      return 0;
    }
  }

  for (index = 0; index < utest_state.tests_length; index++) {
    if (utest_should_filter_test(filter, utest_state.tests[index].name)) {
      continue;
    }

    ran_tests++;
  }

  printf("%s[==========]%s Running %" UTEST_PRIu64 " test cases.\n",
         colours[GREEN], colours[RESET], UTEST_CAST(utest_uint64_t, ran_tests));

  if (utest_state.output) {
    fprintf(utest_state.output, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
    fprintf(utest_state.output,
            "<testsuites tests=\"%" UTEST_PRIu64 "\" name=\"All\">\n",
            UTEST_CAST(utest_uint64_t, ran_tests));
    fprintf(utest_state.output,
            "<testsuite name=\"Tests\" tests=\"%" UTEST_PRIu64 "\">\n",
            UTEST_CAST(utest_uint64_t, ran_tests));
  }

  for (index = 0; index < utest_state.tests_length; index++) {
    int result = 0;
    utest_int64_t ns = 0;

    if (utest_should_filter_test(filter, utest_state.tests[index].name)) {
      continue;
    }

    printf("%s[ RUN      ]%s %s\n", colours[GREEN], colours[RESET],
           utest_state.tests[index].name);

    if (utest_state.output) {
      fprintf(utest_state.output, "<testcase name=\"%s\">",
              utest_state.tests[index].name);
    }

    ns = utest_ns();
    utest_state.tests[index].func(&result, utest_state.tests[index].index);
    ns = utest_ns() - ns;

    if (utest_state.output) {
      fprintf(utest_state.output, "</testcase>\n");
    }

    if (0 != result) {
      const size_t failed_testcase_index = failed_testcases_length++;
      failed_testcases = UTEST_PTR_CAST(
          size_t *, realloc(UTEST_PTR_CAST(void *, failed_testcases),
                            sizeof(size_t) * failed_testcases_length));
      failed_testcases[failed_testcase_index] = index;
      failed++;
      printf("%s[  FAILED  ]%s %s (%" UTEST_PRId64 "ns)\n", colours[RED],
             colours[RESET], utest_state.tests[index].name, ns);
    } else {
      printf("%s[       OK ]%s %s (%" UTEST_PRId64 "ns)\n", colours[GREEN],
             colours[RESET], utest_state.tests[index].name, ns);
    }
  }

  printf("%s[==========]%s %" UTEST_PRIu64 " test cases ran.\n", colours[GREEN],
         colours[RESET], ran_tests);
  printf("%s[  PASSED  ]%s %" UTEST_PRIu64 " tests.\n", colours[GREEN],
         colours[RESET], ran_tests - failed);

  if (0 != failed) {
    printf("%s[  FAILED  ]%s %" UTEST_PRIu64 " tests, listed below:\n",
           colours[RED], colours[RESET], failed);
    for (index = 0; index < failed_testcases_length; index++) {
      printf("%s[  FAILED  ]%s %s\n", colours[RED], colours[RESET],
             utest_state.tests[failed_testcases[index]].name);
    }
  }

  if (utest_state.output) {
    fprintf(utest_state.output, "</testsuite>\n</testsuites>\n");
  }

cleanup:
  for (index = 0; index < utest_state.tests_length; index++) {
    free(UTEST_PTR_CAST(void *, utest_state.tests[index].name));
  }

  free(UTEST_PTR_CAST(void *, failed_testcases));
  free(UTEST_PTR_CAST(void *, utest_state.tests));

  if (utest_state.output) {
    fclose(utest_state.output);
  }

  return UTEST_CAST(int, failed);
}

/*
   we need, in exactly one source file, define the global struct that will hold
   the data we need to run utest. This macro allows the user to declare the
   data without having to use the UTEST_MAIN macro, thus allowing them to write
   their own main() function.
*/
#define UTEST_STATE() struct utest_state_s utest_state = {0, 0, 0}

/*
   define a main() function to call into utest.h and start executing tests! A
   user can optionally not use this macro, and instead define their own main()
   function and manually call utest_main. The user must, in exactly one source
   file, use the UTEST_STATE macro to declare a global struct variable that
   utest requires.
*/
#define UTEST_MAIN()                                                           \
  UTEST_STATE();                                                               \
  int main(int argc, const char *const argv[]) {                               \
    return utest_main(argc, argv);                                             \
  }

#endif /* SHEREDOM_UTEST_H_INCLUDED */ 

```