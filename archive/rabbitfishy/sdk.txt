Project Path: arc_rabbitfishy_sdk_e4ulp77o

Source Tree:

```txt
arc_rabbitfishy_sdk_e4ulp77o
├── LICENSE
├── README.md
├── sdk
│   ├── dependencies
│   │   ├── console
│   │   │   ├── console.cpp
│   │   │   └── console.h
│   │   ├── dependency.h
│   │   ├── maths
│   │   │   ├── maths.cpp
│   │   │   └── maths.h
│   │   ├── memory
│   │   │   ├── convars.h
│   │   │   ├── memory.cpp
│   │   │   ├── modules.h
│   │   │   ├── scanner.h
│   │   │   ├── signatures.h
│   │   │   └── virtual.h
│   │   ├── other
│   │   │   ├── color.h
│   │   │   ├── dump.h
│   │   │   ├── global.h
│   │   │   ├── hash.h
│   │   │   ├── other.cpp
│   │   │   └── translate.h
│   │   └── render
│   │       ├── font.h
│   │       ├── render.cpp
│   │       └── render.h
│   ├── entry.cpp
│   ├── external
│   │   └── minhook
│   │       ├── buffer.c
│   │       ├── buffer.h
│   │       ├── hde
│   │       │   ├── hde32.c
│   │       │   ├── hde32.h
│   │       │   ├── hde64.c
│   │       │   ├── hde64.h
│   │       │   ├── pstdint.h
│   │       │   ├── table32.h
│   │       │   └── table64.h
│   │       ├── hook.c
│   │       ├── include
│   │       │   └── minhook.h
│   │       ├── trampoline.c
│   │       └── trampoline.h
│   ├── hooks
│   │   ├── hooked
│   │   │   ├── hk_client.cpp
│   │   │   ├── hk_other.cpp
│   │   │   └── hk_surface.cpp
│   │   ├── hooks.cpp
│   │   └── hooks.h
│   ├── include.h
│   ├── sdk.vcxproj
│   ├── sdk.vcxproj.filters
│   └── valve
│       ├── classes
│       │   ├── clients.h
│       │   ├── other.h
│       │   └── user_cmd.h
│       ├── entity
│       │   ├── entity.cpp
│       │   ├── entity.h
│       │   └── other.h
│       ├── interface
│       │   ├── classes
│       │   │   ├── base_client.h
│       │   │   ├── base_interface.h
│       │   │   ├── client_mode.h
│       │   │   ├── debug_overlay.h
│       │   │   ├── engine_client.h
│       │   │   ├── engine_convar.h
│       │   │   ├── engine_sound.h
│       │   │   ├── engine_trace.h
│       │   │   ├── engine_vgui.h
│       │   │   ├── entity_list.h
│       │   │   ├── event_manager.h
│       │   │   ├── game_console.h
│       │   │   ├── game_types.h
│       │   │   ├── global_vars.h
│       │   │   ├── input.h
│       │   │   ├── key_value_system.h
│       │   │   ├── localize.h
│       │   │   ├── material_system.h
│       │   │   ├── mdl_cache.h
│       │   │   ├── model_info.h
│       │   │   ├── network.h
│       │   │   ├── panel.h
│       │   │   ├── physics_surface_props.h
│       │   │   ├── prediction.h
│       │   │   ├── studio_render.h
│       │   │   ├── surface.h
│       │   │   └── weapon_system.h
│       │   ├── interface.cpp
│       │   └── interface.h
│       ├── maths
│       │   ├── matrix.h
│       │   ├── other.h
│       │   ├── q_angle.h
│       │   ├── utl_vector.h
│       │   └── vector.h
│       ├── netvar
│       │   ├── data_map.h
│       │   ├── data_table.h
│       │   ├── netvar.cpp
│       │   └── netvar.h
│       ├── other
│       │   ├── animations.cpp
│       │   ├── animations.h
│       │   ├── bitbuf.h
│       │   ├── convar.cpp
│       │   ├── convar.h
│       │   ├── key_value.cpp
│       │   ├── key_value.h
│       │   ├── net_channel.h
│       │   ├── studio.h
│       │   └── weapon_info.h
│       └── valve.h
└── sdk.sln

```

`LICENSE`:

```
MIT License

Copyright (c) 2023 rabbitfishy

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# sdk

This is an sdk base that I've been working on.
Originally is for personal use and to practice with. 
However, my hard drive keep corrupting the sdk.
So I decided to upload here and download it whenever without the worry of being courrupted.
You can use it if you want, primarily this project is for personal use and a safe place to keep it.

```

`sdk.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.3.32929.385
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "sdk", "sdk\sdk.vcxproj", "{D9F5694A-6376-4E96-A26F-0F37ECFCAA74}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x86 = Debug|x86
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{D9F5694A-6376-4E96-A26F-0F37ECFCAA74}.Debug|x86.ActiveCfg = Debug|Win32
		{D9F5694A-6376-4E96-A26F-0F37ECFCAA74}.Debug|x86.Build.0 = Debug|Win32
		{D9F5694A-6376-4E96-A26F-0F37ECFCAA74}.Release|x86.ActiveCfg = Release|Win32
		{D9F5694A-6376-4E96-A26F-0F37ECFCAA74}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {8D164902-6D54-45CE-BCEB-5FD05AA9B311}
	EndGlobalSection
EndGlobal

```

`sdk/dependencies/console/console.cpp`:

```cpp
#include "console.h"

windows_console* console = new windows_console;

void windows_console::setup(const char* title)
{
	AllocConsole();
	freopen_s((FILE**)stdin, "conin$", "r", stdin);
	freopen_s((FILE**)stdout, "conout$", "w", stdout);
	SetConsoleTitle(title);
}

void windows_console::restore()
{
	fclose(stdin);
	fclose(stdout);
	FreeConsole();
}

void windows_console::log(log_type type, const char* logs, ...)
{
	char buffer[2048];
	if (std::strlen(logs) >= sizeof(buffer))
		return;

	va_list arguments;
	va_start(arguments, logs);
	vsprintf_s(buffer, sizeof(buffer), logs, arguments);
	va_end(arguments);

	std::array< std::string, log_type::log_count > output_type = { "[sdk]", "[+]", "[-]", "[!]" };
	std::cout << output_type[type].c_str() << " ";
	std::cout << buffer << std::endl;
}
```

`sdk/dependencies/console/console.h`:

```h
#pragma once
#include <Windows.h>
#include <iostream>
#include <fstream>
#include <array>

enum log_type : int
{
	log_normal,
	log_success,
	log_fail,
	log_error,
	log_count
};

class windows_console
{
public:
	void setup(const char* title);
	void restore();
	void log(log_type type, const char* logs, ...);
};

extern windows_console* console;
```

`sdk/dependencies/dependency.h`:

```h
#pragma once
#include "../include.h"
#include "console/console.h"

#pragma region memory

#include "memory/convars.h"
#include "memory/modules.h"
#include "memory/scanner.h"
#include "memory/signatures.h"
#include "memory/virtual.h"

#pragma endregion

#pragma region other

#include "other/color.h"
#include "other/dump.h"
#include "other/global.h"
#include "other/hash.h"
#include "other/translate.h"

#pragma endregion

#include "render/render.h"
#include "maths/maths.h"

```

`sdk/dependencies/maths/maths.cpp`:

```cpp
#include "maths.h"
#include "../dependency.h"

game_maths* maths = new game_maths;

bool game_maths::world_to_screen(const vector_3d& origin, vector_2d& screen)
{
    const view_matrix& world_to_screen = interfaces->engine_client->world_to_screen_matrix();

    const float width = world_to_screen[3][0] * origin.x + world_to_screen[3][1] * origin.y + world_to_screen[3][2] * origin.z + world_to_screen[3][3];

    if (width < 0.001f)
        return false;

    const float inverse = 1.f / width;

    screen = { (world_to_screen[0][0] * origin.x + world_to_screen[0][1] * origin.y + world_to_screen[0][2] * origin.z + world_to_screen[0][3]) * inverse,
               (world_to_screen[1][0] * origin.x + world_to_screen[1][1] * origin.y + world_to_screen[1][2] * origin.z + world_to_screen[1][3]) * inverse };

    screen = { render->screen.w * 0.5f + screen.x * render->screen.w * 0.5f, render->screen.h * 0.5f - screen.y * render->screen.h * 0.5f };

    return true;
}

vector_3d game_maths::vector_transform(vector_3d& transform, matrix_3x4& matrix)
{
    return vector_3d(transform.dot(matrix[0]) + matrix[0][3],
        transform.dot(matrix[1]) + matrix[1][3],
        transform.dot(matrix[2]) + matrix[2][3]);
}

matrix_3x4 game_maths::angle_matrix(const q_angle& angle)
{
    float cos_x = std::cos(deg_to_rad(angle.x)), sin_x = std::sin(deg_to_rad(angle.x));
    float cos_y = std::cos(deg_to_rad(angle.y)), sin_y = std::sin(deg_to_rad(angle.y));
    float cos_z = std::cos(deg_to_rad(angle.z)), sin_z = std::sin(deg_to_rad(angle.z));

    return {
        cos_x * cos_y, sin_x * sin_z * cos_y - cos_z * sin_y, (sin_x * cos_z * cos_y + sin_z * sin_y), 0.f,
        cos_x * sin_y, sin_x * sin_z * sin_y + cos_z * cos_y, (sin_x * cos_z * sin_y - sin_z * cos_y), 0.f,
        -sin_x, sin_z * cos_x, cos_z * cos_x, 0.f
    };
}

void game_maths::normalize_angle(float& angle)
{
    // bad number.
    if (!std::isfinite(angle))
    {
        angle = 0.f;
        return;
    }

    // no need to normalize this angle.
    if (angle >= -180.f && angle <= 180.f)
        return;

    // get amount of rotations needed.
    float rotate = std::round(std::abs(angle / 360.f));

    // normalize.
    angle = (angle < 0.f) ? angle + (360.f * rotate) : angle - (360.f * rotate);
}

void game_maths::angle_vectors(const q_angle& angles, vector_3d* forward, vector_3d* right, vector_3d* up)
{
    float cos_x = std::cos(deg_to_rad(angles.x)), sin_x = std::sin(deg_to_rad(angles.x));
    float cos_y = std::cos(deg_to_rad(angles.y)), sin_y = std::sin(deg_to_rad(angles.y));
    float cos_z = std::cos(deg_to_rad(angles.z)), sin_z = std::sin(deg_to_rad(angles.z));

    if (forward)
    {
        forward->x = cos_x * cos_y;
        forward->y = cos_x * sin_y;
        forward->z = -sin_x;
    }

    if (right)
    {
        right->x = -1.f * sin_z * sin_x * cos_y + -1.f * cos_z * -sin_y;
        right->y = -1.f * sin_z * sin_x * sin_y + -1.f * cos_z * cos_y;
        right->z = -1.f * sin_z * cos_x;
    }

    if (up)
    {
        up->x = cos_z * sin_x * cos_y + -sin_z * -sin_y;
        up->y = cos_z * sin_x * sin_y + -sin_z * cos_y;
        up->z = cos_z * cos_x;
    }
}

// this the 'corrected' calculation for vector to angles conversion.
// credit: https://www.unknowncheats.me/forum/1147000-post18.html
q_angle game_maths::vector_angles(const vector_3d& relative)
{
    q_angle angle;
    float   pitch, yaw;

    if (relative.x == 0.f && relative.y == 0.f)
    {
        pitch = (relative.z > 0.f) ? 270.f : 90.f;
        yaw = 0.f;
    }
    else
    {
        // the hypotenuse is the magnitude of a vector.
        float magnitude = relative.length();

        // now remember pitch is the Y of our vector, and yaw is the X of our vector.
        // we have an X and Y, so we can use arctan, or inverse tangent, to find the yaw.
        yaw = rad_to_deg(std::atan2(relative.y, relative.x));
        this->normalize_angle(yaw);

        // we have Z and the hypotenuse, so we can use arcsin, or inverse sine, to find the pitch.
        pitch = rad_to_deg(std::asin(relative.z / magnitude)) * -1.f;
        this->normalize_angle(pitch);
    }

    // now you can just add this resulting angle to the current viewangles.
    angle.x = pitch, angle.y = yaw;
    return angle;
}

// this calculation is wrong but still helpful resource.
// credit: https://www.unknowncheats.me/forum/1146758-post1.html
q_angle game_maths::calculate_angle(const vector_3d& start, const vector_3d& end)
{
    // subtract our enemies position from our origin position to get the relative angle.
    vector_3d relative = end - start;
    return this->vector_angles(relative);
}

```

`sdk/dependencies/maths/maths.h`:

```h
#pragma once
#include "../../valve/maths/q_angle.h"
#include "../../valve/maths/vector.h"
#include "../../valve/maths/matrix.h"
#include "../../valve/maths/other.h"

class game_maths
{
public:
	bool world_to_screen(const vector_3d& origin, vector_2d& screen);
	vector_3d vector_transform(vector_3d& transform, matrix_3x4& matrix);
	matrix_3x4 angle_matrix(const q_angle& angle);

	void normalize_angle(float& angle);
	void angle_vectors(const q_angle& angles, vector_3d* forward, vector_3d* right = nullptr, vector_3d* up = nullptr);
	q_angle vector_angles(const vector_3d& relative);
	q_angle calculate_angle(const vector_3d& start, const vector_3d& end);
};

extern game_maths* maths;


```

`sdk/dependencies/memory/convars.h`:

```h
#pragma once

#define CVAR( name, variable ) struct name { static game_convar* convar( ) { return interfaces->convar->find( variable ); } }

/*
* put all your convars here cuz its easier to find and maintain.
* example of use:
* struct [what ever name u want] <-- this here is to keep it maintained and less messy also easier to find.
* {
*	CVAR([convar name], "convar variable here.");
* };
*/

namespace convars
{
	struct other
	{
		CVAR(inferno_flame_lifetime, "inferno_flame_lifetime");
	};
}

```

`sdk/dependencies/memory/memory.cpp`:

```cpp
#include "../dependency.h"

game_modules* modules = new game_modules;

void game_modules::setup()
{
	client				= ("client.dll");
	engine				= ("engine.dll");
	vgui2				= ("vgui2.dll");
	vgui_surface		= ("vguimatsurface.dll");
	material_system		= ("materialsystem.dll");
	directx9			= ("shaderapidx9.dll");
	data_cache			= ("datacache.dll");
	matchmaking			= ("matchmaking.dll");
	physics				= ("vphysics.dll");
	studio_render		= ("studiorender.dll");
	tier0				= ("tier0.dll");
	localize			= ("localize.dll");
	stdlib				= ("vstdlib.dll");
	input_system		= ("inputsystem.dll");
	server				= ("server.dll");
	server_browser		= ("serverbrowser.dll");

	console->log(log_type::log_success, "modules intsalled!");
}

game_scanner* scanner = new game_scanner;

MODULEENTRY32 game_scanner::capture_module(const char* modules)
{
	HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, GetCurrentProcessId());

	if (snapshot != INVALID_HANDLE_VALUE) {
		MODULEENTRY32 entry;
		entry.dwSize = sizeof(entry);
		if (Module32First(snapshot, &entry)) {
			do {
				if (!std::strcmp(entry.szModule, modules)) {
					CloseHandle(snapshot);
					return entry;
				}
			} while (Module32Next(snapshot, &entry));
		}
	}

	MODULEENTRY32 module = { DWORD(-1) };
	return module;
}

DWORD game_scanner::scan(const char* modules, const char* signature)
{
	MODULEENTRY32 modules_entry = this->capture_module(modules);

	if (!modules_entry.hModule) 
		return FALSE;

	// get our start and end of memory.
	DWORD start = (DWORD)modules_entry.modBaseAddr;
	DWORD end	= start + modules_entry.modBaseSize;

	// keep count of our pattern matches.
	int first_match = 0;

	// store our pattern for comparing later.
	const char* pattern = signature;

	for (DWORD i = start; i < end; i++)
	{
		// our pattern don't match in game memory section then return.
		if (!*pattern)
			return first_match;

		// our pattern found a wild card or the pattern itself matched.
		if (*(BYTE*)pattern == '\?' || *(BYTE*)i == data_byte(pattern))
		{
			// we haven't found our first match yet then loop through the pattern array.
			if (!first_match)
				first_match = i;

			// isn't our second pattern index then return the first match.
			if (!pattern[2])
				return first_match;

			// our pattern have 2 wild cards then extend 3 indexes ahead.
			// otherwise we have a wild card then extend it by 2 indexes ahead.
			if (*(WORD*)pattern == '\?\?' || *(BYTE*)pattern != '\?')
				pattern += 3;
			else
				pattern += 2;
		}
		else
		{
			// all those conditions haven't been met then start all over again.
			pattern		= signature;
			first_match = 0;
		}
	}

	return FALSE;
}

game_virtuals* virtuals = new game_virtuals;

```

`sdk/dependencies/memory/modules.h`:

```h
#pragma once

class game_modules
{
public:
	void setup();

	const char* client				= nullptr;
	const char* engine				= nullptr;
	const char* vgui2				= nullptr;
	const char* vgui_surface		= nullptr;
	const char* material_system		= nullptr;
	const char* directx9			= nullptr;
	const char* data_cache			= nullptr;
	const char* matchmaking			= nullptr;
	const char* physics				= nullptr;
	const char* studio_render		= nullptr;
	const char* tier0				= nullptr;
	const char* localize			= nullptr;
	const char* stdlib				= nullptr;
	const char* input_system		= nullptr;
	const char* server				= nullptr;
	const char* server_browser		= nullptr;
};

extern game_modules* modules;
```

`sdk/dependencies/memory/scanner.h`:

```h
#pragma once
#include <TlHelp32.h>

#define in_range( x, a, b ) ( x >= a && x <= b )
#define data_bits( x ) ( in_range( ( x & ( ~0x20 ) ), 'A', 'F' ) ? ( ( x & ( ~0x20 ) ) - 'A' + 0xA ): ( in_range( x, '0', '9' ) ? x - '0': 0 ) )
#define data_byte( x ) ( data_bits( x[0] ) << 4 | data_bits( x[1] ) )

class game_scanner
{
public:
	MODULEENTRY32 capture_module(const char* modules);
	DWORD scan(const char* modules, const char* signature);
};

extern game_scanner* scanner;
```

`sdk/dependencies/memory/signatures.h`:

```h
#pragma once

#define PATTERN( name, pattern ) struct name { static const char* signature( ) { return ( const char* )( pattern ); } }

/*
* put all your pattern sigs here cuz its easier to find and maintain.
* example of use:
* struct [what ever name u want] <-- this here is to keep it maintained and less messy also easier to find and update.
* {
*	PATTERN([sig name], "sig pattern here.");
* };
*/

namespace signatures
{
	struct interfaces
	{
		PATTERN(client_state, "A1 ? ? ? ? 8B 88 ? ? ? ? 85 C9 75 07");
		PATTERN(weapon_system, "8B 35 ? ? ? ? FF 10 0F B7 C0");
		PATTERN(input, "B9 ? ? ? ? F3 0F 11 04 24 FF 50 10");
	};

	struct hooks
	{
		PATTERN(alloc_key_value_engine, "E8 ? ? ? ? 83 C4 08 84 C0 75 10 FF 75 0C");
		PATTERN(alloc_key_value_client, "E8 ? ? ? ? 83 C4 08 84 C0 75 10");
	};

	struct entity
	{
		PATTERN(set_abs_origin, "55 8B EC 83 E4 F8 51 53 56 57 8B F1 E8");
		PATTERN(set_abs_angle, "55 8B EC 83 E4 F8 83 EC 64 53 56 57 8B F1 E8");
		PATTERN(animation_overlays, "8B 89 ? ? ? ? 8D 0C D1");
		PATTERN(model_bone_counter, "3B 05 ? ? ? ? 0F 84 ? ? ? ? 8B 47");
		PATTERN(physics_run_think, "55 8B EC 83 EC 10 53 56 57 8B F9 8B 87");
		PATTERN(get_last_command, "8D 8E ? ? ? ? 89 5C 24 3C");
		PATTERN(post_think_vphysics, "55 8B EC 83 E4 F8 81 EC ? ? ? ? 53 8B D9 56 57 83 BB");
		PATTERN(simulate_player_simulated_entities, "56 8B F1 57 8B BE ? ? ? ? 83 EF 01 78 74");
	};

	struct other
	{
		PATTERN(key_value_constructor, "55 8B EC 56 8B F1 33 C0 8B 4D 0C 81");
		PATTERN(key_value_destructor, "56 8B F1 E8 ? ? ? ? 8B 4E 14");
		PATTERN(from_string, "55 8B EC 83 E4 F8 81 EC 0C 05");
		PATTERN(load_from_buffer, "55 8B EC 83 E4 F8 83 EC 34 53 8B 5D 0C 89");
		PATTERN(load_from_file, "55 8B EC 83 E4 F8 83 EC 14 53 56 8B 75 08 57 FF");
		PATTERN(find_key, "55 8B EC 83 EC 1C 53 8B D9 85 DB");
		PATTERN(get_string, "55 8B EC 83 E4 C0 81 EC ? ? ? ? 53 8B 5D 08");
		PATTERN(set_string, "55 8B EC A1 ? ? ? ? 53 56 57 8B F9 8B 08 8B 01");
		PATTERN(animation_state_constructor, "55 8B EC 56 8B F1 B9 ? ? ? ? C7 46");
		PATTERN(animation_state_update, "55 8B EC 83 E4 F8 83 EC 18 56 57 8B F9 F3 0F 11 54 24");
		PATTERN(animation_state_reset, "56 6A 01 68 ? ? ? ? 8B F1");
	};
}

```

`sdk/dependencies/memory/virtual.h`:

```h
#pragma once
#include <Windows.h>
#include <system_error>
#include "scanner.h"

class game_virtuals
{
public:
	// virtual function pointer of specified class at given index.
	template <typename t>
	constexpr t get(void* thisptr, std::size_t index)
	{
		return (*static_cast<t**>(thisptr))[index];
	}

	// call virtual function of specified class at given index.
	// @note: references should be wrapped with std::ref call!
	template <typename t, typename ... param>
	constexpr t call(void* thisptr, std::size_t index, param... argument)
	{
		using virtual_detail = t(__thiscall*)(void*, decltype(argument)...);
		return (*static_cast<virtual_detail**>(thisptr))[index](thisptr, argument...);
	}
};

extern game_virtuals* virtuals;

// virtual protect raii wrapper
// credit: https://github.com/rollraw/qo0-base/blob/92a3b3aefa220da941c3feee387702c772d1af82/base/utilities/memory.h#L53
class game_protect
{
public:
	game_protect(void* base_address, const std::size_t address_length, const DWORD flags) : base(base_address), length(address_length)
	{
		if (!VirtualProtect(base_address, address_length, flags, &this->old_flags))
			throw std::system_error(GetLastError(), std::system_category(), "[!] failed to protect region!");
	}

	~game_protect()
	{
		VirtualProtect(this->base, this->length, this->old_flags, &this->old_flags);
	}

private:
	void*			base;
	std::size_t		length;
	DWORD			old_flags;
};

#define PROTECT( address, length, flags ) game_protect( address, length, flags )

// thanks danielkrupinski, Bartis1313 & opaiidev! <3
// credit: https://github.com/opaiidev/airflow-legacy/blob/main/Airflow/base/tools/address.h
// ref: https://github.com/danielkrupinski/Osiris/blob/01e9e735056c4a8938a74f48bdf56f09d50de4fd/Source/SafeAddress.h#L6
// ref: https://github.com/Bartis1313/csgo/blob/0f7891bb72f11725dda584bc3c62a53d3bce0920/hack/gamememory/address.hpp#L21
enum dereference : std::size_t
{
	once = 1,
	twice,
	three
};

class game_address
{
public:
	explicit game_address() : base{ } { }
	~game_address() { }

	// pass by offset and pointer.
	explicit game_address(std::uintptr_t address) : base{ address } { }
	explicit game_address(const void* address) : base{ reinterpret_cast<std::uintptr_t>(address) } { }

	// arithmetic operators for native types.
	operator std::uintptr_t()	{ return this->base; }
	operator void* ()			{ return reinterpret_cast<void*>(this->base); }
	operator const void* ()		{ return reinterpret_cast<const void*>(this->base); }

	// cast pointer.
	template<typename c = game_address>
	c cast() const { return this->base ? (c)this->base : c{ }; }

	// is-equals-operator.
	bool operator==(game_address address) const { return this->cast<std::uintptr_t>() == address.cast<std::uintptr_t>(); }
	bool operator!=(game_address address) const { return this->cast<std::uintptr_t>() != address.cast<std::uintptr_t>(); }

	// add offset.
	template<typename a = game_address>
	a add(std::size_t offset) const { return this->base ? (a)(this->base + offset) : a{ }; }

	template<typename a = game_address>
	a add(std::ptrdiff_t offset) const { return this->base ? (a)(this->base + offset) : a{ }; }

	// subtract offset.
	template<typename s = game_address>
	s sub(std::size_t offset) const { return this->base ? (s)(this->base - offset) : s{ }; }

	template<typename s = game_address>
	s sub(std::ptrdiff_t offset) const { return this->base ? (s)(this->base - offset) : s{ }; }

	// dereference.
	template<typename d = game_address>
	d reinterpret() const { return this->base ? reinterpret_cast<d>(this->base) : d{ }; }

	// verify adddress and dereference n times.
	template<typename d = game_address>
	d deref(std::size_t n = dereference::once)
	{
		std::uintptr_t result = { };

		if (!this->base)
			return d{ };

		result = this->base;

		for (std::size_t i = n; i > 0; i--)
		{
			// can't dereference, return null.
			if (!this->valid(result))
				return d{ };

			result = *reinterpret_cast<std::uintptr_t*>(result);
		}

		return (d)result;
	}

	// follow relative8 and relative16/32 offsets.
	template<typename r = game_address>
	r rel8(std::size_t offset)
	{
		std::uintptr_t result = { };
		std::uint8_t relative = { };

		if (!this->base)
			return r{ };

		result = this->base + offset;

		// get relative offset.
		relative = *reinterpret_cast<std::uint8_t*>(result);
		if (!relative)
			return r{ };

		// relative to address of next instruction.
		// short jumps can go forward and backward depending on the size of the second byte.
		// if the second byte is below 128, the jmp goes forwards.
		// if the second byte is above 128, the jmp goes backwards ( subtract two's complement of the relative offset from the address of the next instruction ).
		if (relative < 128)
			result = (result + 0x1) + relative;
		else
			result = (result + 0x1) - static_cast<std::uint8_t>(~relative + 0x1);

		return (r)result;
	}

	template<typename r = game_address>
	r rel32(std::size_t offset)
	{
		std::uintptr_t result = { };
		std::uint32_t relative = { };

		if (!this->base)
			return r{ };

		result = this->base + offset;

		// get relative offset.
		relative = *reinterpret_cast<std::uint32_t*>(result);
		if (!relative)
			return r{ };

		// relative to address of next instruction.
		result = (result + 0x4) + relative;

		return (r)result;
	}

private:
	// checks if address is not null and has correct page protection.
	static bool valid(std::uintptr_t address)
	{
		MEMORY_BASIC_INFORMATION info;

		// check for invalid address.
		if (!address)
			return false;

		// check for invalid page protection.
		if (!VirtualQuery((const void*)address, &info, sizeof(info)))
			return false;

		// todo - dex; fix this, its wrong... check for rwe or something too
		if ((info.Protect & PAGE_NOACCESS) || (info.Protect & PAGE_GUARD))
			return false;

		return true;
	}

	std::uintptr_t base;
};

#define ADDRESS( pointer ) game_address( pointer )
#define SEARCH( modules, signatures ) ADDRESS( scanner->scan( modules, signatures ) )

```

`sdk/dependencies/other/color.h`:

```h
#pragma once

class color
{
public:
	color() : r{ 0 }, g{ 0 }, b{ 0 }, a{ 255 } { };
	color(int r, int g, int b, int a = 255) : r{ r }, g{ g }, b{ b }, a{ a } { };

	// add color stuff here


	int r, g, b, a;
};
```

`sdk/dependencies/other/dump.h`:

```h
#pragma once
#include <Windows.h>
#include <tchar.h>
#include <strsafe.h>
#include <iostream>

#include <DbgHelp.h>
#pragma comment(lib, "DbgHelp.lib")

/*
* mini dumps can help you debug with better accuracy,
* as mini dumps tells you exactly which line of code caused
* the crash by the program.
*
* these helped me figure out how to create the dumps.
* credit: https://www.youtube.com/watch?v=W2NnpEZ1Gdk
*/

class windows_dump
{
public:
	int create_dump(EXCEPTION_POINTERS* exception);
};

extern windows_dump* dump;
```

`sdk/dependencies/other/global.h`:

```h
#pragma once

class cs_player;

struct game_global
{
	cs_player* local_player		= nullptr;
	game_user_cmd* cmd			= nullptr;
	bool* send_packet			= nullptr;
};

extern game_global* csgo;
```

`sdk/dependencies/other/hash.h`:

```h
#pragma once
#include <Windows.h>
#include <string>
#include <bit>

/*
* fnv hash implementation.
* credit: http://www.isthe.com/chongo/tech/comp/fnv/
* fnv: https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
*/

typedef std::uint32_t hash32;

namespace game_hash
{
	struct hash_internal
	{
		enum hash_seed : hash32
		{
			prime = 0x1000193,
			basis = 0x811C9DC5
		};
	};

	struct hashing : hash_internal
	{
		// compile time hash.
		static constexpr hash32 compile(const char* value, hash32 seed = hash_seed::basis)
		{
			return (value[0] == '\0') ? seed : compile(&value[1], (seed ^ static_cast<hash32>(value[0])) * hash_seed::prime);
		}

		// runtime hash.
		inline static hash32 runtime(const char* value, hash32 seed = hash_seed::basis)
		{
			for (std::size_t i = 0; i < strlen(value); i++)
			{
				seed ^= value[i];
				seed *= hash_seed::prime;
			}

			return seed;
		}
	};
}

using hash = game_hash::hashing;

#define HASH_COMPILE( value, ... ) hash::compile( value, __VA_ARGS__ )
#define HASH_RUNTIME( value, ... ) hash::runtime( value, __VA_ARGS__ )

/*
* fletcher checksum implementation (not implemented but still useful).
* credit: https://stackoverflow.com/a/71226758	// 32 bit
* credit: https://stackoverflow.com/a/34149107	// 8 bit
* -----------------------------------------------------------------------
* crc checksum implementation.
* credit: https://en.wikipedia.org/wiki/Cyclic_redundancy_check
* credit: https://github.com/rollraw/qo0-csgo/blob/master/base/sdk/hash/crc32.cpp
* credit: https://stackoverflow.com/a/26051190
*/

typedef unsigned long checksum_long;
typedef std::uint32_t checksum32;
typedef std::uint8_t checksum8;

namespace game_checksum
{
	struct checksum_internal
	{
		enum checksum_seed : checksum_long
		{
			polynomial	= 0xEDB88320,
			basis		= 0xFFFFFFFFUL
		};

		static constexpr void generate_table(checksum_long table[])
		{
			checksum_long remainder;
			checksum8 byte = 0;

			do {
				// start with data byte.
				remainder = byte;

				for (checksum_long bit = 8; bit > 0; bit--)
				{
					if (remainder & 1)
						remainder = (remainder >> 1) ^ checksum_seed::polynomial;
					else
						remainder = (remainder >> 1);
				}

				table[(checksum32)byte] = remainder;

			} while (0 != byte++);
		}

		static constexpr checksum_long proccess_crc(const checksum8* buffer, checksum32 buffer_size, checksum_long table[])
		{
			checksum_long crc = checksum_seed::basis;
			checksum32 i;

			for (i = 0; i < buffer_size; i++)
				crc = table[*buffer++ ^ (crc & 0xFF)] ^ (crc >> 8);

			return(~crc);
		}
	};

	struct crc_checksum : checksum_internal
	{
		// compile time crc.
		static constexpr checksum32 proccess(const void* buffer, checksum32 buffer_size)
		{
			// create our canvas table.
			checksum_long table[256];

			// first generate our lookup table and populate it.
			generate_table(table);

			// then proccess the generated lookup table.
			const checksum8* current_byte = static_cast<const checksum8*>(buffer);
			return proccess_crc(current_byte, buffer_size, table);
		}
	};
}

using checksum = game_checksum::crc_checksum;

#define CHECKSUM( crc, size ) checksum::proccess( &crc, size );
```

`sdk/dependencies/other/other.cpp`:

```cpp
#include "../dependency.h"

windows_dump* dump = new windows_dump;

int windows_dump::create_dump(EXCEPTION_POINTERS* exception)
{
	MINIDUMP_EXCEPTION_INFORMATION info;

	WCHAR file_path[MAX_PATH];
	DWORD buffer_size		= MAX_PATH;
	const WCHAR* file_name	= L"sdk dump";
	WCHAR name_path[MAX_PATH];

	// get our file destination path (%temp% file).
	GetTempPathW(MAX_PATH, file_path);

	// name our folder name.
	StringCchPrintfW(name_path, MAX_PATH, L"%s%s", file_path, file_name);

	// create the file(s).
	CreateDirectoryW(name_path, NULL);

	// name our dump file(s).
	StringCchPrintfW(name_path, MAX_PATH, L"%s%s\\%s.dmp", file_path, file_name, L"sdk");

	// get handle to dump file.
	HANDLE dump_file = CreateFileW(name_path, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_WRITE | FILE_SHARE_READ, 0, CREATE_ALWAYS, 0, 0);

	info.ThreadId			= GetCurrentThreadId();
	info.ExceptionPointers	= exception;
	info.ClientPointers		= TRUE;

	// check if we successfully created the dump file(s).
	bool successful = MiniDumpWriteDump(GetCurrentProcess(), GetCurrentProcessId(), dump_file, MiniDumpWithDataSegs, &info, NULL, NULL);

	// returns true if we created the dump otherwise we continue searching for any code that caused the crash.
	return successful ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH;
}

text_translate* translate = new text_translate;
game_global* csgo = new game_global;

```

`sdk/dependencies/other/translate.h`:

```h
#pragma once
#include <Windows.h>
#include <string>
#include <algorithm>
#include <sstream>
#include <bitset>

class text_translate
{
public:
	// used for weapon esp name cleaning.
	std::wstring clean(std::wstring input)
	{
		std::wstring clean = this->add_space(this->replace(input.data()));
		return clean;
	}

	// converting string to uppercase - so we don't have to write it out manually everytime we need to convert to uppercase characters.
	std::string upper(std::string input)
	{
		std::transform(input.begin(), input.end(), input.begin(), ::toupper);
		return input;
	}

	std::wstring upper(std::wstring input)
	{
		std::transform(input.begin(), input.end(), input.begin(), ::toupper);
		return input;
	}

	std::string remove_space(std::string input)
	{
		std::replace(input.begin(), input.end(), ' ', '\0');
		std::string convert = std::string(input.begin(), input.end());
		return convert;
	}

	// convert unicode to ascii (utf8).
	std::string ascii(std::wstring input)
	{
		if (input.empty()) 
			return std::string();

		const auto size = WideCharToMultiByte(CP_UTF8, 0, input.data(), input.size(), 0, 0, 0, 0);
		auto utf8 = std::string(size, 0);
		WideCharToMultiByte(CP_UTF8, 0, input.data(), input.size(), utf8.data(), size, 0, 0);

		return utf8;
	}

	// convert ascii to unicode (utf16).
	std::wstring unicode(std::string input)
	{
		if (input.empty()) 
			return std::wstring();

		const auto size = MultiByteToWideChar(CP_UTF8, 0, input.data(), input.size(), 0, 0);
		auto unicode = std::wstring(size, 0);
		MultiByteToWideChar(CP_UTF8, 0, input.data(), input.size(), unicode.data(), size);

		return unicode;
	}

	/*
	* converting compressed fonts in c array or converting any binary data in a c array,
	* results may vary depends on what is being converted. mainly used to convert fonts.
	* NOTE: this algorithm doesn't account for glyphs thats in the font.
	* credit: https://stackoverflow.com/a/23344876
	*/
	std::string binary(unsigned char* binary_data)
	{
		std::string ascii_data;
		std::stringstream ss(*binary_data);

		while (ss.good()) 
		{
			std::bitset<8> bits;			// get 8 bit data set. (since 8 bit equals to one character)
			ss >> bits;				// divide binary data by bits two times.
			ascii_data += char(bits.to_ulong());	// convert those bits and assign it to the string variable to store converted data.
		}

		return ascii_data;
	}

	// format decimal number to string.
	std::string format(const char* layout, ...)
	{
		char buffer[256];
		if (std::strlen(layout) >= sizeof(buffer))
			return std::string();

		va_list arguments;
		va_start(arguments, layout);
		vsprintf_s(buffer, sizeof(buffer), layout, arguments);
		std::string result = buffer;
		va_end(arguments);

		return result;
	}

private:
	// find space then add space to it - if it makes sense lmao.
	std::wstring add_space(const std::string& input)
	{
		std::wstring wide_string;

		for (std::size_t i = 0; i < input.length(); i++) 
		{
			if (isspace(input[i]) && i != 0)
				wide_string += this->unicode("  ");
			wide_string += input[i];
		}

		return wide_string;
	}

	// replace '-' with space.
	std::string replace(std::wstring input)
	{
		std::replace(input.begin(), input.end(), '-', ' ');
		std::string convert = std::string(input.begin(), input.end());
		return convert;
	}
};

extern text_translate* translate;

```

`sdk/dependencies/render/font.h`:

```h
#pragma once

enum font_alignment : int
{
	align_left		= 1,
	align_right		= 1 << 1,
	align_center		= 1 << 2
};

class render_font
{
public:
	render_font() : handle{ } { }
	render_font(const char* name, int height, int weight, int flags)
	{
		this->handle = interfaces->surface->font_create();
		interfaces->surface->set_font_glyph_set(this->handle, name, height, weight, 0, 0, flags);
	}

	void text(int x, int y, std::string text, color color, font_alignment flags = align_left)
	{
		if (flags)
		{
			static dimension text_size = { };
			interfaces->surface->get_text_size(this->handle, translate->unicode(text).c_str(), text_size.w, text_size.h);
			this->handle_flags(x, text_size.w, text_size.h, flags);
		}

		interfaces->surface->draw_set_text_color(color.r, color.g, color.b, color.a);
		interfaces->surface->draw_set_text_font(this->handle);
		interfaces->surface->draw_set_text_pos(x, y);
		interfaces->surface->draw_print_text(translate->unicode(text).c_str(), text.length());
	}

	void wtext(int x, int y, std::wstring text, color color, font_alignment flags = align_left)
	{
		if (flags)
		{
			static dimension text_size = { };
			interfaces->surface->get_text_size(this->handle, text.c_str(), text_size.w, text_size.h);
			this->handle_flags(x, text_size.w, text_size.h, flags);
		}

		interfaces->surface->draw_set_text_color(color.r, color.g, color.b, color.a);
		interfaces->surface->draw_set_text_font(this->handle);
		interfaces->surface->draw_set_text_pos(x, y);
		interfaces->surface->draw_print_text(text.c_str(), text.length());
	}

	dimension text_size(std::string text)
	{
		static dimension text_area = { };
		interfaces->surface->get_text_size(this->handle, translate->unicode(text).c_str(), text_area.w, text_area.h);
		return text_area;
	}

	dimension wtext_size(std::wstring text)
	{
		static dimension text_area = { };
		interfaces->surface->get_text_size(this->handle, text.c_str(), text_area.w, text_area.h);
		return text_area;
	}

private:
	h_font handle;

	void handle_flags(int& x, int width, int height, int flags)
	{
		if (flags & font_alignment::align_right)
			x -= width;

		if (flags & font_alignment::align_center)
			x -= width / 2;
	}
};

```

`sdk/dependencies/render/render.cpp`:

```cpp
#include "render.h"

game_render* render = new game_render;
game_fonts* fonts = new game_fonts;

void game_render::setup()
{
	// create our font here.
	fonts->tahoma		= render_font("tahoma", 12, FW_NORMAL, font_dropshadow);
	fonts->verdana		= render_font("verdana", 12, FW_NORMAL, font_antialias | font_dropshadow);
	fonts->small_font	= render_font("small fonts", 8, FW_NORMAL, font_outline);

	// calculate screen size.
	this->setup_screen();

	console->log(log_type::log_success, "render intsalled!");
}

void game_render::line(int x, int y, int w, int h, color color)
{
	interfaces->surface->draw_set_color(color.r, color.g, color.b, color.a);
	interfaces->surface->draw_line(x, y, w, h);
}

void game_render::filled_rect(int x, int y, int w, int h, color color)
{
	interfaces->surface->draw_set_color(color.r, color.g, color.b, color.a);
	interfaces->surface->draw_filled_rect(x, y, x + w, y + h);
}

void game_render::outlined_rect(int x, int y, int w, int h, color color)
{
	interfaces->surface->draw_set_color(color.r, color.g, color.b, color.a);
	interfaces->surface->draw_outlined_rect(x, y, x + w, y + h);
}

void game_render::gradient(int x, int y, int w, int h, color first, color second, gradient_orientation orientation)
{
	interfaces->surface->draw_set_color(first.r, first.g, first.b, first.a);
	interfaces->surface->draw_filled_rect_fade(x, y, x + w, y + h, 255, 255, orientation);

	interfaces->surface->draw_set_color(second.r, second.g, second.b, second.a);
	interfaces->surface->draw_filled_rect_fade(x, y, x + w, y + h, 0, 255, orientation);
}

void game_render::start_clip(rect area)
{
	rect canvas = { area.x, area.y, area.x + area.w, area.y + area.h };
	// turn off clipping as we need to display items.
	interfaces->surface->disable_clip(true);
	interfaces->surface->set_clip_rect(canvas.x, canvas.y, canvas.w, canvas.h);
}

void game_render::end_clip()
{
	// turn on clipping cuz we don't want items to be shown beyond this point.
	interfaces->surface->disable_clip(false);
}

void game_render::setup_screen()
{
	dimension canvas = { 0, 0 };
	interfaces->engine_client->get_screen_size(canvas.w, canvas.h);
	this->screen = { canvas.w, canvas.h };
}

```

`sdk/dependencies/render/render.h`:

```h
#pragma once
#include "../console/console.h"
#include "../../valve/interface/interface.h"
#include "../../valve/maths/other.h"
#include "../other/translate.h"
#include "font.h"

enum gradient_orientation : int
{
	vertical	= 0,
	horizontal	= 1
};

struct game_fonts
{
	render_font tahoma;
	render_font verdana;
	render_font small_font;
};

extern game_fonts* fonts;

class game_render
{
public:
	void setup();

	void line(int x, int y, int w, int h, color color);
	void filled_rect(int x, int y, int w, int h, color color);
	void outlined_rect(int x, int y, int w, int h, color color);
	void gradient(int x, int y, int w, int h, color first, color second, gradient_orientation orientation = vertical);

	void start_clip(rect area);
	void end_clip();

	dimension screen = { };

private:
	void setup_screen();
};

extern game_render* render;

```

`sdk/entry.cpp`:

```cpp
#include "include.h"

// it has to be exactly 'DllMain' to tell the .dll file is the entry point to inject to the proccess.
#define DLL_ENTRY DllMain

DWORD WINAPI setup(HMODULE instance)
{
#ifdef _DEBUG
    console->setup("sdk console");
#endif // DEBUG

    __try {
        do {
            modules->setup();
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
        } // this the last module for the game to be loaded.
        while (!scanner->capture_module(modules->server_browser).hModule);

        // install game sdk.
        interfaces->setup();
        netvar->setup();
        render->setup();

        // install hooks.
        hooks->setup();
    }
    __except (dump->create_dump(GetExceptionInformation())) {
        FreeLibraryAndExitThread(instance, EXIT_FAILURE);
    }

    // unload hack cuz convenient!
    while (!GetAsyncKeyState(VK_DELETE))
        std::this_thread::sleep_for(std::chrono::milliseconds(100));

    FreeLibraryAndExitThread(instance, EXIT_SUCCESS);

    return FALSE;
}

DWORD WINAPI restore()
{
    // uninstall hooks.
    hooks->restore();

#ifdef _DEBUG
    console->restore();
#endif // DEBUG

    return TRUE;
}

BOOL APIENTRY DLL_ENTRY(HMODULE instance, DWORD call_reason, LPVOID reserved)
{
    switch (call_reason)
    {
    case DLL_PROCESS_ATTACH:
        // optimisation purposes.
        DisableThreadLibraryCalls(instance);

        if (const HANDLE thread = CreateThread(nullptr, NULL, (LPTHREAD_START_ROUTINE)setup, instance, NULL, nullptr))
            CloseHandle(thread);

        break;

    case DLL_PROCESS_DETACH:
        // perform any necessary cleanup.
        restore();
        break;
    }

    return TRUE;

}

```

`sdk/external/minhook/buffer.c`:

```c
/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2017 Tsuda Kageyu.
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 *  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 *  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
 *  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <windows.h>
#include "buffer.h"

// Size of each memory block. (= page size of VirtualAlloc)
#define MEMORY_BLOCK_SIZE 0x1000

// Max range for seeking a memory block. (= 1024MB)
#define MAX_MEMORY_RANGE 0x40000000

// Memory protection flags to check the executable address.
#define PAGE_EXECUTE_FLAGS \
    (PAGE_EXECUTE | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY)

// Memory slot.
typedef struct _MEMORY_SLOT
{
    union
    {
        struct _MEMORY_SLOT *pNext;
        UINT8 buffer[MEMORY_SLOT_SIZE];
    };
} MEMORY_SLOT, *PMEMORY_SLOT;

// Memory block info. Placed at the head of each block.
typedef struct _MEMORY_BLOCK
{
    struct _MEMORY_BLOCK *pNext;
    PMEMORY_SLOT pFree;         // First element of the free slot list.
    UINT usedCount;
} MEMORY_BLOCK, *PMEMORY_BLOCK;

//-------------------------------------------------------------------------
// Global Variables:
//-------------------------------------------------------------------------

// First element of the memory block list.
PMEMORY_BLOCK g_pMemoryBlocks;

//-------------------------------------------------------------------------
VOID InitializeBuffer(VOID)
{
    // Nothing to do for now.
}

//-------------------------------------------------------------------------
VOID UninitializeBuffer(VOID)
{
    PMEMORY_BLOCK pBlock = g_pMemoryBlocks;
    g_pMemoryBlocks = NULL;

    while (pBlock)
    {
        PMEMORY_BLOCK pNext = pBlock->pNext;
        VirtualFree(pBlock, 0, MEM_RELEASE);
        pBlock = pNext;
    }
}

//-------------------------------------------------------------------------
#if defined(_M_X64) || defined(__x86_64__)
static LPVOID FindPrevFreeRegion(LPVOID pAddress, LPVOID pMinAddr, DWORD dwAllocationGranularity)
{
    ULONG_PTR tryAddr = (ULONG_PTR)pAddress;

    // Round down to the allocation granularity.
    tryAddr -= tryAddr % dwAllocationGranularity;

    // Start from the previous allocation granularity multiply.
    tryAddr -= dwAllocationGranularity;

    while (tryAddr >= (ULONG_PTR)pMinAddr)
    {
        MEMORY_BASIC_INFORMATION mbi;
        if (VirtualQuery((LPVOID)tryAddr, &mbi, sizeof(mbi)) == 0)
            break;

        if (mbi.State == MEM_FREE)
            return (LPVOID)tryAddr;

        if ((ULONG_PTR)mbi.AllocationBase < dwAllocationGranularity)
            break;

        tryAddr = (ULONG_PTR)mbi.AllocationBase - dwAllocationGranularity;
    }

    return NULL;
}
#endif

//-------------------------------------------------------------------------
#if defined(_M_X64) || defined(__x86_64__)
static LPVOID FindNextFreeRegion(LPVOID pAddress, LPVOID pMaxAddr, DWORD dwAllocationGranularity)
{
    ULONG_PTR tryAddr = (ULONG_PTR)pAddress;

    // Round down to the allocation granularity.
    tryAddr -= tryAddr % dwAllocationGranularity;

    // Start from the next allocation granularity multiply.
    tryAddr += dwAllocationGranularity;

    while (tryAddr <= (ULONG_PTR)pMaxAddr)
    {
        MEMORY_BASIC_INFORMATION mbi;
        if (VirtualQuery((LPVOID)tryAddr, &mbi, sizeof(mbi)) == 0)
            break;

        if (mbi.State == MEM_FREE)
            return (LPVOID)tryAddr;

        tryAddr = (ULONG_PTR)mbi.BaseAddress + mbi.RegionSize;

        // Round up to the next allocation granularity.
        tryAddr += dwAllocationGranularity - 1;
        tryAddr -= tryAddr % dwAllocationGranularity;
    }

    return NULL;
}
#endif

//-------------------------------------------------------------------------
static PMEMORY_BLOCK GetMemoryBlock(LPVOID pOrigin)
{
    PMEMORY_BLOCK pBlock;
#if defined(_M_X64) || defined(__x86_64__)
    ULONG_PTR minAddr;
    ULONG_PTR maxAddr;

    SYSTEM_INFO si;
    GetSystemInfo(&si);
    minAddr = (ULONG_PTR)si.lpMinimumApplicationAddress;
    maxAddr = (ULONG_PTR)si.lpMaximumApplicationAddress;

    // pOrigin ± 512MB
    if ((ULONG_PTR)pOrigin > MAX_MEMORY_RANGE && minAddr < (ULONG_PTR)pOrigin - MAX_MEMORY_RANGE)
        minAddr = (ULONG_PTR)pOrigin - MAX_MEMORY_RANGE;

    if (maxAddr > (ULONG_PTR)pOrigin + MAX_MEMORY_RANGE)
        maxAddr = (ULONG_PTR)pOrigin + MAX_MEMORY_RANGE;

    // Make room for MEMORY_BLOCK_SIZE bytes.
    maxAddr -= MEMORY_BLOCK_SIZE - 1;
#endif

    // Look the registered blocks for a reachable one.
    for (pBlock = g_pMemoryBlocks; pBlock != NULL; pBlock = pBlock->pNext)
    {
#if defined(_M_X64) || defined(__x86_64__)
        // Ignore the blocks too far.
        if ((ULONG_PTR)pBlock < minAddr || (ULONG_PTR)pBlock >= maxAddr)
            continue;
#endif
        // The block has at least one unused slot.
        if (pBlock->pFree != NULL)
            return pBlock;
    }

#if defined(_M_X64) || defined(__x86_64__)
    // Alloc a new block above if not found.
    {
        LPVOID pAlloc = pOrigin;
        while ((ULONG_PTR)pAlloc >= minAddr)
        {
            pAlloc = FindPrevFreeRegion(pAlloc, (LPVOID)minAddr, si.dwAllocationGranularity);
            if (pAlloc == NULL)
                break;

            pBlock = (PMEMORY_BLOCK)VirtualAlloc(
                pAlloc, MEMORY_BLOCK_SIZE, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
            if (pBlock != NULL)
                break;
        }
    }

    // Alloc a new block below if not found.
    if (pBlock == NULL)
    {
        LPVOID pAlloc = pOrigin;
        while ((ULONG_PTR)pAlloc <= maxAddr)
        {
            pAlloc = FindNextFreeRegion(pAlloc, (LPVOID)maxAddr, si.dwAllocationGranularity);
            if (pAlloc == NULL)
                break;

            pBlock = (PMEMORY_BLOCK)VirtualAlloc(
                pAlloc, MEMORY_BLOCK_SIZE, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
            if (pBlock != NULL)
                break;
        }
    }
#else
    // In x86 mode, a memory block can be placed anywhere.
    pBlock = (PMEMORY_BLOCK)VirtualAlloc(
        NULL, MEMORY_BLOCK_SIZE, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
#endif

    if (pBlock != NULL)
    {
        // Build a linked list of all the slots.
        PMEMORY_SLOT pSlot = (PMEMORY_SLOT)pBlock + 1;
        pBlock->pFree = NULL;
        pBlock->usedCount = 0;
        do
        {
            pSlot->pNext = pBlock->pFree;
            pBlock->pFree = pSlot;
            pSlot++;
        } while ((ULONG_PTR)pSlot - (ULONG_PTR)pBlock <= MEMORY_BLOCK_SIZE - MEMORY_SLOT_SIZE);

        pBlock->pNext = g_pMemoryBlocks;
        g_pMemoryBlocks = pBlock;
    }

    return pBlock;
}

//-------------------------------------------------------------------------
LPVOID AllocateBuffer(LPVOID pOrigin)
{
    PMEMORY_SLOT  pSlot;
    PMEMORY_BLOCK pBlock = GetMemoryBlock(pOrigin);
    if (pBlock == NULL)
        return NULL;

    // Remove an unused slot from the list.
    pSlot = pBlock->pFree;
    pBlock->pFree = pSlot->pNext;
    pBlock->usedCount++;
#ifdef _DEBUG
    // Fill the slot with INT3 for debugging.
    memset(pSlot, 0xCC, sizeof(MEMORY_SLOT));
#endif
    return pSlot;
}

//-------------------------------------------------------------------------
VOID FreeBuffer(LPVOID pBuffer)
{
    PMEMORY_BLOCK pBlock = g_pMemoryBlocks;
    PMEMORY_BLOCK pPrev = NULL;
    ULONG_PTR pTargetBlock = ((ULONG_PTR)pBuffer / MEMORY_BLOCK_SIZE) * MEMORY_BLOCK_SIZE;

    while (pBlock != NULL)
    {
        if ((ULONG_PTR)pBlock == pTargetBlock)
        {
            PMEMORY_SLOT pSlot = (PMEMORY_SLOT)pBuffer;
#ifdef _DEBUG
            // Clear the released slot for debugging.
            memset(pSlot, 0x00, sizeof(MEMORY_SLOT));
#endif
            // Restore the released slot to the list.
            pSlot->pNext = pBlock->pFree;
            pBlock->pFree = pSlot;
            pBlock->usedCount--;

            // Free if unused.
            if (pBlock->usedCount == 0)
            {
                if (pPrev)
                    pPrev->pNext = pBlock->pNext;
                else
                    g_pMemoryBlocks = pBlock->pNext;

                VirtualFree(pBlock, 0, MEM_RELEASE);
            }

            break;
        }

        pPrev = pBlock;
        pBlock = pBlock->pNext;
    }
}

//-------------------------------------------------------------------------
BOOL IsExecutableAddress(LPVOID pAddress)
{
    MEMORY_BASIC_INFORMATION mi;
    VirtualQuery(pAddress, &mi, sizeof(mi));

    return (mi.State == MEM_COMMIT && (mi.Protect & PAGE_EXECUTE_FLAGS));
}

```

`sdk/external/minhook/buffer.h`:

```h
/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2017 Tsuda Kageyu.
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 *  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 *  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
 *  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#pragma once

// Size of each memory slot.
#if defined(_M_X64) || defined(__x86_64__)
    #define MEMORY_SLOT_SIZE 64
#else
    #define MEMORY_SLOT_SIZE 32
#endif

VOID   InitializeBuffer(VOID);
VOID   UninitializeBuffer(VOID);
LPVOID AllocateBuffer(LPVOID pOrigin);
VOID   FreeBuffer(LPVOID pBuffer);
BOOL   IsExecutableAddress(LPVOID pAddress);

```

`sdk/external/minhook/hde/hde32.c`:

```c
/*
 * Hacker Disassembler Engine 32 C
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 */

#if defined(_M_IX86) || defined(__i386__)

#include <string.h>
#include "hde32.h"
#include "table32.h"

unsigned int hde32_disasm(const void *code, hde32s *hs)
{
    uint8_t x, c, *p = (uint8_t *)code, cflags, opcode, pref = 0;
    uint8_t *ht = hde32_table, m_mod, m_reg, m_rm, disp_size = 0;

    memset(hs, 0, sizeof(hde32s));

    for (x = 16; x; x--)
        switch (c = *p++) {
            case 0xf3:
                hs->p_rep = c;
                pref |= PRE_F3;
                break;
            case 0xf2:
                hs->p_rep = c;
                pref |= PRE_F2;
                break;
            case 0xf0:
                hs->p_lock = c;
                pref |= PRE_LOCK;
                break;
            case 0x26: case 0x2e: case 0x36:
            case 0x3e: case 0x64: case 0x65:
                hs->p_seg = c;
                pref |= PRE_SEG;
                break;
            case 0x66:
                hs->p_66 = c;
                pref |= PRE_66;
                break;
            case 0x67:
                hs->p_67 = c;
                pref |= PRE_67;
                break;
            default:
                goto pref_done;
        }
  pref_done:

    hs->flags = (uint32_t)pref << 23;

    if (!pref)
        pref |= PRE_NONE;

    if ((hs->opcode = c) == 0x0f) {
        hs->opcode2 = c = *p++;
        ht += DELTA_OPCODES;
    } else if (c >= 0xa0 && c <= 0xa3) {
        if (pref & PRE_67)
            pref |= PRE_66;
        else
            pref &= ~PRE_66;
    }

    opcode = c;
    cflags = ht[ht[opcode / 4] + (opcode % 4)];

    if (cflags == C_ERROR) {
        hs->flags |= F_ERROR | F_ERROR_OPCODE;
        cflags = 0;
        if ((opcode & -3) == 0x24)
            cflags++;
    }

    x = 0;
    if (cflags & C_GROUP) {
        uint16_t t;
        t = *(uint16_t *)(ht + (cflags & 0x7f));
        cflags = (uint8_t)t;
        x = (uint8_t)(t >> 8);
    }

    if (hs->opcode2) {
        ht = hde32_table + DELTA_PREFIXES;
        if (ht[ht[opcode / 4] + (opcode % 4)] & pref)
            hs->flags |= F_ERROR | F_ERROR_OPCODE;
    }

    if (cflags & C_MODRM) {
        hs->flags |= F_MODRM;
        hs->modrm = c = *p++;
        hs->modrm_mod = m_mod = c >> 6;
        hs->modrm_rm = m_rm = c & 7;
        hs->modrm_reg = m_reg = (c & 0x3f) >> 3;

        if (x && ((x << m_reg) & 0x80))
            hs->flags |= F_ERROR | F_ERROR_OPCODE;

        if (!hs->opcode2 && opcode >= 0xd9 && opcode <= 0xdf) {
            uint8_t t = opcode - 0xd9;
            if (m_mod == 3) {
                ht = hde32_table + DELTA_FPU_MODRM + t*8;
                t = ht[m_reg] << m_rm;
            } else {
                ht = hde32_table + DELTA_FPU_REG;
                t = ht[t] << m_reg;
            }
            if (t & 0x80)
                hs->flags |= F_ERROR | F_ERROR_OPCODE;
        }

        if (pref & PRE_LOCK) {
            if (m_mod == 3) {
                hs->flags |= F_ERROR | F_ERROR_LOCK;
            } else {
                uint8_t *table_end, op = opcode;
                if (hs->opcode2) {
                    ht = hde32_table + DELTA_OP2_LOCK_OK;
                    table_end = ht + DELTA_OP_ONLY_MEM - DELTA_OP2_LOCK_OK;
                } else {
                    ht = hde32_table + DELTA_OP_LOCK_OK;
                    table_end = ht + DELTA_OP2_LOCK_OK - DELTA_OP_LOCK_OK;
                    op &= -2;
                }
                for (; ht != table_end; ht++)
                    if (*ht++ == op) {
                        if (!((*ht << m_reg) & 0x80))
                            goto no_lock_error;
                        else
                            break;
                    }
                hs->flags |= F_ERROR | F_ERROR_LOCK;
              no_lock_error:
                ;
            }
        }

        if (hs->opcode2) {
            switch (opcode) {
                case 0x20: case 0x22:
                    m_mod = 3;
                    if (m_reg > 4 || m_reg == 1)
                        goto error_operand;
                    else
                        goto no_error_operand;
                case 0x21: case 0x23:
                    m_mod = 3;
                    if (m_reg == 4 || m_reg == 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
            }
        } else {
            switch (opcode) {
                case 0x8c:
                    if (m_reg > 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
                case 0x8e:
                    if (m_reg == 1 || m_reg > 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
            }
        }

        if (m_mod == 3) {
            uint8_t *table_end;
            if (hs->opcode2) {
                ht = hde32_table + DELTA_OP2_ONLY_MEM;
                table_end = ht + sizeof(hde32_table) - DELTA_OP2_ONLY_MEM;
            } else {
                ht = hde32_table + DELTA_OP_ONLY_MEM;
                table_end = ht + DELTA_OP2_ONLY_MEM - DELTA_OP_ONLY_MEM;
            }
            for (; ht != table_end; ht += 2)
                if (*ht++ == opcode) {
                    if ((*ht++ & pref) && !((*ht << m_reg) & 0x80))
                        goto error_operand;
                    else
                        break;
                }
            goto no_error_operand;
        } else if (hs->opcode2) {
            switch (opcode) {
                case 0x50: case 0xd7: case 0xf7:
                    if (pref & (PRE_NONE | PRE_66))
                        goto error_operand;
                    break;
                case 0xd6:
                    if (pref & (PRE_F2 | PRE_F3))
                        goto error_operand;
                    break;
                case 0xc5:
                    goto error_operand;
            }
            goto no_error_operand;
        } else
            goto no_error_operand;

      error_operand:
        hs->flags |= F_ERROR | F_ERROR_OPERAND;
      no_error_operand:

        c = *p++;
        if (m_reg <= 1) {
            if (opcode == 0xf6)
                cflags |= C_IMM8;
            else if (opcode == 0xf7)
                cflags |= C_IMM_P66;
        }

        switch (m_mod) {
            case 0:
                if (pref & PRE_67) {
                    if (m_rm == 6)
                        disp_size = 2;
                } else
                    if (m_rm == 5)
                        disp_size = 4;
                break;
            case 1:
                disp_size = 1;
                break;
            case 2:
                disp_size = 2;
                if (!(pref & PRE_67))
                    disp_size <<= 1;
                break;
        }

        if (m_mod != 3 && m_rm == 4 && !(pref & PRE_67)) {
            hs->flags |= F_SIB;
            p++;
            hs->sib = c;
            hs->sib_scale = c >> 6;
            hs->sib_index = (c & 0x3f) >> 3;
            if ((hs->sib_base = c & 7) == 5 && !(m_mod & 1))
                disp_size = 4;
        }

        p--;
        switch (disp_size) {
            case 1:
                hs->flags |= F_DISP8;
                hs->disp.disp8 = *p;
                break;
            case 2:
                hs->flags |= F_DISP16;
                hs->disp.disp16 = *(uint16_t *)p;
                break;
            case 4:
                hs->flags |= F_DISP32;
                hs->disp.disp32 = *(uint32_t *)p;
                break;
        }
        p += disp_size;
    } else if (pref & PRE_LOCK)
        hs->flags |= F_ERROR | F_ERROR_LOCK;

    if (cflags & C_IMM_P66) {
        if (cflags & C_REL32) {
            if (pref & PRE_66) {
                hs->flags |= F_IMM16 | F_RELATIVE;
                hs->imm.imm16 = *(uint16_t *)p;
                p += 2;
                goto disasm_done;
            }
            goto rel32_ok;
        }
        if (pref & PRE_66) {
            hs->flags |= F_IMM16;
            hs->imm.imm16 = *(uint16_t *)p;
            p += 2;
        } else {
            hs->flags |= F_IMM32;
            hs->imm.imm32 = *(uint32_t *)p;
            p += 4;
        }
    }

    if (cflags & C_IMM16) {
        if (hs->flags & F_IMM32) {
            hs->flags |= F_IMM16;
            hs->disp.disp16 = *(uint16_t *)p;
        } else if (hs->flags & F_IMM16) {
            hs->flags |= F_2IMM16;
            hs->disp.disp16 = *(uint16_t *)p;
        } else {
            hs->flags |= F_IMM16;
            hs->imm.imm16 = *(uint16_t *)p;
        }
        p += 2;
    }
    if (cflags & C_IMM8) {
        hs->flags |= F_IMM8;
        hs->imm.imm8 = *p++;
    }

    if (cflags & C_REL32) {
      rel32_ok:
        hs->flags |= F_IMM32 | F_RELATIVE;
        hs->imm.imm32 = *(uint32_t *)p;
        p += 4;
    } else if (cflags & C_REL8) {
        hs->flags |= F_IMM8 | F_RELATIVE;
        hs->imm.imm8 = *p++;
    }

  disasm_done:

    if ((hs->len = (uint8_t)(p-(uint8_t *)code)) > 15) {
        hs->flags |= F_ERROR | F_ERROR_LENGTH;
        hs->len = 15;
    }

    return (unsigned int)hs->len;
}

#endif // defined(_M_IX86) || defined(__i386__)

```

`sdk/external/minhook/hde/hde32.h`:

```h
/*
 * Hacker Disassembler Engine 32
 * Copyright (c) 2006-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 * hde32.h: C/C++ header file
 *
 */

#ifndef _HDE32_H_
#define _HDE32_H_

/* stdint.h - C99 standard header
 * http://en.wikipedia.org/wiki/stdint.h
 *
 * if your compiler doesn't contain "stdint.h" header (for
 * example, Microsoft Visual C++), you can download file:
 *   http://www.azillionmonkeys.com/qed/pstdint.h
 * and change next line to:
 *   #include "pstdint.h"
 */
#include "pstdint.h"

#define F_MODRM         0x00000001
#define F_SIB           0x00000002
#define F_IMM8          0x00000004
#define F_IMM16         0x00000008
#define F_IMM32         0x00000010
#define F_DISP8         0x00000020
#define F_DISP16        0x00000040
#define F_DISP32        0x00000080
#define F_RELATIVE      0x00000100
#define F_2IMM16        0x00000800
#define F_ERROR         0x00001000
#define F_ERROR_OPCODE  0x00002000
#define F_ERROR_LENGTH  0x00004000
#define F_ERROR_LOCK    0x00008000
#define F_ERROR_OPERAND 0x00010000
#define F_PREFIX_REPNZ  0x01000000
#define F_PREFIX_REPX   0x02000000
#define F_PREFIX_REP    0x03000000
#define F_PREFIX_66     0x04000000
#define F_PREFIX_67     0x08000000
#define F_PREFIX_LOCK   0x10000000
#define F_PREFIX_SEG    0x20000000
#define F_PREFIX_ANY    0x3f000000

#define PREFIX_SEGMENT_CS   0x2e
#define PREFIX_SEGMENT_SS   0x36
#define PREFIX_SEGMENT_DS   0x3e
#define PREFIX_SEGMENT_ES   0x26
#define PREFIX_SEGMENT_FS   0x64
#define PREFIX_SEGMENT_GS   0x65
#define PREFIX_LOCK         0xf0
#define PREFIX_REPNZ        0xf2
#define PREFIX_REPX         0xf3
#define PREFIX_OPERAND_SIZE 0x66
#define PREFIX_ADDRESS_SIZE 0x67

#pragma pack(push,1)

typedef struct {
    uint8_t len;
    uint8_t p_rep;
    uint8_t p_lock;
    uint8_t p_seg;
    uint8_t p_66;
    uint8_t p_67;
    uint8_t opcode;
    uint8_t opcode2;
    uint8_t modrm;
    uint8_t modrm_mod;
    uint8_t modrm_reg;
    uint8_t modrm_rm;
    uint8_t sib;
    uint8_t sib_scale;
    uint8_t sib_index;
    uint8_t sib_base;
    union {
        uint8_t imm8;
        uint16_t imm16;
        uint32_t imm32;
    } imm;
    union {
        uint8_t disp8;
        uint16_t disp16;
        uint32_t disp32;
    } disp;
    uint32_t flags;
} hde32s;

#pragma pack(pop)

#ifdef __cplusplus
extern "C" {
#endif

/* __cdecl */
unsigned int hde32_disasm(const void *code, hde32s *hs);

#ifdef __cplusplus
}
#endif

#endif /* _HDE32_H_ */

```

`sdk/external/minhook/hde/hde64.c`:

```c
/*
 * Hacker Disassembler Engine 64 C
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 */

#if defined(_M_X64) || defined(__x86_64__)

#include <string.h>
#include "hde64.h"
#include "table64.h"

unsigned int hde64_disasm(const void *code, hde64s *hs)
{
    uint8_t x, c, *p = (uint8_t *)code, cflags, opcode, pref = 0;
    uint8_t *ht = hde64_table, m_mod, m_reg, m_rm, disp_size = 0;
    uint8_t op64 = 0;

    memset(hs, 0, sizeof(hde64s));

    for (x = 16; x; x--)
        switch (c = *p++) {
            case 0xf3:
                hs->p_rep = c;
                pref |= PRE_F3;
                break;
            case 0xf2:
                hs->p_rep = c;
                pref |= PRE_F2;
                break;
            case 0xf0:
                hs->p_lock = c;
                pref |= PRE_LOCK;
                break;
            case 0x26: case 0x2e: case 0x36:
            case 0x3e: case 0x64: case 0x65:
                hs->p_seg = c;
                pref |= PRE_SEG;
                break;
            case 0x66:
                hs->p_66 = c;
                pref |= PRE_66;
                break;
            case 0x67:
                hs->p_67 = c;
                pref |= PRE_67;
                break;
            default:
                goto pref_done;
        }
  pref_done:

    hs->flags = (uint32_t)pref << 23;

    if (!pref)
        pref |= PRE_NONE;

    if ((c & 0xf0) == 0x40) {
        hs->flags |= F_PREFIX_REX;
        if ((hs->rex_w = (c & 0xf) >> 3) && (*p & 0xf8) == 0xb8)
            op64++;
        hs->rex_r = (c & 7) >> 2;
        hs->rex_x = (c & 3) >> 1;
        hs->rex_b = c & 1;
        if (((c = *p++) & 0xf0) == 0x40) {
            opcode = c;
            goto error_opcode;
        }
    }

    if ((hs->opcode = c) == 0x0f) {
        hs->opcode2 = c = *p++;
        ht += DELTA_OPCODES;
    } else if (c >= 0xa0 && c <= 0xa3) {
        op64++;
        if (pref & PRE_67)
            pref |= PRE_66;
        else
            pref &= ~PRE_66;
    }

    opcode = c;
    cflags = ht[ht[opcode / 4] + (opcode % 4)];

    if (cflags == C_ERROR) {
      error_opcode:
        hs->flags |= F_ERROR | F_ERROR_OPCODE;
        cflags = 0;
        if ((opcode & -3) == 0x24)
            cflags++;
    }

    x = 0;
    if (cflags & C_GROUP) {
        uint16_t t;
        t = *(uint16_t *)(ht + (cflags & 0x7f));
        cflags = (uint8_t)t;
        x = (uint8_t)(t >> 8);
    }

    if (hs->opcode2) {
        ht = hde64_table + DELTA_PREFIXES;
        if (ht[ht[opcode / 4] + (opcode % 4)] & pref)
            hs->flags |= F_ERROR | F_ERROR_OPCODE;
    }

    if (cflags & C_MODRM) {
        hs->flags |= F_MODRM;
        hs->modrm = c = *p++;
        hs->modrm_mod = m_mod = c >> 6;
        hs->modrm_rm = m_rm = c & 7;
        hs->modrm_reg = m_reg = (c & 0x3f) >> 3;

        if (x && ((x << m_reg) & 0x80))
            hs->flags |= F_ERROR | F_ERROR_OPCODE;

        if (!hs->opcode2 && opcode >= 0xd9 && opcode <= 0xdf) {
            uint8_t t = opcode - 0xd9;
            if (m_mod == 3) {
                ht = hde64_table + DELTA_FPU_MODRM + t*8;
                t = ht[m_reg] << m_rm;
            } else {
                ht = hde64_table + DELTA_FPU_REG;
                t = ht[t] << m_reg;
            }
            if (t & 0x80)
                hs->flags |= F_ERROR | F_ERROR_OPCODE;
        }

        if (pref & PRE_LOCK) {
            if (m_mod == 3) {
                hs->flags |= F_ERROR | F_ERROR_LOCK;
            } else {
                uint8_t *table_end, op = opcode;
                if (hs->opcode2) {
                    ht = hde64_table + DELTA_OP2_LOCK_OK;
                    table_end = ht + DELTA_OP_ONLY_MEM - DELTA_OP2_LOCK_OK;
                } else {
                    ht = hde64_table + DELTA_OP_LOCK_OK;
                    table_end = ht + DELTA_OP2_LOCK_OK - DELTA_OP_LOCK_OK;
                    op &= -2;
                }
                for (; ht != table_end; ht++)
                    if (*ht++ == op) {
                        if (!((*ht << m_reg) & 0x80))
                            goto no_lock_error;
                        else
                            break;
                    }
                hs->flags |= F_ERROR | F_ERROR_LOCK;
              no_lock_error:
                ;
            }
        }

        if (hs->opcode2) {
            switch (opcode) {
                case 0x20: case 0x22:
                    m_mod = 3;
                    if (m_reg > 4 || m_reg == 1)
                        goto error_operand;
                    else
                        goto no_error_operand;
                case 0x21: case 0x23:
                    m_mod = 3;
                    if (m_reg == 4 || m_reg == 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
            }
        } else {
            switch (opcode) {
                case 0x8c:
                    if (m_reg > 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
                case 0x8e:
                    if (m_reg == 1 || m_reg > 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
            }
        }

        if (m_mod == 3) {
            uint8_t *table_end;
            if (hs->opcode2) {
                ht = hde64_table + DELTA_OP2_ONLY_MEM;
                table_end = ht + sizeof(hde64_table) - DELTA_OP2_ONLY_MEM;
            } else {
                ht = hde64_table + DELTA_OP_ONLY_MEM;
                table_end = ht + DELTA_OP2_ONLY_MEM - DELTA_OP_ONLY_MEM;
            }
            for (; ht != table_end; ht += 2)
                if (*ht++ == opcode) {
                    if ((*ht++ & pref) && !((*ht << m_reg) & 0x80))
                        goto error_operand;
                    else
                        break;
                }
            goto no_error_operand;
        } else if (hs->opcode2) {
            switch (opcode) {
                case 0x50: case 0xd7: case 0xf7:
                    if (pref & (PRE_NONE | PRE_66))
                        goto error_operand;
                    break;
                case 0xd6:
                    if (pref & (PRE_F2 | PRE_F3))
                        goto error_operand;
                    break;
                case 0xc5:
                    goto error_operand;
            }
            goto no_error_operand;
        } else
            goto no_error_operand;

      error_operand:
        hs->flags |= F_ERROR | F_ERROR_OPERAND;
      no_error_operand:

        c = *p++;
        if (m_reg <= 1) {
            if (opcode == 0xf6)
                cflags |= C_IMM8;
            else if (opcode == 0xf7)
                cflags |= C_IMM_P66;
        }

        switch (m_mod) {
            case 0:
                if (pref & PRE_67) {
                    if (m_rm == 6)
                        disp_size = 2;
                } else
                    if (m_rm == 5)
                        disp_size = 4;
                break;
            case 1:
                disp_size = 1;
                break;
            case 2:
                disp_size = 2;
                if (!(pref & PRE_67))
                    disp_size <<= 1;
                break;
        }

        if (m_mod != 3 && m_rm == 4) {
            hs->flags |= F_SIB;
            p++;
            hs->sib = c;
            hs->sib_scale = c >> 6;
            hs->sib_index = (c & 0x3f) >> 3;
            if ((hs->sib_base = c & 7) == 5 && !(m_mod & 1))
                disp_size = 4;
        }

        p--;
        switch (disp_size) {
            case 1:
                hs->flags |= F_DISP8;
                hs->disp.disp8 = *p;
                break;
            case 2:
                hs->flags |= F_DISP16;
                hs->disp.disp16 = *(uint16_t *)p;
                break;
            case 4:
                hs->flags |= F_DISP32;
                hs->disp.disp32 = *(uint32_t *)p;
                break;
        }
        p += disp_size;
    } else if (pref & PRE_LOCK)
        hs->flags |= F_ERROR | F_ERROR_LOCK;

    if (cflags & C_IMM_P66) {
        if (cflags & C_REL32) {
            if (pref & PRE_66) {
                hs->flags |= F_IMM16 | F_RELATIVE;
                hs->imm.imm16 = *(uint16_t *)p;
                p += 2;
                goto disasm_done;
            }
            goto rel32_ok;
        }
        if (op64) {
            hs->flags |= F_IMM64;
            hs->imm.imm64 = *(uint64_t *)p;
            p += 8;
        } else if (!(pref & PRE_66)) {
            hs->flags |= F_IMM32;
            hs->imm.imm32 = *(uint32_t *)p;
            p += 4;
        } else
            goto imm16_ok;
    }


    if (cflags & C_IMM16) {
      imm16_ok:
        hs->flags |= F_IMM16;
        hs->imm.imm16 = *(uint16_t *)p;
        p += 2;
    }
    if (cflags & C_IMM8) {
        hs->flags |= F_IMM8;
        hs->imm.imm8 = *p++;
    }

    if (cflags & C_REL32) {
      rel32_ok:
        hs->flags |= F_IMM32 | F_RELATIVE;
        hs->imm.imm32 = *(uint32_t *)p;
        p += 4;
    } else if (cflags & C_REL8) {
        hs->flags |= F_IMM8 | F_RELATIVE;
        hs->imm.imm8 = *p++;
    }

  disasm_done:

    if ((hs->len = (uint8_t)(p-(uint8_t *)code)) > 15) {
        hs->flags |= F_ERROR | F_ERROR_LENGTH;
        hs->len = 15;
    }

    return (unsigned int)hs->len;
}

#endif // defined(_M_X64) || defined(__x86_64__)

```

`sdk/external/minhook/hde/hde64.h`:

```h
/*
 * Hacker Disassembler Engine 64
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 * hde64.h: C/C++ header file
 *
 */

#ifndef _HDE64_H_
#define _HDE64_H_

/* stdint.h - C99 standard header
 * http://en.wikipedia.org/wiki/stdint.h
 *
 * if your compiler doesn't contain "stdint.h" header (for
 * example, Microsoft Visual C++), you can download file:
 *   http://www.azillionmonkeys.com/qed/pstdint.h
 * and change next line to:
 *   #include "pstdint.h"
 */
#include "pstdint.h"

#define F_MODRM         0x00000001
#define F_SIB           0x00000002
#define F_IMM8          0x00000004
#define F_IMM16         0x00000008
#define F_IMM32         0x00000010
#define F_IMM64         0x00000020
#define F_DISP8         0x00000040
#define F_DISP16        0x00000080
#define F_DISP32        0x00000100
#define F_RELATIVE      0x00000200
#define F_ERROR         0x00001000
#define F_ERROR_OPCODE  0x00002000
#define F_ERROR_LENGTH  0x00004000
#define F_ERROR_LOCK    0x00008000
#define F_ERROR_OPERAND 0x00010000
#define F_PREFIX_REPNZ  0x01000000
#define F_PREFIX_REPX   0x02000000
#define F_PREFIX_REP    0x03000000
#define F_PREFIX_66     0x04000000
#define F_PREFIX_67     0x08000000
#define F_PREFIX_LOCK   0x10000000
#define F_PREFIX_SEG    0x20000000
#define F_PREFIX_REX    0x40000000
#define F_PREFIX_ANY    0x7f000000

#define PREFIX_SEGMENT_CS   0x2e
#define PREFIX_SEGMENT_SS   0x36
#define PREFIX_SEGMENT_DS   0x3e
#define PREFIX_SEGMENT_ES   0x26
#define PREFIX_SEGMENT_FS   0x64
#define PREFIX_SEGMENT_GS   0x65
#define PREFIX_LOCK         0xf0
#define PREFIX_REPNZ        0xf2
#define PREFIX_REPX         0xf3
#define PREFIX_OPERAND_SIZE 0x66
#define PREFIX_ADDRESS_SIZE 0x67

#pragma pack(push,1)

typedef struct {
    uint8_t len;
    uint8_t p_rep;
    uint8_t p_lock;
    uint8_t p_seg;
    uint8_t p_66;
    uint8_t p_67;
    uint8_t rex;
    uint8_t rex_w;
    uint8_t rex_r;
    uint8_t rex_x;
    uint8_t rex_b;
    uint8_t opcode;
    uint8_t opcode2;
    uint8_t modrm;
    uint8_t modrm_mod;
    uint8_t modrm_reg;
    uint8_t modrm_rm;
    uint8_t sib;
    uint8_t sib_scale;
    uint8_t sib_index;
    uint8_t sib_base;
    union {
        uint8_t imm8;
        uint16_t imm16;
        uint32_t imm32;
        uint64_t imm64;
    } imm;
    union {
        uint8_t disp8;
        uint16_t disp16;
        uint32_t disp32;
    } disp;
    uint32_t flags;
} hde64s;

#pragma pack(pop)

#ifdef __cplusplus
extern "C" {
#endif

/* __cdecl */
unsigned int hde64_disasm(const void *code, hde64s *hs);

#ifdef __cplusplus
}
#endif

#endif /* _HDE64_H_ */

```

`sdk/external/minhook/hde/pstdint.h`:

```h
/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2017 Tsuda Kageyu. All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR
 *  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 *  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#pragma once

#include <windows.h>

// Integer types for HDE.
typedef INT8   int8_t;
typedef INT16  int16_t;
typedef INT32  int32_t;
typedef INT64  int64_t;
typedef UINT8  uint8_t;
typedef UINT16 uint16_t;
typedef UINT32 uint32_t;
typedef UINT64 uint64_t;

```

`sdk/external/minhook/hde/table32.h`:

```h
/*
 * Hacker Disassembler Engine 32 C
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 */

#define C_NONE    0x00
#define C_MODRM   0x01
#define C_IMM8    0x02
#define C_IMM16   0x04
#define C_IMM_P66 0x10
#define C_REL8    0x20
#define C_REL32   0x40
#define C_GROUP   0x80
#define C_ERROR   0xff

#define PRE_ANY  0x00
#define PRE_NONE 0x01
#define PRE_F2   0x02
#define PRE_F3   0x04
#define PRE_66   0x08
#define PRE_67   0x10
#define PRE_LOCK 0x20
#define PRE_SEG  0x40
#define PRE_ALL  0xff

#define DELTA_OPCODES      0x4a
#define DELTA_FPU_REG      0xf1
#define DELTA_FPU_MODRM    0xf8
#define DELTA_PREFIXES     0x130
#define DELTA_OP_LOCK_OK   0x1a1
#define DELTA_OP2_LOCK_OK  0x1b9
#define DELTA_OP_ONLY_MEM  0x1cb
#define DELTA_OP2_ONLY_MEM 0x1da

unsigned char hde32_table[] = {
  0xa3,0xa8,0xa3,0xa8,0xa3,0xa8,0xa3,0xa8,0xa3,0xa8,0xa3,0xa8,0xa3,0xa8,0xa3,
  0xa8,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xac,0xaa,0xb2,0xaa,0x9f,0x9f,
  0x9f,0x9f,0xb5,0xa3,0xa3,0xa4,0xaa,0xaa,0xba,0xaa,0x96,0xaa,0xa8,0xaa,0xc3,
  0xc3,0x96,0x96,0xb7,0xae,0xd6,0xbd,0xa3,0xc5,0xa3,0xa3,0x9f,0xc3,0x9c,0xaa,
  0xaa,0xac,0xaa,0xbf,0x03,0x7f,0x11,0x7f,0x01,0x7f,0x01,0x3f,0x01,0x01,0x90,
  0x82,0x7d,0x97,0x59,0x59,0x59,0x59,0x59,0x7f,0x59,0x59,0x60,0x7d,0x7f,0x7f,
  0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x9a,0x88,0x7d,
  0x59,0x50,0x50,0x50,0x50,0x59,0x59,0x59,0x59,0x61,0x94,0x61,0x9e,0x59,0x59,
  0x85,0x59,0x92,0xa3,0x60,0x60,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,
  0x59,0x59,0x9f,0x01,0x03,0x01,0x04,0x03,0xd5,0x03,0xcc,0x01,0xbc,0x03,0xf0,
  0x10,0x10,0x10,0x10,0x50,0x50,0x50,0x50,0x14,0x20,0x20,0x20,0x20,0x01,0x01,
  0x01,0x01,0xc4,0x02,0x10,0x00,0x00,0x00,0x00,0x01,0x01,0xc0,0xc2,0x10,0x11,
  0x02,0x03,0x11,0x03,0x03,0x04,0x00,0x00,0x14,0x00,0x02,0x00,0x00,0xc6,0xc8,
  0x02,0x02,0x02,0x02,0x00,0x00,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0xff,0xca,
  0x01,0x01,0x01,0x00,0x06,0x00,0x04,0x00,0xc0,0xc2,0x01,0x01,0x03,0x01,0xff,
  0xff,0x01,0x00,0x03,0xc4,0xc4,0xc6,0x03,0x01,0x01,0x01,0xff,0x03,0x03,0x03,
  0xc8,0x40,0x00,0x0a,0x00,0x04,0x00,0x00,0x00,0x00,0x7f,0x00,0x33,0x01,0x00,
  0x00,0x00,0x00,0x00,0x00,0xff,0xbf,0xff,0xff,0x00,0x00,0x00,0x00,0x07,0x00,
  0x00,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0xff,0xff,0x00,0x00,0x00,0xbf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x7f,0x00,0x00,0xff,0x4a,0x4a,0x4a,0x4a,0x4b,0x52,0x4a,0x4a,0x4a,0x4a,0x4f,
  0x4c,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x55,0x45,0x40,0x4a,0x4a,0x4a,
  0x45,0x59,0x4d,0x46,0x4a,0x5d,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,
  0x4a,0x4a,0x4a,0x4a,0x4a,0x61,0x63,0x67,0x4e,0x4a,0x4a,0x6b,0x6d,0x4a,0x4a,
  0x45,0x6d,0x4a,0x4a,0x44,0x45,0x4a,0x4a,0x00,0x00,0x00,0x02,0x0d,0x06,0x06,
  0x06,0x06,0x0e,0x00,0x00,0x00,0x00,0x06,0x06,0x06,0x00,0x06,0x06,0x02,0x06,
  0x00,0x0a,0x0a,0x07,0x07,0x06,0x02,0x05,0x05,0x02,0x02,0x00,0x00,0x04,0x04,
  0x04,0x04,0x00,0x00,0x00,0x0e,0x05,0x06,0x06,0x06,0x01,0x06,0x00,0x00,0x08,
  0x00,0x10,0x00,0x18,0x00,0x20,0x00,0x28,0x00,0x30,0x00,0x80,0x01,0x82,0x01,
  0x86,0x00,0xf6,0xcf,0xfe,0x3f,0xab,0x00,0xb0,0x00,0xb1,0x00,0xb3,0x00,0xba,
  0xf8,0xbb,0x00,0xc0,0x00,0xc1,0x00,0xc7,0xbf,0x62,0xff,0x00,0x8d,0xff,0x00,
  0xc4,0xff,0x00,0xc5,0xff,0x00,0xff,0xff,0xeb,0x01,0xff,0x0e,0x12,0x08,0x00,
  0x13,0x09,0x00,0x16,0x08,0x00,0x17,0x09,0x00,0x2b,0x09,0x00,0xae,0xff,0x07,
  0xb2,0xff,0x00,0xb4,0xff,0x00,0xb5,0xff,0x00,0xc3,0x01,0x00,0xc7,0xff,0xbf,
  0xe7,0x08,0x00,0xf0,0x02,0x00
};

```

`sdk/external/minhook/hde/table64.h`:

```h
/*
 * Hacker Disassembler Engine 64 C
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 */

#define C_NONE    0x00
#define C_MODRM   0x01
#define C_IMM8    0x02
#define C_IMM16   0x04
#define C_IMM_P66 0x10
#define C_REL8    0x20
#define C_REL32   0x40
#define C_GROUP   0x80
#define C_ERROR   0xff

#define PRE_ANY  0x00
#define PRE_NONE 0x01
#define PRE_F2   0x02
#define PRE_F3   0x04
#define PRE_66   0x08
#define PRE_67   0x10
#define PRE_LOCK 0x20
#define PRE_SEG  0x40
#define PRE_ALL  0xff

#define DELTA_OPCODES      0x4a
#define DELTA_FPU_REG      0xfd
#define DELTA_FPU_MODRM    0x104
#define DELTA_PREFIXES     0x13c
#define DELTA_OP_LOCK_OK   0x1ae
#define DELTA_OP2_LOCK_OK  0x1c6
#define DELTA_OP_ONLY_MEM  0x1d8
#define DELTA_OP2_ONLY_MEM 0x1e7

unsigned char hde64_table[] = {
  0xa5,0xaa,0xa5,0xb8,0xa5,0xaa,0xa5,0xaa,0xa5,0xb8,0xa5,0xb8,0xa5,0xb8,0xa5,
  0xb8,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xac,0xc0,0xcc,0xc0,0xa1,0xa1,
  0xa1,0xa1,0xb1,0xa5,0xa5,0xa6,0xc0,0xc0,0xd7,0xda,0xe0,0xc0,0xe4,0xc0,0xea,
  0xea,0xe0,0xe0,0x98,0xc8,0xee,0xf1,0xa5,0xd3,0xa5,0xa5,0xa1,0xea,0x9e,0xc0,
  0xc0,0xc2,0xc0,0xe6,0x03,0x7f,0x11,0x7f,0x01,0x7f,0x01,0x3f,0x01,0x01,0xab,
  0x8b,0x90,0x64,0x5b,0x5b,0x5b,0x5b,0x5b,0x92,0x5b,0x5b,0x76,0x90,0x92,0x92,
  0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x6a,0x73,0x90,
  0x5b,0x52,0x52,0x52,0x52,0x5b,0x5b,0x5b,0x5b,0x77,0x7c,0x77,0x85,0x5b,0x5b,
  0x70,0x5b,0x7a,0xaf,0x76,0x76,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,
  0x5b,0x5b,0x86,0x01,0x03,0x01,0x04,0x03,0xd5,0x03,0xd5,0x03,0xcc,0x01,0xbc,
  0x03,0xf0,0x03,0x03,0x04,0x00,0x50,0x50,0x50,0x50,0xff,0x20,0x20,0x20,0x20,
  0x01,0x01,0x01,0x01,0xc4,0x02,0x10,0xff,0xff,0xff,0x01,0x00,0x03,0x11,0xff,
  0x03,0xc4,0xc6,0xc8,0x02,0x10,0x00,0xff,0xcc,0x01,0x01,0x01,0x00,0x00,0x00,
  0x00,0x01,0x01,0x03,0x01,0xff,0xff,0xc0,0xc2,0x10,0x11,0x02,0x03,0x01,0x01,
  0x01,0xff,0xff,0xff,0x00,0x00,0x00,0xff,0x00,0x00,0xff,0xff,0xff,0xff,0x10,
  0x10,0x10,0x10,0x02,0x10,0x00,0x00,0xc6,0xc8,0x02,0x02,0x02,0x02,0x06,0x00,
  0x04,0x00,0x02,0xff,0x00,0xc0,0xc2,0x01,0x01,0x03,0x03,0x03,0xca,0x40,0x00,
  0x0a,0x00,0x04,0x00,0x00,0x00,0x00,0x7f,0x00,0x33,0x01,0x00,0x00,0x00,0x00,
  0x00,0x00,0xff,0xbf,0xff,0xff,0x00,0x00,0x00,0x00,0x07,0x00,0x00,0xff,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,
  0x00,0x00,0x00,0xbf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7f,0x00,0x00,
  0xff,0x40,0x40,0x40,0x40,0x41,0x49,0x40,0x40,0x40,0x40,0x4c,0x42,0x40,0x40,
  0x40,0x40,0x40,0x40,0x40,0x40,0x4f,0x44,0x53,0x40,0x40,0x40,0x44,0x57,0x43,
  0x5c,0x40,0x60,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,
  0x40,0x40,0x64,0x66,0x6e,0x6b,0x40,0x40,0x6a,0x46,0x40,0x40,0x44,0x46,0x40,
  0x40,0x5b,0x44,0x40,0x40,0x00,0x00,0x00,0x00,0x06,0x06,0x06,0x06,0x01,0x06,
  0x06,0x02,0x06,0x06,0x00,0x06,0x00,0x0a,0x0a,0x00,0x00,0x00,0x02,0x07,0x07,
  0x06,0x02,0x0d,0x06,0x06,0x06,0x0e,0x05,0x05,0x02,0x02,0x00,0x00,0x04,0x04,
  0x04,0x04,0x05,0x06,0x06,0x06,0x00,0x00,0x00,0x0e,0x00,0x00,0x08,0x00,0x10,
  0x00,0x18,0x00,0x20,0x00,0x28,0x00,0x30,0x00,0x80,0x01,0x82,0x01,0x86,0x00,
  0xf6,0xcf,0xfe,0x3f,0xab,0x00,0xb0,0x00,0xb1,0x00,0xb3,0x00,0xba,0xf8,0xbb,
  0x00,0xc0,0x00,0xc1,0x00,0xc7,0xbf,0x62,0xff,0x00,0x8d,0xff,0x00,0xc4,0xff,
  0x00,0xc5,0xff,0x00,0xff,0xff,0xeb,0x01,0xff,0x0e,0x12,0x08,0x00,0x13,0x09,
  0x00,0x16,0x08,0x00,0x17,0x09,0x00,0x2b,0x09,0x00,0xae,0xff,0x07,0xb2,0xff,
  0x00,0xb4,0xff,0x00,0xb5,0xff,0x00,0xc3,0x01,0x00,0xc7,0xff,0xbf,0xe7,0x08,
  0x00,0xf0,0x02,0x00
};

```

`sdk/external/minhook/hook.c`:

```c
/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2017 Tsuda Kageyu.
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 *  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 *  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
 *  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <windows.h>
#include <tlhelp32.h>
#include <limits.h>

#include "include/minhook.h"
#include "buffer.h"
#include "trampoline.h"

#ifndef ARRAYSIZE
    #define ARRAYSIZE(A) (sizeof(A)/sizeof((A)[0]))
#endif

// Initial capacity of the HOOK_ENTRY buffer.
#define INITIAL_HOOK_CAPACITY   32

// Initial capacity of the thread IDs buffer.
#define INITIAL_THREAD_CAPACITY 128

// Special hook position values.
#define INVALID_HOOK_POS UINT_MAX
#define ALL_HOOKS_POS    UINT_MAX

// Freeze() action argument defines.
#define ACTION_DISABLE      0
#define ACTION_ENABLE       1
#define ACTION_APPLY_QUEUED 2

// Thread access rights for suspending/resuming threads.
#define THREAD_ACCESS \
    (THREAD_SUSPEND_RESUME | THREAD_GET_CONTEXT | THREAD_QUERY_INFORMATION | THREAD_SET_CONTEXT)

// Hook information.
typedef struct _HOOK_ENTRY
{
    LPVOID pTarget;             // Address of the target function.
    LPVOID pDetour;             // Address of the detour or relay function.
    LPVOID pTrampoline;         // Address of the trampoline function.
    UINT8  backup[8];           // Original prologue of the target function.

    UINT8  patchAbove  : 1;     // Uses the hot patch area.
    UINT8  isEnabled   : 1;     // Enabled.
    UINT8  queueEnable : 1;     // Queued for enabling/disabling when != isEnabled.

    UINT   nIP : 4;             // Count of the instruction boundaries.
    UINT8  oldIPs[8];           // Instruction boundaries of the target function.
    UINT8  newIPs[8];           // Instruction boundaries of the trampoline function.
} HOOK_ENTRY, *PHOOK_ENTRY;

// Suspended threads for Freeze()/Unfreeze().
typedef struct _FROZEN_THREADS
{
    LPDWORD pItems;         // Data heap
    UINT    capacity;       // Size of allocated data heap, items
    UINT    size;           // Actual number of data items
} FROZEN_THREADS, *PFROZEN_THREADS;

//-------------------------------------------------------------------------
// Global Variables:
//-------------------------------------------------------------------------

// Spin lock flag for EnterSpinLock()/LeaveSpinLock().
volatile LONG g_isLocked = FALSE;

// Private heap handle. If not NULL, this library is initialized.
HANDLE g_hHeap = NULL;

// Hook entries.
struct
{
    PHOOK_ENTRY pItems;     // Data heap
    UINT        capacity;   // Size of allocated data heap, items
    UINT        size;       // Actual number of data items
} g_hooks;

//-------------------------------------------------------------------------
// Returns INVALID_HOOK_POS if not found.
static UINT FindHookEntry(LPVOID pTarget)
{
    UINT i;
    for (i = 0; i < g_hooks.size; ++i)
    {
        if ((ULONG_PTR)pTarget == (ULONG_PTR)g_hooks.pItems[i].pTarget)
            return i;
    }

    return INVALID_HOOK_POS;
}

//-------------------------------------------------------------------------
static PHOOK_ENTRY AddHookEntry()
{
    if (g_hooks.pItems == NULL)
    {
        g_hooks.capacity = INITIAL_HOOK_CAPACITY;
        g_hooks.pItems = (PHOOK_ENTRY)HeapAlloc(
            g_hHeap, 0, g_hooks.capacity * sizeof(HOOK_ENTRY));
        if (g_hooks.pItems == NULL)
            return NULL;
    }
    else if (g_hooks.size >= g_hooks.capacity)
    {
        PHOOK_ENTRY p = (PHOOK_ENTRY)HeapReAlloc(
            g_hHeap, 0, g_hooks.pItems, (g_hooks.capacity * 2) * sizeof(HOOK_ENTRY));
        if (p == NULL)
            return NULL;

        g_hooks.capacity *= 2;
        g_hooks.pItems = p;
    }

    return &g_hooks.pItems[g_hooks.size++];
}

//-------------------------------------------------------------------------
static VOID DeleteHookEntry(UINT pos)
{
    if (pos < g_hooks.size - 1)
        g_hooks.pItems[pos] = g_hooks.pItems[g_hooks.size - 1];

    g_hooks.size--;

    if (g_hooks.capacity / 2 >= INITIAL_HOOK_CAPACITY && g_hooks.capacity / 2 >= g_hooks.size)
    {
        PHOOK_ENTRY p = (PHOOK_ENTRY)HeapReAlloc(
            g_hHeap, 0, g_hooks.pItems, (g_hooks.capacity / 2) * sizeof(HOOK_ENTRY));
        if (p == NULL)
            return;

        g_hooks.capacity /= 2;
        g_hooks.pItems = p;
    }
}

//-------------------------------------------------------------------------
static DWORD_PTR FindOldIP(PHOOK_ENTRY pHook, DWORD_PTR ip)
{
    UINT i;

    if (pHook->patchAbove && ip == ((DWORD_PTR)pHook->pTarget - sizeof(JMP_REL)))
        return (DWORD_PTR)pHook->pTarget;

    for (i = 0; i < pHook->nIP; ++i)
    {
        if (ip == ((DWORD_PTR)pHook->pTrampoline + pHook->newIPs[i]))
            return (DWORD_PTR)pHook->pTarget + pHook->oldIPs[i];
    }

#if defined(_M_X64) || defined(__x86_64__)
    // Check relay function.
    if (ip == (DWORD_PTR)pHook->pDetour)
        return (DWORD_PTR)pHook->pTarget;
#endif

    return 0;
}

//-------------------------------------------------------------------------
static DWORD_PTR FindNewIP(PHOOK_ENTRY pHook, DWORD_PTR ip)
{
    UINT i;
    for (i = 0; i < pHook->nIP; ++i)
    {
        if (ip == ((DWORD_PTR)pHook->pTarget + pHook->oldIPs[i]))
            return (DWORD_PTR)pHook->pTrampoline + pHook->newIPs[i];
    }

    return 0;
}

//-------------------------------------------------------------------------
static VOID ProcessThreadIPs(HANDLE hThread, UINT pos, UINT action)
{
    // If the thread suspended in the overwritten area,
    // move IP to the proper address.

    CONTEXT c;
#if defined(_M_X64) || defined(__x86_64__)
    DWORD64 *pIP = &c.Rip;
#else
    DWORD   *pIP = &c.Eip;
#endif
    UINT count;

    c.ContextFlags = CONTEXT_CONTROL;
    if (!GetThreadContext(hThread, &c))
        return;

    if (pos == ALL_HOOKS_POS)
    {
        pos = 0;
        count = g_hooks.size;
    }
    else
    {
        count = pos + 1;
    }

    for (; pos < count; ++pos)
    {
        PHOOK_ENTRY pHook = &g_hooks.pItems[pos];
        BOOL        enable;
        DWORD_PTR   ip;

        switch (action)
        {
        case ACTION_DISABLE:
            enable = FALSE;
            break;

        case ACTION_ENABLE:
            enable = TRUE;
            break;

        default: // ACTION_APPLY_QUEUED
            enable = pHook->queueEnable;
            break;
        }
        if (pHook->isEnabled == enable)
            continue;

        if (enable)
            ip = FindNewIP(pHook, *pIP);
        else
            ip = FindOldIP(pHook, *pIP);

        if (ip != 0)
        {
            *pIP = ip;
            SetThreadContext(hThread, &c);
        }
    }
}

//-------------------------------------------------------------------------
static BOOL EnumerateThreads(PFROZEN_THREADS pThreads)
{
    BOOL succeeded = FALSE;

    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
    if (hSnapshot != INVALID_HANDLE_VALUE)
    {
        THREADENTRY32 te;
        te.dwSize = sizeof(THREADENTRY32);
        if (Thread32First(hSnapshot, &te))
        {
            succeeded = TRUE;
            do
            {
                if (te.dwSize >= (FIELD_OFFSET(THREADENTRY32, th32OwnerProcessID) + sizeof(DWORD))
                    && te.th32OwnerProcessID == GetCurrentProcessId()
                    && te.th32ThreadID != GetCurrentThreadId())
                {
                    if (pThreads->pItems == NULL)
                    {
                        pThreads->capacity = INITIAL_THREAD_CAPACITY;
                        pThreads->pItems
                            = (LPDWORD)HeapAlloc(g_hHeap, 0, pThreads->capacity * sizeof(DWORD));
                        if (pThreads->pItems == NULL)
                        {
                            succeeded = FALSE;
                            break;
                        }
                    }
                    else if (pThreads->size >= pThreads->capacity)
                    {
                        pThreads->capacity *= 2;
                        LPDWORD p = (LPDWORD)HeapReAlloc(
                            g_hHeap, 0, pThreads->pItems, pThreads->capacity * sizeof(DWORD));
                        if (p == NULL)
                        {
                            succeeded = FALSE;
                            break;
                        }

                        pThreads->pItems = p;
                    }
                    pThreads->pItems[pThreads->size++] = te.th32ThreadID;
                }

                te.dwSize = sizeof(THREADENTRY32);
            } while (Thread32Next(hSnapshot, &te));

            if (succeeded && GetLastError() != ERROR_NO_MORE_FILES)
                succeeded = FALSE;

            if (!succeeded && pThreads->pItems != NULL)
            {
                HeapFree(g_hHeap, 0, pThreads->pItems);
                pThreads->pItems = NULL;
            }
        }
        CloseHandle(hSnapshot);
    }

    return succeeded;
}

//-------------------------------------------------------------------------
static MH_STATUS Freeze(PFROZEN_THREADS pThreads, UINT pos, UINT action)
{
    MH_STATUS status = MH_OK;

    pThreads->pItems   = NULL;
    pThreads->capacity = 0;
    pThreads->size     = 0;
    if (!EnumerateThreads(pThreads))
    {
        status = MH_ERROR_MEMORY_ALLOC;
    }
    else if (pThreads->pItems != NULL)
    {
        UINT i;
        for (i = 0; i < pThreads->size; ++i)
        {
            HANDLE hThread = OpenThread(THREAD_ACCESS, FALSE, pThreads->pItems[i]);
            if (hThread != NULL)
            {
                SuspendThread(hThread);
                ProcessThreadIPs(hThread, pos, action);
                CloseHandle(hThread);
            }
        }
    }

    return status;
}

//-------------------------------------------------------------------------
static VOID Unfreeze(PFROZEN_THREADS pThreads)
{
    if (pThreads->pItems != NULL)
    {
        UINT i;
        for (i = 0; i < pThreads->size; ++i)
        {
            HANDLE hThread = OpenThread(THREAD_ACCESS, FALSE, pThreads->pItems[i]);
            if (hThread != NULL)
            {
                ResumeThread(hThread);
                CloseHandle(hThread);
            }
        }

        HeapFree(g_hHeap, 0, pThreads->pItems);
    }
}

//-------------------------------------------------------------------------
static MH_STATUS EnableHookLL(UINT pos, BOOL enable)
{
    PHOOK_ENTRY pHook = &g_hooks.pItems[pos];
    DWORD  oldProtect;
    SIZE_T patchSize    = sizeof(JMP_REL);
    LPBYTE pPatchTarget = (LPBYTE)pHook->pTarget;

    if (pHook->patchAbove)
    {
        pPatchTarget -= sizeof(JMP_REL);
        patchSize    += sizeof(JMP_REL_SHORT);
    }

    if (!VirtualProtect(pPatchTarget, patchSize, PAGE_EXECUTE_READWRITE, &oldProtect))
        return MH_ERROR_MEMORY_PROTECT;

    if (enable)
    {
        PJMP_REL pJmp = (PJMP_REL)pPatchTarget;
        pJmp->opcode = 0xE9;
        pJmp->operand = (UINT32)((LPBYTE)pHook->pDetour - (pPatchTarget + sizeof(JMP_REL)));

        if (pHook->patchAbove)
        {
            PJMP_REL_SHORT pShortJmp = (PJMP_REL_SHORT)pHook->pTarget;
            pShortJmp->opcode = 0xEB;
            pShortJmp->operand = (UINT8)(0 - (sizeof(JMP_REL_SHORT) + sizeof(JMP_REL)));
        }
    }
    else
    {
        if (pHook->patchAbove)
            memcpy(pPatchTarget, pHook->backup, sizeof(JMP_REL) + sizeof(JMP_REL_SHORT));
        else
            memcpy(pPatchTarget, pHook->backup, sizeof(JMP_REL));
    }

    VirtualProtect(pPatchTarget, patchSize, oldProtect, &oldProtect);

    // Just-in-case measure.
    FlushInstructionCache(GetCurrentProcess(), pPatchTarget, patchSize);

    pHook->isEnabled   = enable;
    pHook->queueEnable = enable;

    return MH_OK;
}

//-------------------------------------------------------------------------
static MH_STATUS EnableAllHooksLL(BOOL enable)
{
    MH_STATUS status = MH_OK;
    UINT i, first = INVALID_HOOK_POS;

    for (i = 0; i < g_hooks.size; ++i)
    {
        if (g_hooks.pItems[i].isEnabled != enable)
        {
            first = i;
            break;
        }
    }

    if (first != INVALID_HOOK_POS)
    {
        FROZEN_THREADS threads;
        status = Freeze(&threads, ALL_HOOKS_POS, enable ? ACTION_ENABLE : ACTION_DISABLE);
        if (status == MH_OK)
        {
            for (i = first; i < g_hooks.size; ++i)
            {
                if (g_hooks.pItems[i].isEnabled != enable)
                {
                    status = EnableHookLL(i, enable);
                    if (status != MH_OK)
                        break;
                }
            }

            Unfreeze(&threads);
        }
    }

    return status;
}

//-------------------------------------------------------------------------
static VOID EnterSpinLock(VOID)
{
    SIZE_T spinCount = 0;

    // Wait until the flag is FALSE.
    while (InterlockedCompareExchange(&g_isLocked, TRUE, FALSE) != FALSE)
    {
        // No need to generate a memory barrier here, since InterlockedCompareExchange()
        // generates a full memory barrier itself.

        // Prevent the loop from being too busy.
        if (spinCount < 32)
            Sleep(0);
        else
            Sleep(1);

        spinCount++;
    }
}

//-------------------------------------------------------------------------
static VOID LeaveSpinLock(VOID)
{
    // No need to generate a memory barrier here, since InterlockedExchange()
    // generates a full memory barrier itself.

    InterlockedExchange(&g_isLocked, FALSE);
}

//-------------------------------------------------------------------------
MH_STATUS WINAPI MH_Initialize(VOID)
{
    MH_STATUS status = MH_OK;

    EnterSpinLock();

    if (g_hHeap == NULL)
    {
        g_hHeap = HeapCreate(0, 0, 0);
        if (g_hHeap != NULL)
        {
            // Initialize the internal function buffer.
            InitializeBuffer();
        }
        else
        {
            status = MH_ERROR_MEMORY_ALLOC;
        }
    }
    else
    {
        status = MH_ERROR_ALREADY_INITIALIZED;
    }

    LeaveSpinLock();

    return status;
}

//-------------------------------------------------------------------------
MH_STATUS WINAPI MH_Uninitialize(VOID)
{
    MH_STATUS status = MH_OK;

    EnterSpinLock();

    if (g_hHeap != NULL)
    {
        status = EnableAllHooksLL(FALSE);
        if (status == MH_OK)
        {
            // Free the internal function buffer.

            // HeapFree is actually not required, but some tools detect a false
            // memory leak without HeapFree.

            UninitializeBuffer();

            HeapFree(g_hHeap, 0, g_hooks.pItems);
            HeapDestroy(g_hHeap);

            g_hHeap = NULL;

            g_hooks.pItems   = NULL;
            g_hooks.capacity = 0;
            g_hooks.size     = 0;
        }
    }
    else
    {
        status = MH_ERROR_NOT_INITIALIZED;
    }

    LeaveSpinLock();

    return status;
}

//-------------------------------------------------------------------------
MH_STATUS WINAPI MH_CreateHook(LPVOID pTarget, LPVOID pDetour, LPVOID *ppOriginal)
{
    MH_STATUS status = MH_OK;

    EnterSpinLock();

    if (g_hHeap != NULL)
    {
        if (IsExecutableAddress(pTarget) && IsExecutableAddress(pDetour))
        {
            UINT pos = FindHookEntry(pTarget);
            if (pos == INVALID_HOOK_POS)
            {
                LPVOID pBuffer = AllocateBuffer(pTarget);
                if (pBuffer != NULL)
                {
                    TRAMPOLINE ct;

                    ct.pTarget     = pTarget;
                    ct.pDetour     = pDetour;
                    ct.pTrampoline = pBuffer;
                    if (CreateTrampolineFunction(&ct))
                    {
                        PHOOK_ENTRY pHook = AddHookEntry();
                        if (pHook != NULL)
                        {
                            pHook->pTarget     = ct.pTarget;
#if defined(_M_X64) || defined(__x86_64__)
                            pHook->pDetour     = ct.pRelay;
#else
                            pHook->pDetour     = ct.pDetour;
#endif
                            pHook->pTrampoline = ct.pTrampoline;
                            pHook->patchAbove  = ct.patchAbove;
                            pHook->isEnabled   = FALSE;
                            pHook->queueEnable = FALSE;
                            pHook->nIP         = ct.nIP;
                            memcpy(pHook->oldIPs, ct.oldIPs, ARRAYSIZE(ct.oldIPs));
                            memcpy(pHook->newIPs, ct.newIPs, ARRAYSIZE(ct.newIPs));

                            // Back up the target function.

                            if (ct.patchAbove)
                            {
                                memcpy(
                                    pHook->backup,
                                    (LPBYTE)pTarget - sizeof(JMP_REL),
                                    sizeof(JMP_REL) + sizeof(JMP_REL_SHORT));
                            }
                            else
                            {
                                memcpy(pHook->backup, pTarget, sizeof(JMP_REL));
                            }

                            if (ppOriginal != NULL)
                                *ppOriginal = pHook->pTrampoline;
                        }
                        else
                        {
                            status = MH_ERROR_MEMORY_ALLOC;
                        }
                    }
                    else
                    {
                        status = MH_ERROR_UNSUPPORTED_FUNCTION;
                    }

                    if (status != MH_OK)
                    {
                        FreeBuffer(pBuffer);
                    }
                }
                else
                {
                    status = MH_ERROR_MEMORY_ALLOC;
                }
            }
            else
            {
                status = MH_ERROR_ALREADY_CREATED;
            }
        }
        else
        {
            status = MH_ERROR_NOT_EXECUTABLE;
        }
    }
    else
    {
        status = MH_ERROR_NOT_INITIALIZED;
    }

    LeaveSpinLock();

    return status;
}

//-------------------------------------------------------------------------
MH_STATUS WINAPI MH_RemoveHook(LPVOID pTarget)
{
    MH_STATUS status = MH_OK;

    EnterSpinLock();

    if (g_hHeap != NULL)
    {
        UINT pos = FindHookEntry(pTarget);
        if (pos != INVALID_HOOK_POS)
        {
            if (g_hooks.pItems[pos].isEnabled)
            {
                FROZEN_THREADS threads;
                status = Freeze(&threads, pos, ACTION_DISABLE);
                if (status == MH_OK)
                {
                    status = EnableHookLL(pos, FALSE);

                    Unfreeze(&threads);
                }
            }

            if (status == MH_OK)
            {
                FreeBuffer(g_hooks.pItems[pos].pTrampoline);
                DeleteHookEntry(pos);
            }
        }
        else
        {
            status = MH_ERROR_NOT_CREATED;
        }
    }
    else
    {
        status = MH_ERROR_NOT_INITIALIZED;
    }

    LeaveSpinLock();

    return status;
}

//-------------------------------------------------------------------------
static MH_STATUS EnableHook(LPVOID pTarget, BOOL enable)
{
    MH_STATUS status = MH_OK;

    EnterSpinLock();

    if (g_hHeap != NULL)
    {
        if (pTarget == MH_ALL_HOOKS)
        {
            status = EnableAllHooksLL(enable);
        }
        else
        {
            UINT pos = FindHookEntry(pTarget);
            if (pos != INVALID_HOOK_POS)
            {
                if (g_hooks.pItems[pos].isEnabled != enable)
                {
                    FROZEN_THREADS threads;
                    status = Freeze(&threads, pos, ACTION_ENABLE);
                    if (status == MH_OK)
                    {
                        status = EnableHookLL(pos, enable);

                        Unfreeze(&threads);
                    }
                }
                else
                {
                    status = enable ? MH_ERROR_ENABLED : MH_ERROR_DISABLED;
                }
            }
            else
            {
                status = MH_ERROR_NOT_CREATED;
            }
        }
    }
    else
    {
        status = MH_ERROR_NOT_INITIALIZED;
    }

    LeaveSpinLock();

    return status;
}

//-------------------------------------------------------------------------
MH_STATUS WINAPI MH_EnableHook(LPVOID pTarget)
{
    return EnableHook(pTarget, TRUE);
}

//-------------------------------------------------------------------------
MH_STATUS WINAPI MH_DisableHook(LPVOID pTarget)
{
    return EnableHook(pTarget, FALSE);
}

//-------------------------------------------------------------------------
static MH_STATUS QueueHook(LPVOID pTarget, BOOL queueEnable)
{
    MH_STATUS status = MH_OK;

    EnterSpinLock();

    if (g_hHeap != NULL)
    {
        if (pTarget == MH_ALL_HOOKS)
        {
            UINT i;
            for (i = 0; i < g_hooks.size; ++i)
                g_hooks.pItems[i].queueEnable = queueEnable;
        }
        else
        {
            UINT pos = FindHookEntry(pTarget);
            if (pos != INVALID_HOOK_POS)
            {
                g_hooks.pItems[pos].queueEnable = queueEnable;
            }
            else
            {
                status = MH_ERROR_NOT_CREATED;
            }
        }
    }
    else
    {
        status = MH_ERROR_NOT_INITIALIZED;
    }

    LeaveSpinLock();

    return status;
}

//-------------------------------------------------------------------------
MH_STATUS WINAPI MH_QueueEnableHook(LPVOID pTarget)
{
    return QueueHook(pTarget, TRUE);
}

//-------------------------------------------------------------------------
MH_STATUS WINAPI MH_QueueDisableHook(LPVOID pTarget)
{
    return QueueHook(pTarget, FALSE);
}

//-------------------------------------------------------------------------
MH_STATUS WINAPI MH_ApplyQueued(VOID)
{
    MH_STATUS status = MH_OK;
    UINT i, first = INVALID_HOOK_POS;

    EnterSpinLock();

    if (g_hHeap != NULL)
    {
        for (i = 0; i < g_hooks.size; ++i)
        {
            if (g_hooks.pItems[i].isEnabled != g_hooks.pItems[i].queueEnable)
            {
                first = i;
                break;
            }
        }

        if (first != INVALID_HOOK_POS)
        {
            FROZEN_THREADS threads;
            status = Freeze(&threads, ALL_HOOKS_POS, ACTION_APPLY_QUEUED);
            if (status == MH_OK)
            {
                for (i = first; i < g_hooks.size; ++i)
                {
                    PHOOK_ENTRY pHook = &g_hooks.pItems[i];
                    if (pHook->isEnabled != pHook->queueEnable)
                    {
                        status = EnableHookLL(i, pHook->queueEnable);
                        if (status != MH_OK)
                            break;
                    }
                }

                Unfreeze(&threads);
            }
        }
    }
    else
    {
        status = MH_ERROR_NOT_INITIALIZED;
    }

    LeaveSpinLock();

    return status;
}

//-------------------------------------------------------------------------
MH_STATUS WINAPI MH_CreateHookApiEx(
    LPCWSTR pszModule, LPCSTR pszProcName, LPVOID pDetour,
    LPVOID *ppOriginal, LPVOID *ppTarget)
{
    HMODULE hModule;
    LPVOID  pTarget;

    hModule = GetModuleHandleW(pszModule);
    if (hModule == NULL)
        return MH_ERROR_MODULE_NOT_FOUND;

    pTarget = (LPVOID)GetProcAddress(hModule, pszProcName);
    if (pTarget == NULL)
        return MH_ERROR_FUNCTION_NOT_FOUND;

    if(ppTarget != NULL)
        *ppTarget = pTarget;

    return MH_CreateHook(pTarget, pDetour, ppOriginal);
}

//-------------------------------------------------------------------------
MH_STATUS WINAPI MH_CreateHookApi(
    LPCWSTR pszModule, LPCSTR pszProcName, LPVOID pDetour, LPVOID *ppOriginal)
{
   return MH_CreateHookApiEx(pszModule, pszProcName, pDetour, ppOriginal, NULL);
}

//-------------------------------------------------------------------------
const char * WINAPI MH_StatusToString(MH_STATUS status)
{
#define MH_ST2STR(x)    \
    case x:             \
        return #x;

    switch (status) {
        MH_ST2STR(MH_UNKNOWN)
        MH_ST2STR(MH_OK)
        MH_ST2STR(MH_ERROR_ALREADY_INITIALIZED)
        MH_ST2STR(MH_ERROR_NOT_INITIALIZED)
        MH_ST2STR(MH_ERROR_ALREADY_CREATED)
        MH_ST2STR(MH_ERROR_NOT_CREATED)
        MH_ST2STR(MH_ERROR_ENABLED)
        MH_ST2STR(MH_ERROR_DISABLED)
        MH_ST2STR(MH_ERROR_NOT_EXECUTABLE)
        MH_ST2STR(MH_ERROR_UNSUPPORTED_FUNCTION)
        MH_ST2STR(MH_ERROR_MEMORY_ALLOC)
        MH_ST2STR(MH_ERROR_MEMORY_PROTECT)
        MH_ST2STR(MH_ERROR_MODULE_NOT_FOUND)
        MH_ST2STR(MH_ERROR_FUNCTION_NOT_FOUND)
    }

#undef MH_ST2STR

    return "(unknown)";
}

```

`sdk/external/minhook/include/minhook.h`:

```h
/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2017 Tsuda Kageyu.
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 *  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 *  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
 *  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#pragma once

#if !(defined _M_IX86) && !(defined _M_X64) && !(defined __i386__) && !(defined __x86_64__)
    #error MinHook supports only x86 and x64 systems.
#endif

#include <windows.h>

// MinHook Error Codes.
typedef enum MH_STATUS
{
    // Unknown error. Should not be returned.
    MH_UNKNOWN = -1,

    // Successful.
    MH_OK = 0,

    // MinHook is already initialized.
    MH_ERROR_ALREADY_INITIALIZED,

    // MinHook is not initialized yet, or already uninitialized.
    MH_ERROR_NOT_INITIALIZED,

    // The hook for the specified target function is already created.
    MH_ERROR_ALREADY_CREATED,

    // The hook for the specified target function is not created yet.
    MH_ERROR_NOT_CREATED,

    // The hook for the specified target function is already enabled.
    MH_ERROR_ENABLED,

    // The hook for the specified target function is not enabled yet, or already
    // disabled.
    MH_ERROR_DISABLED,

    // The specified pointer is invalid. It points the address of non-allocated
    // and/or non-executable region.
    MH_ERROR_NOT_EXECUTABLE,

    // The specified target function cannot be hooked.
    MH_ERROR_UNSUPPORTED_FUNCTION,

    // Failed to allocate memory.
    MH_ERROR_MEMORY_ALLOC,

    // Failed to change the memory protection.
    MH_ERROR_MEMORY_PROTECT,

    // The specified module is not loaded.
    MH_ERROR_MODULE_NOT_FOUND,

    // The specified function is not found.
    MH_ERROR_FUNCTION_NOT_FOUND
}
MH_STATUS;

// Can be passed as a parameter to MH_EnableHook, MH_DisableHook,
// MH_QueueEnableHook or MH_QueueDisableHook.
#define MH_ALL_HOOKS NULL

#ifdef __cplusplus
extern "C" {
#endif

    // Initialize the MinHook library. You must call this function EXACTLY ONCE
    // at the beginning of your program.
    MH_STATUS WINAPI MH_Initialize(VOID);

    // Uninitialize the MinHook library. You must call this function EXACTLY
    // ONCE at the end of your program.
    MH_STATUS WINAPI MH_Uninitialize(VOID);

    // Creates a hook for the specified target function, in disabled state.
    // Parameters:
    //   pTarget     [in]  A pointer to the target function, which will be
    //                     overridden by the detour function.
    //   pDetour     [in]  A pointer to the detour function, which will override
    //                     the target function.
    //   ppOriginal  [out] A pointer to the trampoline function, which will be
    //                     used to call the original target function.
    //                     This parameter can be NULL.
    MH_STATUS WINAPI MH_CreateHook(LPVOID pTarget, LPVOID pDetour, LPVOID *ppOriginal);

    // Creates a hook for the specified API function, in disabled state.
    // Parameters:
    //   pszModule   [in]  A pointer to the loaded module name which contains the
    //                     target function.
    //   pszProcName [in]  A pointer to the target function name, which will be
    //                     overridden by the detour function.
    //   pDetour     [in]  A pointer to the detour function, which will override
    //                     the target function.
    //   ppOriginal  [out] A pointer to the trampoline function, which will be
    //                     used to call the original target function.
    //                     This parameter can be NULL.
    MH_STATUS WINAPI MH_CreateHookApi(
        LPCWSTR pszModule, LPCSTR pszProcName, LPVOID pDetour, LPVOID *ppOriginal);

    // Creates a hook for the specified API function, in disabled state.
    // Parameters:
    //   pszModule   [in]  A pointer to the loaded module name which contains the
    //                     target function.
    //   pszProcName [in]  A pointer to the target function name, which will be
    //                     overridden by the detour function.
    //   pDetour     [in]  A pointer to the detour function, which will override
    //                     the target function.
    //   ppOriginal  [out] A pointer to the trampoline function, which will be
    //                     used to call the original target function.
    //                     This parameter can be NULL.
    //   ppTarget    [out] A pointer to the target function, which will be used
    //                     with other functions.
    //                     This parameter can be NULL.
    MH_STATUS WINAPI MH_CreateHookApiEx(
        LPCWSTR pszModule, LPCSTR pszProcName, LPVOID pDetour, LPVOID *ppOriginal, LPVOID *ppTarget);

    // Removes an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    MH_STATUS WINAPI MH_RemoveHook(LPVOID pTarget);

    // Enables an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                enabled in one go.
    MH_STATUS WINAPI MH_EnableHook(LPVOID pTarget);

    // Disables an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                disabled in one go.
    MH_STATUS WINAPI MH_DisableHook(LPVOID pTarget);

    // Queues to enable an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                queued to be enabled.
    MH_STATUS WINAPI MH_QueueEnableHook(LPVOID pTarget);

    // Queues to disable an already created hook.
    // Parameters:
    //   pTarget [in] A pointer to the target function.
    //                If this parameter is MH_ALL_HOOKS, all created hooks are
    //                queued to be disabled.
    MH_STATUS WINAPI MH_QueueDisableHook(LPVOID pTarget);

    // Applies all queued changes in one go.
    MH_STATUS WINAPI MH_ApplyQueued(VOID);

    // Translates the MH_STATUS to its name as a string.
    const char * WINAPI MH_StatusToString(MH_STATUS status);

#ifdef __cplusplus
}
#endif

```

`sdk/external/minhook/trampoline.c`:

```c
/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2017 Tsuda Kageyu.
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 *  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 *  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
 *  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <windows.h>

#ifdef _MSC_VER
    #include <intrin.h>
#endif

#ifndef ARRAYSIZE
    #define ARRAYSIZE(A) (sizeof(A)/sizeof((A)[0]))
#endif

#if defined(_M_X64) || defined(__x86_64__)
    #include "./hde/hde64.h"
    typedef hde64s HDE;
    #define HDE_DISASM(code, hs) hde64_disasm(code, hs)
#else
    #include "./hde/hde32.h"
    typedef hde32s HDE;
    #define HDE_DISASM(code, hs) hde32_disasm(code, hs)
#endif

#include "trampoline.h"
#include "buffer.h"

// Maximum size of a trampoline function.
#if defined(_M_X64) || defined(__x86_64__)
    #define TRAMPOLINE_MAX_SIZE (MEMORY_SLOT_SIZE - sizeof(JMP_ABS))
#else
    #define TRAMPOLINE_MAX_SIZE MEMORY_SLOT_SIZE
#endif

//-------------------------------------------------------------------------
static BOOL IsCodePadding(LPBYTE pInst, UINT size)
{
    UINT i;

    if (pInst[0] != 0x00 && pInst[0] != 0x90 && pInst[0] != 0xCC)
        return FALSE;

    for (i = 1; i < size; ++i)
    {
        if (pInst[i] != pInst[0])
            return FALSE;
    }
    return TRUE;
}

//-------------------------------------------------------------------------
BOOL CreateTrampolineFunction(PTRAMPOLINE ct)
{
#if defined(_M_X64) || defined(__x86_64__)
    CALL_ABS call = {
        0xFF, 0x15, 0x00000002, // FF15 00000002: CALL [RIP+8]
        0xEB, 0x08,             // EB 08:         JMP +10
        0x0000000000000000ULL   // Absolute destination address
    };
    JMP_ABS jmp = {
        0xFF, 0x25, 0x00000000, // FF25 00000000: JMP [RIP+6]
        0x0000000000000000ULL   // Absolute destination address
    };
    JCC_ABS jcc = {
        0x70, 0x0E,             // 7* 0E:         J** +16
        0xFF, 0x25, 0x00000000, // FF25 00000000: JMP [RIP+6]
        0x0000000000000000ULL   // Absolute destination address
    };
#else
    CALL_REL call = {
        0xE8,                   // E8 xxxxxxxx: CALL +5+xxxxxxxx
        0x00000000              // Relative destination address
    };
    JMP_REL jmp = {
        0xE9,                   // E9 xxxxxxxx: JMP +5+xxxxxxxx
        0x00000000              // Relative destination address
    };
    JCC_REL jcc = {
        0x0F, 0x80,             // 0F8* xxxxxxxx: J** +6+xxxxxxxx
        0x00000000              // Relative destination address
    };
#endif

    UINT8     oldPos   = 0;
    UINT8     newPos   = 0;
    ULONG_PTR jmpDest  = 0;     // Destination address of an internal jump.
    BOOL      finished = FALSE; // Is the function completed?
#if defined(_M_X64) || defined(__x86_64__)
    UINT8     instBuf[16];
#endif

    ct->patchAbove = FALSE;
    ct->nIP        = 0;

    do
    {
        HDE       hs;
        UINT      copySize;
        LPVOID    pCopySrc;
        ULONG_PTR pOldInst = (ULONG_PTR)ct->pTarget     + oldPos;
        ULONG_PTR pNewInst = (ULONG_PTR)ct->pTrampoline + newPos;

        copySize = HDE_DISASM((LPVOID)pOldInst, &hs);
        if (hs.flags & F_ERROR)
            return FALSE;

        pCopySrc = (LPVOID)pOldInst;
        if (oldPos >= sizeof(JMP_REL))
        {
            // The trampoline function is long enough.
            // Complete the function with the jump to the target function.
#if defined(_M_X64) || defined(__x86_64__)
            jmp.address = pOldInst;
#else
            jmp.operand = (UINT32)(pOldInst - (pNewInst + sizeof(jmp)));
#endif
            pCopySrc = &jmp;
            copySize = sizeof(jmp);

            finished = TRUE;
        }
#if defined(_M_X64) || defined(__x86_64__)
        else if ((hs.modrm & 0xC7) == 0x05)
        {
            // Instructions using RIP relative addressing. (ModR/M = 00???101B)

            // Modify the RIP relative address.
            PUINT32 pRelAddr;

            // Avoid using memcpy to reduce the footprint.
#ifndef _MSC_VER
            memcpy(instBuf, (LPBYTE)pOldInst, copySize);
#else
            __movsb(instBuf, (LPBYTE)pOldInst, copySize);
#endif
            pCopySrc = instBuf;

            // Relative address is stored at (instruction length - immediate value length - 4).
            pRelAddr = (PUINT32)(instBuf + hs.len - ((hs.flags & 0x3C) >> 2) - 4);
            *pRelAddr
                = (UINT32)((pOldInst + hs.len + (INT32)hs.disp.disp32) - (pNewInst + hs.len));

            // Complete the function if JMP (FF /4).
            if (hs.opcode == 0xFF && hs.modrm_reg == 4)
                finished = TRUE;
        }
#endif
        else if (hs.opcode == 0xE8)
        {
            // Direct relative CALL
            ULONG_PTR dest = pOldInst + hs.len + (INT32)hs.imm.imm32;
#if defined(_M_X64) || defined(__x86_64__)
            call.address = dest;
#else
            call.operand = (UINT32)(dest - (pNewInst + sizeof(call)));
#endif
            pCopySrc = &call;
            copySize = sizeof(call);
        }
        else if ((hs.opcode & 0xFD) == 0xE9)
        {
            // Direct relative JMP (EB or E9)
            ULONG_PTR dest = pOldInst + hs.len;

            if (hs.opcode == 0xEB) // isShort jmp
                dest += (INT8)hs.imm.imm8;
            else
                dest += (INT32)hs.imm.imm32;

            // Simply copy an internal jump.
            if ((ULONG_PTR)ct->pTarget <= dest
                && dest < ((ULONG_PTR)ct->pTarget + sizeof(JMP_REL)))
            {
                if (jmpDest < dest)
                    jmpDest = dest;
            }
            else
            {
#if defined(_M_X64) || defined(__x86_64__)
                jmp.address = dest;
#else
                jmp.operand = (UINT32)(dest - (pNewInst + sizeof(jmp)));
#endif
                pCopySrc = &jmp;
                copySize = sizeof(jmp);

                // Exit the function if it is not in the branch.
                finished = (pOldInst >= jmpDest);
            }
        }
        else if ((hs.opcode & 0xF0) == 0x70
            || (hs.opcode & 0xFC) == 0xE0
            || (hs.opcode2 & 0xF0) == 0x80)
        {
            // Direct relative Jcc
            ULONG_PTR dest = pOldInst + hs.len;

            if ((hs.opcode & 0xF0) == 0x70      // Jcc
                || (hs.opcode & 0xFC) == 0xE0)  // LOOPNZ/LOOPZ/LOOP/JECXZ
                dest += (INT8)hs.imm.imm8;
            else
                dest += (INT32)hs.imm.imm32;

            // Simply copy an internal jump.
            if ((ULONG_PTR)ct->pTarget <= dest
                && dest < ((ULONG_PTR)ct->pTarget + sizeof(JMP_REL)))
            {
                if (jmpDest < dest)
                    jmpDest = dest;
            }
            else if ((hs.opcode & 0xFC) == 0xE0)
            {
                // LOOPNZ/LOOPZ/LOOP/JCXZ/JECXZ to the outside are not supported.
                return FALSE;
            }
            else
            {
                UINT8 cond = ((hs.opcode != 0x0F ? hs.opcode : hs.opcode2) & 0x0F);
#if defined(_M_X64) || defined(__x86_64__)
                // Invert the condition in x64 mode to simplify the conditional jump logic.
                jcc.opcode  = 0x71 ^ cond;
                jcc.address = dest;
#else
                jcc.opcode1 = 0x80 | cond;
                jcc.operand = (UINT32)(dest - (pNewInst + sizeof(jcc)));
#endif
                pCopySrc = &jcc;
                copySize = sizeof(jcc);
            }
        }
        else if ((hs.opcode & 0xFE) == 0xC2)
        {
            // RET (C2 or C3)

            // Complete the function if not in a branch.
            finished = (pOldInst >= jmpDest);
        }

        // Can't alter the instruction length in a branch.
        if (pOldInst < jmpDest && copySize != hs.len)
            return FALSE;

        // Trampoline function is too large.
        if ((newPos + copySize) > TRAMPOLINE_MAX_SIZE)
            return FALSE;

        // Trampoline function has too many instructions.
        if (ct->nIP >= ARRAYSIZE(ct->oldIPs))
            return FALSE;

        ct->oldIPs[ct->nIP] = oldPos;
        ct->newIPs[ct->nIP] = newPos;
        ct->nIP++;

        // Avoid using memcpy to reduce the footprint.
#ifndef _MSC_VER
        memcpy((LPBYTE)ct->pTrampoline + newPos, pCopySrc, copySize);
#else
        __movsb((LPBYTE)ct->pTrampoline + newPos, (LPBYTE)pCopySrc, copySize);
#endif
        newPos += copySize;
        oldPos += hs.len;
    }
    while (!finished);

    // Is there enough place for a long jump?
    if (oldPos < sizeof(JMP_REL)
        && !IsCodePadding((LPBYTE)ct->pTarget + oldPos, sizeof(JMP_REL) - oldPos))
    {
        // Is there enough place for a short jump?
        if (oldPos < sizeof(JMP_REL_SHORT)
            && !IsCodePadding((LPBYTE)ct->pTarget + oldPos, sizeof(JMP_REL_SHORT) - oldPos))
        {
            return FALSE;
        }

        // Can we place the long jump above the function?
        if (!IsExecutableAddress((LPBYTE)ct->pTarget - sizeof(JMP_REL)))
            return FALSE;

        if (!IsCodePadding((LPBYTE)ct->pTarget - sizeof(JMP_REL), sizeof(JMP_REL)))
            return FALSE;

        ct->patchAbove = TRUE;
    }

#if defined(_M_X64) || defined(__x86_64__)
    // Create a relay function.
    jmp.address = (ULONG_PTR)ct->pDetour;

    ct->pRelay = (LPBYTE)ct->pTrampoline + newPos;
    memcpy(ct->pRelay, &jmp, sizeof(jmp));
#endif

    return TRUE;
}

```

`sdk/external/minhook/trampoline.h`:

```h
/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2017 Tsuda Kageyu.
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 *  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 *  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
 *  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#pragma once

#pragma pack(push, 1)

// Structs for writing x86/x64 instructions.

// 8-bit relative jump.
typedef struct _JMP_REL_SHORT
{
    UINT8  opcode;      // EB xx: JMP +2+xx
    UINT8  operand;
} JMP_REL_SHORT, *PJMP_REL_SHORT;

// 32-bit direct relative jump/call.
typedef struct _JMP_REL
{
    UINT8  opcode;      // E9/E8 xxxxxxxx: JMP/CALL +5+xxxxxxxx
    UINT32 operand;     // Relative destination address
} JMP_REL, *PJMP_REL, CALL_REL;

// 64-bit indirect absolute jump.
typedef struct _JMP_ABS
{
    UINT8  opcode0;     // FF25 00000000: JMP [+6]
    UINT8  opcode1;
    UINT32 dummy;
    UINT64 address;     // Absolute destination address
} JMP_ABS, *PJMP_ABS;

// 64-bit indirect absolute call.
typedef struct _CALL_ABS
{
    UINT8  opcode0;     // FF15 00000002: CALL [+6]
    UINT8  opcode1;
    UINT32 dummy0;
    UINT8  dummy1;      // EB 08:         JMP +10
    UINT8  dummy2;
    UINT64 address;     // Absolute destination address
} CALL_ABS;

// 32-bit direct relative conditional jumps.
typedef struct _JCC_REL
{
    UINT8  opcode0;     // 0F8* xxxxxxxx: J** +6+xxxxxxxx
    UINT8  opcode1;
    UINT32 operand;     // Relative destination address
} JCC_REL;

// 64bit indirect absolute conditional jumps that x64 lacks.
typedef struct _JCC_ABS
{
    UINT8  opcode;      // 7* 0E:         J** +16
    UINT8  dummy0;
    UINT8  dummy1;      // FF25 00000000: JMP [+6]
    UINT8  dummy2;
    UINT32 dummy3;
    UINT64 address;     // Absolute destination address
} JCC_ABS;

#pragma pack(pop)

typedef struct _TRAMPOLINE
{
    LPVOID pTarget;         // [In] Address of the target function.
    LPVOID pDetour;         // [In] Address of the detour function.
    LPVOID pTrampoline;     // [In] Buffer address for the trampoline and relay function.

#if defined(_M_X64) || defined(__x86_64__)
    LPVOID pRelay;          // [Out] Address of the relay function.
#endif
    BOOL   patchAbove;      // [Out] Should use the hot patch area?
    UINT   nIP;             // [Out] Number of the instruction boundaries.
    UINT8  oldIPs[8];       // [Out] Instruction boundaries of the target function.
    UINT8  newIPs[8];       // [Out] Instruction boundaries of the trampoline function.
} TRAMPOLINE, *PTRAMPOLINE;

BOOL CreateTrampolineFunction(PTRAMPOLINE ct);

```

`sdk/hooks/hooked/hk_client.cpp`:

```cpp
#include "../hooks.h"

void __stdcall hk_create_move(int sequence, float input_sample_frametime, bool active, bool& send_packet)
{
	originals->create_move_original(interfaces->base_client, sequence, input_sample_frametime, active);

	game_user_cmd* cmd = interfaces->input->user_cmd(sequence);
	game_verified_user_cmd* verified_cmd = interfaces->input->verified_cmd(sequence);

	// check do we have valid commands, finished signing on to server and not playing back demos (where our commands are ignored)
	if (cmd == nullptr || verified_cmd == nullptr || !active)
		return;

	// store global variables to global pointer.
	csgo->cmd = cmd;
	csgo->local_player = interfaces->entity_list->get<cs_player>(interfaces->engine_client->get_local_player());
	csgo->send_packet = &send_packet;



	// anti-untrust (essential if you don't want ban).
	cmd->view_angles.sanitize();

	verified_cmd->cmd		= *cmd;
	verified_cmd->checksum	= cmd->checksum();
}

__declspec (naked) void __stdcall hk_functions::create_move_proxy(int sequence, float input_sample_frametime, bool active)
{
	/*
	* credit: https://github.com/rollraw/qo0-base/blob/2de7c14bf1941ad2ad77f30783f9e06fc646a153/base/core/hooks.cpp#L322
	* credit: https://github.com/lagcomp/csgo_sdk/blob/94ecdd119d8f4a502cca725687c6ab119362c56b/csgo_sdk/csgo/hooks/impl/hooks.cpp#L57
	* both of these resources helped me alot on figuring out how to hook create_move like this.
	*/

	__asm
	{
		push ebp
		mov  ebp, esp							// store the stack.
		push ebx								// send_packet.
		push esp								// restore the stack.

		push dword ptr[active]					// ebp + 16.
		push dword ptr[input_sample_frametime]	// ebp + 12.
		push dword ptr[sequence]				// ebp + 8.

		call hk_create_move						// our function.

		pop  ebx
		pop  ebp

		retn 12
	}
}
```

`sdk/hooks/hooked/hk_other.cpp`:

```cpp
#include "../hooks.h"

#include <intrin.h>
#pragma intrinsic(_ReturnAddress)

// credit: https://github.com/rollraw/qo0-base/blob/92a3b3aefa220da941c3feee387702c772d1af82/base/core/hooks.cpp#L197
void* __stdcall hk_functions::alloc_key_value_memory(int size)
{
	// return addresses of check function.
	static const std::uintptr_t alloc_key_value_engine = SEARCH(modules->engine, signatures::hooks::alloc_key_value_engine::signature()).add(0x1).rel32<std::uintptr_t>(0x4A);
	static const std::uintptr_t alloc_key_value_client = SEARCH(modules->client, signatures::hooks::alloc_key_value_client::signature()).add(0x1).rel32<std::uintptr_t>(0x3E);

	const std::uintptr_t return_address = reinterpret_cast<std::uintptr_t>(_ReturnAddress());

	if (return_address == alloc_key_value_engine || return_address == alloc_key_value_client)
		return nullptr;

	return originals->alloc_key_value_memory_original(interfaces->key_value_system, size);
}

```

`sdk/hooks/hooked/hk_surface.cpp`:

```cpp
#include "../hooks.h"

void __stdcall hk_functions::paint_traverse(v_panel panel, bool force_repaint, bool allow_force)
{
	hash32 draw_panel = HASH_COMPILE(interfaces->panel->name(panel));

	switch (draw_panel)
	{
	case HASH_COMPILE("MatSystemTopPanel"):
		// drawing functions here.

		
		
		break;
	}

	originals->paint_traverse_original(interfaces->panel, panel, force_repaint, allow_force);
}

```

`sdk/hooks/hooks.cpp`:

```cpp
#include "hooks.h"

game_hooks* hooks = new game_hooks;
hk_originals* originals = new hk_originals;

void game_hooks::setup()
{
	// install hooking library.
	if (MH_Initialize() != MH_STATUS::MH_OK)
		console->log(log_type::log_error, "failed to install minhook!");

	// virtual hook target.
	void* alloc_key_value_memory_target		= virtuals->get<void*>(interfaces->key_value_system, hk_index::alloc_key_value_memory);
	void* create_move_target				= virtuals->get<void*>(interfaces->base_client, hk_index::create_move);
	void* paint_traverse_target				= virtuals->get<void*>(interfaces->panel, hk_index::paint_traverse);

	// add hooks here.
	create_hook("alloc_key_value_memory", alloc_key_value_memory_target, hk_functions::alloc_key_value_memory, &originals->alloc_key_value_memory_original);
	create_hook("create_move", create_move_target, hk_functions::create_move_proxy, &originals->create_move_original);
	create_hook("paint_traverse", paint_traverse_target, hk_functions::paint_traverse, &originals->paint_traverse_original);

	// then enable hooking.
	MH_EnableHook(MH_ALL_HOOKS);

	console->log(log_type::log_success, "hooks intsalled!");
}

void game_hooks::restore()
{
	// disable hooking library.
	MH_DisableHook(MH_ALL_HOOKS);

	// then remove hook(s).
	MH_RemoveHook(MH_ALL_HOOKS);

	// then uninstall hooking library.
	MH_Uninitialize();
}

```

`sdk/hooks/hooks.h`:

```h
#pragma once
#include "../dependencies/console/console.h"
#include "../valve/interface/interface.h"
#include "../dependencies/dependency.h"
#include <minhook.h>

// add hooks indexes here.
enum hk_index : int
{
	alloc_key_value_memory = 2,
	create_move = 22,
	paint_traverse = 41,
};

/*
* add hooks linker here.
* example: typedef type_parameter(call_parameter* name_linker)(parameters);
* NOTE: the 'call_parameter' is your hook functions call parameter(such as __stdcall, __fastcall and etc...) and
* the 'type_parameter' is your hook functions type parameter(such as void, bool, int and etc...),
* so you replace it with whatever your hook parameter is.
*/
struct hk_linker
{
	typedef void* (__thiscall* lnk_alloc_key_value_memory)(game_key_value_system*, int);
	typedef void(__thiscall* lnk_create_move_proxy)(game_base_client*, int, float, bool);
	typedef void(__thiscall* lnk_paint_traverse)(game_panel*, v_panel, bool, bool);
};

// add your standard hooking functions here.
struct hk_functions
{
	static void* __stdcall alloc_key_value_memory(int size);
	static void __stdcall create_move_proxy(int sequence, float input_sample_frametime, bool active);
	static void __stdcall paint_traverse(v_panel panel, bool force_repaint, bool allow_force);
};

/*
* add your hooked functions original variable here.
* example: hk_linker::name_linker name_original = nullptr;
*/
struct hk_originals : hk_linker
{
	lnk_alloc_key_value_memory alloc_key_value_memory_original	= nullptr;
	lnk_create_move_proxy create_move_original					= nullptr;
	lnk_paint_traverse paint_traverse_original					= nullptr;
};

extern hk_originals* originals;

class game_hooks
{
public:
	void setup();
	void restore();

private:
	/*
	* create hook wrapper.
	* it allows you to remove annoying reinterpret_casts.
	* credit: https://www.codeproject.com/Articles/44326/MinHook-The-Minimalistic-x-x-API-Hooking-Libra
	*/
	template <typename t>
	MH_STATUS create_hook(std::string hook_name, LPVOID target_hook, LPVOID function_hook, t** original_hook)
	{
		/*
		* void ptr to string conversion help credit: https://stackoverflow.com/a/3077027
		* if needed to convert void* to string use. ^^^
		*/

		MH_STATUS create = MH_CreateHook(target_hook, function_hook, (LPVOID*)original_hook);

		if (create != MH_STATUS::MH_OK)
			console->log(log_type::log_error, "failed to hook %s!", hook_name.c_str());

		return create;
	}
};

extern game_hooks* hooks;
```

`sdk/include.h`:

```h
#pragma once
#include <Windows.h>
#include <iostream>
#include <thread>
#include <string>
#include <array>

#include "hooks/hooks.h"
#include "dependencies/dependency.h"
#include "valve/valve.h"
```

`sdk/sdk.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{d9f5694a-6376-4e96-a26f-0f37ecfcaa74}</ProjectGuid>
    <RootNamespace>sdk</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v145</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v145</PlatformToolset>
    <WholeProgramOptimization>false</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <OutDir>$(SolutionDir)output\debug\</OutDir>
    <IntDir>$(SolutionDir)output\intermediates\</IntDir>
    <IncludePath>$(SolutionDir)sdk\external\minhook\include;$(IncludePath);$(VC_IncludePath);$(WindowsSDK_IncludePath)</IncludePath>
    <LibraryPath>$(LibraryPath);$(VC_LibraryPath_x86);$(WindowsSDK_LibraryPath_x86)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <OutDir>$(SolutionDir)output\release\</OutDir>
    <IntDir>$(SolutionDir)output\intermediates\</IntDir>
    <IncludePath>$(SolutionDir)sdk\external\minhook\include;$(IncludePath);$(VC_IncludePath);$(WindowsSDK_IncludePath)</IncludePath>
    <LibraryPath>$(LibraryPath);$(VC_LibraryPath_x86);$(WindowsSDK_LibraryPath_x86)</LibraryPath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>DEBUG_CONSOLE;NOMINMAX;WIN32;_DEBUG;SDK_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NOMINMAX;WIN32;NDEBUG;SDK_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="dependencies\console\console.cpp" />
    <ClCompile Include="dependencies\maths\maths.cpp" />
    <ClCompile Include="dependencies\memory\memory.cpp" />
    <ClCompile Include="dependencies\other\other.cpp" />
    <ClCompile Include="dependencies\render\render.cpp" />
    <ClCompile Include="entry.cpp" />
    <ClCompile Include="external\minhook\buffer.c" />
    <ClCompile Include="external\minhook\hde\hde32.c" />
    <ClCompile Include="external\minhook\hde\hde64.c" />
    <ClCompile Include="external\minhook\hook.c" />
    <ClCompile Include="external\minhook\trampoline.c" />
    <ClCompile Include="hooks\hooked\hk_client.cpp" />
    <ClCompile Include="hooks\hooked\hk_other.cpp" />
    <ClCompile Include="hooks\hooked\hk_surface.cpp" />
    <ClCompile Include="hooks\hooks.cpp" />
    <ClCompile Include="valve\entity\entity.cpp" />
    <ClCompile Include="valve\interface\interface.cpp" />
    <ClCompile Include="valve\netvar\netvar.cpp" />
    <ClCompile Include="valve\other\animations.cpp" />
    <ClCompile Include="valve\other\convar.cpp" />
    <ClCompile Include="valve\other\key_value.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="dependencies\console\console.h" />
    <ClInclude Include="dependencies\dependency.h" />
    <ClInclude Include="dependencies\maths\maths.h" />
    <ClInclude Include="dependencies\memory\convars.h" />
    <ClInclude Include="dependencies\memory\modules.h" />
    <ClInclude Include="dependencies\memory\scanner.h" />
    <ClInclude Include="dependencies\memory\signatures.h" />
    <ClInclude Include="dependencies\memory\virtual.h" />
    <ClInclude Include="dependencies\other\color.h" />
    <ClInclude Include="dependencies\other\dump.h" />
    <ClInclude Include="dependencies\other\global.h" />
    <ClInclude Include="dependencies\other\hash.h" />
    <ClInclude Include="dependencies\other\translate.h" />
    <ClInclude Include="dependencies\render\font.h" />
    <ClInclude Include="dependencies\render\render.h" />
    <ClInclude Include="external\minhook\buffer.h" />
    <ClInclude Include="external\minhook\hde\hde32.h" />
    <ClInclude Include="external\minhook\hde\hde64.h" />
    <ClInclude Include="external\minhook\hde\pstdint.h" />
    <ClInclude Include="external\minhook\hde\table32.h" />
    <ClInclude Include="external\minhook\hde\table64.h" />
    <ClInclude Include="external\minhook\include\minhook.h" />
    <ClInclude Include="external\minhook\trampoline.h" />
    <ClInclude Include="hooks\hooks.h" />
    <ClInclude Include="include.h" />
    <ClInclude Include="valve\classes\clients.h" />
    <ClInclude Include="valve\classes\other.h" />
    <ClInclude Include="valve\classes\user_cmd.h" />
    <ClInclude Include="valve\interface\classes\base_interface.h" />
    <ClInclude Include="valve\interface\classes\client_mode.h" />
    <ClInclude Include="valve\entity\entity.h" />
    <ClInclude Include="valve\entity\other.h" />
    <ClInclude Include="valve\interface\classes\base_client.h" />
    <ClInclude Include="valve\interface\classes\debug_overlay.h" />
    <ClInclude Include="valve\interface\classes\engine_client.h" />
    <ClInclude Include="valve\interface\classes\engine_convar.h" />
    <ClInclude Include="valve\interface\classes\engine_sound.h" />
    <ClInclude Include="valve\interface\classes\engine_trace.h" />
    <ClInclude Include="valve\interface\classes\engine_vgui.h" />
    <ClInclude Include="valve\interface\classes\entity_list.h" />
    <ClInclude Include="valve\interface\classes\event_manager.h" />
    <ClInclude Include="valve\interface\classes\game_console.h" />
    <ClInclude Include="valve\interface\classes\game_types.h" />
    <ClInclude Include="valve\interface\classes\global_vars.h" />
    <ClInclude Include="valve\interface\classes\input.h" />
    <ClInclude Include="valve\interface\classes\key_value_system.h" />
    <ClInclude Include="valve\interface\classes\localize.h" />
    <ClInclude Include="valve\interface\classes\material_system.h" />
    <ClInclude Include="valve\interface\classes\mdl_cache.h" />
    <ClInclude Include="valve\interface\classes\model_info.h" />
    <ClInclude Include="valve\interface\classes\network.h" />
    <ClInclude Include="valve\interface\classes\panel.h" />
    <ClInclude Include="valve\interface\classes\physics_surface_props.h" />
    <ClInclude Include="valve\interface\classes\prediction.h" />
    <ClInclude Include="valve\interface\classes\studio_render.h" />
    <ClInclude Include="valve\interface\classes\surface.h" />
    <ClInclude Include="valve\interface\classes\weapon_system.h" />
    <ClInclude Include="valve\interface\interface.h" />
    <ClInclude Include="valve\maths\matrix.h" />
    <ClInclude Include="valve\maths\other.h" />
    <ClInclude Include="valve\maths\q_angle.h" />
    <ClInclude Include="valve\maths\utl_vector.h" />
    <ClInclude Include="valve\maths\vector.h" />
    <ClInclude Include="valve\netvar\data_map.h" />
    <ClInclude Include="valve\netvar\data_table.h" />
    <ClInclude Include="valve\netvar\netvar.h" />
    <ClInclude Include="valve\other\animations.h" />
    <ClInclude Include="valve\other\bitbuf.h" />
    <ClInclude Include="valve\other\convar.h" />
    <ClInclude Include="valve\other\key_value.h" />
    <ClInclude Include="valve\other\net_channel.h" />
    <ClInclude Include="valve\other\studio.h" />
    <ClInclude Include="valve\other\weapon_info.h" />
    <ClInclude Include="valve\valve.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

```

`sdk/sdk.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="entry.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="dependencies\console\console.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="dependencies\memory\memory.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="dependencies\other\other.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="valve\netvar\netvar.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="valve\interface\interface.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="valve\other\convar.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="valve\other\key_value.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="hooks\hooks.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="external\minhook\hde\hde32.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="external\minhook\hde\hde64.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="external\minhook\buffer.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="external\minhook\hook.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="external\minhook\trampoline.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="hooks\hooked\hk_client.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="hooks\hooked\hk_other.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="dependencies\render\render.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="hooks\hooked\hk_surface.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="dependencies\maths\maths.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="valve\entity\entity.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="valve\other\animations.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="include.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="dependencies\console\console.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="dependencies\dependency.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="dependencies\memory\modules.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="dependencies\other\hash.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="dependencies\memory\scanner.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="dependencies\memory\signatures.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="dependencies\memory\virtual.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="dependencies\other\dump.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\valve.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\netvar\netvar.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\netvar\data_map.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\netvar\data_table.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\interface\interface.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\interface\classes\base_client.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\classes\clients.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\entity\entity.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\entity\other.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\interface\classes\client_mode.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\maths\utl_vector.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\maths\vector.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\maths\q_angle.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\maths\matrix.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\maths\other.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\other\bitbuf.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\other\net_channel.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\interface\classes\debug_overlay.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\interface\classes\engine_client.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\interface\classes\engine_convar.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\interface\classes\engine_sound.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\interface\classes\engine_trace.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\interface\classes\engine_vgui.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\interface\classes\entity_list.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\interface\classes\event_manager.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\interface\classes\game_console.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\interface\classes\game_types.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\interface\classes\global_vars.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\interface\classes\input.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\interface\classes\key_value_system.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\interface\classes\localize.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\interface\classes\material_system.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\interface\classes\model_info.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\interface\classes\network.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\interface\classes\panel.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\interface\classes\studio_render.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\interface\classes\surface.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\interface\classes\weapon_system.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\other\studio.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\other\convar.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\other\key_value.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\other\weapon_info.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\classes\user_cmd.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="dependencies\other\color.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="hooks\hooks.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="external\minhook\hde\hde32.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="external\minhook\hde\hde64.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="external\minhook\hde\pstdint.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="external\minhook\hde\table32.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="external\minhook\hde\table64.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="external\minhook\include\minhook.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="external\minhook\buffer.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="external\minhook\trampoline.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="dependencies\render\render.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="dependencies\other\translate.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="dependencies\other\global.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\interface\classes\prediction.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\interface\classes\physics_surface_props.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="dependencies\maths\maths.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\interface\classes\base_interface.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="dependencies\render\font.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\other\animations.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="dependencies\memory\convars.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\classes\other.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="valve\interface\classes\mdl_cache.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>

```

`sdk/valve/classes/clients.h`:

```h
#pragma once
#include "../interface/interface.h"
#include "../netvar/netvar.h"
#include "../other/bitbuf.h"
#include "../../dependencies/memory/convars.h"
#include "../../dependencies/memory/modules.h"
#include "../../dependencies/memory/signatures.h"
#include "../../dependencies/maths/maths.h"
#include "other.h"

class collideable;
class client_networkable;
class client_renderable;
class game_client_entity;
class base_entity;
class client_thinkable;
class client_alpha_property;

class client_unknown : public handle_entity
{
public:
	virtual collideable*			collideable() = 0;
	virtual client_networkable*		networkable() = 0;
	virtual client_renderable*		renderable() = 0;
	virtual game_client_entity*		client_entity() = 0;
	virtual base_entity*			entity() = 0;
	virtual client_thinkable*		thinkable() = 0;
	virtual client_alpha_property*	alpha_property() = 0;
};

#pragma region collideable

enum solid_type
{
	solid_none = 0,	// no solid model
	solid_bsp = 1,	// a bsp tree
	solid_bbox = 2,	// an aabb
	solid_obb = 3,	// an obb (not implemented yet)
	solid_obb_yaw = 4,	// an obb, constrained so that it can only yaw
	solid_custom = 5,	// always call into the entity for tests
	solid_vphysics = 6,	// solid vphysics object, get vcollide from the model and collide with that
	solid_last,
};

class collideable
{
public:
	virtual handle_entity*			entity_handle() = 0;
	virtual const vector_3d&		obb_mins() const = 0;
	virtual const vector_3d&		obb_maxs() const = 0;
	virtual void					world_space_trigger_bounds(vector_3d* mins, vector_3d* maxs) const = 0;
	virtual bool					test_collision(const game_ray& ray, unsigned int mask, game_trace& tr) = 0;
	virtual bool					test_hitboxes(const game_ray& ray, unsigned int mask, game_trace& tr) = 0;
	virtual int						collision_model_index() = 0;
	virtual const game_model*		collision_model() = 0;
	virtual const vector_3d&		collision_origin() const = 0;
	virtual const q_angle&			collision_angles() const = 0;
	virtual const matrix_3x4&		collision_to_world_transform() const = 0;
	virtual solid_type				get_solid() const = 0;
	virtual int						get_solid_flags() const = 0;
	virtual client_unknown*			unknown() = 0;
	virtual int						get_collision_group() const = 0;

	/*
	* note: should be equivalent to C_BaseAnimating::ComputeHitboxSurroundingBox
	* DOESNT NEEDED TRANSORMATION!
	* and bugged when trying to get non-player entity box
	*/
	virtual void					world_space_surrounding_bounds(vector_3d* mins, vector_3d* maxs) = 0;
	virtual unsigned int			get_required_trigger_flags() const = 0;
	// returns null unless this collideable has specified fsolid_root_parent_aligned
	virtual const matrix_3x4*		get_root_parent_to_world_transform() const = 0;
	virtual void*					get_vphysics_object() const = 0;
};

#pragma endregion

#pragma region networkable

enum should_transmit_state
{
	should_transmit_start = 0,
	should_transmit_end
};

enum data_update_type
{
	data_update_created = 0,
	data_update_datatable_changed,
	data_update_post_update,
};

class client_networkable
{
public:
	virtual client_unknown*			unknown() = 0;
	virtual void					release() = 0;
	virtual game_client_class*		client_class() = 0;
	virtual void					notify_should_transmit(should_transmit_state state) = 0;
	virtual void					on_pre_data_changed(data_update_type update_type) = 0;
	virtual void					on_data_changed(data_update_type update_type) = 0;
	virtual void					pre_data_update(data_update_type update_type) = 0;
	virtual void					post_data_update(data_update_type update_type) = 0;
	virtual void					on_data_unchanged_in_pvs() = 0;
	virtual bool					dormant(void) const = 0;
	virtual int						index(void) const = 0;
	virtual void					receive_message(int class_id, bf_read& message) = 0;
	virtual void*					datatable_base_ptr() = 0;
	virtual void					set_destroyed_on_recreate_entities(void) = 0;
};

#pragma endregion

#pragma region renderable

enum model_data_category
{
	model_data_lighting_model,	// data type returned is a renderablelightingmodel_t
	model_data_stencil,			// data type returned is a shaderstencilstate_t
	model_data_category_count,
};

enum shadow_type
{
	shadows_none = 0,
	shadows_simple,
	shadows_render_to_texture,
	shadows_render_to_texture_dynamic,			// the shadow is always changing state
	shadows_render_to_depth_texture,
	shadows_render_to_texture_dynamic_custom,	// changing, and entity uses custom rendering code for shadow
};

class client_model_renderable
{
public:
	virtual bool						get_render_data(void* data, model_data_category category) = 0;
};

struct renderable_instance
{
	std::uint8_t alpha;
};

class client_renderable
{
public:
	virtual client_unknown*				unknown() = 0;
	virtual vector_3d const&			render_origin(void) = 0;
	virtual q_angle const&				render_angles(void) = 0;
	virtual bool						should_draw(void) = 0;
	virtual int							render_flags(void) = 0;
	virtual void						unused(void) const { }
	virtual unsigned short				shadow_handle() const = 0;
	virtual unsigned short&				render_handle() = 0;
	virtual const game_model*			get_model() const = 0;
	virtual int							draw_model(int flags, const renderable_instance& instance) = 0;
	virtual int							get_body() = 0;
	virtual void						color_modulation(float* color) = 0;
	virtual bool						lod_test() = 0;
	virtual bool						setup_bones(matrix_3x4* bone_to_world_out, int max_bones, int bone_mask, float current_time) = 0;
	virtual void						setup_weights(const matrix_3x4* bone_to_world, int flex_weight_count, float* flex_weights, float* flex_delayed_weights) = 0;
	virtual void						do_animation_events(void) = 0;
	virtual void*						pvs_notify_interface() = 0;
	virtual void						render_bounds(vector_3d& mins, vector_3d& maxs) = 0;
	virtual void						render_bounds_world_space(vector_3d& mins, vector_3d& maxs) = 0;
	virtual void						shadow_render_bounds(vector_3d& mins, vector_3d& maxs, shadow_type type) = 0;
	virtual bool						should_receive_projected_textures(int flags) = 0;
	virtual bool						shadow_cast_distance(float* dist, shadow_type type) const = 0;
	virtual bool						shadow_cast_direction(vector_3d* direction, shadow_type type) const = 0;
	virtual bool						is_shadow_dirty() = 0;
	virtual void						mark_shadow_dirty(bool dirty) = 0;
	virtual client_renderable*			get_shadow_parent() = 0;
	virtual client_renderable*			first_shadow_child() = 0;
	virtual client_renderable*			next_shadow_peer() = 0;
	virtual shadow_type					shadow_cast_type() = 0;
	virtual void						unused2() { }
	virtual void						create_model_instance() = 0;
	virtual unsigned short				model_instance() = 0;
	virtual const matrix_3x4&			renderable_to_world_transform() = 0;
	virtual int							lookup_attachment(const char* attachment_name) = 0;
	virtual	bool						get_attachment(int number, vector_3d& origin, vector_3d& angles) = 0;
	virtual bool						get_attachment(int number, matrix_3x4& matrix) = 0;
	virtual bool						compute_lighting_origin(int attachment_index, vector_3d model_lighting_center, const matrix_3x4& matrix, vector_3d& transformed_lighting_center) = 0;
	virtual float*						render_clip_plane(void) = 0;
	virtual int							get_skin() = 0;
	virtual void						on_threaded_draw_setup() = 0;
	virtual bool						uses_flex_delayed_weights() = 0;
	virtual void						record_tool_message() = 0;
	virtual bool						should_draw_for_split_screen_user(int slot) = 0;
	virtual std::uint8_t				override_alpha_modulation(std::uint8_t alpha) = 0;
	virtual std::uint8_t				override_shadow_alpha_modulation(std::uint8_t alpha) = 0;
	virtual client_model_renderable*	client_model_renderable() = 0;
};

#pragma endregion

#pragma region thinkable

class client_thinkable
{
public:
	virtual client_unknown*		unknown() = 0;
	virtual void				client_think() = 0;
	virtual void*				get_think_handle() = 0;
	virtual void				set_think_handle(int think) = 0;
	virtual void				release() = 0;
};

#pragma endregion

#pragma region alpha_property

enum client_alpha_distance_fade_mode
{
	client_alpha_distance_fade_use_center = 0,
	client_alpha_distance_fade_use_nearest_bbox,
	client_alpha_distance_fade_mode_count,
};

enum render_fx
{
	render_fx_none = 0,
	render_fx_pulse_slow,
	render_fx_pulse_fast,
	render_fx_pulse_slow_wide,
	render_fx_pulse_fast_wide,

	render_fx_fade_slow,
	render_fx_fade_fast,
	render_fx_solid_slow,
	render_fx_solid_fast,
	render_fx_strobe_slow,

	render_fx_strobe_fast,
	render_fx_strobe_faster,
	render_fx_flicker_slow,
	render_fx_flicker_fast,
	render_fx_no_dissipation,

	render_fx_fade_out,
	render_fx_fade_in,
	render_fx_pulse_fast_wider,
	render_fx_glow_shell,

	render_fx_max
};

enum render_mode
{
	render_normal = 0,				// src
	render_trans_color,				// c*a+dest*(1-a)
	render_trans_texture,			// src*a+dest*(1-a)
	render_glow,					// src*a+dest -- no z buffer checks -- fixed size in screen space
	render_trans_alpha,				// src*srca+dest*(1-srca)
	render_trans_add,				// src*a+dest
	render_environmental,			// not drawn, used for environmental effects
	render_trans_add_frame_blend,	// use a fractional frame value to blend between animation frames
	render_trans_alpha_add,			// src + dest*(1-a)
	render_world_glow,				// same as krenderglow but not fixed size in screen space
	render_none,					// don't render.

	render_mode_count,				// must be last
};

class client_alpha_property
{
public:
	virtual client_unknown*		unknown() = 0;
	virtual void				set_alpha_modulation(std::uint8_t alpha) = 0;
	virtual void				set_render_fx(render_fx render_fx, render_mode render_mode, float start_time = std::numeric_limits<float>::max(), float duration = 0.0f) = 0;
	virtual void				set_fade(float global_fade_scale, float dist_fade_start, float dist_fade_end) = 0;
	virtual void				set_desync_offset(int offset) = 0;
	virtual void				enable_alpha_modulation_override(bool enable) = 0;
	virtual void				enable_shadow_alpha_modulation_override(bool enable) = 0;
	virtual void				set_distance_fade_mode(client_alpha_distance_fade_mode fade_mode) = 0;
};

#pragma endregion

#pragma region client_entity

class mouth_info;

class game_client_entity : public client_unknown, public client_renderable, public client_networkable, public client_thinkable
{
public:
	virtual void				release(void) = 0;
	virtual const vector_3d&	abs_origin(void) const = 0;
	virtual const q_angle&		abs_angles(void) const = 0;
	virtual mouth_info*			get_mouth(void) = 0;
	virtual bool				sound_spatialization(struct spatialization_info& info) = 0;
	virtual bool				is_blurred(void) = 0;

	void set_abs_origin(const vector_3d& origin)
	{
		using set_abs_origin_details = void(__thiscall*)(void*, const vector_3d&);
		static auto original_set_abs_origin = SEARCH(modules->client, signatures::entity::set_abs_origin::signature()).cast<set_abs_origin_details>();
		original_set_abs_origin(this, origin);
	}

	void set_abs_angle(const q_angle& view_angle)
	{
		using set_abs_angle_details = void(__thiscall*)(void*, const q_angle&);
		static auto original_set_abs_angle = SEARCH(modules->client, signatures::entity::set_abs_angle::signature()).cast<set_abs_angle_details>();
		original_set_abs_angle(this, view_angle);
	}

	game_data_map* description_map() { return virtuals->call<game_data_map*>(this, 15); }
	game_data_map* prediction_map() { return virtuals->call<game_data_map*>(this, 17); }
};

#pragma endregion

```

`sdk/valve/classes/other.h`:

```h
#pragma once

#define tick_interval			interfaces->global_vars->interval_per_tick
#define time_to_ticks( value )  ( static_cast<int>( 0.5f + static_cast<float>( value ) / tick_interval ) )
#define ticks_to_time( value )  ( tick_interval * static_cast<float>( value ) )
#define round_to_ticks( value ) ( tick_interval * time_to_ticks( value ) )

enum game_flags : int
{
	fl_on_ground				= (1 << 0),		// entity is at rest / on the ground
	fl_ducking					= (1 << 1),		// player is fully crouched/uncrouched
	fl_anim_ducking				= (1 << 2),		// player is in the process of crouching or uncrouching but could be in transition
	fl_water_jump				= (1 << 3),		// player is jumping out of water
	fl_on_train					= (1 << 4),		// player is controlling a train, so movement commands should be ignored on client during prediction
	fl_in_rain					= (1 << 5),		// entity is standing in rain
	fl_frozen					= (1 << 6),		// player is frozen for 3rd-person camera
	fl_at_controls				= (1 << 7),		// player can't move, but keeps key inputs for controlling another entity
	fl_client					= (1 << 8),		// entity is a client (player)
	fl_fake_client				= (1 << 9),		// entity is a fake client, simulated server side; don't send network messages to them
	fl_in_water					= (1 << 10),	// entity is in water
	fl_fly						= (1 << 11),
	fl_swim						= (1 << 12),
	fl_conveyor					= (1 << 13),
	fl_npc						= (1 << 14),
	fl_godmode					= (1 << 15),
	fl_no_target				= (1 << 16),
	fl_aim_target				= (1 << 17),
	fl_partial_ground			= (1 << 18),	// entity is standing on a place where not all corners are valid
	fl_static_prop				= (1 << 19),	// entity is a static property
	fl_graphed					= (1 << 20),
	fl_grenade					= (1 << 21),
	fl_step_movement			= (1 << 22),
	fl_dont_touch				= (1 << 23),
	fl_base_velocity			= (1 << 24),	// entity have applied base velocity this frame
	fl_world_brush				= (1 << 25),	// entity is not moveable/removeable brush (part of the world, but represented as an entity for transparency or something)
	fl_object					= (1 << 26),
	fl_kill_me					= (1 << 27),	// entity is marked for death and will be freed by the game
	fl_on_fire					= (1 << 28),
	fl_dissolving				= (1 << 29),
	fl_trans_ragdoll			= (1 << 30),	// entity is turning into client-side ragdoll
	fl_unblockable_by_player	= (1 << 31)
};

enum game_entity_flags : int
{
	efl_kill_me								= (1 << 0),
	efl_dormant								= (1 << 1),
	efl_noclip_active						= (1 << 2),
	efl_setting_up_bones					= (1 << 3),
	efl_keep_on_recreate_entities			= (1 << 4),
	efl_dirty_shadowupdate					= (1 << 5),
	efl_notify								= (1 << 6),
	efl_force_check_transmit				= (1 << 7),
	efl_bot_frozen							= (1 << 8),
	efl_server_only							= (1 << 9),
	efl_no_auto_edict_attach				= (1 << 10),
	efl_dirty_abs_transform					= (1 << 11),
	efl_dirty_abs_velocity					= (1 << 12),
	efl_dirty_abs_ang_velocity				= (1 << 13),
	efl_dirty_surrounding_collision_bounds	= (1 << 14),
	efl_dirty_spatial_partition				= (1 << 15),
	efl_has_player_child					= (1 << 16),
	efl_in_skybox							= (1 << 17),
	efl_use_partition_when_not_solid		= (1 << 18),
	efl_touching_fluid						= (1 << 19),
	efl_is_being_lifted_by_barnacle			= (1 << 20),
	efl_no_rotorwash_push					= (1 << 21),
	efl_no_think_function					= (1 << 22),
	efl_no_game_physics_simulation			= (1 << 23),
	efl_check_untouch						= (1 << 24),
	efl_dont_block_los						= (1 << 25),
	efl_dont_walk_on						= (1 << 26),
	efl_no_dissolve							= (1 << 27),
	efl_no_megaphyscannon_ragdoll			= (1 << 28),
	efl_no_water_velocity_change			= (1 << 29),
	efl_no_physcannon_interaction			= (1 << 30),
	efl_no_damage_forces					= (1 << 31)
};

enum game_move_type : int
{
	move_type_none = 0,
	move_type_isometric,
	move_type_walk,
	move_type_step,
	move_type_fly,						// no gravity, but still collides with stuff
	move_type_fly_gravity,				// flies through the air and is affected by gravity
	move_type_vphysics,
	move_type_push,						// no clip to world, push and crush
	move_type_noclip,					// no gravity, no collisions, still do velocity/absvelocity
	move_type_ladder,
	move_type_observer,					// observer movement, depends on player's observer mode
	move_type_custom,
	move_type_last = move_type_custom,
	move_type_max_bits = 4
};

enum game_effect_flags : int
{
	ef_bonemerge					= (1 << 0),  // performs bone merge on client side
	ef_bright_light					= (1 << 1),  // dlight centered at entity origin
	ef_dim_light					= (1 << 2),  // player flashlight
	ef_no_interp					= (1 << 3),  // don't interpolate the next frame
	ef_no_shadow					= (1 << 4),  // don't cast no shadow
	ef_no_draw						= (1 << 5),  // don't draw entity
	ef_no_receive_shadow			= (1 << 6),  // don't receive no shadow
	ef_bonemerge_fastcull			= (1 << 7),  // for use with 'ef_bonemerge'. if this is set, then it places this ent's origin at its parent and uses the parent's bbox + the max extents of the aiment. otherwise, it sets up the parent's bones every frame to figure out where to place the aiment, which is inefficient because it'll setup the parent's bones even if the parent is not in the pvs
	ef_item_blink					= (1 << 8),  // blink an item so that the user notices it
	ef_parent_animates				= (1 << 9),  // always assume that the parent entity is animating
	ef_marked_for_fast_reflection	= (1 << 10), // marks an entity for reflection rendering when using "$reflectonlymarkedentities" material variable
	ef_no_shadow_depth				= (1 << 11), // indicates this entity does not render into any shadow depthmap
	ef_shadow_depth_nocache			= (1 << 12), // indicates this entity cannot be cached in shadow depthmap and should render every frame
	ef_no_flash_light				= (1 << 13),
	ef_no_csm						= (1 << 14), // indicates this entity does not render into the cascade shadow depthmap
	ef_max_bits						= 15
};

enum game_team_id : int
{
	team_unassigned = 0,
	team_spectator,
	team_t,
	team_ct
};

enum game_observer_mode : int
{
	obs_mode_none = 0,
	obs_mode_deathcam,
	obs_mode_freezecam,
	obs_mode_fixed,
	obs_mode_in_eye,
	obs_mode_chase,
	obs_mode_roaming
};

enum game_think_method : int
{
	think_fire_all_functions = 0,
	think_fire_base_only,
	think_fire_all_but_base,
};

```

`sdk/valve/classes/user_cmd.h`:

```h
#pragma once
#include "../maths/q_angle.h"
#include "../../dependencies/memory/modules.h"
#include "../../dependencies/memory/scanner.h"
#include "../../dependencies/memory/signatures.h"
#include "../../dependencies/memory/virtual.h"
#include "../../dependencies/other/hash.h"
#include "../maths/vector.h"

#pragma region user cmd flags

enum command_buttons : int
{
	in_attack			= (1 << 0),
	in_jump				= (1 << 1),
	in_duck				= (1 << 2),
	in_forward			= (1 << 3),
	in_back				= (1 << 4),
	in_use				= (1 << 5),
	in_cancel			= (1 << 6),
	in_left				= (1 << 7),
	in_right			= (1 << 8),
	in_move_left		= (1 << 9),
	in_move_right		= (1 << 10),
	in_second_attack	= (1 << 11),
	in_run				= (1 << 12),
	in_reload			= (1 << 13),
	in_left_alt			= (1 << 14),
	in_right_alt		= (1 << 15),
	in_score			= (1 << 16),
	in_speed			= (1 << 17),
	in_walk				= (1 << 18),
	in_zoom				= (1 << 19),
	in_first_weapon		= (1 << 20),
	in_second_weapon	= (1 << 21),
	in_bullrush			= (1 << 22),
	in_first_grenade	= (1 << 23),
	in_second_grenade	= (1 << 24),
	in_middle_attack	= (1 << 25),
	in_use_or_reload	= (1 << 26)
};

#pragma endregion

class game_user_cmd
{
public:
	virtual			~game_user_cmd() { }	// 0x00
	int				command_number;			// 0x04
	int				tick_count;				// 0x08
	q_angle			view_angles;			// 0x0C
	vector_3d		aim_direction;			// 0x18
	float			forward_move;			// 0x24
	float			side_move;				// 0x28
	float			up_move;				// 0x2C
	int				buttons;				// 0x30
	std::uint8_t	impulse;				// 0x34
	int				weapon_select;			// 0x38
	int				weapon_sub_type;		// 0x3C
	int				random_seed;			// 0x40
	short			mouse_x;				// 0x44
	short			mouse_y;				// 0x46
	bool			has_been_predicted;		// 0x48
	q_angle			head_angles;			// 0x4C
	vector_3d		head_offset;			// 0x58

	/*
	* NOTE: this no longer needed anymore.
	* thanks to lagcomp csgo_sdk for the checksum signature pattern and how it's being used.
	* credit: https://github.com/lagcomp/csgo_sdk/blob/84b1557347e1c14b73e808048c8366ebe6053fd7/csgo_sdk/csgo/ctx/impl/ctx.cpp#L275
	* credit: https://github.com/lagcomp/csgo_sdk/blob/84b1557347e1c14b73e808048c8366ebe6053fd7/csgo_sdk/csgo/valve/other/other.hpp#L135
	*/
	checksum32 checksum() const 
	{
		checksum32 check = 0UL;
		check = CHECKSUM(command_number, sizeof(command_number));
		check = CHECKSUM(tick_count, sizeof(tick_count));
		check = CHECKSUM(view_angles, sizeof(view_angles));
		check = CHECKSUM(aim_direction, sizeof(aim_direction));
		check = CHECKSUM(forward_move, sizeof(forward_move));
		check = CHECKSUM(side_move, sizeof(side_move));
		check = CHECKSUM(up_move, sizeof(up_move));
		check = CHECKSUM(buttons, sizeof(buttons));
		check = CHECKSUM(impulse, sizeof(impulse));
		check = CHECKSUM(weapon_select, sizeof(weapon_select));
		check = CHECKSUM(weapon_sub_type, sizeof(weapon_sub_type));
		check = CHECKSUM(random_seed, sizeof(random_seed));
		check = CHECKSUM(mouse_x, sizeof(mouse_x));
		check = CHECKSUM(mouse_y, sizeof(mouse_y));
		check = CHECKSUM(has_been_predicted, sizeof(has_been_predicted));
		check = CHECKSUM(head_angles, sizeof(head_angles));
		check = CHECKSUM(head_offset, sizeof(head_offset));
		return check;
	}
};

class game_verified_user_cmd
{
public:
	game_user_cmd	cmd;	    // 0x00
	checksum32		checksum;	// 0x64
};
```

`sdk/valve/entity/entity.cpp`:

```cpp
#include "entity.h"

base_combat_weapon* base_player::active_weapon()
{
	if (!this)
		return nullptr;

	return interfaces->entity_list->get_handle<base_combat_weapon>(this->active_weapon_handle());
}

game_weapon_info* base_combat_weapon::weapon_data()
{
	if (!this)
		return nullptr;

	return interfaces->weapon_system->weapon_data(this->item_definition_index());
}

int base_animating::bone_by_hash(const hash32 bone_hash)
{
	game_studio_hdr* model_hdr = this->model_ptr();

	if (model_hdr != nullptr)
	{
		for (int i = 0; i < model_hdr->bone_count; i++)
		{
			game_studio_bone* bone = model_hdr->bone(i);

			if (bone != nullptr && HASH_RUNTIME(bone->name()) == bone_hash)
				return i;
		}
	}

	// given invalid bone hash or model header is corrupted.
	assert(false);
	return game_bone_index::bone_invalid;
}

vector_3d base_animating::bone_position(int bone_index)
{
	game_studio_hdr* model_hdr = this->model_ptr();

	if (model_hdr != nullptr && bone_index >= 0 && bone_index < model_hdr->bone_count)
	{
		if (!this->setup_bones(nullptr, -1, bone_used_by_anything, interfaces->global_vars->current_time))
			return vector_3d();

		const game_bone_accessor& accessor = this->bone_accessor();
		return accessor.matrix_bones[bone_index].get_origin();
	}

	// given invalid bone index or model header is corrupted.
	assert(false);
	return vector_3d();
}

vector_3d base_animating::hitbox_position(int hitbox_index)
{
	game_studio_hdr* model_hdr = this->model_ptr();

	if (model_hdr != nullptr && hitbox_index > game_hitbox::hitbox_invalid && hitbox_index < game_hitbox::hitbox_max)
	{
		game_studio_bounding_box* hitbox = model_hdr->hitbox_set(this->hitbox_set())->hitbox(hitbox_index);

		if (hitbox != nullptr)
		{
			if (!this->setup_bones(nullptr, -1, bone_used_by_anything, interfaces->global_vars->current_time))
				return vector_3d();

			const game_bone_accessor& accessor = this->bone_accessor();
			const matrix_3x4& transform_bone = accessor.matrix_bones[hitbox->bone];

			matrix_3x4 bone_orientation = maths->angle_matrix(hitbox->offset_orientation);
			bone_orientation = transform_bone.concat_transforms(bone_orientation);

			const vector_3d min = maths->vector_transform(hitbox->mins, bone_orientation),
							max = maths->vector_transform(hitbox->maxs, bone_orientation);

			// get centre of hitbox.
			return (min + max) * 0.5f;
		}
	}

	// given invalid hitbox index or model header is corrupted.
	assert(false);
	return vector_3d();
}

vector_3d cs_player::shoot_position()
{
	vector_3d position = this->eye_position();

	if (this->is_new_animation_state())
	{
		const game_animation_state* animation_state = this->animation_state();
		
		if (animation_state != nullptr)
			animation_state->modify_eye_position(position);
	}

	return position;
}

void base_player::post_think()
{
	static auto post_think_vphysics_original				= SEARCH(modules->client, signatures::entity::post_think_vphysics::signature()).reinterpret<bool(__thiscall*)(base_entity*)>();
	static auto simulate_player_simulated_entities_original = SEARCH(modules->client, signatures::entity::simulate_player_simulated_entities::signature()).reinterpret<void(__thiscall*)(base_entity*)>();

	interfaces->mdl_cache->begin_lock();
	{
		if (this->alive() || static_cast<cs_player*>(this)->ghost())
		{
			this->update_collision_bounds();

			if (this->flags() & fl_on_ground)
				this->local_data()->fall_velocity() = 0.f;

			if (this->sequence() == -1)
				this->set_sequence(0);

			this->studio_frame_advance();
			post_think_vphysics_original(this);
		}

		simulate_player_simulated_entities_original(this);
	}
	interfaces->mdl_cache->end_lock();
}

```

`sdk/valve/entity/entity.h`:

```h
#pragma once
#include "../classes/clients.h"
#include "../other/animations.h"

class base_entity : public game_client_entity
{
public:
	NETVAR("CBaseEntity->m_iTeamNum", team, int)

	NETVAR("CBaseEntity->m_flAnimTime", animation_time, float)
	NETVAR("CBaseEntity->m_flSimulationTime", simulation_time, float)

	NETVAR_OFFSET("CBaseEntity->m_flSimulationTime", 0x4, old_simulation_time, float)

	NETVAR("CBaseEntity->m_bSpotted", spotted, bool)

	NETVAR("CBaseEntity->m_vecOrigin", origin, vector_3d)

	NETVAR("CBaseEntity->m_angRotation", rotation, q_angle)

	NETVAR("CBaseCombatCharacter->m_hActiveWeapon", active_weapon_handle, base_handle)

	DATAMAP(this->prediction_map(), "m_iEFlags", eflags, int)
	DATAMAP(this->prediction_map(), "m_MoveType", move_type, int)

	DATAMAP(this->prediction_map(), "m_vecAbsVelocity", abs_velocity, vector_3d)
	DATAMAP(this->prediction_map(), "m_angAbsRotation", abs_rotation, q_angle)

	DATAMAP(this->description_map(), "m_rgflCoordinateFrame", coordinate_frame, const matrix_3x4&)

	[[nodiscard]] bool physics_run_think(game_think_method think_method = think_fire_all_functions)
	{
		static auto physics_run_think_original = SEARCH(modules->client, signatures::entity::physics_run_think::signature()).reinterpret<bool(__thiscall*)(base_entity*, game_think_method)>();
		return physics_run_think_original(this, think_method);
	}
};

class base_animating : public base_entity
{
public:
	NETVAR("CBaseAnimating->m_nHitboxSet", hitbox_set, int)
	NETVAR("CBaseAnimating->m_nSequence", sequence, int)

	NETVAR("CBaseAnimating->m_flCycle", cycle, float)

	NETVAR("CBaseAnimating->m_bClientSideAnimation", client_side_animation, bool)

	NETVAR_OFFSET("CBaseAnimating->m_nForceBone", 0x4, most_recent_bone_counter, unsigned long)
	NETVAR_OFFSET("CBaseAnimating->m_nForceBone", 0x3C, bone_attachments, utl_vector<base_handle>)
	NETVAR_OFFSET("CBaseAnimating->m_nForceBone", 0x18, bone_accessor, game_bone_accessor)

	NETVAR_OFFSET("CBaseAnimating->m_hLightingOrigin", -0x20, last_bone_setup_time, float)
	NETVAR_OFFSET("CBaseAnimating->m_hLightingOrigin", -0x18, allow_jiggle_bones, bool)

	game_studio_hdr* model_ptr()
	{
		game_studio_hdr* hdr = interfaces->model_info->studio_model(this->get_model());

		if (!hdr)
			return nullptr;

		return hdr;
	}

	void update_client_side_animation()
	{
		virtuals->call<void>(this, 224);
	}

	void set_sequence(int handle)
	{
		virtuals->call<void>(this, 219, handle);
	}

	void studio_frame_advance()
	{
		virtuals->call<void>(this, 220);
	}

	void invalidate_bone_cache()
	{
		static unsigned long& model_bone_counter = *SEARCH(modules->client, signatures::entity::model_bone_counter::signature()).add(0x2).reinterpret<unsigned long*>();
		this->most_recent_bone_counter() = model_bone_counter - 1;
		this->last_bone_setup_time() = -FLT_MAX;
	}

	int bone_by_hash(const hash32 bone_hash);
	vector_3d bone_position(int bone_index);
	vector_3d hitbox_position(int hitbox_index);
};

class base_animating_overlay : public base_animating
{
public:
	utl_vector<game_animation_layer>& animation_overlays()
	{
		static const std::uintptr_t original_animation_overlays = *SEARCH(modules->client, signatures::entity::animation_overlays::signature()).add<std::uintptr_t*>(0x2);
		return *reinterpret_cast<utl_vector<game_animation_layer>*>(reinterpret_cast<std::uint8_t*>(this) + original_animation_overlays);
	}

	bool update_dispatch_layer(game_animation_layer* layer, game_studio_hdr* hdr, int sequence) { return virtuals->call<bool>(this, 247, layer, hdr, sequence); }
};

class base_combat_weapon : public base_animating
{
public:
	NETVAR("CBaseCombatWeapon->m_flNextPrimaryAttack", next_primary_attack, float)
	NETVAR("CBaseCombatWeapon->m_flNextSecondaryAttack", next_secondary_attack, float)

	NETVAR("CBaseAttributableItem->m_iItemDefinitionIndex", item_definition_index, short)

	NETVAR("CBaseCombatWeapon->m_iClip1", ammo, int)

	[[nodiscard]] float spread()		{ return virtuals->call<float>(this, 453); }
	[[nodiscard]] float inaccuracy()	{ return virtuals->call<float>(this, 483); }

	game_weapon_info* weapon_data();
};

class player_local_data
{
public:
	NETVAR("CLocal->m_flFallVelocity", fall_velocity, float)
};

class base_player : public base_animating_overlay
{
public:
	NETVAR("CBasePlayer->m_fFlags", flags, int)
	NETVAR("CBasePlayer->m_iHealth", health, int)
	NETVAR("CBasePlayer->m_nTickBase", tick_base, int)
	NETVAR("CBasePlayer->m_iObserverMode", observer_mode, int)
	NETVAR("CBasePlayer->m_nNextThinkTick", next_think_tick, int)

	NETVAR_OFFSET("CBasePlayer->m_hViewEntity", -0xC, get_button_disabled, int)
	NETVAR_OFFSET("CBasePlayer->m_hViewEntity", -0x8, get_button_forced, int)
	DATAMAP(this->prediction_map(), "m_nButtons", get_buttons, int)
	DATAMAP(this->prediction_map(), "m_afButtonLast", get_button_last, int)
	DATAMAP(this->prediction_map(), "m_afButtonPressed", get_button_pressed, int)
	DATAMAP(this->prediction_map(), "m_afButtonReleased", get_button_released, int)

	NETVAR_PTR("CBasePlayer->m_Local", local_data, player_local_data)

	NETVAR("CBasePlayer->m_aimPunchAngle", aim_punch, q_angle)
	NETVAR("CBasePlayer->m_viewPunchAngle", view_punch, q_angle)

	NETVAR_OFFSET_PTR("CBasePlayer->deadflag", 0x4, view_angles, q_angle)

	NETVAR("CBasePlayer->m_vecVelocity[0]", velocity, vector_3d)
	NETVAR("CBasePlayer->m_vecViewOffset[0]", view_offset, vector_3d)

	NETVAR("CBasePlayer->m_hGroundEntity", ground_entity_handle, base_handle)

	NETVAR_OFFSET("CBasePlayer->m_hViewEntity", -0x4, get_current_command, game_user_cmd*)

	base_combat_weapon* active_weapon();

	[[nodiscard]] game_user_cmd& get_last_command()
	{
		return *SEARCH(modules->client, signatures::entity::get_last_command::signature()).add(0x2).reinterpret<game_user_cmd*>();
	}

	void pre_think()
	{
		virtuals->call<void>(this, 318);
	}

	void think()
	{
		virtuals->call<void>(this, 139);
	}

	void update_collision_bounds()
	{
		virtuals->call<void>(this, 340);
	}

	void post_think();

	bool alive()
	{
		if (!this) return false;
		return this->health() > 0;
	}

	vector_3d eye_position()
	{
		vector_3d position = this->client_entity()->abs_origin() + this->view_offset();
		return position;
	}
};

class cs_player : public base_player
{
public:
	NETVAR("CCSPlayer->m_ArmorValue", armor, int)

	NETVAR("CCSPlayer->m_flLowerBodyYawTarget", lby, float)
	NETVAR("CCSPlayer->m_flDuckAmount", duck_amount, float)
	NETVAR("CCSPlayer->m_flFlashDuration", flash_duration, float)
	NETVAR("CCSPlayer->m_flFlashMaxAlpha", flash_max_alpha, float)

	NETVAR("CCSPlayer->m_bIsScoped", scoped, bool)
	NETVAR("CCSPlayer->m_bHasHelmet", helmet, bool)
	NETVAR("CCSPlayer->m_bGunGameImmunity", immunity, bool)
	NETVAR("CCSPlayer->m_bHasHeavyArmor", heavy_armor, bool)
	NETVAR("CCSPlayer->m_bIsPlayerGhost", ghost, bool)

	NETVAR_OFFSET("CCSPlayer->m_flLastExoJumpTime", 0x8, is_new_animation_state, bool)

	NETVAR("CCSPlayer->m_angEyeAngles[0]", eye_angle, q_angle)

	NETVAR_OFFSET("CCSPlayer->m_bIsScoped", -0x14, animation_state, game_animation_state*)

	vector_3d shoot_position();
};

class weapon_cs_base : public base_combat_weapon
{
public:
	NETVAR("CWeaponCSBase->m_fAccuracyPenalty", accuracy_penalty, float)
	NETVAR("CWeaponCSBase->m_flPostponeFireReadyTime", fire_ready_time, float)
};

class base_cs_grenade : public weapon_cs_base
{
public:
	NETVAR("CBaseCSGrenade->m_bPinPulled", pin_pulled, bool)
	NETVAR("CBaseCSGrenade->m_fThrowTime", throw_time, float)
	NETVAR("CBaseCSGrenade->m_flThrowStrength", throw_strength, float)
	NETVAR("CBaseCSGrenadeProjectile->m_nExplodeEffectTickBegin", effect_tick_begin, int)
};

class smoke_grenade
{
public:
	NETVAR("CSmokeGrenadeProjectile->m_nSmokeEffectTickBegin", effect_tick_begin, int)
	float expiry_time() { return 18.f; }
};

class inferno
{
public:
	NETVAR("CInferno->m_nFireEffectTickBegin", effect_tick_begin, int)

	float expiry_time() {
		return convars::other::inferno_flame_lifetime::convar()->get_float();
	}
};

class planted_c4
{
public:
	NETVAR("CPlantedC4->m_bBombTicking", planted, bool)
	NETVAR("CPlantedC4->m_bBombDefused", defused, bool)

	NETVAR("CPlantedC4->m_flC4Blow", blow_time, float)
	NETVAR("CPlantedC4->m_flTimerLength", bomb_timer_length, float)
	NETVAR("CPlantedC4->m_flDefuseLength", defuse_length, float)
	NETVAR("CPlantedC4->m_flDefuseCountDown", defuse_countdown, float)

	NETVAR("CPlantedC4->m_hBombDefuser", defuser_handle, base_handle)

	float bomb_timer(const float server_time) { return std::clamp(this->blow_time() - server_time, 0.f, this->bomb_timer_length()); }
	float defuse_timer(const float server_time) { return std::clamp(this->defuse_countdown() - server_time, 0.f, this->defuse_length()); }
};

```

`sdk/valve/entity/other.h`:

```h
#pragma once
#include <assert.h>

#pragma region base handle definitions

// how many bits to use to encode an edict
#define	MAX_EDICT_BITS 11

// max number of edicts in a level
#define	MAX_EDICTS ( 1 << MAX_EDICT_BITS )

#define ENTITY_ENTRY_BITS ( MAX_EDICT_BITS + 2 )
#define ENTITY_ENTRIES ( 1 << ENTITY_ENTRY_BITS )

#define SERIAL_BITS 16
#define SERIAL_SHIFT_BITS ( 32 - SERIAL_BITS )
#define ENTITY_ENTRY_MASK ( ( 1 << SERIAL_BITS ) - 1 )

#define INVALID_HANDLE_INDEX 0xFFFFFFFF
#define STATIC_PROP_HANDLE_MASK ( ( 1 << 30 ) >> SERIAL_SHIFT_BITS )

#pragma endregion

class base_handle
{
public:
	base_handle() noexcept : index{ INVALID_HANDLE_INDEX } { }
	base_handle(const base_handle& other) noexcept : index{ other.index } { }

	base_handle(const int entry, const int serial) noexcept
	{
		assert(entry >= 0 && (entry & ENTITY_ENTRY_MASK) == entry);
		assert(serial >= 0 && serial < (1 << SERIAL_BITS));
		this->index = entry | (serial << SERIAL_SHIFT_BITS);
	}

	bool operator!=(const base_handle& other) const noexcept
	{
		return this->index != other.index;
	}

	bool operator==(const base_handle& other) const noexcept
	{
		return this->index == other.index;
	}

	bool operator<(const base_handle& other) const noexcept
	{
		return this->index < other.index;
	}

	[[nodiscard]] bool valid() const noexcept
	{
		return this->index != INVALID_HANDLE_INDEX;
	}

	[[nodiscard]] int entry_index() const noexcept
	{
		if (!this->valid())
			return ENTITY_ENTRIES - 1;

		return static_cast<int>(this->index & ENTITY_ENTRY_MASK);
	}

	[[nodiscard]] int serial_number() const noexcept
	{
		return static_cast<int>(this->index >> SERIAL_SHIFT_BITS);
	}

public:
	std::uint32_t index;
};

class handle_entity
{
public:
	virtual ~handle_entity() { }
	virtual void set_ref_entity_handle(const base_handle& ref) = 0;
	virtual const base_handle& get_ref_entity_handle() const = 0;
};

template <typename t>
class bit_flags
{
public:
	bit_flags() : value{ } { }
	bit_flags(const t& input) { value = input; }

	bool has(const t& input) const { return value & input; }
	void add(const t& input) { value |= input; }
	void remove(const t& input) { value &= ~input; }
	void clear() { value = NULL; }
	bool empty() const { return value == std::numeric_limits<t>::quiet_NaN(); }

	operator t() const { return value; }

	bit_flags<t>& operator=(const bit_flags<t>& input) {
		value = input.value;
		return *this;
	}

	t& operator=(const t& input) {
		value = input;
		return value;
	}

protected:
	t value;
};
```

`sdk/valve/interface/classes/base_client.h`:

```h
#pragma once

class client_networkable;
using create_client_class = client_networkable * (__cdecl*)(int, int);
using create_event = client_networkable * (__cdecl*)();
struct receive_table;

struct game_client_class
{
	create_client_class			create_class;
	create_event				create_event;
	char*						network_name;
	receive_table*				recv_table;
	game_client_class*			next;
	int							class_id;
};

class game_base_client
{
public:
	game_client_class* capture_all() { return virtuals->call<game_client_class*>(this, 8); }
};
```

`sdk/valve/interface/classes/base_interface.h`:

```h
#pragma once

// all interfaces derive from this.
class game_base_interface
{
public:
	virtual ~game_base_interface() { }
};

using instantiate_interface = void* (__cdecl*)();

// used internally to register interface classes.
class interface_register
{
public:
	instantiate_interface	create; // 0x00
	const char*				name;	// 0x04
	interface_register*		next;	// 0x08
};
```

`sdk/valve/interface/classes/client_mode.h`:

```h
#pragma once

#pragma region signon state definitions

#define signon_state_none			0	// no state yet, about to connect
#define signon_state_challenge		1	// client challenging server, all oob packets
#define signon_state_connected		2	// client is connected to server, netchans ready
#define signon_state_new			3	// just got serverinfo and string tables
#define signon_state_pre_spawn		4	// received signon buffers
#define signon_state_spawn			5	// ready to receive entity packets
#define signon_state_full			6	// we are fully connected, first non-delta packet received (in-game check)
#define signon_state_change_level	7	// server is changing level, please wait

#pragma endregion

typedef DWORD h_cursor;

class game_view_setup
{
public:
	int			x;
	int			unscaled_x;
	int			y;
	int			unscaled_y;
	int			width;
	int			unscaled_width;
	int			height;
	int			unscaled_height;
	bool		ortho;
	float		ortho_left;
	float		ortho_top;
	float		ortho_right;
	float		ortho_bottom;
	std::byte	_pad0[0x7c];
	float		fov;
	float		viewmodel_fov;
	vector_3d	origin;
	q_angle		view_angle;
	float		near_z;
	float		far_z;
	float		near_viewmodel_z;
	float		far_viewmodel_z;
	float		aspect_ratio;
	float		near_blur_depth;
	float		near_focus_depth;
	float		far_focus_depth;
	float		far_blur_depth;
	float		near_blur_radius;
	float		far_blur_radius;
	float		do_fquality;
	int			motion_blur_mode;
	float		shutter_time;
	vector_3d	shutter_open_position;
	q_angle		shutter_open_angles;
	vector_3d	shutter_close_position;
	q_angle		shutter_close_angles;
	float		off_center_top;
	float		off_center_bottom;
	float		off_center_left;
	float		off_center_right;
	bool		off_center : 1;
	bool		render_to_subrect_of_larger_screen : 1;
	bool		do_bloom_and_tone_mapping : 1;
	bool		do_depth_of_field : 1;
	bool		hdr_target : 1;
	bool		draw_world_normal : 1;
	bool		cull_font_faces : 1;
	bool		cache_fullscene_state : 1;
	bool		csm_view : 1;
};

class game_hud_chat;
class game_client_mode
{
public:
	std::byte		_pad0[0x1b];
	void*			view_port;
	game_hud_chat*	chat_element;
	h_cursor		cursor_none;
	void*			weapon_selection;
	int				root_size[2];
};

class game_app_system
{
private:
	virtual void function0() = 0;
	virtual void function1() = 0;
	virtual void function2() = 0;
	virtual void function3() = 0;
	virtual void function4() = 0;
	virtual void function5() = 0;
	virtual void function6() = 0;
	virtual void function7() = 0;
	virtual void function8() = 0;
};

class game_event_info
{
public:
	short						class_id;		// 0x00 // 0 implies not in use
	float						fire_delay;		// 0x02 // if non-zero, the delay time when the event should be fired ( fixed up on the client )
	const void*					send_table;		// 0x06
	const game_client_class*	client_class;	// 0x0a // clienclass pointer
	void*						data;			// 0x0e // raw event data
	std::intptr_t				packed_bits;	// 0x12
	int							flags;			// 0x16
	std::byte					_pad0[0x16];	// 0x1a
};

class game_client_state
{
public:
	std::byte			_pad0[0x9c];				// 0x0000
	game_net_channel*	net_channel;				// 0x009c
	int					challenge;					// 0x00a0
	std::byte			_pad1[0x64];				// 0x00a4
	int					signon_state;				// 0x0108
	std::byte			_pad2[0x8];					// 0x010c
	float				next_cmd_time;				// 0x0114
	int					server_count;				// 0x0118
	int					current_sequence;			// 0x011c
	std::byte			_pad3[0x54];				// 0x0120
	int					delta_tick;					// 0x0174
	bool				paused;						// 0x0178
	std::byte			_pad4[0x7];					// 0x0179
	int					view_entity;				// 0x0180
	int					player_slot;				// 0x0184
	char				level_name[MAX_PATH];		// 0x0188
	char				level_name_short[80];		// 0x028c
	char				map_group_name[80];			// 0x02dc
	char				last_level_name_short[80];	// 0x032c
	std::byte			_pad5[0xc];					// 0x037c
	int					max_clients;				// 0x0388 
	std::byte			_pad6[0x498c];				// 0x038c
	float				last_server_tick_time;		// 0x4d18
	bool				in_simulation;				// 0x4d1c
	std::byte			_pad7[0x3];					// 0x4d1d
	int					old_tick_count;				// 0x4d20
	float				tick_remainder;				// 0x4d24
	float				frame_time;					// 0x4d28
	int					last_out_going_command;		// 0x4d2c
	int					choked_commands;			// 0x4d30
	int					last_command_ack;			// 0x4d34
	int					command_ack;				// 0x4d38
	int					sound_sequence;				// 0x4d3c
	std::byte			_pad8[0x50];				// 0x4d40
	q_angle				view_angle;					// 0x4d90
	std::byte			_pad9[0xd0];				// 0x4d9c
	game_event_info*	events;						// 0x4e6c
};
```

`sdk/valve/interface/classes/debug_overlay.h`:

```h
#pragma once

class game_overlay_text;

class game_debug_overlay
{
public:
	virtual void				add_entity_text_overlay(int entity_index, int line_offset, float duration, int r, int g, int b, int a, const char* fmt, ...) = 0;
	virtual void				add_box_overlay(const vector_3d& origin, const vector_3d& abs_min, const vector_3d& abs_max, const q_angle& orientation, int r, int g, int b, int a, float duration) = 0;
	virtual void				add_sphere_overlay(const vector_3d& origin, float radius, int theta, int phi, int r, int g, int b, int a, float duration) = 0;
	virtual void				add_triangle_overlay(const vector_3d& p1, const vector_3d& p2, const vector_3d& p3, int r, int g, int b, int a, bool no_depth_test, float duration) = 0;
	virtual void				add_line_overlay(const vector_3d& origin, const vector_3d& vecdest, int r, int g, int b, bool no_depth_test, float duration) = 0;
	virtual void				add_text_overlay(const vector_3d& origin, float duration, const char* fmt, ...) = 0;
	virtual void				add_text_overlay(const vector_3d& origin, int line_offset, float duration, const char* fmt, ...) = 0;
	virtual void				add_screen_text_overlay(float x_pos, float y_pos, float duration, int r, int g, int b, int a, const char* text) = 0;
	virtual void				add_swept_box_overlay(const vector_3d& start, const vector_3d& end, const vector_3d& mins, const vector_3d& maxs, const q_angle& angles, int r, int g, int b, int a, float duration) = 0;
	virtual void				add_grid_overlay(const vector_3d& origin) = 0;
	virtual void				add_coord_frame_overlay(const matrix_3x4& frame, float scale, int color_table[3][3] = nullptr) = 0;
	virtual int					screen_position(const vector_3d& point, vector_3d& screen) = 0;
	virtual int					screen_position(float x_pos, float y_pos, vector_3d& screen) = 0;
	virtual game_overlay_text*	get_first() = 0;
	virtual game_overlay_text*	get_next(game_overlay_text* current) = 0;
	virtual void				clear_dead_overlays() = 0;
	virtual void				clear_all_overlays() = 0;
	virtual void				add_text_overlay_rgb(const vector_3d& origin, int line_offset, float duration, float r, float g, float b, float a, const char* fmt, ...) = 0;
	virtual void				add_text_overlay_rgb(const vector_3d& origin, int line_offset, float duration, int r, int g, int b, int a, const char* fmt, ...) = 0;
	virtual void				add_line_overlay_alpha(const vector_3d& origin, const vector_3d& dest, int r, int g, int b, int a, bool no_depth_test, float duration) = 0;
	virtual void				add_box_overlay2(const vector_3d& origin, const vector_3d& abs_min, const vector_3d& abs_max, const q_angle& orientation, const color& face_color, const color& edge_color, float duration) = 0;
	virtual void				add_line_overlay(const vector_3d& origin, const vector_3d& vecdest, int r, int g, int b, int a, float thickness, float duration) = 0;
	virtual void				purge_text_overlays() = 0;
	virtual void				add_capsule_overlay(const vector_3d& abs_min, const vector_3d& abs_max, const float& radius, int r, int g, int b, int a, float duration) = 0;
	virtual void				draw_pill(vector_3d& abs_min, vector_3d& abs_max, float radius, int r, int g, int b, int a, float duration) = 0;
};
```

`sdk/valve/interface/classes/engine_client.h`:

```h
#pragma once
#include "../../../dependencies/other/hash.h"

#pragma region engine client flags

enum client_frame_stage : int
{
	frame_undefined = -1,
	frame_start,

	// a network packet is being recieved.
	frame_net_update_start,

	// data has been received and we are going to start calling postdataupdate.
	frame_net_update_post_data_update_start,

	// data has been received and called postdataupdate on all data recipients.
	frame_net_update_post_data_update_end,

	// received all packets, we can now do interpolation, prediction, etc...
	frame_net_update_end,

	// start rendering the scene.
	frame_render_start,

	// finished rendering the scene.
	frame_render_end,
	frame_net_full_frame_update_on_remove
};

#pragma endregion

struct game_player_info
{
	std::uint64_t	version;
	std::uint64_t	xuid;
	char			name[128];
	int				user_id;
	char			steam_id[33];
	std::uint32_t	friends_id;
	char			friends_name[128];
	bool			fake_player;
	bool			is_hltv;
	checksum32		custom_files[4];
	std::uint8_t	files_downloaded;
};

class game_engine_client
{
public:
	void					get_screen_size(int& width, int& height) { return virtuals->call<void>(this, 5, std::ref(width), std::ref(height)); }
	bool					get_player_info(int index, game_player_info* info) { return virtuals->call<bool>(this, 8, index, info); }
	int						get_player_uid(int uid) { return virtuals->call<int>(this, 9, uid); }
	bool					is_console_visible() { return virtuals->call<bool>(this, 11); }
	int						get_local_player() { return virtuals->call<int>(this, 12); }
	void					get_view_angles(q_angle& view_angle) { return virtuals->call<void>(this, 18, std::ref(view_angle)); }
	void					set_view_angles(q_angle& view_angle) { return virtuals->call<void>(this, 19, std::ref(view_angle)); }
	bool					in_game() { return virtuals->call<bool>(this, 26); }
	const view_matrix&			world_to_screen_matrix() { return virtuals->call<const view_matrix&>(this, 37); }
	game_net_channel_info*	net_info() { return virtuals->call<game_net_channel_info*>(this, 78); }
	bool					hltv() { return virtuals->call<bool>(this, 93); }
};

```

`sdk/valve/interface/classes/engine_convar.h`:

```h
#pragma once

#pragma region engine convar flags

enum game_engine_convar_flags
{
	// convar systems
	cvar_none						= 0,
	cvar_unregistered				= (1 << 0),		// if this is set, don't add to linked list, etc.
	cvar_development_only			= (1 << 1),		// hidden in released products. flag is removed automatically if allow_development_cvars is defined.
	cvar_game_dll					= (1 << 2),		// defined by the game dll
	cvar_client_dll					= (1 << 3),		// defined by the client dll
	cvar_hidden						= (1 << 4),		// hidden. doesn't appear in find or autocomplete. like developmentonly, but can't be compiled out.

	// convar only
	cvar_protected					= (1 << 5),		// it's a server cvar, but we don't send the data since it's a password, etc.  sends 1 if it's not bland/zero, 0 otherwise as value
	cvar_sponly						= (1 << 6),		// this cvar cannot be changed by clients connected to a multiplayer server.
	cvar_archive					= (1 << 7),		// set to cause it to be saved to vars.rc
	cvar_notify						= (1 << 8),		// notifies players when changed
	cvar_userinfo					= (1 << 9),		// changes the client's info string
	cvar_cheat						= (1 << 14),	// only useable in singleplayer / debug / multiplayer & sv_cheats
	cvar_printable_only				= (1 << 10),	// this cvar's string cannot contain unprintable characters ( e.g., used for player name etc ).
	cvar_unlogged					= (1 << 11),	// if this is a fcvar_server, don't log changes to the log file / console if we are creating a log
	cvar_never_as_string			= (1 << 12),	// never try to print that cvar

	// it's a convar that's shared between the client and the server.
	// at signon, the values of all such convars are sent from the server to the client (skipped for local client, ofc )
	// if a change is requested it must come from the console (i.e., no remote client changes)
	// if a value is changed while a server is active, it's replicated to all connected clients
	cvar_server						= (1 << 13),	// server setting enforced on clients, replicated
	cvar_demo						= (1 << 16),	// record this cvar when starting a demo file
	cvar_dont_record				= (1 << 17),	// don't record these command in demofiles
	cvar_reload_materials			= (1 << 20),	// if this cvar changes, it forces a material reload
	cvar_reload_textures			= (1 << 21),	// if this cvar changes, if forces a texture reload
	cvar_not_connected				= (1 << 22),	// cvar cannot be changed by a client that is connected to a server
	cvar_material_system_thread		= (1 << 23),	// indicates this cvar is read from the material system thread
	cvar_archive_xbox				= (1 << 24),	// cvar written to config.cfg on the xbox
	cvar_accessible_from_threads	= (1 << 25),	// used as a debugging tool necessary to check material system thread convars
	cvar_server_can_execute			= (1 << 28),	// the server is allowed to execute this command on clients via clientcommand/net_stringcmd/cbaseclientstate::processstringcmd.
	cvar_server_cannot_query		= (1 << 29),	// if this is set, then the server is not allowed to query this cvar's value (via iserverpluginhelpers::startquerycvarvalue).
	cvar_clientcmd_can_execute		= (1 << 30),	// ivengineclient::clientcmd is allowed to execute this command. 
	cvar_material_thread_mask		= (cvar_reload_materials | cvar_reload_textures | cvar_material_system_thread)
};

#pragma endregion

typedef int game_convar_dll_identifier;
class convar_cmd;
class convar_base;

class game_engine_convar : public game_app_system
{
public:
	virtual game_convar_dll_identifier	allocate_dll_identifier() = 0;
	virtual void						register_command(game_convar* command_base, int default_value = 1) = 0;
	virtual void						unregister_command(game_convar* command_base) = 0;
	virtual void						unregister_commands(game_convar_dll_identifier id) = 0;
	virtual const char*					get_command_value(const char* variable_name) = 0;
	virtual convar_base*				find_command_base(const char* name) = 0;
	virtual const convar_base*			find_command_base(const char* name) const = 0;
	virtual game_convar*				find(const char* variable_name) = 0;
	virtual const game_convar*			find(const char* variable_name) const = 0;
	virtual convar_cmd*					find_command(const char* name) = 0;
	virtual const convar_cmd*			find_command(const char* name) const = 0;
	virtual void						install_global_change_callback(change_callback callback) = 0;
	virtual void						remove_global_change_callback(change_callback callback) = 0;
	virtual void						call_global_change_callbacks(game_convar* var, const char* old_string, float old_value) = 0;
	virtual void						install_console_display_func(void* display_func) = 0;
	virtual void						remove_console_display_func(void* display_func) = 0;
	virtual void						console_color_printf(const color& color, const char* format, ...) const = 0;
	virtual void						console_printf(const char* format, ...) const = 0;
	virtual void						console_dprintf(const char* format, ...) const = 0;
	virtual void						revert_flagged_convars(int flag) = 0;
};
```

`sdk/valve/interface/classes/engine_sound.h`:

```h
#pragma once

#pragma region engine sound flags

enum game_sound_channel
{
	chan_replace	= -1,
	chan_auto		= 0,
	chan_weapon		= 1,
	chan_voice		= 2,
	chan_item		= 3,
	chan_body		= 4,
	chan_stream		= 5,						// allocate stream channel from the static or dynamic area
	chan_static		= 6,						// allocate channel from the static area 
	chan_voice2		= 7,
	chan_voice_base = 8,						// allocate channel for network voice data
	chan_user_base	= (chan_voice_base + 128)	// anything >= this number is allocated to game code.
};

enum game_sound_level : int
{
	snd_lvl_none		= 0,
	snd_lvl_20db		= 20,			// rustling leaves
	snd_lvl_25db		= 25,			// whispering
	snd_lvl_30db		= 30,			// library
	snd_lvl_35db		= 35,
	snd_lvl_40db		= 40,
	snd_lvl_45db		= 45,			// refrigerator
	snd_lvl_50db		= 50,			// 3.9	// average home
	snd_lvl_55db		= 55,			// 3.0

	snd_lvl_idle		= 60,			// 2.0	
	snd_lvl_60db		= 60,			// 2.0	// normal conversation, clothes dryer
	snd_lvl_65db		= 65,			// 1.5	// washing machine, dishwasher

	snd_lvl_static		= 66,			// 1.25
	snd_lvl_70db		= 70,			// 1.0	// car, vacuum cleaner, mixer, electric sewing machine

	snd_lvl_norm		= 75,
	snd_lvl_75db		= 75,			// 0.8	// busy traffic
	snd_lvl_80db		= 80,			// 0.7	// mini-bike, alarm clock, noisy restaurant, office tabulator, outboard motor, passing snowmobile

	snd_lvl_talking		= 80,			// 0.7
	snd_lvl_85db		= 85,			// 0.6	// average factory, electric shaver
	snd_lvl_90db		= 90,			// 0.5	// screaming child, passing motorcycle, convertible ride on frw
	snd_lvl_95db		= 95,
	snd_lvl_100db		= 100,			// 0.4	// subway train, diesel truck, woodworking shop, pneumatic drill, boiler shop, jackhammer
	snd_lvl_105db		= 105,			// helicopter, power mower
	snd_lvl_110db		= 110,			// snowmobile drvrs seat, inboard motorboat, sandblasting
	snd_lvl_120db		= 120,			// auto horn, propeller aircraft
	snd_lvl_130db		= 130,			// air raid siren

	snd_lvl_gunfire		= 140,			// 0.27	// threshold of pain, gunshot, jet engine
	snd_lvl_140db		= 140,			// 0.2
	snd_lvl_150db		= 150,			// 0.2
	snd_lvl_180db		= 180,			// rocket launching
};

enum game_sound_flags : int
{
	snd_no_flags								= 0,			// to keep the compiler happy
	snd_change_vol								= (1 << 0),		// change sound vol
	snd_change_pitch							= (1 << 1),		// change sound pitch
	snd_stop									= (1 << 2),		// stop the sound
	snd_spawning								= (1 << 3),		// we're spawning, used in some cases for ambients
	// not sent over net, only a param between dll and server.
	snd_delay									= (1 << 4),		// sound has an initial delay
	snd_stop_looping							= (1 << 5),		// stop all looping sounds on the entity.
	snd_speaker									= (1 << 6),		// being played again by a microphone through a speaker
	snd_should_pause							= (1 << 7),		// this sound should be paused if the game is paused
	snd_ignore_phonemes							= (1 << 8),
	snd_ignore_name								= (1 << 9),		// used to change all sounds emitted by an entity, regardless of scriptname
	snd_do_not_overwrite_existing_on_channel	= (1 << 10)
};

#pragma endregion

#pragma region engine sound definitions

// volume 
#define vol_norm			1.0f

// attenuation 
#define attn_none			0.0f
#define attn_norm			0.8f
#define attn_idle			2.0f
#define attn_static			1.25f 
#define attn_ricochet		1.5f
#define attn_gunfire		0.27f
#define max_attenuation		3.98f

// sound level limits 
#define max_sndlvl_bits		9
#define min_sndlvl_value	0
#define max_sndlvl_value	((1 << max_sndlvl_bits) - 1)

// sound level 
#define sndlevel_to_compatibility_mode( x )		static_cast<game_sound_level>(static_cast<int>(x + 256))
#define sndlevel_from_compatibility_mode( x )	static_cast<game_sound_level>(static_cast<int>(x - 256))
#define sndlevel_is_compatibility_mode( x )		( x ) >= 256

// convertation 
#define attn_to_sndlvl( a ) static_cast<game_sound_level>(static_cast<int>( a ) ? (50 + 20 / (static_cast<float>( a ))) : 0)
#define sndlvl_to_attn( a ) ((a > 50) ? (20.0f / static_cast<float>(a - 50)) : 4.0)

// sound 
#define snd_flag_bits_encode 11

#define max_sound_delay_msec_encode_bits	13
#define max_sound_index_bits				14
#define	max_sounds							(1 << max_sound_index_bits)
#define max_sound_delay_msec				(1 << (max_sound_delay_msec_encode_bits - 1))    // 4096 msec or about 4 seconds

// source 
#define sound_from_ui_panel			-2
#define sound_from_local_player		-1
#define sound_from_world			0

// pitch 
#define pitch_low			95
#define	pitch_norm			100
#define pitch_high			120

#define default_sound_packet_volume 1.0f
#define default_sound_packet_pitch	100
#define default_sound_packet_delay	0.0f

#pragma endregion

using game_file_name_handle = void*;

struct game_sound_info
{
	int						guid;
	game_file_name_handle	file_name;
	int						sound_source;
	int						channel;
	int						speaker_entity;
	float					volume;
	float					last_spatialized_volume;
	float					radius;
	int						pitch;
	vector_3d*				origin;
	vector_3d*				direction;
	bool					update_positions;
	bool					is_sentence;
	bool					dry_mix;
	bool					speaker;
	bool					special_dsp;
	bool					from_server;
};

class sfx_table;

struct start_sound_parameters
{
	bool				static_sound;
	int					user_data;
	int					sound_source;
	int					entity_channel;
	sfx_table*			sfx;
	vector_3d			origin;
	vector_3d			direction;
	bool				update_positions;
	float				volume;
	game_sound_level	sound_level;
	int					flags;
	int					pitch;
	bool				from_server;
	float				delay;
	int					speaker_entity;
	bool				suppress_recording;
	int					initial_stream_position;
};

class game_recipient_filter
{
public:
	virtual			~game_recipient_filter() { }

	virtual bool	is_reliable() const = 0;
	virtual bool	is_init_message() const = 0;

	virtual int		recipient_count() const = 0;
	virtual int		recipient_index(int nslot) const = 0;
};

class vector_3d;

class game_engine_sound
{
public:
	virtual bool	pre_cache_sound(const char* sample, bool preload = false, bool is_ui_sound = false) = 0;
	virtual bool	is_sound_pre_cached(const char* sample) = 0;
	virtual void	pre_fetch_sound(const char* sample) = 0;
	virtual bool	is_looping_sound(const char* sample) = 0;
	virtual float	sound_duration(const char* sample) = 0;

	virtual int		emit_sound(game_recipient_filter& filter, int entity_index, int channel, const char* sound_entry, unsigned int sound_entry_hash, const char* sample,
		float volume, float attenuation, int seed, int flags, int pitch,
		const vector_3d* origin, const vector_3d* direction, utl_vector<vector_3d>* utl_origins, bool update_positions, float sound_time, int speaker_entity, start_sound_parameters& parameters) = 0;

	virtual int		emit_sound(game_recipient_filter& filter, int entity_index, int channel, const char* sound_entry, unsigned int sound_entry_hash, const char* sample,
		float volume, game_sound_level sound_level, int seed, int flags, int pitch,
		const vector_3d* origin, const vector_3d* direction, utl_vector<vector_3d>* utl_origins, bool update_positions, float sound_time, int speaker_entity, start_sound_parameters& parameters) = 0;

	virtual void	emit_sentence_by_index(game_recipient_filter& filter, int entity_index, int channel, int sentence_index,
		float volume, game_sound_level sound_level, int seed, int flags = 0, int pitch = pitch_norm,
		const vector_3d* origin = nullptr, const vector_3d* direction = nullptr, utl_vector<vector_3d>* utl_origins = nullptr, bool update_positions = true, float sound_time = 0.0f, int speaker_entity = -1) = 0;

	virtual void	stop_sound(int entity_index, int channel, const char* sample, unsigned int sound_entry_hash) = 0;
	virtual void	stop_all_sounds(bool clear_buffers) = 0;
	virtual void	set_room_type(game_recipient_filter& filter, int room_type) = 0;
	virtual void	set_player_dsp(game_recipient_filter& filter, int dsp_type, bool fast_reset) = 0;
	virtual void	emit_ambient_sound(const char* sample, float volume, int pitch = pitch_norm, int flags = 0, float sound_time = 0.0f) = 0;
	virtual float	distance_gain_from_sound_level(game_sound_level sound_level, float distance) = 0;
	virtual int		guid_for_last_sound_emitted() = 0;
	virtual bool	is_sound_still_playing(int guid) = 0;
	virtual void	stop_sound_by_guid(int guid, bool force_sync) = 0;
	virtual void	set_volume_by_guid(int guid, float volume) = 0;
private:
	virtual void	function0() = 0;
public:
	virtual void	active_sounds(utl_vector<game_sound_info>& sound_list) = 0;
	virtual void	pre_cache_sentence_group(const char* group_name) = 0;
	virtual void	notify_begin_movie_playback() = 0;
	virtual void	notify_end_movie_playback() = 0;
	virtual bool	sound_channel_volume(const char* sound, float& volume_left, float& volume_right) = 0;
	virtual float	elapsed_time_by_guid(int guid) = 0;
	virtual bool	prevent_sound() = 0;
	virtual void	set_replay_sound_fade(float replay_volume) = 0;
	virtual float	replay_sound_fade() const = 0;
};
```

`sdk/valve/interface/classes/engine_trace.h`:

```h
#pragma once
#include "../../maths/utl_vector.h"
#include "../../../dependencies/memory/modules.h"
#include "../../../dependencies/memory/signatures.h"
#include "../../../dependencies/memory/virtual.h"

#pragma region engine trace flags

enum game_char_texture
{
	char_texture_antlion		= 'A',
	char_texture_bloody_flesh	= 'B',
	char_texture_concrete		= 'C',
	char_texture_dirt			= 'D',
	char_texture_egg_shell		= 'E',
	char_texture_flesh			= 'F',
	char_texture_grate			= 'G',
	char_texture_alien_flesh	= 'H',
	char_texture_clip			= 'I',
	char_texture_snow			= 'K',
	char_texture_plastic		= 'L',
	char_texture_metal			= 'M',
	char_texture_sand			= 'N',
	char_texture_foliage		= 'O',
	char_texture_computer		= 'P',
	char_texture_reflective		= 'R',
	char_texture_slosh			= 'S',
	char_texture_tile			= 'T',
	char_texture_cardboard		= 'U',
	char_texture_vent			= 'V',
	char_texture_wood			= 'W',
	char_texture_fake			= 'X',
	char_texture_glass			= 'Y',
	char_texture_warp_shield	= 'Z',
	char_texture_sand_barrel	= '\xC'
};

enum game_damage_type : int
{
	damage_no			= 0,
	damage_events_only	= 1,
	damage_yes			= 2,
	damage_aim			= 3
};

enum game_collision_group : int
{
	collision_none = 0,
	collision_debris,					// collides with nothing but world and static stuff
	collision_debris_trigger,			// same as debris, but hits triggers
	collision_interactive_debris,		// collides with everything except other interactive debris or debris
	collision_interactive,				// collides with everything except interactive debris or debris
	collision_player,
	collision_breakable_glass,
	collision_vehicle,
	collision_player_movement,			// for hl2, same as collision_group_player, for / tf2, this filters out other players and cbaseobjects
	collision_npc,						// generic npc group
	collision_in_vehicle,				// for any entity inside a vehicle
	collision_weapon,					// for any weapons that need collision detection
	collision_vehicle_clip,				// vehicle clip brush to restrict vehicle movement
	collision_projectile,				// projectiles!
	collision_door_blocker,				// blocks entities not permitted to get near moving doors
	collision_passable_door,			// doors that the player shouldn't collide with
	collision_dissolving,				// things that are dissolving are in this group
	collision_push_away,				// nonsolid on client and server, pushaway in player code
	collision_npc_actor,				// used so npcs in scripts ignore the player.
	collision_npc_scripted,				// used for npcs in scripts that should not collide with each other
	collision_pz_clip,
	collision_debris_block_projectile,	// only collides with bullets
	collision_last_shared
};

enum game_trace_type : int
{
	trace_everything = 0,
	trace_world_only,
	trace_entities_only,
	trace_everything_filter_props,
	trace_filter_sky
};

enum game_trace_contents : int
{
	contents_empty					= 0,
	contents_solid					= (1 << 0),
	contents_window					= (1 << 1),
	contents_aux					= (1 << 2),
	contents_grate					= (1 << 3),
	contents_slime					= (1 << 4),
	contents_water					= (1 << 5),
	contents_blocklos				= (1 << 6),
	contents_opaque					= (1 << 7),
	contents_testfogvolum			= (1 << 8),
	contents_unused					= (1 << 9),
	contents_block_light			= (1 << 10),
	contents_team1					= (1 << 11),
	contents_team2					= (1 << 12),
	contents_ignore_nodraw_opaque	= (1 << 13),
	contents_moveable				= (1 << 14),
	contents_area_portal			= (1 << 15),
	contents_player_clip			= (1 << 16),
	contents_monster_clip			= (1 << 17),
	contents_current_0				= (1 << 18),
	contents_current_90				= (1 << 19),
	contents_current_180			= (1 << 20),
	contents_current_270			= (1 << 21),
	contents_current_up				= (1 << 22),
	contents_current_down			= (1 << 23),
	contents_origin					= (1 << 24),
	contents_monster				= (1 << 25),
	contents_debris					= (1 << 26),
	contents_detail					= (1 << 27),
	contents_translucent			= (1 << 29),
	contents_ladder					= (1 << 29),
	contents_hitbox					= (1 << 30),
	contents_last_visible			= contents_opaque,
	contents_all_visible			= (contents_last_visible | (contents_last_visible - 1))
};

enum game_trace_masks : int
{
	mask_solid						= (contents_solid | contents_moveable | contents_window | contents_monster | contents_grate),
	mask_player_solid				= (contents_solid | contents_moveable | contents_player_clip | contents_window | contents_monster | contents_grate),
	mask_npc_solid					= (contents_solid | contents_moveable | contents_monster_clip | contents_window | contents_monster | contents_grate),
	mask_npc_fluid					= (contents_solid | contents_moveable | contents_monster_clip | contents_window | contents_monster),
	mask_water						= (contents_water | contents_moveable | contents_slime),
	mask_opaque						= (contents_solid | contents_moveable | contents_opaque),
	mask_opaque_and_npcs			= (mask_opaque | contents_monster),
	mask_blocklos					= (contents_solid | contents_moveable | contents_blocklos),
	mask_blocklos_and_npcs			= (mask_blocklos | contents_monster),
	mask_visible					= (mask_opaque | contents_ignore_nodraw_opaque),
	mask_visible_and_npcs			= (mask_opaque_and_npcs | contents_ignore_nodraw_opaque),
	mask_shot						= (contents_solid | contents_moveable | contents_monster | contents_window | contents_debris | contents_hitbox),
	mask_shot_brush_only			= (contents_solid | contents_moveable | contents_window | contents_debris),
	mask_shot_hull					= (contents_solid | contents_moveable | contents_monster | contents_window | contents_debris | contents_grate),
	mask_shot_portal				= (contents_solid | contents_moveable | contents_window | contents_monster),
	mask_solid_brush_only			= (contents_solid | contents_moveable | contents_window | contents_grate),
	mask_player_solid_brush_only	= (contents_solid | contents_moveable | contents_window | contents_player_clip | contents_grate),
	mask_npc_solid_brush_only		= (contents_solid | contents_moveable | contents_window | contents_monster_clip | contents_grate),
	mask_npc_world_static			= (contents_solid | contents_window | contents_monster_clip | contents_grate),
	mask_npc_world_static_fluid		= (contents_solid | contents_window | contents_monster_clip),
	mask_split_area_portal			= (contents_water | contents_slime),
	mask_current					= (contents_current_0 | contents_current_90 | contents_current_180 | contents_current_270 | contents_current_up | contents_current_down),
	mask_dead_solid					= (contents_solid | contents_player_clip | contents_window | contents_grate),
	mask_all						= (contents_solid | contents_window | contents_aux | contents_grate | contents_slime | contents_water | contents_blocklos | contents_opaque | contents_testfogvolum | contents_unused | contents_block_light | contents_team1 | contents_team2 | contents_ignore_nodraw_opaque | contents_moveable | contents_area_portal | contents_player_clip | contents_monster_clip | contents_current_0 | contents_current_90 | contents_current_180 | contents_current_270 | contents_current_up | contents_current_down | contents_origin | contents_monster | contents_debris | contents_detail | contents_translucent | contents_ladder | contents_hitbox)
};

enum game_surface_flags : int
{
	surf_light		= (1 << 0),
	surf_sky2d		= (1 << 1),
	surf_sky		= (1 << 2),
	surf_warp		= (1 << 3),
	surf_trans		= (1 << 4),
	surf_no_portal	= (1 << 5),
	surf_trigger	= (1 << 6),
	surf_no_draw	= (1 << 7),
	surf_hint		= (1 << 8),
	surf_skip		= (1 << 9),
	surf_no_light	= (1 << 10),
	surf_bump_light = (1 << 11),
	surf_no_shadows = (1 << 12),
	surf_no_decals	= (1 << 13),
	surf_no_chop	= (1 << 14),
	surf_hitbox		= (1 << 15)
};

enum game_displacement_surface : int
{
	displacement_surface		= (1 << 0),
	displacement_walkable		= (1 << 1),
	displacement_buildable		= (1 << 2),
	displacement_surface_prop1	= (1 << 3),
	displacement_surface_prop2	= (1 << 4)
};

#pragma endregion

struct game_brush_side_info
{
	vector_aligned	plane;		// the plane of the brush side
	std::uint16_t	bevel;		// bevel plane?
	std::uint16_t	thin;		// thin?
};

struct game_cplane
{
	vector_3d		normal;		// 0x00
	float			distance;	// 0x0c
	std::uint8_t	type;		// 0x10
	std::uint8_t	sign_bits;	// 0x11
};

struct game_csurface
{
	const char*		name;			// 0x00
	short			surface_props;	// 0x04
	std::uint16_t	flags;			// 0x06
};

class game_base_trace
{
public:
	game_base_trace() { }

	vector_3d		start;			// start position
	vector_3d		end;			// final position
	game_cplane		plane;			// surface normal at impact
	float			fraction;		// time completed, 1.0 = didn't hit anything
	int				contents;		// contents on other side of surface hit
	std::uint16_t	displacement;	// displacement flags for marking surfaces with data
	bool			all_solid;		// if true, plane is not valid
	bool			start_solid;	// if true, the initial point was in a solid area
};

class base_entity;
class game_trace : public game_base_trace
{
public:
	game_trace() : hit_entity(nullptr) { }

	float				fraction_left_solid;	// time we left a solid, only valid if we started in solid
	game_csurface		surface;				// surface hit (impact surface)
	int					hitgroup;				// 0 == generic, non-zero is specific body part
	short				physics_bone;			// physics bone hit by trace in studio
	std::uint16_t		world_surface_index;	// index of the msurface2_t, if applicable
	base_entity*		hit_entity;				// entity hit by trace
	int					hitbox;					// box hit by trace in studio

	inline bool did_hit() const { return (fraction < 1.f || all_solid || start_solid); }
	inline bool is_visible() const { return (fraction > 0.97f); }

private:
	game_trace(const game_trace& other)
	{
		this->start					= other.start;
		this->end					= other.end;
		this->plane					= other.plane;
		this->fraction				= other.fraction;
		this->contents				= other.contents;
		this->displacement			= other.displacement;
		this->all_solid				= other.all_solid;
		this->start_solid			= other.start_solid;
		this->fraction_left_solid	= other.fraction_left_solid;
		this->surface				= other.surface;
		this->hitgroup				= other.hitgroup;
		this->physics_bone			= other.physics_bone;
		this->world_surface_index	= other.world_surface_index;
		this->hit_entity			= other.hit_entity;
		this->hitbox				= other.hitbox;
	}
};

struct game_ray
{
	game_ray() : world_axis_transform{ }, is_ray{ }, is_swept{ } { }

	game_ray(const vector_3d& ray_start, const vector_3d& ray_end)
	{
		delta					= vector_aligned(ray_end - ray_start);
		is_swept				= (delta.length_sqr() != 0.f);
		world_axis_transform	= nullptr;
		is_ray					= true;
		start					= ray_start;

		start_offset.zero();
		extents.zero();
	}

	game_ray(const vector_3d& ray_start, const vector_3d& ray_end, const vector_3d& ray_mins, const vector_3d& ray_maxs)
	{
		delta					= vector_aligned(ray_end - ray_start);
		world_axis_transform	= nullptr;
		is_swept				= (delta.length_sqr() != 0.f);
		extents					= vector_aligned(ray_maxs - ray_mins);
		extents					*= 0.5f;
		is_ray					= (extents.length_sqr() < 1e-6);
		start_offset			= vector_aligned(ray_mins + ray_maxs);
		start_offset			*= 0.5f;
		start					= vector_aligned(ray_start + start_offset);
		start_offset			*= -1.f;
	}

	vector_aligned      start;
	vector_aligned      delta;
	vector_aligned		start_offset;
	vector_aligned		extents;
	const matrix_3x4*	world_axis_transform;
	bool				is_ray;
	bool				is_swept;
};

class handle_entity;
class base_trace_filter
{
public:
	virtual bool				should_hit_entity(handle_entity* entity, int contents_mask) = 0;
	virtual game_trace_type		trace_types() const = 0;
};

class trace_filter : public base_trace_filter
{
public:
	game_trace_type trace_types() const override
	{
		return trace_everything;
	}
};

class trace_filter_entities_only : public base_trace_filter
{
public:
	game_trace_type trace_types() const override
	{
		return trace_entities_only;
	}
};

class trace_filter_world_only : public base_trace_filter
{
public:
	bool should_hit_entity(handle_entity* entity, int contents_mask) override
	{
		return false;
	}

	game_trace_type trace_types() const override
	{
		return trace_world_only;
	}
};

class trace_filter_world_and_props_only : public base_trace_filter
{
public:
	bool should_hit_entity(handle_entity* entity, int contents_mask) override
	{
		return false;
	}

	game_trace_type trace_types() const override
	{
		return trace_everything;
	}
};

class game_trace_filter : public trace_filter
{
	using should_hit_callback = bool(__cdecl*)(handle_entity*, int);

public:
	game_trace_filter(const handle_entity* entity, int collision_group = collision_none, should_hit_callback should_hit = nullptr)
		: skip(entity), collision(collision_group), callback(should_hit) {
	}

	bool should_hit_entity(handle_entity* entity, int contents_mask) override
	{
		return entity != this->skip;
	}

	inline const handle_entity* skip_entity() const
	{
		return this->skip;
	}

	inline int collision_group() const
	{
		return this->collision;
	}

private:
	const handle_entity*	skip;		// 0x00
	int						collision;	// 0x04
	should_hit_callback		callback;	// 0x08
};

class trace_filter_skip_two_entities : public game_trace_filter
{
public:
	trace_filter_skip_two_entities(const handle_entity* first, const handle_entity* second, int collision_group = collision_none)
		: game_trace_filter(first, collision_group), skip2(second) {
	}

	bool should_hit_entity(handle_entity* entity, int contents_mask) override
	{
		return entity != this->skip2;
	}

private:
	const handle_entity* skip2;
};

class collideable;
class game_engine_trace
{
public:
	int		point_contents(const vector_3d& abs_position, int contents_mask = mask_all, handle_entity** entity = nullptr) { return virtuals->call<int>(this, 0, &abs_position, contents_mask, entity); }
	int		point_contents_world_only(const vector_3d& abs_position, int contents_mask = mask_all) { return virtuals->call<int>(this, 1, this, &abs_position, contents_mask); }
	int		point_contents_collideable(collideable* collide, const vector_3d& abs_position) { return virtuals->call<int>(this, 2, collide, &abs_position); }

	void	clip_ray_to_entity(const game_ray& ray, unsigned int mask, handle_entity* entity, game_trace* trace) { return virtuals->call<void>(this, 3, this, &ray, mask, entity, trace); }
	void	clip_ray_to_collideable(const game_ray& ray, unsigned int mask, collideable* collide, game_trace* trace) { return virtuals->call<void>(this, 4, &ray, mask, collide, trace); }
	void	trace_ray(const game_ray& ray, unsigned int mask, game_trace_filter* filter, game_trace* trace) { return virtuals->call<void>(this, 5, &ray, mask, filter, trace); }

	bool	brush_info(int brush, utl_vector<game_brush_side_info>* info, int* contents) { return virtuals->call<bool>(this, 18, brush, info, contents); }
};

```

`sdk/valve/interface/classes/engine_vgui.h`:

```h
#pragma once

#define invalid_panel 0xFFFFFFFF

enum game_vgui_panel : int
{
	panel_root = 0,
	panel_game_ui_dll,
	panel_client_dll,
	panel_tools,
	panel_in_game_screens,
	panel_game_dll,
	panel_client_dll_tools
};

enum game_paint_mode
{
	paint_ui_panels			= (1 << 0),
	paint_in_game_panels	= (1 << 1),
	paint_cursor			= (1 << 2)
};

class game_engine_vgui
{
public:
	virtual				~game_engine_vgui() { }
	virtual v_panel		panel(game_vgui_panel type) = 0;
	virtual bool		is_game_ui_visible() = 0;
};
```

`sdk/valve/interface/classes/entity_list.h`:

```h
#pragma once

class base_entity;

class game_entity_listener
{
public:
	virtual void	entity_created(base_entity* entity) { }
	virtual void	entity_deleted(base_entity* entity) { }
};

class client_networkable;
class client_unknown;
class game_client_entity;

class game_entity_list
{
public:
	virtual client_networkable*		get_networkable(int index) = 0;
	virtual client_networkable*		get_networkable_from_handle(base_handle networkable_handle) = 0;
	virtual client_unknown*			get_unknown_from_handle(base_handle unknown_handle) = 0;
	virtual game_client_entity*		get_entity(int index) = 0;
	virtual game_client_entity*		get_entity_from_handle(base_handle entity_handle) = 0;
	virtual int						number_of_entities(bool include_non_networkable) = 0;
	virtual int						highest_entity_index() = 0;
	virtual void					set_max_entities(int max_entity) = 0;
	virtual int						max_entities() = 0;

	template <class t = game_client_entity>
	inline t* get(const int index) { return static_cast<t*>(get_entity(index)); }

	template <class t = game_client_entity>
	inline t* get_handle(const base_handle entity_handle) { return static_cast<t*>(get_entity_from_handle(entity_handle)); }

	void add_listener(game_entity_listener* listener) { entity_listeners.add_tail(listener); }
	void remove_listener(game_entity_listener* listener) { entity_listeners.find_remove(listener); }

private:
	utl_vector<game_entity_listener*> entity_listeners;
};

```

`sdk/valve/interface/classes/event_manager.h`:

```h
#pragma once

#define event_debug_id_setup		42
#define event_debug_id_shutdown		13

class game_event
{
public:
	virtual					~game_event() { }
	virtual const char*		name() const = 0;

	virtual bool			reliable() const = 0;
	virtual bool			local() const = 0;
	virtual bool			empty(const char* key_name = nullptr) = 0;

	virtual bool			get_bool(const char* key_name = nullptr, bool default_value = false) = 0;
	virtual int				get_int(const char* key_name = nullptr, int default_value = 0) = 0;
	virtual std::uint64_t	get_uint64(const char* key_name = nullptr, std::uint64_t default_value = 0) = 0;
	virtual float			get_float(const char* key_name = nullptr, float default_value = 0.f) = 0;
	virtual const char*		get_string(const char* key_name = nullptr, const char* default_value = "\0") = 0;
	virtual const wchar_t*	get_wstring(const char* key_name = nullptr, const wchar_t* default_value = L"\0") = 0;
	virtual const void*		get_ptr(const char* key_name = nullptr) const = 0;

	virtual void			set(const char* key_name, bool value) = 0;
	virtual void			set(const char* key_name, int value) = 0;
	virtual void			set(const char* key_name, std::uint64_t value) = 0;
	virtual void			set(const char* key_name, float value) = 0;
	virtual void			set(const char* key_name, const char* value) = 0;
	virtual void			set(const char* key_name, const wchar_t* value) = 0;
	virtual void			set(const char* key_name, const void* value) = 0;

	virtual bool			for_event_data(void* pevent) const = 0;
};

class game_event_listener
{
public:
	virtual			~game_event_listener() { }
	virtual void	fire_game_event(game_event* event) = 0;
	virtual int		get_event_debug_id() { return debug_id; }
public:
	int	debug_id;
};

class csvc_message_game_event;
class game_event_manager
{
public:
	virtual						~game_event_manager() { }
	virtual int					load_from_file(const char* file_name) = 0;
	virtual void				reset() = 0;
	virtual bool				add(game_event_listener* listener, const char* name, bool server_side) = 0;
	virtual bool				find(game_event_listener* listener, const char* name) = 0;
	virtual void				remove(game_event_listener* listener) = 0;
	virtual void				add_global(game_event_listener* listener, bool server_side) = 0;
	virtual game_event*			create_event(const char* name, bool force = false, int* unknown = nullptr) = 0;
	virtual bool				fire_event(game_event* event, bool dont_broadcast = false) = 0;
	virtual bool				fire_event_client_side(game_event* event) = 0;
	virtual game_event*			duplicate(game_event* event) = 0;
	virtual void				free(game_event* event) = 0;
	virtual bool				serialize_event(game_event* event, csvc_message_game_event* event_message) = 0;
	virtual game_event*			unserialize_event(const csvc_message_game_event& event_message) = 0;
	virtual game_key_value*		data_types(game_event* event) = 0;
};
```

`sdk/valve/interface/classes/game_console.h`:

```h
#pragma once

class game_client_console
{
public:
	virtual			~game_client_console() { }
	virtual void	activate() = 0;					// activates the console, makes it visible and brings it to the foreground.
	virtual void	initialize() = 0;
	virtual void	hide() = 0;						// hides the console.
	virtual void	clear() = 0;					// clears the console.
	virtual bool	is_console_visible() = 0;		// return true if the console has focus.
	virtual void	set_parent(int parent) = 0;
};
```

`sdk/valve/interface/classes/game_types.h`:

```h
#pragma once

#pragma region game types flags

enum game_type_flags : int
{
	game_type_unknown = -1,
	game_type_classic,
	game_type_gungame,
	game_type_training,
	game_type_custom,
	game_type_cooperative,
	game_type_skirmish,
	game_type_free_for_all
};

// credit: https://developer.valvesoftware.com/wiki/CSGO_Game_Mode_Commands
enum game_mode_flags : int
{
	game_mode_unknown = 0,
	game_mode_casual,
	game_mode_competitive,
	game_mode_wingman,
	game_mode_arms_race,
	game_mode_demolition,
	game_mode_deathmatch,
	game_mode_guardian,
	game_mode_coopstrike,
	game_mode_danger_zone
};

#pragma endregion

class game_client_types
{
public:
	int				current_game_type() { return virtuals->call<int>(this, 8); }
	int				current_game_mode() { return virtuals->call<int>(this, 9); }
	const char*		current_map_name() { return virtuals->call<const char*>(this, 10); }
	const char*		current_game_type_name_id() { return virtuals->call<const char*>(this, 11); }
	const char*		current_game_mode_name_id() { return virtuals->call<const char*>(this, 13); }
};
```

`sdk/valve/interface/classes/global_vars.h`:

```h
#pragma once

class game_global_vars
{
public:
	float	real_time;
	int		frame_count;
	float	absolute_frame_time;
	float	absolute_frame_start_time;
	float	current_time;
	float	frame_time;
	int		max_clients;
	int		tick_count;
	float	interval_per_tick;
	float	interpolation_amount;
	int		frame_simulation_ticks;
	int		network_protocol;
	void*	save_data;
	bool	client;
	bool	remote_client;
	int		timestamp_networking_base;
	int		timestamp_randomize_window;
};
```

`sdk/valve/interface/classes/input.h`:

```h
#pragma once
#include "../../classes/user_cmd.h"

#define multiplayer_backup 150

class game_input
{
public:
    std::byte               _pad0[0xC];             // 0x00
    bool                    track_ir_available;     // 0x0C
    bool                    mouse_installed;        // 0x0D
    bool                    mouse_active;           // 0x0E
    std::byte               _pad1[0x9A];            // 0x0F
    bool                    camera_in_thirdperson;  // 0xA9
    std::byte               _pad2[0x2];             // 0xAA
    vector_3d               camera_offset;          // 0xAC
    std::byte               _pad3[0x38];            // 0xB8
    game_user_cmd*          commands;               // 0xF0
    game_verified_user_cmd* verified_commands;      // 0xF4
    
    game_user_cmd* user_cmd(const int sequence_number) const 
    {
        if (!this) return nullptr;
        return &commands[sequence_number % multiplayer_backup]; 
    }

    game_verified_user_cmd* verified_cmd(const int sequence_number) const 
    {
        if (!this) return nullptr;
        return &verified_commands[sequence_number % multiplayer_backup]; 
    }
};

class game_input_system
{
public:
    void enable_input(bool enable) { return virtuals->call<void>(this, 11, enable); }
    void reset_input() { return virtuals->call<void>(this, 39); }
};
```

`sdk/valve/interface/classes/key_value_system.h`:

```h
#pragma once

#define invalid_key_symbol (-1)

typedef unsigned long h_key_symbol;

class game_key_value_system
{
public:
	virtual void			register_size(int reg_size) = 0;

private:
	virtual void			function0() = 0;

public:
	virtual void*			alloc_memory(int mem_size) = 0;
	virtual void			free_memory(void* memory_value) = 0;
	virtual h_key_symbol	symbol_string(const char* name, bool create = true) = 0;
	virtual const char*		string_symbol(h_key_symbol h_symbol) = 0;
	virtual void			add_memory_leak_list(void* memory_value, h_key_symbol h_symbol_name) = 0;
	virtual void			remove_from_memory_leak_list(void* memory_value) = 0;
	virtual void			set_expression_symbol(const char* name, bool value) = 0;
	virtual bool			expression_symbol(const char* name) = 0;
	virtual h_key_symbol	symbol_string_case_sensitive(h_key_symbol& case_insensitive_symbol, const char* name, bool create = true) = 0;
};

using key_value_system_detail = game_key_value_system * (__cdecl*)();
```

`sdk/valve/interface/classes/localize.h`:

```h
#pragma once

class game_localize
{
public:
	wchar_t*			find(const char* token) { return virtuals->call<wchar_t*>(this, 11, token); }

	/*
	* this funcion is basically the "find" function above,
	* however this "find_safe" function doesn't crash the game
	* if the value token you inputted is either invalid or incorrect.
	*/
	const wchar_t*		find_safe(const char* token) { return virtuals->call<wchar_t*>(this, 12, token); }
};
```

`sdk/valve/interface/classes/material_system.h`:

```h
#pragma once

#pragma region material flags

enum game_material_flags : int
{
	material_debug							= (1 << 0),
	material_no_debug_override				= (1 << 1),
	material_no_draw						= (1 << 2),
	material_use_in_fillrate_mode			= (1 << 3),
	material_vertex_color					= (1 << 4),
	material_vertex_alpha					= (1 << 5),
	material_selfillum						= (1 << 6),
	material_additive						= (1 << 7),
	material_alpha_test						= (1 << 8),
	material_pseudo_translucent				= (1 << 9),		// used to mark water materials for rendering after opaques but before translucents (with alpha blending but also with depth writes)
	material_znearer						= (1 << 10),
	material_model							= (1 << 11),
	material_flat							= (1 << 12),
	material_nocull							= (1 << 13),
	material_nofog							= (1 << 14),
	material_ignorez						= (1 << 15),
	material_decal							= (1 << 16),
	material_envmap_sphere					= (1 << 17),	// obsolete
	material_aoprepass						= (1 << 18),
	material_envmap_camera_space			= (1 << 19),	// obsolete
	material_base_alpha_envmapmask			= (1 << 20),
	material_translucent					= (1 << 21),
	material_normal_map_alpha_envmapmask	= (1 << 22),
	material_needs_software_skinning		= (1 << 23),	// obsolete
	material_opaque_texture					= (1 << 24),
	material_multiply						= (1 << 25),
	material_suppress_decals				= (1 << 26),
	material_half_lambert					= (1 << 27),
	material_wireframe						= (1 << 28),
	material_allow_alpha_to_coverage		= (1 << 29),
	material_alpha_modified_by_proxy		= (1 << 30),
	material_vertex_fog						= (1 << 31)
};

#pragma endregion

class game_material
{
public:
	void				set_material_flags(const int flags, const bool enable) noexcept { return virtuals->call<void>(this, 29, flags, enable); }
};

class game_material_system
{
public:
	game_material*		create_material(const char* name, game_key_value* key) noexcept { return virtuals->call<game_material*>(this, 83, name, key); }
	game_material*		find(const char* name) noexcept { return virtuals->call<game_material*>(this, 84, name, nullptr, true, nullptr); }
};
```

`sdk/valve/interface/classes/mdl_cache.h`:

```h
#pragma once
#include "client_mode.h"
#include <cstdint>

using mdl_handle = std::uint16_t;

#pragma region mdl cache flags

enum
{
	mdl_handle_invalid = static_cast<mdl_handle>(~0)
};

enum game_mdl_cache_data_type : int
{
	mdl_cache_studio_hdr = 0,
	mdl_cache_studio_hwdata,
	mdl_cache_vcollide,
	mdl_cache_anim_block,
	mdl_cache_virtual_model,
	mdl_cache_vertexes,
	mdl_cache_decoded_anim_block
};

enum game_mdl_cache_flush_flags : unsigned int
{
	mdl_cache_flush_studio_hdr		= (1 << 0),
	mdl_cache_flush_studio_hwdata	= (1 << 1),
	mdl_cache_flush_vcollide		= (1 << 2),
	mdl_cache_flush_anim_block		= (1 << 3),
	mdl_cache_flush_virtual_model	= (1 << 4),
	mdl_cache_flush_autoplay		= (1 << 5),
	mdl_cache_flush_vertexes		= (1 << 6),
	mdl_cache_flush_combined_data	= (1 << 7),
	mdl_cache_flush_ignore_lock		= (1 << 31),
	mdl_cache_flush_all				= 0xFFFFFFFF
};

#pragma endregion

class game_mdl_cache_notify
{
public:
	virtual void on_data_loaded(game_mdl_cache_data_type type, mdl_handle model)		= 0;
	virtual void on_combiner_pre_cache(mdl_handle old_handle, mdl_handle new_handle)	= 0;
	virtual void on_data_unloaded(game_mdl_cache_data_type type, mdl_handle model)		= 0;
	virtual bool should_supress_load_warning(mdl_handle model)							= 0;
};

class game_mdl_cache : public game_app_system
{
public:
	void set_cache_notify(game_mdl_cache_notify* notify)												{ virtuals->call<void>(this, 9, notify); }
	[[nodiscard]] mdl_handle find_mdl(const char* relative_path)										{ return virtuals->call<mdl_handle>(this, 10, relative_path); }
	[[nodiscard]] int add_reference(mdl_handle model)													{ return virtuals->call<int>(this, 11, model); }
	[[nodiscard]] int release(mdl_handle model)															{ return virtuals->call<int>(this, 12, model); }
	[[nodiscard]] int get_reference(mdl_handle model)													{ return virtuals->call<int>(this, 13, model); }
	[[nodiscard]] game_studio_hdr* get_studio_hdr(mdl_handle model)										{ return virtuals->call<game_studio_hdr*>(this, 14, model); }
	[[nodiscard]] unsigned char* get_anim_block(mdl_handle model, int block, bool preload_if_missing)	{ return virtuals->call<unsigned char*>(this, 18, model, block, preload_if_missing); }
	[[nodiscard]] bool has_anim_block_been_preloaded(mdl_handle model, int block)						{ return virtuals->call<bool>(this, 19, model, block); }
	[[nodiscard]] int get_autoplay_list(mdl_handle model, unsigned short** out)							{ return virtuals->call<int>(this, 21, model, out); }
	[[nodiscard]] bool is_error_model(mdl_handle model)													{ return virtuals->call<bool>(this, 26, model); }
	void flush(game_mdl_cache_flush_flags flush_flags = mdl_cache_flush_all)							{ virtuals->call<void>(this, 28, flush_flags); }
	void flush(mdl_handle model, game_mdl_cache_flush_flags flush_flags = mdl_cache_flush_all)			{ virtuals->call<void>(this, 29, model, flush_flags); }
	[[nodiscard]] const char* get_model_name(mdl_handle model)											{ return virtuals->call<const char*>(this, 30, model); }
	[[nodiscard]] void* get_cache_section(game_mdl_cache_data_type type)								{ return virtuals->call<void*>(this, 31, type); }
	void begin_lock()																					{ virtuals->call<void>(this, 33); }
	void end_lock()																						{ virtuals->call<void>(this, 34); }
	[[nodiscard]] game_studio_hdr* lock_studio_hdr(mdl_handle model)									{ return virtuals->call<game_studio_hdr*>(this, 48, model); }
	void unlock_studio_hdr(mdl_handle model)															{ virtuals->call<void>(this, 49, model); }
	[[nodiscard]] bool preload_model(mdl_handle model)													{ return virtuals->call<bool>(this, 50, model); }
	void begin_coarse_lock()																			{ virtuals->call<void>(this, 53); }
	void end_coarse_lock()																				{ virtuals->call<void>(this, 54); }
	void reload_vcollide(mdl_handle model)																{ virtuals->call<void>(this, 55, model); }
	void disable_vcollide_load()																		{ virtuals->call<void>(this, 58); }
	void enable_vcollide_load()																			{ virtuals->call<void>(this, 59); }
};

class game_mdl_cache_critical_section
{
public:
	game_mdl_cache_critical_section(game_mdl_cache* handle) : cache(handle)
	{
		this->cache->begin_lock();
	}

	~game_mdl_cache_critical_section()
	{
		this->cache->end_lock();
	}

	// class no assignment.
	game_mdl_cache_critical_section& operator=(game_mdl_cache_critical_section&&)		= delete;
	game_mdl_cache_critical_section& operator=(const game_mdl_cache_critical_section&&) = delete;

private:
	game_mdl_cache* cache;
};
```

`sdk/valve/interface/classes/model_info.h`:

```h
#pragma once

#pragma region model info flags

enum game_render_flags : unsigned int
{
	render_flags_disable_rendering			= 0x01,
	render_flags_has_changed				= 0x02,
	render_flags_alternate_sorting			= 0x04,
	render_flags_render_with_viewmodels		= 0x08,
	render_flags_bloat_bounds				= 0x10,
	render_flags_bounds_valid				= 0x20,
	render_flags_bounds_always_recompute	= 0x40,
	render_flags_is_sprite					= 0x80,
	render_flags_force_opaque_pass			= 0x100,
};

#pragma endregion

struct game_model
{
	std::byte		_pad0[0x4];
	char			name[260];
	int				load_flags;
	int				server_count;
	int				type;
	int				flags;
	vector_3d		mins;
	vector_3d		maxs;
	float			radius;
	std::byte		_pad1[0x1C];
};

class game_model_info
{
public:
	const char*			model_name(const game_model* model) noexcept { return virtuals->call<const char*>(this, 3, model); }
	game_studio_hdr*	studio_model(const game_model* model) noexcept { return virtuals->call<game_studio_hdr*>(this, 32, model); }
};
```

`sdk/valve/interface/classes/network.h`:

```h
#pragma once

#define invalid_string_table -1
#define invalid_string_index (std::uint16_t)~0

class game_network_table;
using network_string_changed = void(__cdecl*)(void*, game_network_table*, int, char const*, void const*);

class game_network_table
{
public:
	virtual					~game_network_table() { }

	// table info.
	virtual const char*		table_name() const = 0;
	virtual int				table_id() const = 0;
	virtual int				string_count() const = 0;
	virtual int				max_strings() const = 0;
	virtual int				entry_bits() const = 0;

	// networking.
	virtual void			set_tick(int tick) = 0;
	virtual bool			changed_since_tick(int tick) const = 0;

	// accessors.
	virtual int				add(bool is_server, const char* value, int length = -1, const void* user_data = 0) = 0;

	virtual const char*		get(int string) = 0;
	virtual void			set_string_user_data(int string, int length, const void* user_data) = 0;
	virtual const void*		get_string_user_data(int string, int* length) = 0;
	virtual int				find(char const* string) = 0;

	virtual void			set_string_changed_callback(void* object, network_string_changed change_func) = 0;
};

class game_network_container
{
public:
	game_network_table*		find(const char* table_name) { return virtuals->call<game_network_table*>(this, 3, table_name); }
};
```

`sdk/valve/interface/classes/panel.h`:

```h
#pragma once

typedef DWORD v_panel;

class game_panel
{
public:
	void			set_keyboard_input(v_panel panel, bool state) { return virtuals->call<void>(this, 31, panel, state); }
	void			set_mouse_input(v_panel panel, bool state) { return virtuals->call<void>(this, 32, panel, state); }
	const char*		name(v_panel panel) { return virtuals->call<const char*>(this, 36, panel); }
	const char*		name_class(v_panel panel) { return virtuals->call<const char*>(this, 37, panel); }
};
```

`sdk/valve/interface/classes/physics_surface_props.h`:

```h
#pragma once

struct game_surface_physics_params
{
	float friction;
	float elasticity;
	float density;
	float thickness;
	float dampening;
}; // Size: 0x14

struct game_surface_audio_params
{
	float reflectivity;					// like elasticity, but how much sound should be reflected by this surface.
	float hardness_factor;				// like elasticity, but only affects impact sound choices.
	float roughness_factor;				// like friction, but only affects scrape sound choices.
	float rough_threshold;				// surface roughness > this causes "rough" scrapes, < this causes "smooth" scrapes.
	float hard_threshold;				// surface hardness > this causes "hard" impacts, < this causes "soft" impacts.
	float hard_velocity_threshold;		// collision velocity > this causes "hard" impacts, < this causes "soft" impacts.
	float high_pitch_occlusion;			// a value betweeen 0 and 100 where 0 is not occluded at all and 100 is silent (except for any additional reflected sound).
	float mid_pitch_occlusion;
	float low_pitch_occlusion;
}; // Size: 0x24

struct game_surface_sound_names
{
	std::uint16_t walk_step_left;
	std::uint16_t walk_step_right;
	std::uint16_t run_step_left;
	std::uint16_t run_step_right;
	std::uint16_t impact_soft;
	std::uint16_t impact_hard;
	std::uint16_t scrape_smooth;
	std::uint16_t scrape_rough;
	std::uint16_t bullet_impact;
	std::uint16_t rolling;
	std::uint16_t break_sound;
	std::uint16_t strain_sound;
}; // Size: 0x18

struct game_surface_sound_handles
{
	std::uint16_t walk_step_left;
	std::uint16_t walk_step_right;
	std::uint16_t run_step_left;
	std::uint16_t run_step_right;
	std::uint16_t impact_soft;
	std::uint16_t impact_hard;
	std::uint16_t scrape_smooth;
	std::uint16_t scrape_rough;
	std::uint16_t bullet_impact;
	std::uint16_t rolling;
	std::uint16_t break_sound;
	std::uint16_t strain_sound;
}; // Size: 0x18

struct surface_game_props
{
	float					max_speed_factor;
	float					jump_factor;
	float					penetration_modifier;
	float					damage_modifier;
	std::uint16_t			material;
	std::byte				climbable;
	std::byte				_pad0[0x4];
}; // Size: 0x17

struct game_surface_data
{
	game_surface_physics_params		physics;
	game_surface_audio_params		audio;
	game_surface_sound_names		sounds;
	surface_game_props				game;
	game_surface_sound_handles		sound_handles;
}; // Size: 0x7F

class game_physics_surface_props
{
public:
	virtual						~game_physics_surface_props() { }
	virtual int					parse_surface_data(const char* file_name, const char* text_file) = 0;
	virtual int					surface_prop_count() const = 0;
	virtual int					surface_index(const char* surface_prop_name) const = 0;
	virtual void				physics_properties(int surface_data_index, float* density, float* thickness, float* friction, float* elasticity) const = 0;
	virtual game_surface_data*	surface_data(int surface_data_index) = 0;
	virtual const char*			string(unsigned short string_table_index) const = 0;
	virtual const char*			prop_name(int surface_data_index) const = 0;
	virtual void				set_world_material_index_table(int* map_array, int map_size) = 0;
	virtual void				physics_parameters(int surface_data_index, game_surface_physics_params* params_out) const = 0;
};
```

`sdk/valve/interface/classes/prediction.h`:

```h
#pragma once

class game_move_data
{
public:
	bool			first_run_instructions : 1;
	bool			game_code_moved_player : 1;
	bool			no_air_control : 1;
	std::uintptr_t	player_handle;			// edict index on server, client entity handle on client=
	int				impulse_command;		// impulse command issued.
	q_angle			view_angles;			// command view angles (local space)
	q_angle			abs_view_angles;		// command view angles (world space)
	int				buttons;				// attack buttons.
	int				old_buttons;			// from host_client->oldbuttons;
	float			forward_move;
	float			side_move;
	float			up_move;
	float			max_speed;
	float			client_max_speed;
	vector_3d		velocity;				// edict::velocity	// current movement direction.
	vector_3d		trailing_velocity;
	float			trailing_velocity_time;
	vector_3d		angles;					// edict::angles
	vector_3d		old_angles;
	float			out_step_height;		// how much you climbed this move
	vector_3d		out_wish_velocity;		// this is where you tried 
	vector_3d		out_jump_velocity;		// this is your jump velocity
	vector_3d		constraint_center;
	float			constraint_radius;
	float			constraint_width;
	float			constraint_speed_factor;
	bool			constraint_past_radius;
	vector_3d		abs_origin;
};

class game_move_helper
{
public:
	virtual	const char*						name(void* entity) const = 0;
	virtual void							set_host(base_entity* phost) = 0;
	virtual void							reset_touch_list() = 0;
	virtual bool							add_to_touched(const game_trace& trace, const vector_3d& impact_velocity) = 0;
	virtual void							process_impacts() = 0;
	virtual void							con_printf(int nindex, char const* fmt, ...) = 0;
	virtual void							start_sound(const vector_3d& origin, int channel, char const* sample, float volume, game_sound_level sound_level, int flags, int pitch) = 0;
	virtual void							start_sound(const vector_3d& origin, const char* sound_name) = 0;
	virtual void							playback_event_full(int flags, int client_index, unsigned short event_index, float delay, vector_3d& origin, vector_3d& angles, float fl_param1, float fl_param2, int i_param1, int i_param2, int b_param1, int b_param2) = 0;
	virtual bool							player_falling_damage() = 0;
	virtual void							player_set_animation(int player_animation) = 0;
	virtual game_physics_surface_props*		surface_props() = 0;
	virtual bool							is_world_entity(const unsigned long& entity) = 0;
};

class game_movement
{
public:
	virtual						~game_movement() { }
	virtual void				process_movement(base_entity* entity, game_move_data* move) = 0;
	virtual void				reset() = 0;
	virtual void				start_track_prediction_errors(base_entity* entity) = 0;
	virtual void				finish_track_prediction_errors(base_entity* entity) = 0;
	virtual void				diff_print(char const* fmt, ...) = 0;
	virtual vector_3d const&	player_mins(bool ducked) const = 0;
	virtual vector_3d const&	player_maxs(bool ducked) const = 0;
	virtual vector_3d const&	player_view_offset(bool ducked) const = 0;
	virtual bool				is_moving_player_stuck() const = 0;
	virtual base_entity*		moving_player() const = 0;
	virtual void				unblock_pusher(base_entity* entity, base_entity* pusher) = 0;
	virtual void				setup_movement_bounds(game_move_data* move) = 0;
};

class game_prediction
{
public:
	std::byte		_pad0[0x4];						// 0x0000
	std::uintptr_t	last_ground;					// 0x0004
	bool			in_prediction;					// 0x0008
	bool			is_first_time_predicted;		// 0x0009
	bool			engine_paused;					// 0x000a
	bool			old_cl_predict_value;			// 0x000b
	int				previous_start_frame;			// 0x000c
	int				incoming_packet_number;			// 0x0010
	float			last_server_world_time_stamp;	// 0x0014

	struct game_split
	{
		bool						is_first_time_predicted;						// 0x0018
		std::byte					_pad0[0x3];										// 0x0019
		int							commands_predicted;								// 0x001c
		int							server_commands_acknowledged;					// 0x0020
		int							previous_ack_had_errors;						// 0x0024
		float						ideal_pitch;									// 0x0028
		int							last_command_acknowledged;						// 0x002c
		bool						previous_ack_error_triggers_full_latch_reset;	// 0x0030
		utl_vector<base_handle>		entities_with_prediction_errors_in_last_ack;	// 0x0031
		bool						performed_tick_shift;							// 0x0045
	};

	game_split		split[1];	// 0x0018

public:

	void update(int start_frame, bool valid_frame, int incoming_acknowledged, int outgoing_command) { return virtuals->call<void>(this, 3, start_frame, valid_frame, incoming_acknowledged, outgoing_command); }
	void local_view_angles(q_angle& view_angle) { return virtuals->call<void>(this, 12, std::ref(view_angle)); }
	void set_local_view_angles(q_angle& view_angle) { return virtuals->call<void>(this, 13, std::ref(view_angle)); }
	void check_moving_ground(base_entity* entity, double frame_time) { return virtuals->call<void>(this, 18, entity, frame_time); }
	void setup_move(base_entity* entity, game_user_cmd* cmd, game_move_helper* helper, game_move_data* move_data) { return virtuals->call<void>(this, 20, entity, cmd, helper, move_data); }
	void finish_move(base_entity* entity, game_user_cmd* cmd, game_move_data* move_data) { return virtuals->call<void>(this, 21, entity, cmd, move_data); }
};
```

`sdk/valve/interface/classes/studio_render.h`:

```h
#pragma once

#pragma region studio render flags

enum
{
	studio_render_draw_entire_model										= 0,
	studio_render_draw_opaque_only										= 0x01,
	studio_render_draw_translucent_only									= 0x02,
	studio_render_draw_group_mask										= 0x03,
	studio_render_draw_no_flexes										= 0x04,
	studio_render_draw_static_lighting									= 0x08,
	studio_render_draw_accurate_time									= 0x10,		// use accurate timing when drawing the model.
	studio_render_draw_no_shadows										= 0x20,
	studio_render_draw_get_perf_stats									= 0x40,
	studio_render_draw_wireframe										= 0x80,
	studio_render_draw_item_blink										= 0x100,
	studio_render_shadow_depth_texture									= 0x200,
	studio_render_unused												= 0x400,
	studio_render_skip_decals											= 0x800,
	studio_render_model_is_cacheable									= 0x1000,
	studio_render_shadow_depth_texture_include_translucent_materials	= 0x2000,
	studio_render_no_primary_draw										= 0x4000,
	studio_render_ssao_depth_texture									= 0x8000,
};

enum game_override_type : int
{
	override_normal = 0,
	override_build_shadows,
	override_depth_write,
	override_selective,
	override_ssao_depth_write,
};

#pragma endregion

class game_studio_hdr;
class client_renderable;
class game_draw_model_info
{
public:
	game_studio_hdr*	studio_hdr;
	void*				hardware_data;
	int					decals;
	int					skin;
	int					body;
	int					hitbox_set;
	client_renderable*	renderable;
};

class game_studio_render
{
public:
	void		set_color_modulation(const float* color) noexcept { return virtuals->call<void>(this, 27, color); }
	void		set_alpha_modulation(const float alpha) noexcept { return virtuals->call<void>(this, 28, alpha); }
	void		forced_material_override(game_material* material, const int type = override_normal, const int index = -1) noexcept { return virtuals->call<void>(this, 33, material, type, index); }
	bool		is_forced_material_override() noexcept { return virtuals->call<bool>(this, 34); }
};
```

`sdk/valve/interface/classes/surface.h`:

```h
#pragma once
#include "../../netvar/netvar.h"

typedef DWORD h_font;

#pragma region surface flags

enum font_draw_type : int
{
	font_draw_default		= 0,
	font_draw_non_additive,
	font_draw_additive,
	font_draw_type_count	= 2
};

enum font_flags
{
	font_none,
	font_italic			= 0x001,
	font_underline		= 0x002,
	font_strikeout		= 0x004,
	font_symbol			= 0x008,
	font_antialias		= 0x010,
	font_gaussian_blur	= 0x020,
	font_rotary			= 0x040,
	font_dropshadow		= 0x080,
	font_additive		= 0x100,
	font_outline		= 0x200,
	font_custom			= 0x400,
	font_bitmap			= 0x800
};

#pragma endregion

class game_surface
{
public:
	void	draw_set_color(int r, int g, int b, int a) { virtuals->call<void>(this, 15, r, g, b, a); }
	void	draw_filled_rect(int x, int y, int w, int h) { virtuals->call<void>(this, 16, x, y, w, h); }
	void	draw_filled_rect_fade(int x, int y, int w, int h, std::uint32_t first, std::uint32_t second, bool horizontal) { virtuals->call<void>(this, 123, x, y, w, h, first, second, horizontal); }
	void	draw_outlined_rect(int x, int y, int w, int h) { virtuals->call<void>(this, 18, x, y, w, h); }
	void	draw_line(int x, int y, int w, int h) { virtuals->call<void>(this, 19, x, y, w, h); }
	void	draw_polyline(int* x, int* y, int points) { virtuals->call<void>(this, 20, x, y, points); }
	void	draw_set_text_font(h_font font_handle) { virtuals->call<void>(this, 23, font_handle); }
	void	draw_set_text_color(int r, int g, int b, int a) { virtuals->call<void>(this, 25, r, g, b, a); }
	void	draw_set_text_pos(int x, int y) { virtuals->call<void>(this, 26, x, y); }
	void	draw_print_text(const wchar_t* text, int text_length, font_draw_type draw_type = font_draw_default) { virtuals->call<void>(this, 28, text, text_length, draw_type); }
	void	draw_set_texture_rgba(int index, const unsigned char* rgba, int width, int height) { virtuals->call<void>(this, 37, index, rgba, width, height); }
	void	draw_set_texture(int index) { virtuals->call<void>(this, 38, index); }
	int		create_new_texture(bool procedural = false) { return virtuals->call<int>(this, 43, procedural); }
	void	unlock_cursor() { return virtuals->call<void>(this, 66); }
	void	lock_cursor() { return virtuals->call<void>(this, 67); }
	h_font	font_create() { return virtuals->call<h_font>(this, 71); }
	bool	set_font_glyph_set(h_font font_handle, const char* windows_font_name, int height, int weight, int blur, int scan_lines, int flags, int range_min = 0, int range_max = 0) { return virtuals->call<bool>(this, 72, font_handle, windows_font_name, height, weight, blur, scan_lines, flags, range_min, range_max); }
	void	get_text_size(h_font font_handle, const wchar_t* text, int& width, int& height) { virtuals->call<void>(this, 79, font_handle, text, std::ref(width), std::ref(height)); }
	void	playsound_surface(const char* file_name) { virtuals->call<void>(this, 82, file_name); }
	void	draw_outlined_circle(int x, int y, int radius, int segments) { virtuals->call<void>(this, 103, x, y, radius, segments); }
	void	draw_textured_polygon(int index, vertex* vertice, bool clip_vertices = true) { virtuals->call<void>(this, 106, index, vertice, clip_vertices); }

	// ref: https://www.unknowncheats.me/forum/2547880-post10.html
	// ref: https://github.com/otvv/csgo-linux-cheat-sdk/blob/cc3bc2d6ae4ab3e305f681228728083db6d6de7f/csgo-sdk/src/interfaces/isurface.hpp#L191
	void	set_clip_rect(int x, int y, int w, int h) { return virtuals->call<void>(this, 147, x, y, w, h); }
	void	disable_clip(bool disable) { this->enable_clip() = !disable; }

private:
	// ref: https://www.unknowncheats.me/forum/2450313-post1.html
	// ( 0x280 = 0xA0 * 4 )
	OFFSET(enable_clip, bool, 0x280)
};

```

`sdk/valve/interface/classes/weapon_system.h`:

```h
#pragma once

class game_weapon_system
{
public:
	game_weapon_info*	weapon_data(short item_definition_index) { return virtuals->call<game_weapon_info*>(this, 2, item_definition_index); };
};
```

`sdk/valve/interface/interface.cpp`:

```cpp
#include "interface.h"
#include "../valve.h"

game_interface* interfaces = new game_interface;

void game_interface::setup()
{
#pragma region client.dll

	const interface_register* client_register = this->register_list(modules->client);
	base_client				= create<game_base_client>(client_register, "VClient");
	entity_list				= create<game_entity_list>(client_register, "VClientEntityList");
	game_console			= create<game_client_console>(client_register, "GameConsole");
	prediction				= create<game_prediction>(client_register, "VClientPrediction");
	movement				= create<game_movement>(client_register, "GameMovement");

#pragma endregion

#pragma region engine.dll

	const interface_register* engine_register = this->register_list(modules->engine);
	engine_client			= create<game_engine_client>(engine_register, "VEngineClient");
	engine_trace			= create<game_engine_trace>(engine_register, "EngineTraceClient");
	engine_sound			= create<game_engine_sound>(engine_register, "IEngineSoundClient");
	engine_vgui				= create<game_engine_vgui>(engine_register, "VEngineVGui");
	network_container		= create<game_network_container>(engine_register, "VEngineClientStringTable");
	game_event				= create<game_event_manager>(engine_register, "GAMEEVENTSMANAGER002");
	debug_overlay			= create<game_debug_overlay>(engine_register, "VDebugOverlay");
	model_info				= create<game_model_info>(engine_register, "VModelInfoClient");

#pragma endregion

#pragma region vgui.dll

	const interface_register* vgui2_register = this->register_list(modules->vgui2);
	panel					= create<game_panel>(vgui2_register, "VGUI_Panel");

	const interface_register* vgui_surface_register = this->register_list(modules->vgui_surface);
	surface					= create<game_surface>(vgui_surface_register, "VGUI_Surface");

#pragma endregion

#pragma region others

	const interface_register* stdlib_register = this->register_list(modules->stdlib);
	convar					= create<game_engine_convar>(stdlib_register, "VEngineCvar");

	const interface_register* localize_register = this->register_list(modules->localize);
	localize				= create<game_localize>(localize_register, "Localize_");

	const interface_register* matchmaking_register = this->register_list(modules->matchmaking);
	game_types				= create<game_client_types>(matchmaking_register, "VENGINE_GAMETYPES_VERSION");

	const interface_register* material_system_register = this->register_list(modules->material_system);
	material_system			= create<game_material_system>(material_system_register, "VMaterialSystem");

	const interface_register* data_cache_register = this->register_list(modules->data_cache);
	mdl_cache				= create<game_mdl_cache>(data_cache_register, "MDLCache");
	
	const interface_register* studio_render_register = this->register_list(modules->studio_render);
	studio_render			= create<game_studio_render>(studio_render_register, "VStudioRender");

	const interface_register* input_system_register = this->register_list(modules->input_system);
	input_system			= create<game_input_system>(input_system_register, "InputSystemVersion");

	const interface_register* physics_register = this->register_list(modules->physics);
	physics					= create<game_physics_surface_props>(physics_register, "VPhysicsSurfaceProps");

#pragma endregion

#pragma region custom

	client_mode				= **reinterpret_cast<game_client_mode***>(virtuals->get<std::uint8_t*>(base_client, 10) + 0x5);
	global_vars				= **reinterpret_cast<game_global_vars***>(virtuals->get<std::uint8_t*>(base_client, 11) + 0xA);
	key_value_system		= reinterpret_cast<key_value_system_detail>(GetProcAddress(scanner->capture_module(modules->stdlib).hModule, "KeyValuesSystem"))();
	client_state			= SEARCH(modules->engine, signatures::interfaces::client_state::signature()).add(0x1).deref<game_client_state*>(dereference::twice);
	weapon_system			= SEARCH(modules->client, signatures::interfaces::weapon_system::signature()).add(0x2).deref<game_weapon_system*>();
	input					= SEARCH(modules->client, signatures::interfaces::input::signature()).add(0x1).deref<game_input*>();

#pragma endregion

	console->log(log_type::log_success, "interface installed!");
}

```

`sdk/valve/interface/interface.h`:

```h
#pragma once
#include <Windows.h>
#include <string>
#include "../../dependencies/memory/scanner.h"
#include "../../dependencies/memory/virtual.h"
#include "../../dependencies/other/color.h"
#include "../maths/q_angle.h"
#include "../maths/utl_vector.h"
#include "../maths/vector.h"
#include "../maths/matrix.h"
#include "../maths/other.h"
#include "../other/net_channel.h"
#include "../other/studio.h"
#include "../other/convar.h"
#include "../other/weapon_info.h"
#include "../other/key_value.h"
#include "../entity/other.h"

#pragma region client.dll

#include "classes/base_client.h"
#include "classes/entity_list.h"
#include "classes/game_console.h"

#pragma endregion

#include "classes/panel.h"

#pragma region engine.dll

#include "classes/engine_client.h"
#include "classes/engine_trace.h"
#include "classes/engine_sound.h"
#include "classes/engine_vgui.h"
#include "classes/network.h"
#include "classes/event_manager.h"
#include "classes/debug_overlay.h"
#include "classes/model_info.h"

#pragma endregion

#pragma region vgui.dll

#include "classes/surface.h"

#pragma endregion

#include "classes/client_mode.h"

#pragma region other

#include "classes/engine_convar.h"
#include "classes/localize.h"
#include "classes/game_types.h"
#include "classes/material_system.h"
#include "classes/mdl_cache.h"
#include "classes/studio_render.h"
#include "classes/physics_surface_props.h"

#pragma endregion

#pragma region custom

#include "classes/global_vars.h"
#include "classes/key_value_system.h"
#include "classes/weapon_system.h"
#include "classes/input.h"

#pragma endregion

#include "classes/prediction.h"
#include "classes/base_interface.h"
#include "../../dependencies/console/console.h"

class game_interface
{
public:
	void setup();

#pragma region client.dll

	game_base_client* base_client				= nullptr;
	game_entity_list* entity_list				= nullptr;
	game_client_console* game_console			= nullptr;
	game_prediction* prediction					= nullptr;
	game_movement* movement						= nullptr;

#pragma endregion

#pragma region engine.dll

	game_engine_client* engine_client			= nullptr;
	game_engine_trace* engine_trace				= nullptr;
	game_engine_sound* engine_sound				= nullptr;
	game_engine_vgui* engine_vgui				= nullptr;
	game_network_container* network_container	= nullptr;
	game_event_manager* game_event				= nullptr;
	game_debug_overlay* debug_overlay			= nullptr;
	game_model_info* model_info					= nullptr;

#pragma endregion

#pragma region vgui.dll

	game_panel* panel							= nullptr;
	game_surface* surface						= nullptr;

#pragma endregion

#pragma region others

	game_engine_convar* convar					= nullptr;
	game_localize* localize						= nullptr;
	game_client_types* game_types				= nullptr;
	game_material_system* material_system		= nullptr;
	game_mdl_cache* mdl_cache					= nullptr;
	game_studio_render* studio_render			= nullptr;
	game_input_system* input_system				= nullptr;
	game_physics_surface_props* physics			= nullptr;

#pragma endregion

#pragma region custom

	game_client_mode* client_mode				= nullptr;
	game_global_vars* global_vars				= nullptr;
	game_key_value_system* key_value_system		= nullptr;
	game_client_state* client_state				= nullptr;
	game_weapon_system* weapon_system			= nullptr;
	game_input* input							= nullptr;

#pragma endregion

private:
	static interface_register* register_list(const char* modules)
	{
		std::uint8_t* create_interface = nullptr;

		if (const HMODULE handle = scanner->capture_module(modules).hModule; handle != nullptr)
			create_interface = reinterpret_cast<std::uint8_t*>(GetProcAddress(handle, "CreateInterface"));

		if (create_interface == nullptr)
		{
			console->log(log_type::log_error, "failed to get 0x%02X", create_interface);
			return nullptr;
		}

		return ADDRESS(create_interface).rel32(0x5).add(0x6).deref<interface_register*>(dereference::twice);
	}

	template<typename t>
	t* create(const interface_register* register_module, const std::string_view version)
	{
		for (const interface_register* register_list = register_module; register_list != nullptr; register_list = register_list->next)
		{
			if ((!std::string(register_list->name).compare(0U, version.length(), version) && std::atoi(register_list->name + version.length()) > 0) || !version.compare(register_list->name))
			{
				// capture our interface.
				void* capture = register_list->create();
				return static_cast<t*>(capture);
			}
		}

		console->log(log_type::log_error, "failed to find %s", version);
		return nullptr;
	}
};

extern game_interface* interfaces;

```

`sdk/valve/maths/matrix.h`:

```h
#pragma once
#include <corecrt_math_defines.h>
#include <xmmintrin.h>
#include <assert.h>
#include <bit>

// degrees to radians.
#define deg_to_rad( value ) ( ( value ) * ( const float )M_PI / 180.f )

// radians to degrees.
#define rad_to_deg( value ) ( ( value ) * 180.f / ( const float )M_PI )

using matrix_3x3 = float[3][3];

class matrix_3x4
{
public:
	constexpr matrix_3x4() : data{ } { }

	constexpr matrix_3x4(
		const float m00, const float m01, const float m02, const float m03,
		const float m10, const float m11, const float m12, const float m13,
		const float m20, const float m21, const float m22, const float m23)
	{
		this->data[0][0] = m00; this->data[0][1] = m01; this->data[0][2] = m02; this->data[0][3] = m03;
		this->data[1][0] = m10; this->data[1][1] = m11; this->data[1][2] = m12; this->data[1][3] = m13;
		this->data[2][0] = m20; this->data[2][1] = m21; this->data[2][2] = m22; this->data[2][3] = m23;
	}

	constexpr matrix_3x4(const vector_3d& forward, const vector_3d& left, const vector_3d& up, const vector_3d& origin)
	{
		this->set_forward(forward);
		this->set_left(left);
		this->set_up(up);
		this->set_origin(origin);
	}

	[[nodiscard]] float* operator[](const int index) { return this->data[index]; }
	[[nodiscard]] const float* operator[](const int index) const { return this->data[index]; }

	constexpr void set_forward(const vector_3d& forward)
	{
		this->data[0][0] = forward.x;
		this->data[1][0] = forward.y;
		this->data[2][0] = forward.z;
	}

	constexpr void set_left(const vector_3d& left)
	{
		this->data[0][1] = left.x;
		this->data[1][1] = left.y;
		this->data[2][1] = left.z;
	}

	constexpr void set_up(const vector_3d& up)
	{
		this->data[0][2] = up.x;
		this->data[1][2] = up.y;
		this->data[2][2] = up.z;
	}

	constexpr void set_origin(const vector_3d& origin)
	{
		this->data[0][3] = origin.x;
		this->data[1][3] = origin.y;
		this->data[2][3] = origin.z;
	}

	[[nodiscard]] constexpr vector_3d get_forward() const { return { this->data[0][0], this->data[1][0], this->data[2][0] }; }
	[[nodiscard]] constexpr vector_3d get_left() const { return { this->data[0][1], this->data[1][1], this->data[2][1] }; }
	[[nodiscard]] constexpr vector_3d get_up() const { return { this->data[0][2], this->data[1][2], this->data[2][2] }; }
	[[nodiscard]] constexpr vector_3d get_origin() const { return { this->data[0][3], this->data[1][3], this->data[2][3] }; }

	constexpr void invalidate()
	{
		for (auto& sub_data : this->data)
		{
			for (auto& float_data : sub_data)
				float_data = std::numeric_limits<float>::infinity();
		}
	}

	// concatenate transformations of two matrices into one.
	[[nodiscard]] constexpr matrix_3x4 concat_transforms(const matrix_3x4& m) const
	{
		return
		{
			this->data[0][0] * m.data[0][0] + this->data[0][1] * m.data[1][0] + this->data[0][2] * m.data[2][0],
			this->data[0][0] * m.data[0][1] + this->data[0][1] * m.data[1][1] + this->data[0][2] * m.data[2][1],
			this->data[0][0] * m.data[0][2] + this->data[0][1] * m.data[1][2] + this->data[0][2] * m.data[2][2],
			this->data[0][0] * m.data[0][3] + this->data[0][1] * m.data[1][3] + this->data[0][2] * m.data[2][3] + this->data[0][3],

			this->data[1][0] * m.data[0][0] + this->data[1][1] * m.data[1][0] + this->data[1][2] * m.data[2][0],
			this->data[1][0] * m.data[0][1] + this->data[1][1] * m.data[1][1] + this->data[1][2] * m.data[2][1],
			this->data[1][0] * m.data[0][2] + this->data[1][1] * m.data[1][2] + this->data[1][2] * m.data[2][2],
			this->data[1][0] * m.data[0][3] + this->data[1][1] * m.data[1][3] + this->data[1][2] * m.data[2][3] + this->data[1][3],

			this->data[2][0] * m.data[0][0] + this->data[2][1] * m.data[1][0] + this->data[2][2] * m.data[2][0],
			this->data[2][0] * m.data[0][1] + this->data[2][1] * m.data[1][1] + this->data[2][2] * m.data[2][1],
			this->data[2][0] * m.data[0][2] + this->data[2][1] * m.data[1][2] + this->data[2][2] * m.data[2][2],
			this->data[2][0] * m.data[0][3] + this->data[2][1] * m.data[1][3] + this->data[2][2] * m.data[2][3] + this->data[2][3]
		};
	}

	// angles converted from this matrix.
	[[nodiscard]] q_angle angles() const
	{
		// extract the basis vectors from the matrix. since we only need the z component of the up vector, we don't get x and y.
		const vector_3d forward = this->get_forward();
		const vector_3d left = this->get_left();
		const float up_z = this->data[2][2];

		const float length_2d = forward.to_2d().length();
		const float pitch = rad_to_deg(std::atan2f(-forward.z, length_2d));

		// check is enough here to get angles.
		if (length_2d > 0.001f)
			return { pitch, rad_to_deg(std::atan2f(forward.y, forward.x)), rad_to_deg(std::atan2f(left.z, up_z)) };

		// forward is mostly z, gimbal lock.
		// assume no roll in this case as one degree of freedom has been lost (i.e. yaw equals roll).
		return { pitch, rad_to_deg(std::atan2f(-left.x, left.y)), 0.f };
	}

	float data[3][4];
};

class alignas(16) matrix_aligned : public matrix_3x4
{
public:
	constexpr matrix_aligned() { }

	constexpr matrix_aligned(
		const float m00, const float m01, const float m02, const float m03,
		const float m10, const float m11, const float m12, const float m13,
		const float m20, const float m21, const float m22, const float m23)
	{
		this->data[0][0] = m00; this->data[0][1] = m01; this->data[0][2] = m02; this->data[0][3] = m03;
		this->data[1][0] = m10; this->data[1][1] = m11; this->data[1][2] = m12; this->data[1][3] = m13;
		this->data[2][0] = m20; this->data[2][1] = m21; this->data[2][2] = m22; this->data[2][3] = m23;
	}

	constexpr matrix_aligned(const matrix_3x4& m)
	{
		*this = m;
	}

	constexpr matrix_aligned& operator=(const matrix_3x4& m)
	{
		this->data[0][0] = m.data[0][0]; this->data[0][1] = m.data[0][1]; this->data[0][2] = m.data[0][2]; this->data[0][3] = m.data[0][3];
		this->data[1][0] = m.data[1][0]; this->data[1][1] = m.data[1][1]; this->data[1][2] = m.data[1][2]; this->data[1][3] = m.data[1][3];
		this->data[2][0] = m.data[2][0]; this->data[2][1] = m.data[2][1]; this->data[2][2] = m.data[2][2]; this->data[2][3] = m.data[2][3];
		return *this;
	}

	// concatenate transformations of two aligned matrices into one.
	[[nodiscard]] matrix_aligned concat_transforms(const matrix_aligned& m) const
	{
		matrix_aligned output;
		assert((reinterpret_cast<std::uintptr_t>(this) & 15u) == 0 && (reinterpret_cast<std::uintptr_t>(&m) & 15u) == 0 && (reinterpret_cast<std::uintptr_t>(&output) & 15u) == 0); // matrices aren't aligned

		__m128 this_row0 = _mm_load_ps(this->data[0]);
		__m128 this_row1 = _mm_load_ps(this->data[1]);
		__m128 this_row2 = _mm_load_ps(this->data[2]);

		__m128 other_row0 = _mm_load_ps(m.data[0]);
		__m128 other_row1 = _mm_load_ps(m.data[1]);
		__m128 other_row2 = _mm_load_ps(m.data[2]);

		__m128 out_row0 = _mm_add_ps(_mm_mul_ps(_mm_shuffle_ps(this_row0, this_row0, _MM_SHUFFLE(0, 0, 0, 0)), other_row0), _mm_add_ps(_mm_mul_ps(_mm_shuffle_ps(this_row0, this_row0, _MM_SHUFFLE(1, 1, 1, 1)), other_row1), _mm_mul_ps(_mm_shuffle_ps(this_row0, this_row0, _MM_SHUFFLE(2, 2, 2, 2)), other_row2)));
		__m128 out_row1 = _mm_add_ps(_mm_mul_ps(_mm_shuffle_ps(this_row1, this_row1, _MM_SHUFFLE(0, 0, 0, 0)), other_row0), _mm_add_ps(_mm_mul_ps(_mm_shuffle_ps(this_row1, this_row1, _MM_SHUFFLE(1, 1, 1, 1)), other_row1), _mm_mul_ps(_mm_shuffle_ps(this_row1, this_row1, _MM_SHUFFLE(2, 2, 2, 2)), other_row2)));
		__m128 out_row2 = _mm_add_ps(_mm_mul_ps(_mm_shuffle_ps(this_row2, this_row2, _MM_SHUFFLE(0, 0, 0, 0)), other_row0), _mm_add_ps(_mm_mul_ps(_mm_shuffle_ps(this_row2, this_row2, _MM_SHUFFLE(1, 1, 1, 1)), other_row1), _mm_mul_ps(_mm_shuffle_ps(this_row2, this_row2, _MM_SHUFFLE(2, 2, 2, 2)), other_row2)));

		// add in translation vector
		constexpr std::uint32_t component_mask[4] = { 0x0, 0x0, 0x0, 0xFFFFFFFF };
		out_row0 = _mm_add_ps(out_row0, _mm_and_ps(this_row0, std::bit_cast<__m128>(component_mask)));
		out_row1 = _mm_add_ps(out_row1, _mm_and_ps(this_row1, std::bit_cast<__m128>(component_mask)));
		out_row2 = _mm_add_ps(out_row2, _mm_and_ps(this_row2, std::bit_cast<__m128>(component_mask)));

		_mm_store_ps(output.data[0], out_row0);
		_mm_store_ps(output.data[1], out_row1);
		_mm_store_ps(output.data[2], out_row2);
		return output;
	}
};

class view_matrix
{
public:
	constexpr view_matrix() : data{ } { }

	constexpr view_matrix(
		const float m00, const float m01, const float m02, const float m03,
		const float m10, const float m11, const float m12, const float m13,
		const float m20, const float m21, const float m22, const float m23,
		const float m30, const float m31, const float m32, const float m33)
	{
		this->data[0][0] = m00; this->data[0][1] = m01; this->data[0][2] = m02; this->data[0][3] = m03;
		this->data[1][0] = m10; this->data[1][1] = m11; this->data[1][2] = m12; this->data[1][3] = m13;
		this->data[2][0] = m20; this->data[2][1] = m21; this->data[2][2] = m22; this->data[2][3] = m23;
		this->data[3][0] = m30; this->data[3][1] = m31; this->data[3][2] = m32; this->data[3][3] = m33;
	}

	constexpr view_matrix(const matrix_3x4& m, const vector_4d& additional_row = { })
	{
		this->data[0][0] = m.data[0][0]; this->data[0][1] = m.data[0][1]; this->data[0][2] = m.data[0][2]; this->data[0][3] = m.data[0][3];
		this->data[1][0] = m.data[1][0]; this->data[1][1] = m.data[1][1]; this->data[1][2] = m.data[1][2]; this->data[1][3] = m.data[1][3];
		this->data[2][0] = m.data[2][0]; this->data[2][1] = m.data[2][1]; this->data[2][2] = m.data[2][2]; this->data[2][3] = m.data[2][3];
		this->data[3][0] = additional_row.x; this->data[3][1] = additional_row.y; this->data[3][2] = additional_row.z; this->data[3][3] = additional_row.w;
	}

	[[nodiscard]] float* operator[](const int index) { return this->data[index]; }
	[[nodiscard]] const float* operator[](const int index) const { return this->data[index]; }

	[[nodiscard]] const matrix_3x4& as_3x4() const { return *reinterpret_cast<const matrix_3x4*>(this); }
	[[nodiscard]] matrix_3x4& as_3x4() { return *reinterpret_cast<matrix_3x4*>(this); }

	constexpr view_matrix& operator+=(const view_matrix& m)
	{
		for (std::uint8_t c = 0U; c < 4U; c++)
		{
			for (std::uint8_t r = 0U; r < 4U; r++)
				this->data[c][r] += m[c][r];
		}

		return *this;
	}

	constexpr view_matrix& operator-=(const view_matrix& m)
	{
		for (std::uint8_t c = 0U; c < 4U; c++)
		{
			for (std::uint8_t r = 0U; r < 4U; r++)
				this->data[c][r] -= m[c][r];
		}

		return *this;
	}

	[[nodiscard]] constexpr vector_4d get_row(const int index) const { return { this->data[index][0], this->data[index][1], this->data[index][2], this->data[index][3] }; }
	[[nodiscard]] constexpr vector_4d get_column(const int index) const { return { this->data[0][index], this->data[1][index], this->data[2][index], this->data[3][index] }; }

	constexpr void identity()
	{
		for (std::uint8_t c = 0U; c < 4U; c++)
		{
			for (std::uint8_t r = 0U; r < 4U; r++)
				this->data[c][r] = (c == r) ? 1.f : 0.f;
		}
	}

	// concatenate transformations of two matrices into one.
	[[nodiscard]] constexpr view_matrix concat_transforms(const view_matrix& m) const
	{
		return
		{
			this->data[0][0] * m.data[0][0] + this->data[0][1] * m.data[1][0] + this->data[0][2] * m.data[2][0] + this->data[0][3] * m.data[3][0],
			this->data[0][0] * m.data[0][1] + this->data[0][1] * m.data[1][1] + this->data[0][2] * m.data[2][1] + this->data[0][3] * m.data[3][1],
			this->data[0][0] * m.data[0][2] + this->data[0][1] * m.data[1][2] + this->data[0][2] * m.data[2][2] + this->data[0][3] * m.data[3][2],
			this->data[0][0] * m.data[0][3] + this->data[0][1] * m.data[1][3] + this->data[0][2] * m.data[2][3] + this->data[0][3] * m.data[3][3],

			this->data[1][0] * m.data[0][0] + this->data[1][1] * m.data[1][0] + this->data[1][2] * m.data[2][0] + this->data[1][3] * m.data[3][0],
			this->data[1][0] * m.data[0][1] + this->data[1][1] * m.data[1][1] + this->data[1][2] * m.data[2][1] + this->data[1][3] * m.data[3][1],
			this->data[1][0] * m.data[0][2] + this->data[1][1] * m.data[1][2] + this->data[1][2] * m.data[2][2] + this->data[1][3] * m.data[3][2],
			this->data[1][0] * m.data[0][3] + this->data[1][1] * m.data[1][3] + this->data[1][2] * m.data[2][3] + this->data[1][3] * m.data[3][3],

			this->data[2][0] * m.data[0][0] + this->data[2][1] * m.data[1][0] + this->data[2][2] * m.data[2][0] + this->data[2][3] * m.data[3][0],
			this->data[2][0] * m.data[0][1] + this->data[2][1] * m.data[1][1] + this->data[2][2] * m.data[2][1] + this->data[2][3] * m.data[3][1],
			this->data[2][0] * m.data[0][2] + this->data[2][1] * m.data[1][2] + this->data[2][2] * m.data[2][2] + this->data[2][3] * m.data[3][2],
			this->data[2][0] * m.data[0][3] + this->data[2][1] * m.data[1][3] + this->data[2][2] * m.data[2][3] + this->data[2][3] * m.data[3][3],

			this->data[3][0] * m.data[0][0] + this->data[3][1] * m.data[1][0] + this->data[3][2] * m.data[2][0] + this->data[3][3] * m.data[3][0],
			this->data[3][0] * m.data[0][1] + this->data[3][1] * m.data[1][1] + this->data[3][2] * m.data[2][1] + this->data[3][3] * m.data[3][1],
			this->data[3][0] * m.data[0][2] + this->data[3][1] * m.data[1][2] + this->data[3][2] * m.data[2][2] + this->data[3][3] * m.data[3][2],
			this->data[3][0] * m.data[0][3] + this->data[3][1] * m.data[1][3] + this->data[3][2] * m.data[2][3] + this->data[3][3] * m.data[3][3]
		};
	}

	float data[4][4];

};

```

`sdk/valve/maths/other.h`:

```h
#pragma once

// this is vector 2d but renamed it from 'vector' to 'point' for less confusion.
// it was only made for drawing 2d objects and calculating 2d objects position.
class point
{
public:
	constexpr point() : x{ }, y{ } { }
	constexpr point(int x, int y) : x{ x }, y{ y } { }
	constexpr point(const point& p) : x{ p.x }, y{ p.y } { }

	// equality operators.
	bool operator==(const point& p) const { return p.x == this->x && p.y == this->y; }
	bool operator!=(const point& p) const { return p.x != this->x || p.y != this->y; }

	// copy assignment.
	constexpr point& operator=(const point& p)
	{
		this->x = p.x; this->y = p.y;
		return *this;
	}

	// negation-operator.
	constexpr point operator-() const { return point{ -this->x, -this->y }; }

	// arithmetic operators.
	point operator+(const point& p) const { return { this->x + p.x, this->y + p.y }; }
	point operator-(const point& p) const { return { this->x - p.x, this->y - p.y }; }
	point operator*(const point& p) const { return { this->x * p.x, this->y * p.y }; }
	point operator/(const point& p) const { return { this->x / p.x, this->y / p.y }; }

	int x, y;
};

class rect
{
public:
	constexpr rect() : x{ }, y{ }, w{ }, h{ } { }
	constexpr rect(int x, int y, int w, int h) : x{ x }, y{ y }, w{ w }, h{ h } { }
	int x, y, w, h;
};

class dimension
{
public:
	constexpr dimension() : w{ }, h{ } { }
	constexpr dimension(int w, int h) : w{ w }, h{ h } { }
	int w, h;
};

```

`sdk/valve/maths/q_angle.h`:

```h
#pragma once
#include <algorithm>
#include <cmath>
#include <limits>

class q_angle
{
public:
	constexpr q_angle() : x{ }, y{ }, z{ } { }
	constexpr q_angle(const float x, const float y, const float z) : x{ x }, y{ y }, z{ z } { }

	// index operators.
	[[nodiscard]] float& operator[](const std::size_t index) { return reinterpret_cast<float*>(this)[index]; }
	[[nodiscard]] const float& operator[](const std::size_t index) const { return reinterpret_cast<const float*>(this)[index]; }

	// equality operators.
	bool operator==(const q_angle& q) const { return q.x == this->x && q.y == this->y && q.z == this->z; }
	bool operator!=(const q_angle& q) const { return q.x != this->x || q.y != this->y || q.z != this->z; }

	// copy assignment.
	constexpr q_angle& operator=(const q_angle& q)
	{
		this->x = q.x; this->y = q.y; this->z = q.z;
		return *this;
	}

	// negation-operator.
	constexpr q_angle operator-() const { return q_angle{ -this->x, -this->y, -this->z }; }

	// arithmetic operators.
	q_angle operator+(const q_angle& q) const { return { this->x + q.x, this->y + q.y, this->z + q.z }; }
	q_angle operator-(const q_angle& q) const { return { this->x - q.x, this->y - q.y, this->z - q.z }; }
	q_angle operator*(const q_angle& q) const { return { this->x * q.x, this->y * q.y, this->z * q.z }; }
	q_angle operator/(const q_angle& q) const { return { this->x / q.x, this->y / q.y, this->z / q.z }; }

	// compound assignment operators.
	q_angle operator+=(const q_angle& q)
	{
		this->x += q.x; this->y += q.y; this->z += q.z;
		return *this;
	}

	q_angle operator-=(const q_angle& q)
	{
		this->x -= q.x; this->y -= q.y; this->z -= q.z;
		return *this;
	}

	q_angle operator*=(const q_angle& q)
	{
		this->x *= q.x; this->y *= q.y; this->z *= q.z;
		return *this;
	}

	q_angle operator/=(const q_angle& q)
	{
		this->x /= q.x; this->y /= q.y; this->z /= q.z;
		return *this;
	}

	// arithmetic operators w/ float.
	q_angle operator+(const float f) const { return { this->x + f, this->y + f, this->z + f }; }
	q_angle operator-(const float f) const { return { this->x - f, this->y - f, this->z - f }; }
	q_angle operator*(const float f) const { return { this->x * f, this->y * f, this->z * f }; }
	q_angle operator/(const float f) const { return { this->x / f, this->y / f, this->z / f }; }

	// compound assignment operators w/ float.
	q_angle& operator+=(float f)
	{
		this->x += f; this->y += f; this->z += f;
		return *this;
	}

	q_angle& operator-=(float f)
	{
		this->x -= f; this->y -= f; this->z -= f;
		return *this;
	}

	q_angle& operator*=(float f)
	{
		this->x *= f; this->y *= f; this->z *= f;
		return *this;
	}

	q_angle& operator/=(float f)
	{
		this->x /= f; this->y /= f; this->z /= f;
		return *this;
	}

	// modifier algorithms.
	void normalize()
	{
		this->x = std::isfinite(this->x) ? std::remainderf(this->x, 360.f) : 0.f;
		this->y = std::isfinite(this->y) ? std::remainderf(this->y, 360.f) : 0.f;
		this->z = std::isfinite(this->z) ? std::remainderf(this->z, 360.f) : 0.f;
	}

	q_angle normalized()
	{
		q_angle normalized = *this;
		normalized.normalize();
		return normalized;
	}

	void clamp()
	{
		this->x = std::clamp(this->x, -89.f, 89.f);
		this->y = std::clamp(this->y, -180.f, 180.f);
		this->z = std::clamp(this->z, -45.f, 45.f);
	}

	q_angle clamped()
	{
		q_angle clamped = *this;
		clamped.clamp();
		return clamped;
	}

	q_angle sanitize() const
	{
		q_angle cleaned = *this;
		cleaned.clamp();
		cleaned.normalize();
		return cleaned;
	}

	// extentions.
	[[nodiscard]] bool zero() const { return (this->x == 0.f && this->y == 0.f && this->z == 0.f); }

	[[nodiscard]] constexpr float dot(const q_angle& q) const { return (this->x * q.x + this->y * q.y + this->z * q.z); }
	[[nodiscard]] constexpr float length_sqr() const { return this->dot(*this); }
	[[nodiscard]] float length() const { return std::sqrtf(this->length_sqr()); }

	float x, y, z;
};

```

`sdk/valve/maths/utl_vector.h`:

```h
#pragma once
#include <Windows.h>
#include <corecrt_malloc.h>
#include <malloc.h>
#include <vcruntime_string.h>

template < class t, class n = int >
class utl_memory
{
public:
	t& operator[](n i) { return memory[i]; }
	const t& operator[](n i) const { return memory[i]; }

	t* base() { return memory; }

	[[nodiscard]] int allocated_count() const { return allocation_count; }
	[[nodiscard]] bool is_externally_allocated() const { return grow_size < 0; }

	void grow(const int count = 1)
	{
		if (is_externally_allocated())
			return;

		int allocation_requested = allocation_count + count;
		int new_allocation_count = 0;

		if (grow_size)
			allocation_count = ((1 + ((allocation_requested - 1) / grow_size)) * grow_size);
		else
		{
			if (!allocation_count)
				allocation_count = (31 + sizeof(t)) / sizeof(t);

			while (allocation_count < allocation_requested)
				allocation_count <<= 1;
		}

		if (static_cast<int>(static_cast<n>(new_allocation_count)) < allocation_requested)
		{
			if (static_cast<int>(static_cast<n>(new_allocation_count)) == 0 && static_cast<int>(static_cast<n>(new_allocation_count - 1)) >= allocation_requested)
				--new_allocation_count;
			else
			{
				if (static_cast<int>(static_cast<n>(allocation_requested)) != allocation_requested)
					return;

				while (static_cast<int>(static_cast<n>(new_allocation_count)) < allocation_requested)
					new_allocation_count = (new_allocation_count + allocation_requested) / 2;
			}
		}

		allocation_count = new_allocation_count;

		if (memory != nullptr)
			memory = static_cast<t*>(std::realloc(memory, allocation_count * sizeof(t)));
		else
			memory = static_cast<t*>(std::malloc(allocation_count * sizeof(t)));
	}

protected:
	t*		memory;
	int		allocation_count;
	int		grow_size;
};

template <class t>
void destruct(t* memory) { memory->~t(); }

template <class t>
t* construct(t* memory) { return new(memory) t; }

template< class t >
t* copy(t* memory, t const& source) { return new(memory) t(source); }

template < class t, class a = utl_memory< t > >
class utl_vector
{
	using allocator = a;
public:
	auto begin() noexcept { return memory.base(); }
	auto end() noexcept { return memory.base() + size_count; }

	auto begin() const noexcept { return memory.base(); }
	auto end() const noexcept { return memory.base() + size_count; }

	t& operator[](int i) { return memory[i]; }
	const t& operator[](int i) const { return memory[i]; }

	t& element(int i) { return memory[i]; }
	const t& element(int i) const { return memory[i]; }

	t* base() { return memory.base(); }

	int count() const { return size_count; }
	int& size() { return size_count; }

	void grow_vector(int count = 1)
	{
		if (size_count + count > memory.allocated_count())
			memory.grow(size_count + count - memory.allocated_count());

		size_count += count;
	}

	void shift_elements_right(const int element_index, const int shift = 1)
	{
		const int move_count = size_count - element_index - shift;

		if (move_count > 0 && shift > 0)
			std::memmove(&element(element_index + shift), &element(element_index), move_count * sizeof(t));
	}

	void shift_elements_left(const int element_index, const int shift = 1)
	{
		const int move_count = size_count - element_index - shift;

		if (move_count > 0 && shift > 0)
			std::memmove(&element(element_index), &element(element_index + shift), move_count * sizeof(t));
	}

	int insert_before(const int element_index)
	{
		// can insert at the end
		grow_vector();
		shift_elements_right(element_index);
		construct(&element(element_index));
		return element_index;
	}

	int insert_before(int element_index, const t& source)
	{
		// reallocate if can't insert something that's in the list
		// can insert at the end
		grow_vector();
		shift_elements_right(element_index);
		copy(&element(element_index), source);
		return element_index;
	}

	int add_tail() { return insert_before(size_count); }
	int add_tail(const t& source) { return insert_before(size_count, source); }

	int find(const t& source) const
	{
		for (int i = 0; i < count(); ++i)
		{
			if (element(i) == source)
				return i;
		}

		return -1;
	}

	void remove(const int element_index)
	{
		destruct(&element(element_index));
		shift_elements_left(element_index);
		--size_count;
	}

	void remove_all()
	{
		for (int i = size_count; --i >= 0;)
			destruct(&element(i));

		size_count = 0;
	}

	bool find_remove(const t& source)
	{
		if (const int element_index = find(source); element_index != -1)
		{
			remove(element_index);
			return true;
		}

		return false;
	}

protected:
	allocator	memory;
	int			size_count;
	t*			elements;
};

#define INVALID_UTL_SYMBOL static_cast< unsigned short >( ~0 )

class utl_symbol
{
public:
	utl_symbol() : index{ INVALID_UTL_SYMBOL } { }
	utl_symbol(const unsigned short i) : index{ i } { }
	utl_symbol(utl_symbol& other) : index{ other.index } { }

	utl_symbol& operator=(const utl_symbol& other)
	{
		this->index = other.index;
		return *this;
	}

	bool operator==(const utl_symbol& other) const
	{
		return this->index == other.index;
	}

	[[nodiscard]] bool valid() const
	{
		return this->index != INVALID_UTL_SYMBOL;
	}

	explicit operator unsigned short() const
	{
		return this->index;
	}

protected:
	unsigned short index;
};
```

`sdk/valve/maths/vector.h`:

```h
#pragma once
#include <Windows.h>
#include <cmath>
#include <limits>

class vector_2d
{
public:
	constexpr vector_2d() : x{ }, y{ } { }
	constexpr vector_2d(const float x, const float y) : x{ x }, y{ y } { }

	// index operators.
	[[nodiscard]] float& operator[](const std::size_t index) { return reinterpret_cast<float*>(this)[index]; }
	[[nodiscard]] const float& operator[](const std::size_t index) const { return reinterpret_cast<const float*>(this)[index]; }

	// equality operators.
	bool operator==(const vector_2d& v) const { return v.x == this->x && v.y == this->y; }
	bool operator!=(const vector_2d& v) const { return v.x != this->x || v.y != this->y; }

	// copy assignment.
	constexpr vector_2d& operator=(const vector_2d& v)
	{
		this->x = v.x; this->y = v.y;
		return *this;
	}

	// negation-operator.
	constexpr vector_2d operator-() const { return vector_2d{ -this->x, -this->y }; }

	// arithmetic operators.
	vector_2d operator+(const vector_2d& v) const { return { this->x + v.x, this->y + v.y }; }
	vector_2d operator-(const vector_2d& v) const { return { this->x - v.x, this->y - v.y }; }
	vector_2d operator*(const vector_2d& v) const { return { this->x * v.x, this->y * v.y }; }
	vector_2d operator/(const vector_2d& v) const { return { this->x / v.x, this->y / v.y }; }

	// compound assignment operators.
	vector_2d operator+=(const vector_2d& v)
	{
		this->x += v.x; this->y += v.y;
		return *this;
	}

	vector_2d operator-=(const vector_2d& v)
	{
		this->x -= v.x; this->y -= v.y;
		return *this;
	}

	vector_2d operator*=(const vector_2d& v)
	{
		this->x *= v.x; this->y *= v.y;
		return *this;
	}

	vector_2d operator/=(const vector_2d& v)
	{
		this->x /= v.x; this->y /= v.y;
		return *this;
	}

	// arithmetic operators w/ float.
	vector_2d operator+(const float f) const { return { this->x + f, this->y + f }; }
	vector_2d operator-(const float f) const { return { this->x - f, this->y - f }; }
	vector_2d operator*(const float f) const { return { this->x * f, this->y * f }; }
	vector_2d operator/(const float f) const { return { this->x / f, this->y / f }; }

	// compound assignment operators w/ float.
	vector_2d& operator+=(float f)
	{
		this->x += f; this->y += f;
		return *this;
	}

	vector_2d& operator-=(float f)
	{
		this->x -= f; this->y -= f;
		return *this;
	}

	vector_2d& operator*=(float f)
	{
		this->x *= f; this->y *= f;
		return *this;
	}

	vector_2d& operator/=(float f)
	{
		this->x /= f; this->y /= f;
		return *this;
	}

	// extentions.
	[[nodiscard]] bool zero() const { return (this->x == 0.f && this->y == 0.f); }

	[[nodiscard]] constexpr float dot(const vector_2d& v) const { return (this->x * v.x + this->y * v.y); }
	[[nodiscard]] constexpr float length_sqr() const { return this->dot(*this); }
	[[nodiscard]] float length() const { return std::sqrtf(this->length_sqr()); }

	float x, y;
};

class vector_3d
{
public:
	constexpr vector_3d() : x{ }, y{ }, z{ } { }
	constexpr vector_3d(const float x, const float y, const float z) : x{ x }, y{ y }, z{ z } { }
	constexpr vector_3d(const float* data) : x{ data[0] }, y{ data[1] }, z{ data[2] } { }

	// index operators.
	[[nodiscard]] float& operator[](const std::size_t index) { return reinterpret_cast<float*>(this)[index]; }
	[[nodiscard]] const float& operator[](const std::size_t index) const { return reinterpret_cast<const float*>(this)[index]; }

	// equality operators.
	bool operator==(const vector_3d& v) const { return v.x == this->x && v.y == this->y && v.z == this->z; }
	bool operator!=(const vector_3d& v) const { return v.x != this->x || v.y != this->y || v.z != this->z; }

	// copy assignment.
	constexpr vector_3d& operator=(const vector_3d& v)
	{
		this->x = v.x; this->y = v.y; this->z = v.z;
		return *this;
	}

	// negation-operator.
	constexpr vector_3d operator-() const { return vector_3d{ -this->x, -this->y, -this->z }; }

	// arithmetic operators.
	vector_3d operator+(const vector_3d& v) const { return { this->x + v.x, this->y + v.y, this->z + v.z }; }
	vector_3d operator-(const vector_3d& v) const { return { this->x - v.x, this->y - v.y, this->z - v.z }; }
	vector_3d operator*(const vector_3d& v) const { return { this->x * v.x, this->y * v.y, this->z * v.z }; }
	vector_3d operator/(const vector_3d& v) const { return { this->x / v.x, this->y / v.y, this->z / v.z }; }

	// compound assignment operators.
	vector_3d operator+=(const vector_3d& v)
	{
		this->x += v.x; this->y += v.y; this->z += v.z;
		return *this;
	}

	vector_3d operator-=(const vector_3d& v)
	{
		this->x -= v.x; this->y -= v.y; this->z -= v.z;
		return *this;
	}

	vector_3d operator*=(const vector_3d& v)
	{
		this->x *= v.x; this->y *= v.y; this->z *= v.z;
		return *this;
	}

	vector_3d operator/=(const vector_3d& v)
	{
		this->x /= v.x; this->y /= v.y; this->z /= v.z;
		return *this;
	}

	// arithmetic operators w/ float.
	vector_3d operator+(const float f) const { return { this->x + f, this->y + f, this->z + f }; }
	vector_3d operator-(const float f) const { return { this->x - f, this->y - f, this->z - f }; }
	vector_3d operator*(const float f) const { return { this->x * f, this->y * f, this->z * f }; }
	vector_3d operator/(const float f) const { return { this->x / f, this->y / f, this->z / f }; }

	// compound assignment operators w/ float.
	vector_3d& operator+=(float f)
	{
		this->x += f; this->y += f; this->z += f;
		return *this;
	}

	vector_3d& operator-=(float f)
	{
		this->x -= f; this->y -= f; this->z -= f;
		return *this;
	}

	vector_3d& operator*=(float f)
	{
		this->x *= f; this->y *= f; this->z *= f;
		return *this;
	}

	vector_3d& operator/=(float f)
	{
		this->x /= f; this->y /= f; this->z /= f;
		return *this;
	}

	// modifier algorithms.
	float normalize()
	{
		const float length = this->length();
		const float radius = 1.f / (length + std::numeric_limits<float>::epsilon());

		this->x *= radius;
		this->y *= radius;
		this->z *= radius;

		return length;
	}

	[[nodiscard]] vector_3d normalized()
	{
		vector_3d normalized = *this;
		normalized.normalize();
		return normalized;
	}

	/*
	* Reminder!
	* function: std::pow(n, exponent -> sqaured, cubed or whatever exponential power inputted);
	* std::pow function basically does n ^ p.
	* where n = number that u want to sqaure or whatever, p = power is where the exponent value goes.
	*/

	// extentions.
	[[nodiscard]] bool zero() const { return (this->x == 0.f && this->y == 0.f && this->z == 0.f); }

	[[nodiscard]] constexpr float dot(const vector_3d& v) const { return (this->x * v.x + this->y * v.y + this->z * v.z); }
	[[nodiscard]] constexpr float length_sqr() const { return this->dot(*this); }
	[[nodiscard]] float length() const { return std::sqrtf(this->length_sqr()); }

	[[nodiscard]] constexpr float distance_sqr(const vector_3d& v) const
	{
		vector_3d delta;

		delta.x = this->x - v.x;
		delta.y = this->y - v.y;
		delta.z = this->z - v.z;

		return delta.length_sqr();
	}

	[[nodiscard]] float distance(const vector_3d& v) const
	{
		vector_3d delta;

		delta.x = this->x - v.x;
		delta.y = this->y - v.y;
		delta.z = this->z - v.z;

		return delta.length();
	}

	[[nodiscard]] constexpr vector_3d cross(const vector_3d& v) const { return vector_3d(this->y * v.z - this->z * v.y, this->z * v.x - this->x * v.z, this->x * v.y - this->y * v.x); }

	// convert a 3 dimensional vector to 2 dimensional.
	[[nodiscard]] constexpr vector_2d to_2d() const { return vector_2d(this->x, this->y); }

	float x, y, z;
};

class vector_4d
{
public:
	constexpr vector_4d() : x{ }, y{ }, z{ }, w{ } { }
	constexpr vector_4d(const float x, const float y, const float z, const float w) : x{ x }, y{ y }, z{ z }, w{ w } { }
	float x, y, z, w;
};

class alignas(16) vector_aligned : public vector_3d
{
public:
	vector_aligned() : w{ } { }
	explicit vector_aligned(const vector_3d& v) { this->x = v.x, this->y = v.y, this->z = v.z, this->w = 0.f; }

	constexpr vector_aligned& operator=(const vector_3d& v)
	{
		this->x = v.x, this->y = v.y, this->z = v.z, this->w = 0.f;
		return *this;
	}

	float w;
};

// NOTE: it must be float values for it to render otherwise shit won't render anything in directx.
// that is why i put it here to use vector 2d's to render so it must be float value!!!!
class vertex
{
public:
	vertex() : position{ }, coordinate{ }, colour{ } { }
	vertex(const vector_2d& position, const vector_2d& coordinate, const DWORD colour)
	{
		this->position		= position;
		this->coordinate	= coordinate;
		this->colour		= colour;
	}

	vector_2d	position;
	vector_2d	coordinate;
	DWORD		colour;
};

```

`sdk/valve/netvar/data_map.h`:

```h
#pragma once
#include <cstddef>
#include <cstdint>

#pragma region data map flags

enum field_types : int
{
	field_void = 0,					// no type or value
	field_float,					// any floating point value
	field_string,					// a string id (return from alloc_string)
	field_vector,					// any vector, qangle, or angularimpulse
	field_quaternion,				// a quaternion
	field_integer,					// any integer or enum
	field_boolean,					// boolean, implemented as an int, i may use this as a hint for compression
	field_short,					// 2 byte integer
	field_character,				// a byte
	field_color_32,					// 8-bit per channel r,g,b,a (32bit color)
	field_embedded,					// an embedded object with a datadesc, recursively traverse and embedded class/structure based on an additional typedescription
	field_custom,					// special type that contains function pointers to it's read/write/parse functions
	field_class_ptr,				// cbaseentity*
	field_entity_handle,			// entity handle
	field_edict,					// edict_t*
	field_position_vector,			// a world coordinate (these are fixed up across level transitions automagically)
	field_time,						// a floating point time (these are fixed up automatically too!)
	field_tick,						// an integer tick count( fixed up similarly to time)
	field_model_name,				// engine string that is a model name (needs precache)
	field_sound_name,				// engine string that is a sound name (needs precache)
	field_input,					// a list of inputed data fields (all derived from cmultiinputvar)
	field_function,					// a class function pointer (think, use, etc)
	field_vmatrix,					// a vmatrix (output coords are not worldspace)
	field_vmatrix_world_space,		// a vmatrix that maps some local space to world space (translation is fixed up on level transitions)
	field_matrix_3x4_world_space,	// matrix3x4_t that maps some local space to world space (translation is fixed up on level transitions)
	field_interval,					// a start and range floating point interval ( e.g., 3.2->3.6 == 3.2 and 0.4 )
	field_model_index,				// a model index
	field_material_index,			// a material index (using the material precache string table)
	field_vector_2d,				// 2 floats
	field_integer_64,				// 64bit integer
	field_vector_4d,				// 4 floats
	field_type_count
};

enum
{
	data_offset_normal = 0,
	data_offset_packed = 1,
	data_offset_count
};

#pragma endregion

struct game_data_map;

struct game_type_description
{
public:
	field_types			type;							// 0x0000
	const char*			name;							// 0x0004
	int					offset[data_offset_count];		// 0x0008
	unsigned short		size;							// 0x0010
	short				flags;							// 0x0012
	std::byte			_pad0[0xc];						// 0x0014
	game_data_map*		description;					// 0x0020
	std::byte			_pad1[0x18];					// 0x0024
}; // size: 0x003c

struct game_data_map
{
	game_type_description*	descriptions;
	int						fields;
	const char*				name;
	game_data_map*			data_map;
	bool					chains_validated;
	bool					packed_offsets_computed;
	int						packed_size;
};
```

`sdk/valve/netvar/data_table.h`:

```h
#pragma once
#include <cstddef>
#include <cstdint>

enum send_prop_type : int
{
	dpt_int = 0,
	dpt_float,
	dpt_vector,
	dpt_vector_2d,
	dpt_string,
	dpt_array,
	dpt_data_table,
	dpt_int64,
	dpt_send_prop_type_max
};

struct receive_prop;

struct data_variant
{
	union {
		float			data_float;
		long			data_int;
		char*			data_string;
		void*			data;
		float			data_vector[3];
		std::int64_t	data_int64;
	};

	send_prop_type type;
};

class receive_proxy_data
{
public:
	const receive_prop*			prop;			// the property it's receiving.
	data_variant				value;			// the value given to you to store.
	int							element;		// which array element you're getting.
	int							object_id;		// the object being referred to.
};

using receive_variable_proxy	= void(__cdecl*)(const receive_proxy_data*, void*, void*);
using array_length_proxy		= void(__cdecl*)(void*, int, int);
using data_table_proxy			= void(__cdecl*)(const receive_prop*, void**, void*, int);

class standart_receive_proxies
{
public:
	receive_variable_proxy		int32_to_int8;
	receive_variable_proxy		int32_to_int16;
	receive_variable_proxy		int32_to_int32;
	receive_variable_proxy		int64_to_int64;
	receive_variable_proxy		float_to_float;
	receive_variable_proxy		vector_to_vector;
};

// receive data table.
struct receive_table
{
	receive_prop*		props;
	int					prop_count;
	void*				decoder;
	char*				name;
	bool				installed;
	bool				main_list;
};

// receive prop comes from the receive data table.
struct receive_prop
{
	char*					name;
	send_prop_type			type;
	int						flags;
	int						buffer_size;
	bool					inside;
	const void*				extra;
	receive_prop*			prop;
	array_length_proxy*		array_proxy;
	receive_variable_proxy	proxy;
	data_table_proxy*		table_proxy;
	receive_table*			table;
	int						offset;
	int						element_stride;
	int						elements;
	const char*				parent_name;
};
```

`sdk/valve/netvar/netvar.cpp`:

```cpp
#include "netvar.h"
#include "../valve.h"

game_netvar* netvar = new game_netvar;

bool game_netvar::setup()
{
	// clear values.
	netvar_map.clear();

	for (auto data = interfaces->base_client->capture_all(); data != nullptr; data = data->next)
	{
		if (data->recv_table == nullptr)
			continue;

		this->store_props(data->network_name, data->recv_table);
	}

	console->log(log_type::log_success, "netvar installed!");

	return !netvar_map.empty();
}

void game_netvar::store_props(const char* name, receive_table* table, const std::uintptr_t offset, const int depth)
{
	const hash32 class_hash = HASH_RUNTIME(name);
	const hash32 delimiter_hash = HASH_RUNTIME("->", class_hash);
	const hash32 base_class_hash = HASH_RUNTIME("baseclass", delimiter_hash);

	for (int i = 0; i < table->prop_count; i++)
	{
		const auto prop = &table->props[i];

		// base tables filter.
		if (prop == nullptr || isdigit(prop->name[0]))
			continue;

		// concat to our netvar format just by hash.
		const hash32 total_hash = HASH_RUNTIME(prop->name, delimiter_hash);

		// skip baseclass.
		if (total_hash == base_class_hash)
			continue;

		// has child table.
		if (const auto child = prop->table; child != nullptr && child->prop_count > 0 && child->name[0] == 'D' && prop->type == dpt_data_table)
			this->store_props(name, child, static_cast<std::uintptr_t>(prop->offset) + offset, depth + 1);

		const std::uintptr_t total_offset = static_cast<std::uintptr_t>(prop->offset) + offset;

		// check if we have already grabbed property.
		if (!netvar_map[total_hash].offset)
		{
			// write values to map entry.
			netvar_map[total_hash] = { prop, total_offset };
		}
	}
}

std::uintptr_t game_netvar::find(game_data_map* map, const hash32 field_hash)
{
	while (map != nullptr)
	{
		for (int i = 0; i < map->fields; i++)
		{
			// skip it if we can't find the function name.
			if (map->descriptions[i].name == nullptr)
				continue;

			if (HASH_RUNTIME(map->descriptions[i].name) == field_hash)
				return map->descriptions[i].offset[data_offset_normal];

			if (map->descriptions[i].type == field_embedded)
			{
				if (map->descriptions[i].description != nullptr)
				{
					if (const auto offset = this->find(map->descriptions[i].description, field_hash); offset != 0U)
						return offset;
				}
			}
		}

		map = map->data_map;
	}

	return FALSE;
}
```

`sdk/valve/netvar/netvar.h`:

```h
#pragma once
#include "data_map.h"
#include "data_table.h"
#include "../../dependencies/other/hash.h"
#include <unordered_map>
#include <type_traits>

class game_netvar
{
public:
	struct netvar_object
	{
		receive_prop*	prop	= nullptr;
		std::uintptr_t	offset	= 0U;
	};

	bool setup();

	/*
	* stores the variables of objects in the hierarchy.
	* used to iterate through an object's data descriptions from data map.
	*/
	std::uintptr_t find(game_data_map* map, const hash32 field_hash);

	std::unordered_map<hash32, netvar_object> netvar_map = { };
private:
	/*
	* recursively stores networked properties info from data tables in our map
	* and also format our dump and write values to file.
	*/
	void store_props(const char* name, receive_table* table, const std::uintptr_t offset = 0U, const int depth = 0);
};

extern game_netvar* netvar;

#pragma region netvar methods

#define NETVAR_OFFSET( table, add, name, type )																\
	[[nodiscard]] std::add_lvalue_reference_t<type> name()													\
	{																										\
		static constexpr std::uint32_t hashed = HASH_COMPILE(table);										\
		static std::uintptr_t map_offset = netvar->netvar_map[hashed].offset;								\
		return *(std::add_pointer_t<type>)(reinterpret_cast<std::uintptr_t>(this) + map_offset + add);		\
	}

#define NETVAR( table, name, type ) NETVAR_OFFSET( table, 0U, name, type )

#define NETVAR_OFFSET_PTR( table, add, name, type )															\
	[[nodiscard]] std::add_pointer_t<type> name()															\
	{																										\
		static constexpr std::uint32_t hashed = HASH_COMPILE(table);										\
		static std::uintptr_t map_offset = netvar->netvar_map[hashed].offset;								\
		return (std::add_pointer_t<type>)(reinterpret_cast<std::uintptr_t>(this) + map_offset + add);		\
	}

#define NETVAR_PTR( table, name, type ) NETVAR_OFFSET_PTR( table, 0U, name, type )

#define DATAMAP( map, table, name, type )																	\
	[[nodiscard]] std::add_lvalue_reference_t<type> name()													\
	{																										\
		static constexpr std::uint32_t hashed = HASH_COMPILE(table);										\
		static std::uintptr_t map_offset = netvar->find(map, hashed);										\
		return *(std::add_pointer_t<type>)(reinterpret_cast<std::uintptr_t>(this) + map_offset);			\
	}

#define DATAMAP_PTR( map, table, name, type )																\
	[[nodiscard]] std::add_pointer_t<type> name()															\
	{																										\
		static constexpr std::uint32_t hashed = HASH_COMPILE(table);										\
		static std::uintptr_t map_offset = netvar->find(map, hashed);										\
		return (std::add_pointer_t<type>)(reinterpret_cast<std::uintptr_t>(this) + map_offset);				\
	}

#define OFFSET( name, type, offset )																		\
	[[nodiscard]] std::add_lvalue_reference_t<type> name()													\
	{																										\
		return *(std::add_pointer_t<type>)(reinterpret_cast<std::uintptr_t>(this) + offset);				\
	}

#define OFFSET_PTR( name, type, offset )																	\
	[[nodiscard]] std::add_pointer_t<type> name()															\
	{																										\
		return (std::add_pointer_t<type>)(reinterpret_cast<std::uintptr_t>(this) + offset);					\
	}

#pragma endregion
```

`sdk/valve/other/animations.cpp`:

```cpp
#include "animations.h"
#include "../../dependencies/dependency.h"

game_animation_state::game_animation_state(cs_player* player)
{
	static auto original_constructor = SEARCH(modules->client, signatures::other::animation_state_constructor::signature()).cast<void(__thiscall*)(game_animation_state*, cs_player*)>();
	original_constructor(this, player);
}

void game_animation_state::update(const q_angle& view_angle)
{
	static auto original_constructor = SEARCH(modules->client, signatures::other::animation_state_update::signature()).cast<void(__vectorcall*)(game_animation_state*, void*, float, float, float, void*)>();
	original_constructor(this, nullptr, view_angle.z, view_angle.y, view_angle.x, nullptr);
}

void game_animation_state::reset()
{
	static auto original_constructor = SEARCH(modules->client, signatures::other::animation_state_reset::signature()).cast<void(__thiscall*)(game_animation_state*)>();
	original_constructor(this);
}

void game_animation_state::modify_eye_position(vector_3d& input_eye_position) const
{
	if (!this->player || interfaces->engine_client->hltv())
		return;

	if (!this->landing && this->duck_amount == 0.f && this->player->ground_entity_handle().valid())
		return;

	const int head_bone = this->player->bone_by_hash(HASH_COMPILE("head_0"));
	if (head_bone == game_bone_index::bone_invalid)
		return;

	vector_3d head_position = this->player->bone_position(head_bone);
	head_position.z += 1.7f;

	if (input_eye_position.z > head_position.z)
	{
		const float height_factor = std::clamp((std::fabsf(input_eye_position.z - head_position.z) - 4.f) / 6.f, 0.f, 1.f);
		// simple spline remapval clamped.
		const float height_factor_sqr = (height_factor * height_factor);
		input_eye_position.z += ((head_position.z - input_eye_position.z) * ((height_factor_sqr * 3.f) - ((height_factor_sqr * 2.f) * height_factor)));
	}
}

```

`sdk/valve/other/animations.h`:

```h
#pragma once
#include "../maths/vector.h"
#include "../maths/q_angle.h"
#include "../maths/matrix.h"
#include "../maths/utl_vector.h"
#include "studio.h"
#include <assert.h>

#define max_animation_layer 13

#pragma region animations flags

enum game_animation_state_layer : int
{
	ANIMATION_LAYER_AIM_MATRIX = 0,
	ANIMATION_LAYER_WEAPON_ACTION,
	ANIMATION_LAYER_WEAPON_ACTION_RECROUCH,
	ANIMATION_LAYER_ADJUST,
	ANIMATION_LAYER_MOVEMENT_JUMP_OR_FALL,
	ANIMATION_LAYER_MOVEMENT_LAND_OR_CLIMB,
	ANIMATION_LAYER_MOVEMENT_MOVE,
	ANIMATION_LAYER_MOVEMENT_STRAFE_CHANGE,
	ANIMATION_LAYER_WHOLE_BODY,
	ANIMATION_LAYER_FLASHED,
	ANIMATION_LAYER_FLINCH,
	ANIMATION_LAYER_ALIVE_LOOP,
	ANIMATION_LAYER_LEAN,
	ANIMATION_LAYER_COUNT = 13
};

enum game_animation_pose_parameters : int
{
	PLAYER_POSE_PARAM_FIRST = 0,
	PLAYER_POSE_PARAM_LEAN_YAW = PLAYER_POSE_PARAM_FIRST,
	PLAYER_POSE_PARAM_SPEED,
	PLAYER_POSE_PARAM_LADDER_SPEED,
	PLAYER_POSE_PARAM_LADDER_YAW,
	PLAYER_POSE_PARAM_MOVE_YAW,
	PLAYER_POSE_PARAM_RUN,
	PLAYER_POSE_PARAM_BODY_YAW,
	PLAYER_POSE_PARAM_BODY_PITCH,
	PLAYER_POSE_PARAM_DEATH_YAW,
	PLAYER_POSE_PARAM_STAND,
	PLAYER_POSE_PARAM_JUMP_FALL,
	PLAYER_POSE_PARAM_AIM_BLEND_STAND_IDLE,
	PLAYER_POSE_PARAM_AIM_BLEND_CROUCH_IDLE,
	PLAYER_POSE_PARAM_STRAFE_DIR,
	PLAYER_POSE_PARAM_AIM_BLEND_STAND_WALK,
	PLAYER_POSE_PARAM_AIM_BLEND_STAND_RUN,
	PLAYER_POSE_PARAM_AIM_BLEND_CROUCH_WALK,
	PLAYER_POSE_PARAM_MOVE_BLEND_WALK,
	PLAYER_POSE_PARAM_MOVE_BLEND_RUN,
	PLAYER_POSE_PARAM_MOVE_BLEND_CROUCH_WALK,
	//PLAYER_POSE_PARAM_STRAFE_CROSS,
	PLAYER_POSE_PARAM_COUNT
};

enum game_sequence_activity : int
{
	ACT_INVALID = -1,
	ACT_CSGO_NULL = 957,
	ACT_CSGO_DEFUSE,
	ACT_CSGO_DEFUSE_WITH_KIT,
	ACT_CSGO_FLASHBANG_REACTION,
	ACT_CSGO_FIRE_PRIMARY,
	ACT_CSGO_FIRE_PRIMARY_OPT_1,
	ACT_CSGO_FIRE_PRIMARY_OPT_2,
	ACT_CSGO_FIRE_SECONDARY,
	ACT_CSGO_FIRE_SECONDARY_OPT_1,
	ACT_CSGO_FIRE_SECONDARY_OPT_2,
	ACT_CSGO_RELOAD,
	ACT_CSGO_RELOAD_START,
	ACT_CSGO_RELOAD_LOOP,
	ACT_CSGO_RELOAD_END,
	ACT_CSGO_OPERATE,
	ACT_CSGO_DEPLOY,
	ACT_CSGO_CATCH,
	ACT_CSGO_SILENCER_DETACH,
	ACT_CSGO_SILENCER_ATTACH,
	ACT_CSGO_TWITCH,
	ACT_CSGO_TWITCH_BUY_ZONE,
	ACT_CSGO_PLANT_BOMB,
	ACT_CSGO_IDLE_TURN_BALANCE_ADJUST,
	ACT_CSGO_IDLE_ADJUST_STOPPED_MOVING,
	ACT_CSGO_ALIVE_LOOP,
	ACT_CSGO_FLINCH,
	ACT_CSGO_FLINCH_HEAD,
	ACT_CSGO_FLINCH_MOLOTOV,
	ACT_CSGO_JUMP,
	ACT_CSGO_FALL,
	ACT_CSGO_CLIMB_LADDER,
	ACT_CSGO_LAND_LIGHT,
	ACT_CSGO_LAND_HEAVY,
	ACT_CSGO_EXIT_LADDER_TOP,
	ACT_CSGO_EXIT_LADDER_BOTTOM
};

#pragma endregion

class base_animating;
class base_animating_overlay;
class weapon_cs_base;
class cs_player;

class game_bone_accessor
{
public:
	const base_animating*	animating;
	matrix_aligned*			matrix_bones;	// readable/writable bones
	int						readable_bones; // mask of which bones can be read
	int						writable_bones; // mask of which bones can be written
};

class game_animation_layer
{
public:
	float					animation_time; // 0x00
	float					fade_out_time; // 0x04
	game_studio_hdr*		dispatched_studio_hdr; // 0x08
	int						dispatched_source; // 0x0c
	int						dispatched_destination; // 0x10
	int						order; // 0x14
	int						sequence; // 0x18 // in range: [-1 .. 65535]
	float					previous_cycle; // 0x1c // in range: [-2.0 .. 2.0]
	float					weight; // 0x20 // in range: [-5.0 .. 5.0]
	float					weight_delta_rate; // 0x24 // in range: [-5.0 .. 5.0]
	float					playback_rate; // 0x28
	float					cycle; // 0x2c // in range: [-2.0 .. 2.0]
	base_animating_overlay* owner; // 0x30
	int						invalidate_physics_bits; // 0x34
};

class game_animation_state
{
public:
	game_animation_state(cs_player* player);

	void update(const q_angle& view_angle);
	void reset();
	void modify_eye_position(vector_3d& input_eye_position) const;

public:
	const int*				layer_order_preset; // 0x0000
	bool					first_run; // 0x0004
	bool					first_foot_plant; // 0x0005
	int						last_procedural_foot_plant_update_frame; // 0x0008
	float					eye_position_smooth_lerp; // 0x000c
	float					strafe_change_weight_smooth_falloff; // 0x0010
	std::byte				_pad0[0x3c]; // 0x0014
	int						cached_model_index; // 0x0050
	float					step_height_left; // 0x0054
	float					step_height_right; // 0x0058
	weapon_cs_base*			last_weapon_bone_setup; // 0x005c
	cs_player*				player; // 0x0060
	weapon_cs_base*			weapon; // 0x0064
	weapon_cs_base*			last_weapon; // 0x0068
	float					last_update_time; // 0x006c
	int						last_update_frame; // 0x0070
	float					last_update_increment; // 0x0074
	float					eye_yaw; // 0x0078
	float					eye_pitch; // 0x007c
	float					foot_yaw; // 0x0080
	float					last_foot_yaw; // 0x0084
	float					move_yaw; // 0x0088
	float					move_yaw_ideal; // 0x008c // changes when moving/jumping/hitting ground
	float					move_yaw_current_to_ideal; // 0x0090
	float					time_to_align_lower_body; // 0x0094
	float					primary_cycle; // 0x0098 // in range: [0.0 .. 1.0]
	float					move_weight; // 0x009c // in range: [0.0 .. 1.0]
	float					move_weight_smoothed; // 0x00a0
	float					duck_amount; // 0x00a4
	float					duck_additional; // 0x00a8 // for when we duck a bit after hitting ground from a jump
	float					recrouch_weight; // 0x00ac
	vector_3d				origin; // 0x00b0
	vector_3d				last_origin;// 0x00bc
	vector_3d				velocity; // 0x00c8
	vector_3d				velocity_normalized; // 0x00d4
	vector_3d				velocity_normalized_non_zero; // 0x00e0
	float					velocity_length_2d; // 0x00ec
	float					velocity_length_z; // 0x00f0
	float					run_speed_normalized; // 0x00f4 // @ida: client.dll -> ["f3 0f 59 8f ? ? ? ? 0f 2f" + 0x4]
	float					walk_speed_normalized; // 0x00f8
	float					crouch_speed_normalized; // 0x00fc
	float					moving_duration; // 0x0100
	float					duration_still; // 0x0104
	bool					on_ground; // 0x0108 // @ida: client.dll -> abs["e8 ? ? ? ? f6 86 ? ? ? ? ? 0f 84" + 0x1] + 0x18
	bool					landing; // 0x0109
	float					jump_to_fall; // 0x010c
	float					duration_in_air; // 0x0110
	float					left_ground_height; // 0x0114
	float					hit_ground_weight; // 0x0118
	float					walk_to_run_transition; // 0x011c // in range: [0.0 .. 1.0], doesn't change when walking or crouching, only running // @ida: client.dll -> ["f3 0f 10 9e ? ? ? ? 0f 57 c9" + 0x4]
	std::byte				_pad1[0x4]; // 0x0120
	float					in_air_smooth_value; // 0x0124 // in range: [0.0 .. 1.0], affected while jumping and running, or when just jumping
	bool					on_ladder; // 0x0128
	float					ladder_weight; // 0x012c
	float					ladder_speed; // 0x0130
	bool					walk_to_run_transition_state; // 0x0134
	bool					defuse_started; // 0x0135
	bool					plant_animation_started; // 0x0136
	bool					twitch_animation_started; // 0x0137
	bool					adjustment_started; // 0x0138
	utl_vector<utl_symbol>	activity_modifiers; // 0x013c
	float					next_twitch_time; // 0x0150
	float					time_of_last_known_injury; // 0x0154
	float					last_velocity_test_time; // 0x0158 // @ida: client.dll -> ["f3 0f 5c a7 ? ? ? ? 0f 2f" + 0x4]
	vector_3d				last_velocity; // 0x015c
	vector_3d				target_acceleration; // 0x0168
	vector_3d				acceleration; // 0x0174 // @ida: client.dll -> ["f3 0f 7e 87 ? ? ? ? 8d b7" + 0x4]
	float					acceleration_weight; // 0x0180
	std::byte				_pad2[0xc]; // 0x184
	float					strafe_change_weight; // 0x0190 // @ida: client.dll -> ["f3 0f 10 9e ? ? ? ? 0f 28 ec" + 0x4]
	float					strafe_change_target_weight; // 0x194
	float					strafe_change_cycle; // 0x0198 // @ida: client.dll -> ["f3 0f 10 96 ? ? ? ? f3 0f 59 25" + 0x4]
	int						strafe_sequence; // 0x019c
	bool					strafe_changing; // 0x01a0
	float					strafing_duration; // 0x01a4
	float					foot_lerp; // 0x01a8
	bool					feet_crossed; // 0x01ac
	bool					player_is_accelerating; // 0x01ad // @ida: client.dll -> ["88 86 ? ? ? ? 8b 86 ? ? ? ? 83" + 0x2]
	std::byte				_pad3[0x174 + 0x2]; // 0x01ae
	float					camera_smooth_height; // 0x0324
	bool					smooth_height_valid; // 0x0328 @ida: client.dll -> ["c6 87 ? ? ? ? ? eb 92" + 0x2]
	std::byte				_pad4[0x10 + 0x3]; // 0x0329
	float					aim_yaw_min; // 0x033c // @ida: client.dll -> ["f3 0f 5e 86 ? ? ? ? f3 0f 59 05 ? ? ? ? 80" + 0x4]
	float					aim_yaw_max; // 0x0340
	int						animation_set_version; // 0x0344 // @xref: "animset_version"
};

```

`sdk/valve/other/bitbuf.h`:

```h
#pragma once
#include <Windows.h>

class bf_write
{
public:
	bf_write() = default;

	// the current buffer.
	unsigned long* data;
	int				data_bytes;
	int				data_bits;

	// where we are in the buffer.
	int				current_bit;
};

class bf_read
{
public:
	std::uintptr_t base_address;
	std::uintptr_t current_offset;

	bf_read(std::uintptr_t address) : base_address(address), current_offset(0U) { }

	void set_offset(std::uintptr_t offset) { current_offset = offset; }
	void skip(std::uintptr_t length) { current_offset += length; }

	int read_byte()
	{
		char value = *reinterpret_cast<char*>(base_address + current_offset);
		current_offset++;
		return value;
	}

	bool read_bool()
	{
		bool value = *reinterpret_cast<bool*>(base_address + current_offset);
		current_offset++;
		return value;
	}

	const char* read_string()
	{
		char buffer[256];
		char length = *reinterpret_cast<char*>(base_address + current_offset);
		current_offset++;
		std::memcpy(buffer, reinterpret_cast<void*>(base_address + current_offset), length > 255 ? 255 : length);
		buffer[length > 255 ? 255 : length] = '\0';
		current_offset += length + 1;
		return buffer;
	}
};
```

`sdk/valve/other/convar.cpp`:

```cpp
#include "convar.h"
#include "../valve.h"

game_spoofed_convar::game_spoofed_convar(const char* var)
{
	original_convar = interfaces->convar->find(var);
	spoof();
}

game_spoofed_convar::game_spoofed_convar(game_convar* var)
{
	original_convar = var;
	spoof();
}

game_spoofed_convar::~game_spoofed_convar()
{
	if (is_spoofed())
	{
		// restore values.
		set_flags(original_flags);
		set(original_value); // string values.

		// restore original name.
		game_protect protect = PROTECT((LPVOID)original_convar->name, 128UL, PAGE_READWRITE);
		strcpy_s(const_cast<char*>(original_convar->name), sizeof(original_name), original_name);

		// unregister temporary convar.
		interfaces->convar->unregister_command(dummy_convar);
		free(dummy_convar);
		dummy_convar = nullptr;
	}
}

bool game_spoofed_convar::is_spoofed() const
{
	return dummy_convar != nullptr;
}

void game_spoofed_convar::spoof()
{
	if (!is_spoofed() && original_convar != nullptr)
	{
		// backup old values.
		original_flags = original_convar->flags;
		strcpy_s(original_name, original_convar->name);
		strcpy_s(original_value, original_convar->default_value);
		sprintf_s(dummy_name, 128U, "%s", original_name);

		// create temporary convar.
		dummy_convar = static_cast<game_convar*>(std::malloc(sizeof(game_convar)));

		if (dummy_convar == nullptr)
			return;

		memcpy(dummy_convar, original_convar, sizeof(game_convar));
		dummy_convar->next = nullptr;

		// register temporary convar.
		interfaces->convar->register_command(dummy_convar);

		game_protect protect = PROTECT((LPVOID)original_convar->name, 128UL, PAGE_READWRITE);

		// rename the convar.
		strcpy_s(const_cast<char*>(original_convar->name), sizeof(dummy_name), dummy_name);

		set_flags(cvar_none);
	}
}

void game_spoofed_convar::set_flags(int flags) const
{
	if (is_spoofed())
		original_convar->flags = flags;
}

int game_spoofed_convar::get_flags() const
{
	return original_convar->flags;
}

void game_spoofed_convar::set(bool value) const
{
	if (is_spoofed())
		original_convar->set(value);
}

void game_spoofed_convar::set(int value) const
{
	if (is_spoofed())
		original_convar->set(value);
}

void game_spoofed_convar::set(float value) const
{
	if (is_spoofed())
		original_convar->set(value);
}

void game_spoofed_convar::set(const char* value) const
{
	if (is_spoofed())
		original_convar->set(value);
}

```

`sdk/valve/other/convar.h`:

```h
#pragma once
#include "../../dependencies/memory/virtual.h"
#include "../maths/utl_vector.h"
#include <cstddef>
#include <cstdint>

using command_callback = void(__cdecl*)();
using change_callback = void(__cdecl*)(void*, const char*, float);

class game_convar
{
public:

#pragma region convar get methods

	const char* get_name() { return virtuals->call<const char*>(this, 5); }

	float get_float()
	{
		std::uint32_t xored = *reinterpret_cast<std::uint32_t*>(&parent->float_value) ^ reinterpret_cast<std::uint32_t>(this);
		return *reinterpret_cast<float*>(&xored);
	}

	int get_int() { return static_cast<int>(parent->int_value ^ reinterpret_cast<int>(this)); }
	bool get_bool() { return !!get_int(); }

	const char* get_string() const
	{
		const auto value = parent->string; 
		return value ? value : "\0";
	}

#pragma endregion

#pragma region convar set methods

	void set(const char* value) { return virtuals->call<void>(this, 14, value); }
	void set(float value) { return virtuals->call<void>(this, 15, value); }
	void set(int value) { return virtuals->call<void>(this, 16, value); }
	//void set(color value) { return virtuals->call<void>(this, 17, value); }

#pragma endregion

#pragma region convar variables

	std::byte						_pad0[0x4];			// 0x00
	game_convar*					next;				// 0x04
	bool							registered;			// 0x08
	const char*						name;				// 0x0C
	const char*						help_string;		// 0x10
	int								flags;				// 0x14
	command_callback				callback;			// 0x18
	game_convar*					parent;				// 0x1C
	const char*						default_value;		// 0x20
	char*							string;				// 0x24
	int								string_length;		// 0x28
	float							float_value;		// 0x2C
	int								int_value;			// 0x30
	bool							has_min;			// 0x34
	float							min_value;			// 0x38
	bool							has_max;			// 0x3C
	float							max_value;			// 0x40
	utl_vector<change_callback>		change_callbacks;	// 0x44

#pragma endregion
};

class game_spoofed_convar
{
public:
	game_spoofed_convar() = default;
	game_spoofed_convar(const char* var);
	game_spoofed_convar(game_convar* var);
	~game_spoofed_convar();

	// checks
	bool	is_spoofed() const;
	void	spoof();

	// flags
	void	set_flags(int flags) const;
	int		get_flags() const;

	// methods
	void	set(bool value) const;
	void	set(int value) const;
	void	set(float value) const;
	void	set(const char* value) const;

private:
	game_convar*	original_convar = nullptr;
	char			original_name[128];
	char			original_value[128];
	int				original_flags = 0;

	game_convar*	dummy_convar = nullptr;
	char			dummy_name[128];
	char			dummy_value[128];
};
```

`sdk/valve/other/key_value.cpp`:

```cpp
#include "key_value.h"
#include "../valve.h"
#include <assert.h>

game_key_value::game_key_value(const char* key_name, void* unknown1, h_key_symbol case_insensitive_key_name)
{
	using param_key_value_constructor = void(__thiscall*)(void*, const char*, void*, h_key_symbol);
	static param_key_value_constructor original_constructor = SEARCH(modules->client, signatures::other::key_value_constructor::signature()).cast<param_key_value_constructor>(); // @xref: client.dll -> "OldParticleSystem_Destroy"
	original_constructor(this, key_name, unknown1, case_insensitive_key_name);
}

game_key_value::~game_key_value()
{
	using param_key_values_destructor = void(__thiscall*)(void*, int);
	static param_key_values_destructor original_destructor = SEARCH(modules->client, signatures::other::key_value_destructor::signature()).cast<param_key_values_destructor>();
	original_destructor(this, 1);
}

void* game_key_value::operator new(std::size_t alloc_size)
{
	// manually allocate memory, because game constructor doesn't call it automatically
	return interfaces->key_value_system->alloc_memory(alloc_size);
}

void game_key_value::operator delete(void* memory_ptr)
{
	// do nothing, because game destructor will automatically free memory
	// I::KeyValuesSystem->FreeKeyValuesMemory(memory_ptr);
	(void)memory_ptr;
}

const char* game_key_value::get_name() { return interfaces->key_value_system->string_symbol(this->key_name_case_sensitive1 | (this->key_name_case_sensitive2 << 8)); }

game_key_value* game_key_value::from_string(const char* name, const char* value)
{
	static auto original_from_string = SEARCH(modules->client, signatures::other::from_string::signature()); // @xref: "#empty#", "#int#"
	game_key_value* key_values = nullptr;

	if (original_from_string == 0U)
		return nullptr;

	__asm
	{
		push		0
		mov edx,	value
		mov ecx,	name
		call		original_from_string
		add esp,	4
		mov			key_values, eax
	}

	return key_values;
}

void game_key_value::load_from_buffer(char const* resource_name, const char* buffer, void* file_system, const char* path_id, symbol_proc evaluate_symbol_proc)
{
	using param_load_from_buffer = void(__thiscall*)(void*, const char*, const char*, void*, const char*, void*, void*);
	static auto original_load_from_buffer = SEARCH(modules->client, signatures::other::load_from_buffer::signature()).cast<param_load_from_buffer>(); // @xref: "KeyValues::LoadFromBuffer(%s%s%s): Begin"
	assert(original_load_from_buffer != nullptr);
	original_load_from_buffer(this, resource_name, buffer, file_system, path_id, evaluate_symbol_proc, nullptr);
}

bool game_key_value::load_from_file(void* file_system, const char* resource_name, const char* path_id, symbol_proc evaluate_symbol_proc)
{
	using param_load_from_file = bool(__thiscall*)(void*, void*, const char*, const char*, void*);
	static auto original_load_from_file = SEARCH(modules->client, signatures::other::load_from_file::signature()).cast<param_load_from_file>(); // @xref: "rb"
	assert(original_load_from_file != nullptr);
	return original_load_from_file(this, file_system, resource_name, path_id, evaluate_symbol_proc);
}

game_key_value* game_key_value::find(const char* key_name, const bool create)
{
	using param_find_key = game_key_value * (__thiscall*)(void*, const char*, bool);
	static auto original_find_key = SEARCH(modules->client, signatures::other::find_key::signature()).cast<param_find_key>();
	assert(original_find_key != nullptr);
	return original_find_key(this, key_name, create);
}

int game_key_value::get_int(const char* key_name, const int default_value)
{
	game_key_value* sub_key = this->find(key_name, false);

	if (sub_key == nullptr)
		return default_value;

	switch (sub_key->data_type)
	{
	case type_string:
		return std::atoi(sub_key->value);
	case type_wstring:
		return _wtoi(sub_key->wide_value);
	case type_float:
		return static_cast<int>(sub_key->float_value);
	case type_uint64:
		// can't convert, since it would lose data
		assert(false);
		return 0;
	default:
		break;
	}

	return sub_key->int_value;
}

float game_key_value::get_float(const char* key_name, const float default_value)
{
	game_key_value* sub_key = this->find(key_name, false);

	if (sub_key == nullptr)
		return default_value;

	switch (sub_key->data_type)
	{
	case type_string:
		return static_cast<float>(std::atof(sub_key->value));
	case type_wstring:
		return std::wcstof(sub_key->wide_value, nullptr);
	case type_float:
		return sub_key->float_value;
	case type_int:
		return static_cast<float>(sub_key->int_value);
	case type_uint64:
		return static_cast<float>(*reinterpret_cast<std::uint64_t*>(sub_key->value));
	case type_ptr:
	default:
		return 0.0f;
	}
}

const char* game_key_value::get_string(const char* key_name, const char* default_value)
{
	using param_get_string = const char* (__thiscall*)(void*, const char*, const char*);
	static auto original_get_string = SEARCH(modules->client, signatures::other::get_string::signature()).cast<param_get_string>();
	assert(original_get_string != nullptr);
	return original_get_string(this, key_name, default_value);
}

void game_key_value::set_string(const char* key_name, const char* string_value)
{
	game_key_value* sub_key = this->find(key_name, true);

	if (sub_key == nullptr)
		return;

	using param_set_string = void(__thiscall*)(void*, const char*);
	static auto original_set_string = SEARCH(modules->client, signatures::other::set_string::signature()).cast<param_set_string>();
	assert(original_set_string != nullptr);
	original_set_string(sub_key, string_value);
}

void game_key_value::set_int(const char* key_name, const int value)
{
	game_key_value* sub_key = this->find(key_name, true);

	if (sub_key == nullptr)
		return;

	sub_key->int_value = value;
	sub_key->data_type = type_int;
}

void game_key_value::set_uint64(const char* key_name, const int low_value, const int high_value)
{
	game_key_value* sub_key = this->find(key_name, true);

	if (sub_key == nullptr)
		return;

	// delete the old value.
	delete[] sub_key->value;

	// make sure we're not storing the WSTRING - as we're converting over to STRING.
	delete[] sub_key->wide_value;
	sub_key->wide_value = nullptr;

	sub_key->value = new char[sizeof(std::uint64_t)];
	*reinterpret_cast<std::uint64_t*>(sub_key->value) = static_cast<std::uint64_t>(high_value) << 32ULL | low_value;
	sub_key->data_type = type_uint64;
}
```

`sdk/valve/other/key_value.h`:

```h
#pragma once
#include "../interface/classes/key_value_system.h"
#include <cstddef>
#include <cstdint>

using symbol_proc = bool(__cdecl*)(const char*);

class game_key_value
{
public:
	enum key_type : int
	{
		type_none = 0,
		type_string,
		type_int,
		type_float,
		type_ptr,
		type_wstring,
		type_color,
		type_uint64,
		type_compiled_int_byte,
		type_compiled_int_0,
		type_compiled_int_1,
		type_count
	};

	game_key_value(const char* key_name, void* unknown1 = nullptr, h_key_symbol case_insensitive_key_name = invalid_key_symbol);
	~game_key_value();

	void* operator new(std::size_t alloc_size);
	void operator delete(void* memory_ptr);

	const char* get_name();

	static game_key_value* from_string(const char* name, const char* value);
	void load_from_buffer(char const* resource_name, const char* buffer, void* file_system = nullptr, const char* path_id = nullptr, symbol_proc evaluate_symbol_proc = nullptr);
	bool load_from_file(void* file_system, const char* resource_name, const char* path_id = nullptr, symbol_proc evaluate_symbol_proc = nullptr);

	game_key_value* find(const char* key_name, const bool create);

	int get_int(const char* key_name, const int default_value);
	float get_float(const char* key_name, const float default_value);
	const char* get_string(const char* key_name, const char* default_value);

	void set_string(const char* key_name, const char* string_value);
	void set_int(const char* key_name, const int value);
	void set_uint64(const char* key_name, const int low_value, const int high_value);

	inline void set_bool(const char* key_name, const bool value) { set_int(key_name, value ? 1 : 0); }

private:
	std::uint32_t		key_name : 24;						// 0x00
	std::uint32_t		key_name_case_sensitive1 : 8;		// 0x3 // byte, explicitly specify bits due to packing
	char*				value;								// 0x04
	wchar_t*			wide_value;							// 0x08

	union
	{
		int				int_value;
		float			float_value;
		void*			value_ptr;
		unsigned char	color[4];
	}; // 0x0c

	std::int8_t			data_type;							// 0x10
	bool				has_escape_sequences;				// 0x11
	std::uint16_t		key_name_case_sensitive2;			// 0x12
	void*				unknown14;							// 0x14 // seems like ikeyvaluessystem*, but why do they need it here? also calling smth on destructor and cleans up
	bool				has_case_insensitive_symbol;		// 0x18
	game_key_value*		peer;								// 0x1c
	game_key_value*		sub;								// 0x20
	game_key_value*		chain;								// 0x24
	symbol_proc			expression_symbol_proc;				// 0x28
};
```

`sdk/valve/other/net_channel.h`:

```h
#pragma once
#include "bitbuf.h"

#define flow_out	0
#define flow_in		1
#define max_flow	2

// reference: https://github.com/ValveSoftware/source-sdk-2013/blob/master/sp/src/public/inetchannelinfo.h
class game_net_channel_info
{
public:
	enum
	{
		generic = 0,		// must be first and is default group
		local_player,		// bytes for local player entity update
		other_players,		// bytes for other players update
		entities,			// all other entity bytes
		sounds,				// game sounds
		events,				// event messages
		temp_entities,		// temp entities
		user_messages,		// user messages
		entity_messages,	// entity messages
		voice,				// voice data
		string_table,		// a stringtable update
		move,				// client move cmds
		string_cmd,			// string command
		signon,				// various signondata
		paint_map,			// paintmap data
		encrypted,			// encrypted data
		total,				// must be last and is not a real group
	};

	virtual const char* name() const = 0;													// get channel name
	virtual const char* address() const = 0;												// get channel ip address as string
	virtual float		time() const = 0;													// current net time
	virtual float		time_connected() const = 0;											// get connection time in seconds
	virtual int			buffer_size() const = 0;											// netchannel packet history size
	virtual int			data_rate() const = 0;												// send data rate in byte/sec
	virtual bool		is_loopback() const = 0;											// true if loopback channel
	virtual bool		is_timing_out() const = 0;											// true if timing out
	virtual bool		is_playback() const = 0;											// true if demo playback
	virtual float		latency(int flow) const = 0;										// current latency (rtt), more accurate but jittering
	virtual float		average_latency(int flow) const = 0;								// average packet latency in seconds
	virtual float		average_loss(int flow) const = 0;									// average packet loss[0..1]
	virtual float		average_choke(int flow) const = 0;									// average packet choke[0..1]
	virtual float		average_data(int flow) const = 0;									// data flow in bytes/sec
	virtual float		average_packets(int flow) const = 0;								// average packets/sec
	virtual int			total_data(int flow) const = 0;										// total flow in/out in bytes
	virtual int			total_packets(int flow) const = 0;
	virtual int			sequence(int flow) const = 0;										// last send seq number
	virtual bool		valid_packet(int flow, int frame) const = 0;						// true if packet was not lost/dropped/chocked/flushed
	virtual float		packet_time(int flow, int frame) const = 0;							// time when packet was send
	virtual int			packet_bytes(int flow, int frame, int group) const = 0;				// group size of this packet
	virtual bool		stream_progress(int flow, int* received, int* total) const = 0;		// tcp progress if transmitting
	virtual float		time_since_last_received() const = 0;								// get time since last received packet in seconds
	virtual	float		command_interpolation_amount(int flow, int frame) const = 0;
	virtual void		packet_response_latency(int flow, int frame_number, int* latency_secs, int* choke) const = 0;
	virtual void		remote_framerate(float* frame_time, float* frame_time_standard_deviation, float* frame_start_time_standard_deviation) const = 0;
	virtual float		timeout_seconds() const = 0;
};

class game_net_channel
{
public:
	std::byte	_pad0[0x14];			//0x0000
	bool		processing_messages;	//0x0014
	bool		should_delete;			//0x0015
	bool		stop_processing;		//0x0016
	std::byte	_pad1[0x1];				//0x0017
	int			out_sequence;			//0x0018 last send outgoing sequence number
	int			in_sequence;			//0x001c last received incoming sequence number
	int			out_sequence_ack;		//0x0020 last received acknowledge outgoing sequence number
	int			out_reliable_state;		//0x0024 state of outgoing reliable data (0/1) flip flop used for loss detection
	int			in_reliable_state;		//0x0028 state of incoming reliable data
	int			choked_packets;			//0x002c number of choked packets
	std::byte	_pad2[0x414];			//0x0030

	int		send_datagram(bf_write* datagram) { return virtuals->call<int>(this, 46, datagram); }
	bool	transmit(bool only_reliable = false) { return virtuals->call<bool>(this, 49, only_reliable); }
};

// reference: https://github.com/ValveSoftware/source-sdk-2013/blob/master/sp/src/public/inetmessage.h
class game_net_message
{
public:
	virtual						~game_net_message() { }
	virtual void				set_net_channel(void* net_channel) = 0;
	virtual void				set_reliable(bool state) = 0;
	virtual bool				process() = 0;
	virtual	bool				read_from_buffer(bf_read& buffer) = 0;
	virtual	bool				write_to_buffer(bf_write& buffer) = 0;
	virtual bool				is_reliable() const = 0;
	virtual int					message_type() const = 0;
	virtual int					message_group() const = 0;
	virtual const char*			message_name() const = 0;
	virtual game_net_channel*	net_channel() const = 0;
	virtual const char*			to_string() const = 0;
	virtual std::size_t			get_size() const = 0;
};

class clc_message_move
{
private:
	std::byte _pad0[0x8];
public:
	int backup_commands;
	int new_commands;
};

template <typename t>
class game_net_message_pb : public game_net_message, public t { };
using game_message_move = game_net_message_pb<clc_message_move>;

// reference: https://github.com/ValveSoftware/source-sdk-2013/blob/master/mp/src/public/inetmsghandler.h
class game_net_channel_handler
{
public:
	virtual			~game_net_channel_handler() { }
	virtual void	connection_start(game_net_channel* channel) = 0;											// called first time network channel is established
	virtual void	connection_stop() = 0;																		// called first time network channel is established
	virtual void	connection_closing(const char* reason) = 0;													// network channel is being closed by remote site
	virtual void	connection_crashed(const char* reason) = 0;													// network error occured
	virtual void	packet_start(int incoming_sequence, int outgoing_acknowledged) = 0;							// called each time a new packet arrived
	virtual void	packet_end() = 0;																			// all messages has been parsed
	virtual void	file_requested(const char* file_name, unsigned int transfer_id, bool replay_demo_file) = 0;	// other side request a file for download
	virtual void	file_received(const char* file_name, unsigned int transfer_id, bool replay_demo_file) = 0;	// we received a file
	virtual void	file_denied(const char* file_name, unsigned int transfer_id, bool replay_demo_file) = 0;	// a file request was denied by other side
	virtual void	file_sent(const char* file_name, unsigned int transfer_id, bool replay_demo_file) = 0;		// we sent a file
	virtual bool	change_split_screen_user(int split_screen_user_slot) = 0;									// interleaved networking used by ss system is changing the ss player slot that the subsequent messages pertain to
};
```

`sdk/valve/other/studio.h`:

```h
#pragma once
#include <cstddef>
#include <cstdint>

#pragma region studio flags

enum game_bone_index : int
{
	bone_invalid = -1,
	bone_pelvis,
	bone_lean_root,
	bone_cam_driver,
	bone_spine_0,
	bone_spine_1,
	bone_spine_2,
	bone_spine_3,
	bone_neck,
	bone_head,
	bone_clavicle_l,
	bone_arm_upper_l,
	bone_arm_lower_l,
	bone_hand_l,
	bone_finger_middle_meta_l,
	bone_finger_middle_0_l,
	bone_finger_middle_1_l,
	bone_finger_middle_2_l,
	bone_finger_pinky_meta_l,
	bone_finger_pinky_0_l,
	bone_finger_pinky_1_l,
	bone_finger_pinky_2_l,
	bone_finger_index_meta_l,
	bone_finger_index_0_l,
	bone_finger_index_1_l,
	bone_finger_index_2_l,
	bone_finger_thumb_0_l,
	bone_finger_thumb_1_l,
	bone_finger_thumb_2_l,
	bone_finger_ring_meta_l,
	bone_finger_ring_0_l,
	bone_finger_ring_1_l,
	bone_finger_ring_2_l,
	bone_weapon_hand_l,
	bone_arm_lower_l_twist,
	bone_arm_lower_l_twist1,
	bone_arm_upper_l_twist,
	bone_arm_upper_l_twist1,
	bone_clavicle_r,
	bone_arm_upper_r,
	bone_arm_lower_r,
	bone_hand_r,
	bone_finger_middle_meta_r,
	bone_finger_middle_0_r,
	bone_finger_middle_1_r,
	bone_finger_middle_2_r,
	bone_finger_pinky_meta_r,
	bone_finger_pinky_0_r,
	bone_finger_pinky_1_r,
	bone_finger_pinky_2_r,
	bone_finger_index_meta_r,
	bone_finger_index_0_r,
	bone_finger_index_1_r,
	bone_finger_index_2_r,
	bone_finger_thumb_0_r,
	bone_finger_thumb_1_r,
	bone_finger_thumb_2_r,
	bone_finger_ring_meta_r,
	bone_finger_ring_0_r,
	bone_finger_ring_1_r,
	bone_finger_ring_2_r,
	bone_weapon_hand_r,
	bone_arm_lower_r_twist,
	bone_arm_lower_r_twist1,
	bone_arm_upper_r_twist,
	bone_arm_upper_r_twist1,
	bone_leg_upper_l,
	bone_leg_lower_l,
	bone_ankle_l,
	bone_ball_l,
	bone_lfoot_lock,
	bone_leg_upper_l_twist,
	bone_leg_upper_l_twist1,
	bone_leg_upper_r,
	bone_leg_lower_r,
	bone_ankle_r,
	bone_ball_r,
	bone_rfoot_lock,
	bone_leg_upper_r_twist,
	bone_leg_upper_r_twist1,
	bone_finger_pinky_l_end,
	bone_finger_pinky_r_end,
	bone_valvebiped_weapon_bone,
	bone_lh_ik_driver,
	bone_primary_jiggle_jnt,
};

enum game_hitgroup : int
{
	hitgroup_generic = 0,
	hitgroup_head,
	hitgroup_chest,
	hitgroup_stomach,
	hitgroup_left_arm,
	hitgroup_right_arm,
	hitgroup_left_leg,
	hitgroup_right_leg,
	hitgroup_neck,
	hitgroup_gear = 10
};

enum game_hitbox : int
{
	hitbox_invalid = -1,
	hitbox_head,
	hitbox_neck,
	hitbox_pelvis,
	hitbox_stomach,
	hitbox_thorax,
	hitbox_chest,
	hitbox_upper_chest,
	hitbox_right_thigh,
	hitbox_left_thigh,
	hitbox_right_calf,
	hitbox_left_calf,
	hitbox_right_foot,
	hitbox_left_foot,
	hitbox_right_hand,
	hitbox_left_hand,
	hitbox_right_upper_arm,
	hitbox_right_fore_arm,
	hitbox_left_upper_arm,
	hitbox_left_fore_arm,
	hitbox_max
};

#pragma endregion

#pragma region studio definitions

#define max_studio_bone_ctrls		4
#define max_studio_pose_param		24
#define max_studio_skins			32		// total textures
#define max_studio_flex_ctrl		96		// maximum number of flexcontrollers (input sliders)
#define max_studio_bones			128		// total bones actually used
#define max_studio_anim_blocks		256
#define max_studio_flex_desc		1024	// maximum number of low level flexes (actual morph targets)

#define bone_calculate_mask			0x1f
#define bone_physically_simulated	0x01
#define bone_physics_procedural		0x02
#define bone_always_procedural		0x04
#define bone_screen_align_sphere	0x08
#define bone_screen_align_cylinder	0x10

#define bone_used_mask				0x0007ff00
#define bone_used_by_anything		0x0007ff00
#define bone_used_by_hitbox			0x00000100
#define bone_used_by_attachment		0x00000200
#define bone_used_by_vertex_mask	0x0003fc00
#define bone_used_by_vertex_lod0	0x00000400
#define bone_used_by_vertex_lod1	0x00000800
#define bone_used_by_vertex_lod2	0x00001000
#define bone_used_by_vertex_lod3	0x00002000
#define bone_used_by_vertex_lod4	0x00004000
#define bone_used_by_vertex_lod5	0x00008000
#define bone_used_by_vertex_lod6	0x00010000
#define bone_used_by_vertex_lod7	0x00020000
#define bone_used_by_bone_merge		0x00040000
#define bone_always_setup			0x00080000

#define bone_used_by_vertex_at_lod( lod ) ( bone_used_by_vertex_lod0 << ( lod ) )
#define bone_used_by_anything_at_lod( lod ) ( ( bone_used_by_anything & ~bone_used_by_vertex_mask ) | bone_used_by_vertex_at_lod( lod ) )

#define max_lods_count				8

#define bone_type_mask				0x00f00000
#define bone_fixed_alignment		0x00100000
#define bone_has_save_frame_pos		0x00200000
#define bone_has_save_frame_rot64	0x00400000
#define bone_has_save_frame_rot32	0x00800000

#pragma endregion

struct game_studio_bone
{
	int			name_index;
	int			parent;
	std::byte	_pad0[0x98];
	int			flags;
	std::byte	_pad1[0x34];

	const char* name() const noexcept { return name_index ? reinterpret_cast<const char*>(std::uintptr_t(this) + name_index) : nullptr; }
};

struct game_studio_bounding_box
{
	int			bone;
	int			group;					// intersection group
	vector_3d	mins;					// bounding box
	vector_3d	maxs;
	int			hitbox_name_index;		// offset to the name of the hitbox
	q_angle		offset_orientation;
	float		radius;
	int			unused[4];
};

struct game_studio_hitbox_set
{
	int name_index;
	int hitbox_count;
	int hitbox_index;

	const char* name() const noexcept { return reinterpret_cast<char*>(std::uintptr_t(this) + name_index); }

	game_studio_bounding_box* hitbox(int index) noexcept
	{
		if (index < 0 || index >= hitbox_count) return nullptr;
		return reinterpret_cast<game_studio_bounding_box*>(reinterpret_cast<std::uint8_t*>(this) + hitbox_index) + index;
	}
};

class game_studio_hdr
{
public:
	int			id;
	int			version;
	int			checksum;
	char		name[64];
	int			length;

	vector_3d	eye_position;
	vector_3d	illum_position;
	vector_3d	hull_min;
	vector_3d	hull_max;
	vector_3d	mins;
	vector_3d	maxs;

	int			flags;
	int			bone_count;
	int			bone_index;
	int			bone_controller_count;
	int			bone_controller_index;
	int			hitbox_set_count;
	int			hitbox_set_index;

public:
	game_studio_bone* bone(int index) noexcept
	{
		if (index < 0 || index >= bone_count) return nullptr;
		return reinterpret_cast<game_studio_bone*>(std::uintptr_t(this) + bone_index) + index;
	}

	game_studio_hitbox_set* hitbox_set(int index) noexcept
	{
		if (index < 0 || index >= hitbox_set_count) return nullptr;
		return reinterpret_cast<game_studio_hitbox_set*>(std::uintptr_t(this) + hitbox_set_index) + index;
	}
};
```

`sdk/valve/other/weapon_info.h`:

```h
#pragma once
#include <cstddef>
#include <cstdint>

#pragma region weapon entity flags

enum item_definition_index : short
{
	weapon_none									= 0,
	weapon_deagle								= 1,
	weapon_elite								= 2,
	weapon_fiveseven							= 3,
	weapon_glock								= 4,
	weapon_ak47									= 7,
	weapon_aug									= 8,
	weapon_awp									= 9,
	weapon_famas								= 10,
	weapon_g3sg1								= 11,
	weapon_galilar								= 13,
	weapon_m249									= 14,
	weapon_m4a1									= 16,
	weapon_mac10								= 17,
	weapon_p90									= 19,
	weapon_zone_repulsor						= 20,
	weapon_mp5sd								= 23,
	weapon_ump45								= 24,
	weapon_xm1014								= 25,
	weapon_bizon								= 26,
	weapon_mag7									= 27,
	weapon_negev								= 28,
	weapon_sawedoff								= 29,
	weapon_tec9									= 30,
	weapon_taser								= 31,
	weapon_hkp2000								= 32,
	weapon_mp7									= 33,
	weapon_mp9									= 34,
	weapon_nova									= 35,
	weapon_p250									= 36,
	weapon_shield								= 37,
	weapon_scar20								= 38,
	weapon_sg556								= 39,
	weapon_ssg08								= 40,
	weapon_knife_gg								= 41,
	weapon_knife								= 42,
	weapon_flashbang							= 43,
	weapon_he_grenade							= 44,
	weapon_smoke_grenade						= 45,
	weapon_molotov								= 46,
	weapon_decoy								= 47,
	weapon_incgrenade							= 48,
	weapon_c4									= 49,
	weapon_healthshot							= 57,
	weapon_knife_t								= 59,
	weapon_m4a1_silencer						= 60,
	weapon_usp_silencer							= 61,
	weapon_cz75a								= 63,
	weapon_revolver								= 64,
	weapon_tagrenade							= 68,
	weapon_fists								= 69,
	weapon_breach_charge						= 70,
	weapon_tablet								= 72,
	weapon_melee								= 74,
	weapon_axe									= 75,
	weapon_hammer								= 76,
	weapon_spanner								= 78,
	weapon_knife_ghost							= 80,
	weapon_fire_bomb							= 81,
	weapon_diversion							= 82,
	weapon_frag_grenade							= 83,
	weapon_snowball								= 84,
	weapon_bump_mine							= 85,
	weapon_knife_bayonet						= 500,
	weapon_knife_css							= 503,
	weapon_knife_flip							= 505,
	weapon_knife_gut							= 506,
	weapon_knife_karambit						= 507,
	weapon_knife_m9_bayonet						= 508,
	weapon_knife_tactical						= 509,
	weapon_knife_falchion						= 512,
	weapon_knife_survival_bowie					= 514,
	weapon_knife_butterfly						= 515,
	weapon_knife_push							= 516,
	weapon_knife_cord							= 517,
	weapon_knife_canis							= 518,
	weapon_knife_ursus							= 519,
	weapon_knife_gypsy_jack_knife				= 520,
	weapon_knife_outdoor						= 521,
	weapon_knife_stiletto						= 522,
	weapon_knife_widowmaker						= 523,
	weapon_knife_skeleton						= 525,
	glove_studded_broken_fang					= 4725,
	glove_studded_bloodhound					= 5027,
	glove_t										= 5028,
	glove_ct									= 5029,
	glove_sporty								= 5030,
	glove_slick									= 5031,
	glove_leather_handwraps						= 5032,
	glove_motorcycle							= 5033,
	glove_specialist							= 5034,
	glove_studded_hydra							= 5035,
	special_agent_blueberries_buckshot			= 4619,
	special_agent_two_times_mccoy_tacp			= 4680,
	special_agent_commandor_mae_jamison			= 4711,
	special_agent_1st_lieutenant_farlow,
	special_agent_john_kask,
	special_agent_bio_haz_specialist,
	special_agent_sergeant_bombson,
	special_agent_chem_haz_specialist,
	special_agent_rezan_the_redshirt			= 4718,
	special_agent_sir_bloody_miami_darryl		= 4726,
	special_agent_safecracker_voltzmann,
	special_agent_little_kev,
	special_agent_getaway_sally					= 4730,
	special_agent_number_k						= 4732,
	special_agent_sir_bloody_silent_darryl		= 4733,
	special_agent_sir_bloody_skullhead_darryl,
	special_agent_sir_bloody_darryl_royale,
	special_agent_sir_bloody_loudmouth_darryl,
	special_agent_t								= 5036,
	special_agent_ct							= 5037,
	special_agent_ground_rebel					= 5105,
	special_agent_osiris,
	special_agent_shahmat,
	special_agent_muhlik,
	special_agent_soldier						= 5205,
	special_agent_enforcer,
	special_agent_slingshot,
	special_agent_street_soldier,
	special_agent_operator						= 5305,
	special_agent_markus_delrow,
	special_agent_michael_syfers,
	special_agent_ava,
	special_agent_3rd_commando_company			= 5400,
	special_agent_seal_team_6_soldier,
	special_agent_buckshot,
	special_agent_two_times_mccoy_usaf,
	special_agent_ricksaw,
	special_agent_dragomir						= 5500,
	special_agent_maximus,
	special_agent_rezan_the_ready,
	special_agent_blackwolf						= 5503,
	special_agent_the_doctor,
	special_agent_dragomir_foot_soldiers,
	special_agent_b_squadron_officer			= 5601
};

enum weapon_type : int
{
	weapon_type_knife			= 0,
	weapon_type_pistol			= 1,
	weapon_type_smg				= 2,
	weapon_type_rifle			= 3,
	weapon_type_shotgun			= 4,
	weapon_type_sniper			= 5,
	weapon_type_heavy			= 6,
	weapon_type_c4				= 7,
	weapon_type_place_holder	= 8,
	weapon_type_grenade			= 9,
	weapon_type_healthshot		= 11,
	weapon_type_fists			= 12,
	weapon_type_breach_charge	= 13,
	weapon_type_bump_mine		= 14,
	weapon_type_tablet			= 15,
	weapon_type_melee			= 16
};

#pragma endregion

class game_weapon_info
{
public:
	std::byte		_pad0[0x14];					// 0x0000
	int				max_clip1;						// 0x0014
	int				max_clip2;						// 0x0018
	int				default_clip1;					// 0x001c
	int				default_clip2;					// 0x0020
	int				primary_max_reserve_ammo;		// 0x0024
	int				secondary_max_reserve_ammo;		// 0x0028
	const char*		world_model;					// 0x002c
	const char*		view_model;						// 0x0030
	const char*		dropped_model;					// 0x0034
	std::byte		_pad1[0x50];					// 0x0038
	const char*		hud_name;						// 0x0088
	const char*		weapon_name;					// 0x008c
	std::byte		_pad2[0x2];						// 0x0090
	bool			is_melee_weapon;				// 0x0092
	std::byte		_pad3[0x9];						// 0x0093
	float			weapon_weight;					// 0x009c
	std::byte		_pad4[0x4];						// 0x00a0
	int				slot;							// 0x00a4
	int				position;						// 0x00a8
	std::byte		_pad5[0x1c];					// 0x00ac
	int				weapon_type;					// 0x00c8
	std::byte		_pad6[0x4];						// 0x00cc
	int				weapon_price;					// 0x00d0
	int				kill_award;						// 0x00d4
	const char*		animation_prefix;				// 0x00d8
	float			cycle_time;						// 0x00dc
	float			cycle_time_alt;					// 0x00e0
	std::byte		_pad8[0x8];						// 0x00e4
	bool			full_auto;						// 0x00ec
	std::byte		_pad9[0x3];						// 0x00ed
	int				damage;							// 0x00f0
	float			headshot_multiplier;			// 0x00f4
	float			armor_ratio;					// 0x00f8
	int				bullets;						// 0x00fc
	float			penetration;					// 0x0100
	std::byte		_pad10[0x8];					// 0x0104
	float			range;							// 0x010c
	float			range_modifier;					// 0x0110
	float			throw_velocity;					// 0x0114
	std::byte		_pad11[0xc];					// 0x0118
	bool			has_silencer;					// 0x0124
	std::byte		_pad12[0xf];					// 0x0125
	float			max_speed[2];					// 0x0134
	std::byte		_pad13[0x4];					// 0x013c
	float			spread[2];						// 0x0140
	float			inaccuracy_crouch[2];			// 0x0148
	float			inaccuracy_stand[2];			// 0x0150
	std::byte		_pad14[0x8];					// 0x0158
	float			inaccuracy_jump[2];				// 0x0160
	float			inaccuracy_land[2];				// 0x0168
	float			inaccuracy_ladder[2];			// 0x0170
	float			inaccuracy_fire[2];				// 0x0178
	float			inaccuracy_move[2];				// 0x0180
	float			inaccuracy_reload;				// 0x0188
	int				recoil_seed;					// 0x018c
	float			recoil_angle[2];				// 0x0190
	float			recoil_angle_variance[2];		// 0x0198
	float			recoil_magnitude[2];			// 0x01a0
	float			recoil_magnitude_variance[2];	// 0x01a8
	int				spread_seed;					// 0x01b0
};
```

`sdk/valve/valve.h`:

```h
#pragma once
#include "../dependencies/dependency.h"
#include "interface/interface.h"
#include "netvar/netvar.h"

#pragma region maths

#include "maths/utl_vector.h"
#include "maths/vector.h"
#include "maths/q_angle.h"
#include "maths/matrix.h"
#include "maths/other.h"

#pragma endregion

#include "entity/entity.h"
```