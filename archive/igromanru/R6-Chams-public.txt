Project Path: arc_igromanru_R6-Chams-public_hzmnnq5d

Source Tree:

```txt
arc_igromanru_R6-Chams-public_hzmnnq5d
├── FindPattern
├── R6-Chams-public.sln
├── R6-Chams-public.vcxproj
├── R6-Chams-public.vcxproj.filters
├── R6-Chams-public.vcxproj.user
├── README.md
├── minhook
├── pictures
│   ├── half_visible.jpg
│   ├── invisible.jpg
│   └── visible.jpg
└── src
    ├── Hook.cpp
    ├── Hook.hpp
    ├── Models.hpp
    ├── RGBA.hpp
    └── dllmain.cpp

```

`R6-Chams-public.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.10.34928.147
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "R6-Chams-public", "R6-Chams-public.vcxproj", "{19D314AD-151F-485B-8764-643067156AB6}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{19D314AD-151F-485B-8764-643067156AB6}.Debug|x64.ActiveCfg = Debug|x64
		{19D314AD-151F-485B-8764-643067156AB6}.Debug|x64.Build.0 = Debug|x64
		{19D314AD-151F-485B-8764-643067156AB6}.Release|x64.ActiveCfg = Release|x64
		{19D314AD-151F-485B-8764-643067156AB6}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {6D376835-6050-4AC6-B37D-C09BF49C947F}
	EndGlobalSection
EndGlobal

```

`R6-Chams-public.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{19d314ad-151f-485b-8764-643067156ab6}</ProjectGuid>
    <RootNamespace>R6Chamspublic</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>$(ProjectDir)bin\$(PlatformTarget)\$(Configuration)\</OutDir>
    <IntDir>$(ProjectDir)bin\intermediates\$(Platform)\$(Configuration)\</IntDir>
    <SourcePath>$(ProjectDir)minhook\src;$(SourcePath)</SourcePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>$(ProjectDir)bin\$(PlatformTarget)\$(Configuration)\</OutDir>
    <IntDir>$(ProjectDir)bin\intermediates\$(Platform)\$(Configuration)\</IntDir>
    <SourcePath>$(ProjectDir)minhook\src;$(SourcePath)</SourcePath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;R6CHAMSPUBLIC_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;R6CHAMSPUBLIC_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;_DEBUG;R6CHAMSPUBLIC_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>
      </PrecompiledHeaderFile>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <AdditionalIncludeDirectories>.;src;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <ObjectFileName>$(IntDir)/%(RelativeDir)/</ObjectFileName>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
      <AdditionalDependencies>d3d11.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;NDEBUG;R6CHAMSPUBLIC_EXPORTS;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <PrecompiledHeaderFile>
      </PrecompiledHeaderFile>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <AdditionalIncludeDirectories>.;src;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <ObjectFileName>$(IntDir)/%(RelativeDir)/</ObjectFileName>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableUAC>false</EnableUAC>
      <AdditionalDependencies>d3d11.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="minhook\src\buffer.c" />
    <ClCompile Include="minhook\src\hde\hde32.c" />
    <ClCompile Include="minhook\src\hde\hde64.c" />
    <ClCompile Include="minhook\src\hook.c" />
    <ClCompile Include="minhook\src\trampoline.c" />
    <ClCompile Include="src\dllmain.cpp" />
    <ClCompile Include="src\Hook.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="FindPattern\FindPattern.h" />
    <ClInclude Include="minhook\include\MinHook.h" />
    <ClInclude Include="minhook\src\buffer.h" />
    <ClInclude Include="minhook\src\hde\hde32.h" />
    <ClInclude Include="minhook\src\hde\hde64.h" />
    <ClInclude Include="minhook\src\hde\pstdint.h" />
    <ClInclude Include="minhook\src\hde\table32.h" />
    <ClInclude Include="minhook\src\hde\table64.h" />
    <ClInclude Include="minhook\src\trampoline.h" />
    <ClInclude Include="src\Hook.hpp" />
    <ClInclude Include="src\Models.hpp" />
    <ClInclude Include="src\RGBA.hpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`R6-Chams-public.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="src\dllmain.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="minhook\src\buffer.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="minhook\src\hook.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="minhook\src\trampoline.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="minhook\src\hde\hde32.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="minhook\src\hde\hde64.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="src\Hook.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="minhook\include\MinHook.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="minhook\src\trampoline.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="minhook\src\buffer.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="minhook\src\hde\hde32.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="minhook\src\hde\hde64.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="minhook\src\hde\pstdint.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="minhook\src\hde\table32.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="minhook\src\hde\table64.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\Hook.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\Models.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="src\RGBA.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="FindPattern\FindPattern.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`R6-Chams-public.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>true</ShowAllFiles>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LocalDebuggerCommand>
    </LocalDebuggerCommand>
    <LocalDebuggerCommandArguments>
    </LocalDebuggerCommandArguments>
    <LocalDebuggerWorkingDirectory>
    </LocalDebuggerWorkingDirectory>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LocalDebuggerCommand>
    </LocalDebuggerCommand>
    <LocalDebuggerCommandArguments>
    </LocalDebuggerCommandArguments>
    <LocalDebuggerWorkingDirectory>
    </LocalDebuggerWorkingDirectory>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
</Project>
```

`README.md`:

```md
# R6 Chams - Public source by Igromanru

# Outdated
In 2025 Rainbow Six Siege removed DirectX 11 support, making this project obsolete.  
However, the method to make chams remains the same for games that still support/use DirectX 11.  

## How to use without BattlEye 
1. Use latest Visual Studio to compile the source code into a DLL
2. Open Ubisoft Connect->Library->"..."->Properties
3. Under "Add launch arguments" add `/Belaunch -be` and press **Save** 
4. Start tha game normally (NOT the Vulkan version)
5. Use any injector to inject **R6-Chams-public.dll** into the process `RainbowSix_DX11.exe`

The *Debug* build should definitely be only used without BE and it will provide useful information if something doesn't work.

## Disclaimer
This source code is intended for educational purposes only, to demonstration how Chameleon Models with a "visual check" can be achieved with a more or less clean code.  
I don't use this code while AntiCheat is running and can't guarantee that your account will not be penalized if you use it.    
Use it at your own risk!  

## Possible detection vectors
- WinApi calls
- Detour hook
- Thread creation
  
<sub>That said, my code doesn't do anything what would be more risky than other public sources. If you have a way to use other public Chams without getting banned, my chams are as safe as them.  
However, I still recommend to make your own project and to avoid as many detection vectors as possible</sub>

## Demo
![visible](/pictures/visible.jpg)
![half_visible](/pictures/half_visible.jpg)
![invisible](/pictures/invisible.jpg)
```

`src/Hook.cpp`:

```cpp
/*
 *  R6 Chams by Igromanru
 *  Copyright (C) 2024 Igromanru
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 *  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 *  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
 *  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#include "Hook.hpp"

#ifdef _DEBUG
    #include <cstdio>
    #define DEBUG_PRINT(format, ...) printf(format, __VA_ARGS__)
#else
    #define DEBUG_PRINT(format, ...) (void)0
#endif

#include "minhook/include/MinHook.h"
#include "FindPattern/FindPattern.h"
#include "Models.hpp"

namespace Hook
{
    constexpr void SafeRelease(IUnknown* dxObject)
    {
        if (dxObject)
        {
            dxObject->Release();
            dxObject = nullptr;
        }
    }

    constexpr void SafeReleaseSRVs(ID3D11ShaderResourceView* SRVs[])
    {
        for (int i = 0; i < D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT; i++)
        {
            if (SRVs[i] == nullptr)
            {
                break;
            }
            SafeRelease(SRVs[i]);
        }
    }

    constexpr int CountSRVs(ID3D11ShaderResourceView* SRVs[])
    {
        auto i = 0;
        for (;i < D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT; i++)
        {
            if (!SRVs[i])
            {
                break;
            }
        }
        return i;
    }

    DWORD WINAPI Init()
    {
        auto mhStatus = MH_Initialize();
        if (mhStatus != MH_OK)
        {
            DEBUG_PRINT("Error: Failed to initialize MinHook! Status: %d\n", mhStatus);
            return false;
        }

        // const auto gameHandle = GetCurrentProcess();
        // if (!gameHandle)
        // {
        //     DEBUG_PRINT("Error: Failed to get game module handle. LastError: %lu\n", GetLastError());
        //     return false;
        // }
        // DEBUG_PRINT("Game module handle: %p\n", reinterpret_cast<void*>(gameHandle));

        const auto moduleHandle = reinterpret_cast<uintptr_t>(GetModuleHandleW(L"d3d11.dll"));
        if (!moduleHandle)
        {
            DEBUG_PRINT("Error: Failed to get d3d11.dll module handle. LastError: %lu\n", GetLastError());
            return false;
        }
        DEBUG_PRINT("d3d11.dll module handle: %p\n", reinterpret_cast<void*>(moduleHandle));

        // MODULEINFO info;
        // ZeroMemory(&info, sizeof(info));
        // if (!GetModuleInformation(gameHandle, moduleHandle, &info, sizeof(MODULEINFO)))
        // {
        //     DEBUG_PRINT("Error: Failed to get module information. LastError: %lu\n", GetLastError());
        //     return false;
        // }
        // DEBUG_PRINT("d3d11.dll module size: %lu\n", info.SizeOfImage);

        const auto searchStart = moduleHandle + 0x100000;
        // const auto searchLength = static_cast<size_t>(moduleHandle + info.SizeOfImage - searchStart - 0x1000);
        const auto searchLength = moduleHandle + 0x200000 - searchStart;
        auto functionAddress = reinterpret_cast<LPVOID>(IgroWidgets::FindPattern(searchStart, searchLength,
            reinterpret_cast<const uint8_t*>("\x48\x89\x5C\x24\x08\x48\x89\x74\x24\x10\x57\x48\x83\xEC\x00\x41\x8B\xF0\x48\x8B\xDA\x48\x8D\xB9\x00\x00\x00\xFF\x48\x8B\xCF\xE8\x00\x00\x00\x00\x84\xC0\x74\x00\x48\x85\xDB\x74\x00\x8B\x8B\x00\x00\x00\x00\x8B\x93"),
            "xxxxxxxxxxxxxx?xxxxxxxxx???xxxxx????xxx?xxxx?xx????xx"));
        if (!functionAddress)
        {
            DEBUG_PRINT("Couldn't find DrawIndexedInstancedIndirect with Windows 11 pattern, trying with Windows 10...\n");
            functionAddress = reinterpret_cast<LPVOID>(IgroWidgets::FindPattern(searchStart, searchLength,
                reinterpret_cast<const uint8_t*>("\x48\x83\xEC\x00\x4C\x8B\xD1\x48\x85\xD2\x74\x00\x8B\x82"),
                "xxx?xxxxxxx?xx"));
        }

        DrawIndexedInstancedIndirectAddress = functionAddress;
        if (!DrawIndexedInstancedIndirectAddress)
        {
            DEBUG_PRINT("Error: Couldn't find DrawIndexedInstancedIndirect function!\n");
            return false;
        }
        DEBUG_PRINT("Found DrawIndexedInstancedIndirect function at: %p\n", DrawIndexedInstancedIndirectAddress);

        mhStatus = MH_CreateHook(DrawIndexedInstancedIndirectAddress, DetourDrawIndexedInstancedIndirect, reinterpret_cast<LPVOID*>(&OriginalDrawIndexedInstancedIndirect));
        if (mhStatus != MH_OK)
        {
            DEBUG_PRINT("Error: Failed MH_CreateHook for DrawIndexedInstancedIndirect! Status: %d\n", mhStatus);
            return false;
        }

        mhStatus = MH_EnableHook(DrawIndexedInstancedIndirectAddress);
        if (mhStatus != MH_OK)
        {
            DEBUG_PRINT("Error: Failed MH_EnableHook for DrawIndexedInstancedIndirect! Status: %d\n", mhStatus);
            return false;
        }

        DEBUG_PRINT("DrawIndexedInstancedIndirect hook enabled\n");
        return true;
    }

    void Unload()
    {
        if (DrawIndexedInstancedIndirectAddress)
        {
            MH_DisableHook(DrawIndexedInstancedIndirectAddress);
        }

        SafeRelease(wallHackDSS);

        SafeRelease(redSRV);
        SafeRelease(greenSRV);
    }

    void CreateColorSRV(ID3D11Device* device, const RGBA& color, ID3D11ShaderResourceView** shaderResourceView)
    {
        if (device && shaderResourceView)
        {
            D3D11_SUBRESOURCE_DATA initData;
            initData.pSysMem = &color;
            initData.SysMemPitch = sizeof(color);
            initData.SysMemSlicePitch = 0;

            ID3D11Texture2D* texture = nullptr;
            D3D11_TEXTURE2D_DESC desc;
            ZeroMemory(&desc, sizeof(desc));
            desc.Width = 1;
            desc.Height = 1;
            desc.MipLevels = 1;
            desc.ArraySize = 1;
            desc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
            desc.SampleDesc.Count = 1;
            desc.Usage = D3D11_USAGE_DEFAULT;
            desc.BindFlags = D3D11_BIND_SHADER_RESOURCE;
            device->CreateTexture2D(&desc, &initData, &texture);

            if (texture)
            {
                D3D11_SHADER_RESOURCE_VIEW_DESC SRVDesc;
                ZeroMemory(&SRVDesc, sizeof(SRVDesc));
                SRVDesc.Format = desc.Format;
                SRVDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;
                SRVDesc.Texture2D.MipLevels = 1;
                device->CreateShaderResourceView(texture, &SRVDesc, shaderResourceView);
                SafeRelease(texture);
            }
        }
    }

    void CreateColorSRVs(ID3D11Device* device)
    {
        if (device && !greenSRV && !redSRV)
        {
            const RGBA red(255, 0, 0);
            const RGBA green(0, 255, 0);

            CreateColorSRV(device, red, &redSRV);
            CreateColorSRV(device, green, &greenSRV);
        }
    }

    void CreateDepthStencilStates(ID3D11Device* device)
    {
        if (device && !wallHackDSS)
        {
            D3D11_DEPTH_STENCIL_DESC depthStencilDesc;
            depthStencilDesc.DepthEnable = FALSE;
            depthStencilDesc.DepthWriteMask = D3D11_DEPTH_WRITE_MASK_ALL;
            depthStencilDesc.DepthFunc = D3D11_COMPARISON_GREATER_EQUAL;
            depthStencilDesc.StencilEnable = FALSE;
            depthStencilDesc.StencilReadMask = D3D11_DEFAULT_STENCIL_READ_MASK;
            depthStencilDesc.StencilWriteMask = D3D11_DEFAULT_STENCIL_WRITE_MASK;
            // Stencil operations if pixel is front-facing
            depthStencilDesc.FrontFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
            depthStencilDesc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_KEEP;
            depthStencilDesc.FrontFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
            depthStencilDesc.FrontFace.StencilFunc = D3D11_COMPARISON_ALWAYS;
            // Stencil operations if pixel is back-facing
            depthStencilDesc.BackFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
            depthStencilDesc.BackFace.StencilDepthFailOp = D3D11_STENCIL_OP_KEEP;
            depthStencilDesc.BackFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
            depthStencilDesc.BackFace.StencilFunc = D3D11_COMPARISON_ALWAYS;
            device->CreateDepthStencilState(&depthStencilDesc, &wallHackDSS);
        }
    }

    bool DrawChams(ID3D11DeviceContext* pContext, ID3D11Buffer* pBufferForArgs, UINT AlignedByteOffsetForArgs, ID3D11ShaderResourceView* SRVs[], ID3D11ShaderResourceView* srvWhenInvisible, ID3D11ShaderResourceView* srvWhenVisible)
    {
        if (pContext && pBufferForArgs && SRVs)
        {
            const auto srvCount = CountSRVs(SRVs);
            if (srvWhenInvisible)
            {
                ID3D11DepthStencilState* originalDSS = nullptr;
                UINT originalStencilRef = 0;
                pContext->OMGetDepthStencilState(&originalDSS, &originalStencilRef);

                for (auto i = 0; i < srvCount; i++)
                {
                    pContext->PSSetShaderResources(i, 1, &srvWhenInvisible);
                }
                pContext->OMSetDepthStencilState(wallHackDSS, originalStencilRef);
                OriginalDrawIndexedInstancedIndirect(pContext, pBufferForArgs, AlignedByteOffsetForArgs);
                
                pContext->OMSetDepthStencilState(originalDSS, originalStencilRef);
                SafeRelease(originalDSS);
            }

            if (srvWhenVisible)
            {
                for (auto i = 0; i < srvCount; i++)
                {
                    pContext->PSSetShaderResources(i, 1, &srvWhenVisible);
                }
                OriginalDrawIndexedInstancedIndirect(pContext, pBufferForArgs, AlignedByteOffsetForArgs);
                return true;
            }
        }

        return false;
    }

    void __stdcall DetourDrawIndexedInstancedIndirect(ID3D11DeviceContext* pContext, ID3D11Buffer* pBufferForArgs, UINT AlignedByteOffsetForArgs)
    {
#ifdef _DEBUG
        static auto printOnce = true;
        if (printOnce)
        {
            DEBUG_PRINT("DetourDrawIndexedInstancedIndirect was called, confirmation that the right function was hooked\n");
            printOnce = false;
        }
#endif

        ID3D11Device* device;
        pContext->GetDevice(&device);
        if (!device)
        {
            return OriginalDrawIndexedInstancedIndirect(pContext, pBufferForArgs, AlignedByteOffsetForArgs);
        }

        CreateColorSRVs(device);
        CreateDepthStencilStates(device);

        ID3D11Buffer* veBuffer = nullptr;
        UINT Stride;
        UINT veBufferOffset;
        pContext->IAGetVertexBuffers(0, 1, &veBuffer, &Stride, &veBufferOffset);
        SafeRelease(veBuffer);

        ID3D11Buffer* pscBuffer = nullptr;
        D3D11_BUFFER_DESC pscDesc;
        UINT pscWidth = 0;
        pContext->PSGetConstantBuffers(0, 1, &pscBuffer);
        if (pscBuffer)
        {
            pscBuffer->GetDesc(&pscDesc);
            pscWidth = pscDesc.ByteWidth;
            SafeRelease(pscBuffer);
        }

        ID3D11Buffer* vscBuffer = nullptr;
        D3D11_BUFFER_DESC vscDesc;
        UINT vscWidth = 0;
        pContext->VSGetConstantBuffers(0, 1, &vscBuffer);
        if (vscBuffer)
        {
            vscBuffer->GetDesc(&vscDesc);
            vscWidth = vscDesc.ByteWidth;
            SafeRelease(vscBuffer);
        }

        const auto compVscWidth = vscWidth / 10;
        const auto compPscWidth = pscWidth / 10;

        ID3D11ShaderResourceView* originalSRVs[D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT];
        ZeroMemory(originalSRVs, sizeof(originalSRVs));
        pContext->PSGetShaderResources(0, D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT, originalSRVs);

        if (Models::Body1.IsModel(Stride, compVscWidth, compPscWidth, originalSRVs)
            || Models::Body2.IsModel(Stride, compVscWidth, compPscWidth, originalSRVs)
            || Models::Skin1.IsModel(Stride, compVscWidth, compPscWidth, originalSRVs)
            || Models::Skin2.IsModel(Stride, compVscWidth, compPscWidth, originalSRVs)
            )
        {
            if (DrawChams(pContext, pBufferForArgs, AlignedByteOffsetForArgs, originalSRVs, redSRV, greenSRV))
            {
                SafeReleaseSRVs(originalSRVs);
                return;
            }
        }
        else if (Models::DroneWorldOverlay.IsModel(Stride, compVscWidth, compPscWidth, originalSRVs)
            || Models::WorldOverlay1.IsModel(Stride, compVscWidth, compPscWidth, originalSRVs)
            || Models::WorldOverlay2.IsModel(Stride, compVscWidth, compPscWidth, originalSRVs)
            || Models::WorldOverlay3.IsModel(Stride, compVscWidth, compPscWidth, originalSRVs)
            || (Models::WorldOverlay4.IsModel(Stride, compVscWidth, compPscWidth, originalSRVs) && !Models::Scope.IsModel(Stride, compVscWidth, compPscWidth, originalSRVs))
            )
        {
            SafeReleaseSRVs(originalSRVs);
            return;
        }

        SafeReleaseSRVs(originalSRVs);
        OriginalDrawIndexedInstancedIndirect(pContext, pBufferForArgs, AlignedByteOffsetForArgs);
    }
}

```

`src/Hook.hpp`:

```hpp
/*
 *  R6 Chams by Igromanru
 *  Copyright (C) 2024 Igromanru
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 *  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 *  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
 *  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#pragma once

#include <d3d11.h>
#include "RGBA.hpp"

typedef void(__stdcall* D3D11DrawIndexedInstancedIndirect) (ID3D11DeviceContext* pContext, ID3D11Buffer* pBufferForArgs, UINT AlignedByteOffsetForArgs);

namespace Hook
{
    inline D3D11DrawIndexedInstancedIndirect OriginalDrawIndexedInstancedIndirect = nullptr;
    inline LPVOID DrawIndexedInstancedIndirectAddress = nullptr;

    inline ID3D11DepthStencilState* wallHackDSS = nullptr;

    inline ID3D11ShaderResourceView* redSRV = nullptr;
    inline ID3D11ShaderResourceView* greenSRV = nullptr;

    DWORD WINAPI Init();
    void Unload();

    void CreateColorSRV(ID3D11Device* device, const RGBA& color, ID3D11ShaderResourceView** shaderResourceView);
    void CreateColorSRVs(ID3D11Device* device);

    void CreateDepthStencilStates(ID3D11Device* device);

    bool DrawChams(ID3D11DeviceContext* pContext, ID3D11Buffer* pBufferForArgs, UINT AlignedByteOffsetForArgs, ID3D11ShaderResourceView* SRVs[],
        ID3D11ShaderResourceView* srvWhenInvisible, ID3D11ShaderResourceView* srvWhenVisible);

    void __stdcall DetourDrawIndexedInstancedIndirect(ID3D11DeviceContext* pContext, ID3D11Buffer* pBufferForArgs, UINT AlignedByteOffsetForArgs);
}

```

`src/Models.hpp`:

```hpp
/*
 *  R6 Chams by Igromanru
 *  Copyright (C) 2024 Igromanru
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 *  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 *  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
 *  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#pragma once

#include <d3d11.h>

#pragma warning(disable:4267)

namespace Models
{
    constexpr bool MatchSRVFormat(ID3D11ShaderResourceView* srv, int targetFormat)
    {
        if (srv)
        {
            if (targetFormat > -1)
            {
                D3D11_SHADER_RESOURCE_VIEW_DESC desc;
                srv->GetDesc(&desc);
                return desc.Format == targetFormat;
            }
            return true;
        }
        return false;
    }

    class Model
    {
    public:
        int Stride;
        int VscWidth;
        int PscWidth;
        int SrvFormat;
        int SrvIndex;
        bool SrvFormatNotEqual;

        Model(int stride, int vscWidth, int pscWidth, int psSrvFormat = -1, int srvIndex = -1, bool srvFormatNotEqual = false)
            : Stride(stride), VscWidth(vscWidth), PscWidth(pscWidth), SrvFormat(psSrvFormat), SrvIndex(srvIndex), SrvFormatNotEqual(srvFormatNotEqual)
        {
        }

        bool IsModel(UINT stride, UINT vscWidth, UINT pscWidth, ID3D11ShaderResourceView* SRVs[D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT]) const
        {
            auto result = (Stride < 0 || stride == static_cast<unsigned>(Stride)) && (VscWidth < 0 || vscWidth == static_cast<unsigned>(VscWidth)) && (PscWidth < 0 || pscWidth == static_cast<unsigned>(PscWidth));
            if (result)
            {
                if (SRVs && (SrvIndex >= 0 || SrvFormat >= 0))
                {
                    if (SrvIndex < 0)
                    {
                        result = !SrvFormatNotEqual;
                        for (auto i = 0; i < D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT; i++)
                        {
                            if (!SRVs[i])
                            {
                                result = SrvFormatNotEqual;
                                break;
                            }

                            if (MatchSRVFormat(SRVs[i], SrvFormat))
                            {
                                result = true;
                                break;
                            }
                        }
                    }
                    else
                    {
                        result = SrvIndex < D3D11_COMMONSHADER_INPUT_RESOURCE_SLOT_COUNT
                            && MatchSRVFormat(SRVs[SrvIndex], SrvFormat) != SrvFormatNotEqual;
                    }
                }
            }

            return result;
        }
    };

    inline Model Skin1(8, 75, 4, 83, 2);
    inline Model Skin2(8, 75, 4, 77, 2);
    inline Model Body1(8, 75, 12, 39, 1,true);
    inline Model Body2(8, 75, 14, 39, 0,true);

    inline Model DroneWorldOverlay(8, 49, 3);
    inline Model WorldOverlay1(8, 49, 4);
    inline Model WorldOverlay2(8, 49, 12);
    inline Model WorldOverlay3(8, 49, 14);
    inline Model WorldOverlay4(8, 49, 49);

    inline Model Scope(8, 49, 49, 77, 2); // Scope textures
}
```

`src/RGBA.hpp`:

```hpp
#pragma once

struct RGBA
{
    unsigned char R;
    unsigned char G;
    unsigned char B;
    unsigned char A;

    RGBA(unsigned char r = 0, unsigned char g = 0, unsigned char b = 0, unsigned char a = 255) :
        R(r), G(g), B(b), A(a) {}
};

```

`src/dllmain.cpp`:

```cpp
#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#include "Hook.hpp"

#ifdef _DEBUG
    #include <cstdio>
#endif

BOOL WINAPI DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
                     )
{
    DisableThreadLibraryCalls(hModule);
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
#ifdef _DEBUG
        AllocConsole();
        AttachConsole(GetCurrentProcessId());
        SetConsoleTitleW(L"R6 Chams by Igromanru");
        freopen("CON", "w", stdout);
#endif
        if (const auto threadHandle = CreateThread(nullptr, 0, reinterpret_cast<LPTHREAD_START_ROUTINE>(Hook::Init), nullptr, 0, nullptr))
        {
            CloseHandle(threadHandle);
            return TRUE;
        }
        return FALSE;
    case DLL_PROCESS_DETACH:
        Hook::Unload();
#ifdef _DEBUG
        Sleep(200);
        fclose(stdout);
        FreeConsole();
#endif
        return TRUE;
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
        break;
    }
    return TRUE;
}

```