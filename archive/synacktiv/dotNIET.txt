Project Path: arc_synacktiv_dotNIET_d_9yhjre

Source Tree:

```txt
arc_synacktiv_dotNIET_d_9yhjre
├── README.md
├── dotNIET
│   ├── pdbguid.py
│   ├── resolve.py
│   └── utils.py
├── dotNIET_plugin.py
└── img
    ├── dotNIET_before_after.png
    ├── dotNIET_display.png
    └── vladimir.png

```

`README.md`:

```md
<img align="left" width="100" height="115" src="./img/vladimir.png" alt="vladimir">  
&nbsp;
&nbsp;

# .NIET

![Alt text](./img/dotNIET_before_after.png?raw=true "Before After")

*.NIET* is an IDA Pro plugin. Its purpose is to import missing symbols (usually few thousands) which are resolved at runtime by [.NET Native](https://docs.microsoft.com/en-us/dotnet/framework/net-native/) compiled binaries. These symbols lie in ```SharedLibrary.dll``` and are not exported by this one.

*.NIET* has been tested on IDA Pro 7.5 using python 3.8 on the following platforms:

* Windows
* Linux

This plugin currently supports the following .NET Native framework versions:

* 1.3
* 1.6
* 1.7
* 2.2

**Please create an issue if you encounter another version.**

## Installation

Copy these elements to your IDA Pro plugin directory:

```
dotNIET_plugin.py
dotNIET\
```

## Dependencies

*.NIET* relies on [pefile](https://pypi.org/project/pefile/) in order to parse resources directories.

*pefile* can be installed as follows:

```
pip install pefile
```

## Requirements

Because symbols are imported from ```SharedLibrary.dll```, this one must be provided to *.NIET* **along with its pdb** (its location is searched by the plugin within ```_NT_SYMBOL_PATH```).

Helpers are implemented to identify .NET Native framework versions and verifying that ```SharedLibrary.dll``` ```pdb``` exists within the configured symbols path.

## Usage

![Alt text](./img/dotNIET_display.png?raw=true "Display")

*.NIET* can be launched using shortcut ```Alt-Shift-N``` or through the ```Edit/Plugins``` menu.

Upon launch, the plugin tries to identify current binary .NET Native framework version. All you have to do is to select ```SharedLibrary.dll``` in the right version then click ```Run```.

*.NIET* will identify target dll .NET Native framework version and prompt a message if versions are not the same. **Major and Minor version numbers are usually the only ones that matter.**

## Functioning

*.NIET* looks for .NET Native custom import descriptors table within the ```.rdata``` section. To proceed so, it reads at specific offsets of a ```Custom Header``` structure then parses an ordinals array.

This ordinals array points to various locations within a ```SharedLibrary.dll```'s custom table entries.

Symbol resolution is achieved by launching an IDA Pro headless instance through its binary ```idat``` in order to parse ```SharedLibrary.dll``` ```pdb```

## Imported symbols naming convention

Symbols are imported as is if possible but some corner cases may be encountered:

* sometimes imported addresses are solely ```jmpstubs``` symbols to offsets or single ```jmp``` instructions to symbols. Their symbol name is replaced by *.NIET* to the target function's name prepended with ```jmp_```
* some addresses resolved by the .NET Native runtime point to symbols after multiple derefences. If *.NIET* cannot find a symbol at an imported address it tries to dereference until it finds one. ```deref_X``` is appended to this symbol name, if found, with ```X``` being the number of derefs.
* some addresses points to offsets within an ```EETableSection``` table. Being new to .NET Native, I have no idea what this is (yet?) so these addresses are labeled ```EETableSection_XXX```, ```XXX``` being offsets from ```EETableSection``` within ```SharedLibrary.dll```

## Known limitations

* Does not work (yet) on macOS IDA Pro version
* *.NIET* is pretty slow as it requires to parse ```pdb``` of fairly huge binaries
* "restore .idata" option (kind of "undo" option) solely unsets imported symbols. Because IDA automagically propagates names during import, you will likely need to run auto-analysis again if you want to remove all traces of imported symbols. A workaround could be to create a database snapshot before running the plugin.
* *.NIET* parses symbols solely from ```SharedLibrary.dll``` module although the original routine in charge of symbols resolution likely offers the possibility to parse other modules (I don't know if this really occurs apart from ```SharedLibrary.dll``` module)

## Troubleshooting

```idat``` *logfile* is defined to ```%tmpdir%/dotNIETlogs.txt```

## Why such a name

Because reversing .NET Native is a nightmare
```

`dotNIET/pdbguid.py`:

```py
# ----------------------------------------------------------------------------
# "THE BEER-WARE LICENSE" (Revision 42):
# <jean-christophe.delaunay@synacktiv.com> wrote this file. As long as you 
# retain this notice you can do whatever you want with this stuff. 
# If we meet some day, and you think this stuff is worth it, you can buy me a
# beer in return
# ----------------------------------------------------------------------------

import binascii, struct
import idaapi

try:
    import pefile
except ImportError:
    idaapi.msg("\"pefile\" python module is required")


def byte_swap(value, struct_pack_format):
    if struct_pack_format.startswith("<") or struct_pack_format.startswith("="):
        bswapped_format = ">%s" % struct_pack_format[1:]
    elif struct_pack_format.startswith(">"):
        bswapped_format = "<%s" % struct_pack_format[1:]
    else:
        bswapped_format = ">%s" % struct_pack_format

    return struct.unpack(bswapped_format,struct.pack("%s" % struct_pack_format, value))[0]

def _get_guid(debug_entry):
    if not hasattr(debug_entry, "Signature_Data5"):
        hex_guid = "%08x%04x%04x%s%x" % ( 
            debug_entry.Signature_Data1, 
            debug_entry.Signature_Data2, 
            debug_entry.Signature_Data3, 
            binascii.hexlify(debug_entry.Signature_Data4).decode('ascii'),
            debug_entry.Age
        )
    else:
        hex_guid = "%08x%04x%04x%04x%04x%08x%x" % ( 
            debug_entry.Signature_Data1, 
            debug_entry.Signature_Data2, 
            debug_entry.Signature_Data3, 
            byte_swap(debug_entry.Signature_Data4, "H"),
            byte_swap(debug_entry.Signature_Data5, "H"),
            byte_swap(debug_entry.Signature_Data6, "I"),
            debug_entry.Age
        )

    return hex_guid.upper()

def _get_debug_entry(pe):

    pe.parse_data_directories(directories=[pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_DEBUG']])

    if not hasattr(pe, 'DIRECTORY_ENTRY_DEBUG'):
        raise ValueError("no debug directory present in the binary file.")

    is_debug_entry = lambda x: x.entry is not None and x.entry.name == 'CV_INFO_PDB70'
    debug_entries = list(filter(is_debug_entry, pe.DIRECTORY_ENTRY_DEBUG))

    if not len(debug_entries):
        raise ValueError("no debug entries present in the binary file.")

    return debug_entries[0].entry

def get_guid(filepath):
    try:
        pe = pefile.PE(filepath, fast_load=True)
    except pefile.PEFormatError as pefe:
        idaapi.msg("Binary file %s is not a valid PE file \n" % filepath)
        idaapi.msg(pefe)
        return

    try:
        debug_entry = _get_debug_entry(pe)
    except AttributeError as ae:
        idaapi.msg("[!]  Binary file %s has no debug entry. Skipping \n" % filepath)
        return
    except ValueError as ve:
        idaapi.msg("[!]  Binary file %s has no debug entry. Skipping \n" % filepath)
        return

    return _get_guid(debug_entry)
```

`dotNIET/resolve.py`:

```py
# ----------------------------------------------------------------------------
# "THE BEER-WARE LICENSE" (Revision 42):
# <jean-christophe.delaunay@synacktiv.com> wrote this file. As long as you 
# retain this notice you can do whatever you want with this stuff. 
# If we meet some day, and you think this stuff is worth it, you can buy me a
# beer in return
# ----------------------------------------------------------------------------

import idaapi, ida_pro, idautils, idc


def get_symbols(ordinals):
    symbols = []

    sharedlibrary_base_addr = idaapi.get_imagebase()
    customexport_section_addr = [x[2] for x in list(idautils.Entries()) if x[3] == '$NEAT$'][0]

    # we then get EETableSection address, still don't know what it is though...
    eetablesection_addr = 0
    for names in idautils.Names():
        if names[1] == "EETableSection":
            eetablesection_addr = names[0]
            break

    for i in range(len(ordinals)):
        offset = idaapi.get_dword(customexport_section_addr + ordinals[i])
        symbol_addr = sharedlibrary_base_addr + offset
        name_symbol = idc.get_name(symbol_addr)

        # dirty hacks because no auto-analysis
        if name_symbol == "":
            # we first try to convert to code to see if this is a jmp
            idc.create_insn(symbol_addr)
            if idc.print_insn_mnem(symbol_addr) == 'jmp':
                name_symbol = 'jmp_' + idc.get_name(get_operand_value(symbol_addr,0))
            else:
                # assume off_xxx   dq offset MYSYMBOL
                sym = symbol_addr
                # 3 derefs should be enough...
                for i in range(3):
                    sym = idaapi.get_qword(sym)
                    if idc.get_name(sym) != "":
                        name_symbol = idc.get_name(sym)+ '_deref_' + str(i + 1)
                        break
                if name_symbol == "":
                # assume we are in EETableSection or at an xref, but because 
                # auto-analysis is disabled we have no way to know it easily
                # (eg: could be an offset of a vtable)
                    eetablesection_off = symbol_addr - eetablesection_addr
                    symbols.append("EETableSection" + ["_0x%x" % eetablesection_off \
                                                       if eetablesection_off else ""][0])
                    continue
        # some symbols are just jmpstubs, we fix this to have something
        # more readable
        elif '__jmpstub' in name_symbol:
            # as auto-analysis is disabled, we must create code here first
            idc.create_insn(symbol_addr)
            if idc.print_insn_mnem(symbol_addr) == 'jmp':
                name_symbol = 'jmp_' + idc.get_name(get_operand_value(symbol_addr,0))

        symbols.append(name_symbol)
    return symbols

if __name__ =='__main__':
    # we first disable auto-analysis for performances
    idc.set_inf_attr(INF_AF, idc.get_inf_attr(INF_AF) & (~AF_USED));

    ordinals = []
    with open(idc.ARGV[1], 'r') as f:
        ordinals_array = f.read()
        ordinals = [int(x) for x in ordinals_array.split(',')]
    symbols = get_symbols(ordinals)

    # we write them back to the file
    if len(symbols) != 0:
        with open(idc.ARGV[1], 'w') as f:
            f.write(",".join([str(x) for x in symbols]))
        ida_pro.qexit(0)
    else:
        ida_pro.qexit(1)

```

`dotNIET/utils.py`:

```py
# ----------------------------------------------------------------------------
# "THE BEER-WARE LICENSE" (Revision 42):
# <jean-christophe.delaunay@synacktiv.com> wrote this file. As long as you 
# retain this notice you can do whatever you want with this stuff. 
# If we meet some day, and you think this stuff is worth it, you can buy me a
# beer in return
# ----------------------------------------------------------------------------

import os, re
import pefile
import idaapi, idc, ida_diskio, ida_kernwin
from dotNIET import pdbguid as pdbg


def _parse_symbol_path(value):
    symbol_paths = []
    if value != "":
        for entry in value.split(";"):
            for x in entry.split('*'):
                if x.lower() != "srv" and "http" not in x.lower():
                    symbol_paths.append(x)
    return symbol_paths

def _parse_cfg_file(path):
    with open(path, 'r') as f:
        for line in f.readlines():
            if line.startswith("_NT_SYMBOL_PATH"):
                return _parse_symbol_path(line.split('"')[1])

def find_pdb(dll_path):
    # we first check if the pdb is available
    symbol_paths = []
    cfg_known_locations= [ida_diskio.get_user_idadir() + "/cfg/pdb.cfg", 
                          idc.idadir() + "/cfg/pdb.cfg"]

    for cfg in cfg_known_locations:
        if os.path.exists(cfg):
            symbol_paths = _parse_cfg_file(cfg)
            # ida first check IDAUSR dir and if ok ignore IDADIR cfg
            if symbol_paths is not None and len(symbol_paths):
                break

    nt_symbol_path_env = os.getenv("_NT_SYMBOL_PATH")
    # assume Windows + it overrides values of ida cfg file
    if nt_symbol_path_env is not None and nt_symbol_path_env != "":
        symbol_paths = _parse_symbol_path(os.getenv("_NT_SYMBOL_PATH"))

    if symbol_paths is None or not len(symbol_paths):
        idaapi.msg("Error: \'_NT_SYMBOL_PATH\' could not be found. One must" +\
                    " set for .NIET to work.\n")
        return False
    else:
        # we then compute pdb guid of SharedLibrary.dll
        pdbguid = pdbg.get_guid(dll_path)
        if pdbguid is None:
            return False
        # we can have multiple paths, we check all of them
        for paths in symbol_paths:
            pdb_path = paths.replace('\\','/') + "/SharedLibrary.pdb/" + \
                       pdbguid + "/SharedLibrary.pdb"
            if not os.path.exists(pdb_path):
                idaapi.msg("Error: %s could not be found\n" % pdb_path)
                return False
            else:
                return True

def get_NET_Native_version(filepath):
    try:
        pe = pefile.PE(filepath, fast_load=True)
    except Exception as e: 
        return "Error: %s" % e

    pe.parse_data_directories(directories=[pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_RESOURCE']])

    if not hasattr(pe, 'DIRECTORY_ENTRY_RESOURCE'):
        return "unknown"

    for entry in pe.DIRECTORY_ENTRY_RESOURCE.entries:
        if str(entry.name) == "NETNATIVEBUILDINFO":
            break
    else:
        return "unknown"

    rsrc_data = entry.directory.entries[0].directory.entries[0].data
    data = pe.get_data(rsrc_data.struct.OffsetToData, rsrc_data.struct.Size)
    res = re.findall(b"ilc.exe *: ([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+)", data)

    if res:
        NET_version = res[0]
        return NET_version.decode()

    return "unknown"

def is_x64(dll):
    pe = pefile.PE(dll)
    if hex(pe.FILE_HEADER.Machine) == '0x14c':
        return False
    else:
        return True
```

`dotNIET_plugin.py`:

```py
# ----------------------------------------------------------------------------
# "THE BEER-WARE LICENSE" (Revision 42):
# <jean-christophe.delaunay@synacktiv.com> wrote this file. As long as you 
# retain this notice you can do whatever you want with this stuff. 
# If we meet some day, and you think this stuff is worth it, you can buy me a
# beer in return
# ----------------------------------------------------------------------------

import os, shutil, tempfile, subprocess
from collections import defaultdict

import idaapi, idc, idautils, ida_kernwin, ida_pro
from idaapi import PluginForm
from ida_name import SN_NOCHECK, SN_FORCE, SN_NODUMMY

from PyQt5 import QtCore, QtWidgets
from dotNIET import utils


dotnet_versions_offsets = defaultdict(dict)
dotnet_versions_offsets["1.3"] = {"nbCustomModules" : 0x124, "ImportDescriptors" : 0x120}
dotnet_versions_offsets["1.6"] = {"nbCustomModules" : 0x124, "ImportDescriptors" : 0x120}
dotnet_versions_offsets["1.7"] = {"nbCustomModules" : 0x124, "ImportDescriptors" : 0x120}
dotnet_versions_offsets["2.2"] = {"nbCustomModules" : 0x10C, "ImportDescriptors" : 0x108}

class CustomImportDescriptor:
    def __init__(self, **kwds):
        self.__dict__.update(kwds)


class dotNIET():
    def __init__(self, dotnet_version):
        self.dotnet_version = dotnet_version
        self.imagebase = idaapi.get_imagebase()
        self.module_header_struct = idaapi.get_segm_by_name(".rdata").start_ea
        self.nb_custom_modules = idaapi.get_dword(self.module_header_struct + \
                                 dotnet_versions_offsets[self.dotnet_version]\
                                 ["nbCustomModules"])

    def get_modules_info(self):
        if self.nb_custom_modules == 1:
            idaapi.msg("This binary does not have any custom imports\n")

        import_descriptors_offset = self.module_header_struct + \
                                    idaapi.get_dword(self.module_header_struct 
                                    + dotnet_versions_offsets[self.dotnet_version]\
                                    ["ImportDescriptors"])
        # this array contains structs describing, EAT, IAT and CountIAT of the 
        # modules to be treated for import
        import_descriptors = []
        for i in range(self.nb_custom_modules):
            import_descriptors.append(CustomImportDescriptor(\
            RvaEAT=idaapi.get_dword(import_descriptors_offset + i * 12),
            RvaIAT=idaapi.get_dword(import_descriptors_offset + i * 12 + 4),
            CountIAT=idaapi.get_dword(import_descriptors_offset + i * 12 + 8)))

        # only get SharedLibrary.dll imports. Could there be some more?
        # first entry is the app itself
        assert import_descriptors[0].RvaEAT == import_descriptors[0].RvaIAT \
               and import_descriptors[0].CountIAT == 0

        # First module should not be checked. Now we check that this belongs 
        # to SharedLibrary.dll
        self.eat_addr = self.imagebase + import_descriptors[1].RvaEAT
        # This is the first symbol from the CustomExportSection of SharedLibrary.dll
        assert idc.get_name(self.eat_addr) == "$NEAT$"

        self.ordinals = self.imagebase + import_descriptors[1].RvaIAT
        self.nb_symbols = import_descriptors[1].CountIAT

    def resolve_symbols(self, dll):
        tmpdir  = tempfile.gettempdir().replace('\\','/') + '/'
        # File who will first contain ordinals then symbols
        tmpfile = tmpdir + "dotNIETsymbols.txt"
        tmplog = tmpdir + "dotNIETlogs.txt"
        # Destination path for a copy of SharedLibrary.dll
        tmpdll = tmpdir + os.path.basename(dll)
        # Path to the idat binary, needed to parse a remote idb
        idat = idc.idadir().replace('\\','/') + '/' + 'idat' + \
               ['64' if utils.is_x64(dll) else ''][0]

        if os.getenv("windir") is not None:
            idat += '.exe'
        # script called along with idat in order to parse SharedLibrary.idb
        parsing_script_path = '"' + os.path.dirname(os.path.realpath(__file__)).replace('\\','/')\
                              + '/dotNIET/resolve.py"'

        # we first copy SharedLibrary.dll to tmp to be sure we are in a 
        # writable location
        shutil.copyfile(dll, tmpdll)

        # we have to use temporary files because of the ida headless stuff...
        # pretty dirty
        ordinals = []
        with open(tmpfile, 'w') as f:
            for i in range(self.nb_symbols):
                ordinals.append((idaapi.get_qword(self.ordinals + i * 8) & ~0x8000000000000000)*4)
            f.write(",".join([str(x) for x in ordinals]))

        # be prepared to wait as this will load the binary + pdb
        idaapi.msg("Starting parsing of %d symbols...\n" % self.nb_symbols)
        subprocess.run([idat, "-L" + tmplog, "-c", "-A", "-S" + \
                        parsing_script_path + " " + tmpfile, tmpdll], 
                        creationflags=subprocess.CREATE_NO_WINDOW,
                        check=True)

        # we read back tmpfile which now contains symbols
        symbols = []
        with open(tmpfile, 'r') as f:
            symbolsArray = f.read()
            symbols = symbolsArray.split(',')

        # we first have to undef structure as it is an array and ida will 
        # refuse to set names within it
        idc.del_items(self.ordinals)
        idc.set_cmt(self.ordinals - 8, "Custom imports from SharedLibrary.dll", 0)
        # we then apply the symbols at this very same location (start of .idata)
        for i in range(self.nb_symbols):
            idc.set_name(self.ordinals + i*8, symbols[i], SN_NOCHECK|SN_FORCE|SN_NODUMMY)

        # finally we remove our temp files
        os.remove(tmpfile)
        os.remove(tmpdll)
        # ida generate a db
        os.remove(tmpdll + '.i64')
        # if everything went smoothly, we should not need this anymore
        os.remove(tmplog)


class dotNIETForm_t(PluginForm):
    def cb_btn_run(self):
        if self.dotnet_version_full == "unknown":
            ida_kernwin.warning(".NET Native framework could not be identified.\n"\
                                ".NIET needs it to work properly.")
            return
        # self.dotnet_version_full[:3] is "major.minor"
        if not self.dotnet_version_full[:3] in dotnet_versions_offsets:
            ida_kernwin.warning(".NIET currently does not support %s, please "\
                                "create an issue.")
            return

        instance = dotNIET(self.dotnet_version_full[:3])
        instance.get_modules_info()

        # if "restore" is checked, everything else is greyed out
        if self.cb_restore.checkState() == QtCore.Qt.Checked:
            ida_kernwin.show_wait_box("HIDECANCEL\nClearing symbol names...")
            for i in range(instance.nb_symbols):
                # unset name of imports
                idc.set_name(instance.ordinals + i*8, "")
            idaapi.msg("%d symbols removed!\n" % instance.nb_symbols)
        else :
            if self.dll_input_path.text() == "":
                idaapi.msg("Error: \"SharedLibrary.dll\" path must be selected\n")
                del instance
                return
            # target SharedLibrary.dll .NET framework version is asked to be checked
            if self.cb_verify.checkState() == QtCore.Qt.Checked:
                ida_kernwin.show_wait_box("HIDECANCEL\nVerifying target dll "\
                                          ".NET Native framework version...")
                dll_dotnet_version_full = utils.get_NET_Native_version(self.dll_input_path.text())
                ida_kernwin.hide_wait_box()
                if dll_dotnet_version_full == "unknown" \
                   or dll_dotnet_version_full != self.dotnet_version_full:
                    answer = ida_kernwin.ask_buttons("", "","", 1, "HIDECANCEL\n"\
                                                    "Target dll .NET Native "\
                                                    "framework version is '%s' "\
                                                    "whereas current binary one "\
                                                    "is '%s'.\nProceed anyway?" \
                                                    % (dll_dotnet_version_full,\
                                                    self.dotnet_version_full))
                    # "No" or "cancel/escape"
                    if not answer:
                        return
            # getting target SharedLibrary.dll GUID to verify that the pdb does 
            # exist and is the right one
            ida_kernwin.show_wait_box("HIDECANCEL\nGetting pdb information...")
            if not utils.find_pdb(self.dll_input_path.text()):
                ida_kernwin.hide_wait_box()
                del instance
                return

            # everything is okay, ready to import
            ida_kernwin.replace_wait_box("HIDECANCEL\nImporting symbols...")
            instance.resolve_symbols(self.dll_input_path.text())
            idaapi.msg("%d symbols imported at 0x%x\n" % (instance.nb_symbols, 
                       instance.ordinals))
        ida_kernwin.hide_wait_box()
        del instance

    def cb_btn_browse(self):
        dll = QtWidgets.QFileDialog.getOpenFileName(None, "Select a file...", './',
                                                    filter="*.dll;;All Files (*)")
        if isinstance(dll, tuple):
            self.dll_input_path.setText(str(dll[0]))
        else:
            self.dll_input_path.setText(str(dll))

    def cb_restore_toggle(self, state):
        if state == QtCore.Qt.Checked:
            self.btn_browse.setEnabled(False)
            self.dll_input_path.setEnabled(False)
            self.cb_verify.setEnabled(False)
        else :
            self.btn_browse.setEnabled(True)
            self.dll_input_path.setEnabled(True)
            self.cb_verify.setEnabled(True)

    def disable_plugin_options(self):
        self.btn_browse.setEnabled(False)
        self.btn_run.setEnabled(False)
        if self.cb_restore.isChecked():
            self.cb_restore.toggle()
        self.cb_restore.setEnabled(False)
        if self.cb_verify.isChecked():
            self.cb_verify.toggle()
        self.cb_verify.setEnabled(False)
        self.dll_input_path.setReadOnly(True)

    def OnCreate(self, form):
        # get parent widget
        parent = self.FormToPyQtWidget(form)

        # checkboxes
        self.cb_restore = QtWidgets.QCheckBox('Restore .idata section')
        self.cb_restore.move(20, 20)
        self.cb_restore.stateChanged.connect(self.cb_restore_toggle)

        self.cb_verify = QtWidgets.QCheckBox("Verify target dll .NET Native "\
                                             "framework version")
        self.cb_verify.move(20, 20)
        # default is checked
        self.cb_verify.toggle()

        label_sharedlibrary = QtWidgets.QLabel("Path to target dll "\
                                               "(SharedLibrary.dll):")
        # create input field for SharedLibrary.dll
        self.dll_input_path = QtWidgets.QLineEdit(parent)
        self.dll_input_path.setMaxLength = 256
        self.dll_input_path.setFixedWidth(300)

        # create buttons
        self.btn_run = QtWidgets.QPushButton("Run", parent)
        self.btn_run.setToolTip("Proceed to import or restore.")
        self.btn_run.clicked.connect(self.cb_btn_run)

        self.btn_browse = QtWidgets.QPushButton("Browse", parent)
        self.btn_browse.setToolTip('Browse to "SharedLibrary.dll" location.')
        self.btn_browse.clicked.connect(self.cb_btn_browse)

        # we try to guess .NET Native framework version
        ida_kernwin.show_wait_box("HIDECANCEL\nIdentifying .NET "\
                                  "Native framework version...")
        dotnet_version_full_text = ".NET Native framework version: "
        dotnet_version_full = "unknown"
        if not os.path.exists(idc.get_input_file_path()):
            ida_kernwin.warning("%s could not be found.\n.NIET must identify .NET"\
                                " Native framework version of the original binary "\
                                "in order to work properly."\
                                % idc.get_input_file_path())
        else:
            dotnet_version_full = utils.get_NET_Native_version(idc.get_input_file_path())
            if dotnet_version_full == "unknown":
                ida_kernwin.warning(".NET Native framework could not be identified.\n"\
                                    ".NIET needs it to work properly.")
            # assume pefile raised an error
            elif "Error" in dotnet_version_full:
                ida_kernwin.hide_wait_box()
                ida_kernwin.warning("pefile: %s" % dotnet_version_full)
                self.disable_plugin_options()
                dotnet_version_full = "unsupported"

            self.dotnet_version_full = dotnet_version_full
            dotnet_version_full_text += dotnet_version_full
        ida_kernwin.hide_wait_box()

        label_dotnet_version_full = QtWidgets.QLabel(dotnet_version_full_text)

        # then we check if SharedLibrary.dll is an import
        imported_modules = [idaapi.get_import_module_name(i) for i in range(idaapi.get_import_module_qty())]
        if not "SharedLibrary" in imported_modules:
            ida_kernwin.warning("This binary does not import symbols from "
                                "'SharedLibrary.dll' at runtime.\n.NIET is not"\
                                " required")
            self.disable_plugin_options()

        # create layout
        spacerItem = QtWidgets.QSpacerItem(5, 16)
        layout = QtWidgets.QGridLayout()
        layout.addWidget(label_dotnet_version_full, 0, 0)
        layout.addItem(spacerItem)
        layout.addWidget(label_sharedlibrary, 1, 0)
        layout.addWidget(self.dll_input_path, 2, 0)
        layout.addWidget(self.btn_browse, 2, 1)
        spacerItem = QtWidgets.QSpacerItem(5, 16)
        layout.addItem(spacerItem)
        layout.addWidget(self.cb_restore, 4, 0)
        layout.addWidget(self.btn_run, 5, 0)
        layout.addWidget(self.cb_verify, 5, 1, 1, 2)
        layout.setColumnStretch(4, 1)
        layout.setRowStretch(6, 1)
        parent.setLayout(layout)

    def OnClose(self, form):
        global dotNIETForm
        del dotNIETForm

    def Show(self):
        return PluginForm.Show(self, ".NIET", options=PluginForm.WOPN_PERSIST)


class dotNIETplugin(idaapi.plugin_t):
    flags = idaapi.PLUGIN_KEEP
    comment = ""
    help = ""
    wanted_name = ".NIET"
    wanted_hotkey = "Alt-Shift-N"

    def init(self):
        return idaapi.PLUGIN_KEEP

    def run(self, arg):
        global dotNIETForm
        dotNIETForm = dotNIETForm_t()
        dotNIETForm.Show()

    def term(self):
        pass

def PLUGIN_ENTRY():
    return dotNIETplugin()

```