Project Path: arc_ExploitTheLoop_writemem_jkkjomu0

Source Tree:

```txt
arc_ExploitTheLoop_writemem_jkkjomu0
├── MemoryUtils.iml
├── README.md
└── src
    └── jayne
        └── memoryutils
            ├── AllTools.java
            ├── ByteUtils.java
            ├── Main.java
            ├── MapsPrase.java
            ├── MemorySearch.java
            ├── MemoryWrite.java
            └── ServerThread.java

```

`MemoryUtils.iml`:

```iml
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/src" isTestSource="false" />
    </content>
    <orderEntry type="inheritedJdk" />
    <orderEntry type="sourceFolder" forTests="false" />
  </component>
</module>
```

`README.md`:

```md
# writemem

Add it in your root build.gradle at the end of repositories:

	allprojects {
		repositories {
			...
			maven { url 'https://jitpack.io' }
		}
	}
  
  Step 2. Add the dependency

	dependencies {
	        implementation 'com.github.ExploitTheLoop:writemem:Tag'
	}
	
 step 3 example 
 

            
            AllTools.initUtil("包名");

            
            AllTools.memRange = MemRange.CA;

           
            System.err.println("开始范围搜索.....");
            ArrayList<Long> rangeSearchAddrs = MemorySearch.rangeSearch(12345, DataType.DWORD);
            System.err.println("范围搜索完毕!共: " + rangeSearchAddrs.size() + "个结果");

            System.err.println("开始偏移4匹配结果999...");
            ArrayList<Long> offsetSearchAddrs = MemorySearch.offsetSearch(999, 4, rangeSearchAddrs, DataType.DWORD);
            System.err.println("偏移搜索完成,共: " + offsetSearchAddrs.size() + "个结果!");
            int addrInfo = MemorySearch.getAddrInfo(offsetSearchAddrs.get(0), 0, DataType.DWORD);
            System.err.println("第一个数据为: " + addrInfo);

            
            ArrayList<Integer> addrInfos = MemorySearch.getAddrInfos(rangeSearchAddrs, 0, DataType.DWORD);
            System.err.println("范围搜索数据结果: ");
            for (int i = 0; i < addrInfos.size(); i++) {
                System.err.println(addrInfos.get(i));
            }

            
            ServerThread serverThread = MemorySearch.putAddrInfos(rangeSearchAddrs, 0, DataType.DWORD, 8088);

            
            serverThread.setState(false);

            
            MemoryWrite.addrWrite(54321,0,rangeSearchAddrs,DataType.DWORD);

            
            MemoryWrite.one = true;//将线程状态设置为true
            MemoryWrite.freezeAddrWrite(54321,0,rangeSearchAddrs,DataType.DWORD,300,ThreadNumber.ONE);

           
            MemoryWrite.one = false;//将对应的线程号设置为false即可关闭


       

```

`src/jayne/memoryutils/AllTools.java`:

```java
package jayne.memoryutils;

import java.io.*;
import java.util.ArrayList;

/**
 * @description: 工具类
 * @author: Jayne
 * @date: 2020-02-09 13:54
 */


enum MemRange {//内存范围枚举
    JH, CA, CB, CD, CH, A, AS, S, V, XS, XA, ALL
}

enum ThreadNumber {//线程数枚举
    ONE, TWO, THREE, FOUR, FIVE
}

enum DataType {//数据类型枚举
    DWORD(4), FLOAT(4), DOUBLE(8), BYTE(1), QWORD(2), WORD(8);

    private final int value;

    // 构造器默认也只能是private, 从而保证构造函数只能在内部使用
    DataType(int value) {
        this.value = value;
    }

    public int getValue() {
        return value;
    }
}

public class AllTools {
    static String PACKAGENAME = "";//包名
    static int PID = 0;//pid
    static ArrayList<String> rangeAddrs = new ArrayList();//当前内存范围地址集
    static MemRange memRange = MemRange.ALL; //当前内存范围
    static String MEMPATHNAME = "/proc/" + PID + "/mem";//mem文件路径

    /**
     * 初始化内存插件
     *
     * @param packageName 包名
     */
    public static void initUtil(String packageName) {
        // 设置包名
        if (packageName == null || packageName.length() <= 0) {
            System.out.println("\033[31;0m初始化失败!包名不正确!\033[0m");
            return;
        }
        PACKAGENAME = packageName;

        // 设置pid
        int processid = getProcessid();
        if (processid == 0) {
            System.out.println("\033[31;0m获取进程PID失败!\033[0m");
            return;
        }
        PID = processid;

        //inotify反调试
        try (FileWriter fileWriter = new FileWriter("/proc/sys/fs/inotify/max_queued_events");
             FileWriter fileWriter2 = new FileWriter("/proc/sys/fs/inotify/max_user_watches")) {
            fileWriter.write("0");
            fileWriter.flush();
            fileWriter2.write("0");
            fileWriter2.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }

    /**
     * 设置内存范围
     *
     * @param range 内存范围
     */
    public static void setMemRange(MemRange range) {
        // 设置内存范围
        memRange = range;
    }

    private static int getProcessid() {
        int pid = 0;

        try {
            Process exec = Runtime.getRuntime().exec(
                    "su -c pidof " + PACKAGENAME);
            InputStream inputStream = exec.getInputStream();
            BufferedReader buff = new BufferedReader(new InputStreamReader(inputStream));
            String str = buff.readLine();
            if (str == null || str.length() <= 0) {
                System.out.println("\033[31;0m获取进程PID失败!\033[0m");
                return 0;
            }
            pid = Integer.parseInt(str);
            System.out.println("\033[36;0m进程PID: " + pid + "\033[0m");
        } catch (Exception e) {
            System.out.println("\033[31;0m获取进程PID失败!\033[0m");
            e.printStackTrace();
        }
        return pid;
    }

    public static <T> T typeShift(T data) {
        return data;
    }

}

```

`src/jayne/memoryutils/ByteUtils.java`:

```java
package jayne.memoryutils;

/**
 * @description: 主要用于执行字节数组和基本数据类型之间的互相转换
 * 比如字节数组转int，和int转字节数组
 * java是属于大端字节序的，也就是高位放在低地址处
 * 所有的操作都是针对的大端字节序
 * @author: Jayne
 * @date: 2020-02-09 15:28
 */
public class ByteUtils {

    private static String hexStr = "0123456789ABCDEF";
    private static String[] binaryArray =
            {"0000", "0001", "0010", "0011",
                    "0100", "0101", "0110", "0111",
                    "1000", "1001", "1010", "1011",
                    "1100", "1101", "1110", "1111"};


    /**
     * 字节数组转short
     *
     * @param bytes 需要转换的字节数组
     * @return short
     */
    public static short byteArrToShort(byte[] bytes) {
        int FF = 0xff;
        int first = (bytes[1] & FF) << 8;
        short result = (short) (first | (bytes[0] & FF));
        return result;
        //可以直接return (short) ((bytes[0] << 8) | bytes[1]);
        //之所以向上面那么写，是为了方便看的清楚
    }

    /**
     * short转字节数组
     *
     * @param value 待转换的short
     * @return 字节数组
     */
    public static byte[] shortToByteArr(short value) {
        byte highByte = (byte) (value >> 8);//获取高位的字节
        byte lowByte = (byte) value;//获取低位的字节
        byte[] result = new byte[2];
        result[0] = highByte;
        result[1] = lowByte;
        return result;
    }

    /**
     * 字节数组转int
     *
     * @param bytes 待转换的字节数组
     * @return 转换之后的int
     */
    public static int byteArrToInt(byte[] bytes) {
        int FF = 0xff;
        //假设字节数组 05 0A 07 04
        int h1 = (bytes[3] & FF) << 24;//左移24位之后，h1为05 00 00 00
        int h2 = (bytes[2] & FF) << 16;//左移16位之后，h2为00 0A 00 00
        int h3 = (bytes[1] & FF) << 8;//左移8位之后，h3为00 00 07 00
        int h4 = bytes[0] & FF;//h4为00 00 00 04
        int result = h1 | h2 | h3 | h4;
        return result;
    }

    /**
     * int转字节数组
     *
     * @param value 待转换的int
     * @return 转换之后的字节数组
     */
    public static byte[] intToByteArr(int value) {
        //假设原来的int的16进制为 05 0A 07 04
        byte[] bytes = new byte[4];
        bytes[0] = (byte) (value >> 24);//右移24位之后，返回值00 00 00 05,强转之后变成05
        bytes[1] = (byte) (value >> 16);//右移16位之后，返回值00 00 05 0A,强转之后变成0A
        bytes[2] = (byte) (value >> 8);//右移8位之后，返回值00 05 0A 07,强转之后变成07
        bytes[3] = (byte) value;
        return bytes;
    }

    /**
     * 把字节数组转换成long
     * 这个的处理手法和前面和int和short都有一点差异
     *
     * @param bytes 待转换的字节数组
     * @return 转换之后的long
     */
    public static long byteArrToLong(byte[] bytes) {
        long FF = 0xff;
        //假设字节数组为08 0A 01 03 05 07 02 0B
        long b0 = bytes[7] & FF;//00 00 00 00 00 00 00 08
        long h0 = b0 << 56;//08 00 00 00 00 00 00 00
        long b1 = bytes[6] & FF;//00 00 00 00 00 00 00 0A
        long h1 = b1 << 48;//00 0A 00 00 00 00 00 00
        long b2 = bytes[5] & FF;
        long b3 = bytes[4] & FF;
        long b4 = bytes[3] & FF;
        long b5 = bytes[2] & FF;
        long b6 = bytes[1] & FF;
        long b7 = bytes[0] & FF;
        long h2 = b2 << 40;
        long h3 = b3 << 32;
        long h4 = b4 << 24;
        long h5 = b5 << 16;
        long h6 = b6 << 8;
        long h7 = b7;
        return h0 | h1 | h2 | h3 | h4 | h5 | h6 | h7;
    }

    /**
     * long转换成字节数组
     *
     * @param value 待转换的long
     * @return 转换之后的字节数组
     */
    public static byte[] longToByteArr(long value) {
        //假设待转换的long为08 0A 01 03 05 07 02 0B
        byte[] bytes = new byte[8];
        bytes[0] = (byte) (value >> 56);//右移之后,00 00 00 00 00 00 00 08,强转之后08
        bytes[1] = (byte) (value >> 48);//右移之后,00 00 00 00 00 00 08 0A,强转之后0A
        bytes[2] = (byte) (value >> 40);//右移之后,00 00 00 00 00 08 0A 01,强转之后01
        bytes[3] = (byte) (value >> 32);
        bytes[4] = (byte) (value >> 24);
        bytes[5] = (byte) (value >> 16);
        bytes[6] = (byte) (value >> 8);
        bytes[7] = (byte) value;
        return bytes;
    }

    /**
     * 将字节数组转换成float
     *
     * @param bytes 待转换的字节数组
     * @return 转换之后的float
     */
    public static float byteArrToFloat(byte[] bytes) {
        int FF = 0xff;
        //假设字节数组 05 0A 07 04
        int b0 = bytes[3] & FF;// 00 00 00 05
        int b1 = bytes[2] & FF;// 00 00 00 0A
        int b2 = bytes[1] & FF;
        int b3 = bytes[0] & FF;
        int h0 = b0 << 24;// 05 00 00 00
        int h1 = b1 << 16;// 00 0A 00 00
        int h2 = b2 << 8;
        int h3 = b3;
        int h = h0 | h1 | h2 | h3;
        return Float.intBitsToFloat(h);
    }


    /**
     * float转字节数组
     *
     * @param value 待转换的float
     * @return 转换之后的字节数组
     */
    public static byte[] floatToByteArr(float value) {
        int i = Float.floatToIntBits(value);
        byte[] bytes = new byte[4];
        bytes[0] = (byte) (i >> 24);
        bytes[1] = (byte) (i >> 16);
        bytes[2] = (byte) (i >> 8);
        bytes[3] = (byte) (i);
        return bytes;
    }

    /**
     * 将字节数组转换成double
     *
     * @param bytes 待转换的字节数组
     * @return 转换出来的double
     */
    public static double byteArrToDouble(byte[] bytes) {
        //假设待转换的字节数组为05 0A 07 04 0B 00 03 01
        long FF = 0xFF;
        long b0 = bytes[7] & FF;// 00 00 00 00 00 00 00 05
        long b1 = bytes[6] & FF;// 00 00 00 00 00 00 00 0A
        long b2 = bytes[5] & FF;
        long b3 = bytes[4] & FF;
        long b4 = bytes[3] & FF;
        long b5 = bytes[2] & FF;
        long b6 = bytes[1] & FF;
        long b7 = bytes[0] & FF;
        long h0 = b0 << 56;// 05 00 00 00 00 00 00 00
        long h1 = b1 << 48;// 00 0A 00 00 00 00 00 00
        long h2 = b2 << 40;
        long h3 = b3 << 32;
        long h4 = b4 << 24;
        long h5 = b5 << 16;
        long h6 = b6 << 8;
        long h7 = b7;
        long h = h0 | h1 | h2 | h3 | h4 | h5 | h6 | h7;
        return Double.longBitsToDouble(h);
    }

    /**
     * 将double转换成字节数组
     *
     * @param value 待转换的double
     * @return 转换之后的字节数组
     */
    public static byte[] doubleToByteArr(double value) {
        long lbits = Double.doubleToLongBits(value);
        byte[] bytes = new byte[8];
        bytes[0] = (byte) (lbits >> 56);
        bytes[1] = (byte) (lbits >> 48);
        bytes[2] = (byte) (lbits >> 40);
        bytes[3] = (byte) (lbits >> 32);
        bytes[4] = (byte) (lbits >> 24);
        bytes[5] = (byte) (lbits >> 16);
        bytes[6] = (byte) (lbits >> 8);
        bytes[7] = (byte) (lbits);
        return bytes;
    }

    /**
     * 将字节数组转化成char
     *
     * @param b 待转换的字节数组
     * @return 转换出来的char
     */
    public static char byteToChar(byte[] b) {
        char c = (char) (((b[1] & 0xFF) << 8) | (b[0] & 0xFF));
        return c;
    }


    /**
     * 将字节数组转换成十六进制字符串
     *
     * @param bytes 待转换的字节数组
     * @return 转换之后的十六进制字符串
     */
    public static String bytesToHexStr(byte[] bytes) {

        String result = "";
        String hex = "";
        int F0 = 0xF0;
        int ZeroF = 0x0F;
        for (int i = 0; i < bytes.length; i++) {
            //字节高4位
            hex = String.valueOf("0123456789ABCDEF".charAt((bytes[i] & F0) >> 4));
            //字节低4位
            hex += String.valueOf("0123456789ABCDEF".charAt(bytes[i] & ZeroF));
            result += hex;
        }
        return result;
    }


    /**
     * 将16进制转换成二进制字节数组,注意16进制不要输入0x，只需输入ff，不要输入成0xff
     *
     * @param hexString 带转换的十六进制字符串
     * @return 转换之后的字节数组
     */
    public static byte[] hexStringToBytes(String hexString) {
        if (hexString == null || hexString.equals("")) {
            return null;
        }
        hexString = hexString.toUpperCase();
        int length = hexString.length() / 2;
        char[] hexChars = hexString.toCharArray();
        byte[] d = new byte[length];
        for (int i = 0; i < length; i++) {
            int pos = i * 2;
            d[i] = (byte) (charToByte(hexChars[pos]) << 4 | charToByte(hexChars[pos + 1]));
        }
        return d;
    }

    public static byte charToByte(char c) {
        return (byte) "0123456789ABCDEF".indexOf(c);
    }


    /**
     * 二进制数组转换为二进制字符串   2-2
     */
    public static String bytesToBinStr(byte[] bArray) {
        String outStr = "";
        int pos = 0;
        for (byte b : bArray) {
            //高四位
            pos = (b & 0xF0) >> 4;
            outStr += binaryArray[pos];
            //低四位
            pos = b & 0x0F;
            outStr += binaryArray[pos];
        }
        return outStr;
    }

    /**
     * 将十六进制字符串转换为二进制字符串
     */
    public static String hexStr2BinStr(String hexString) {
        return bytesToBinStr(hexStringToBytes(hexString));
    }

}
```

`src/jayne/memoryutils/Main.java`:

```java
package jayne.memoryutils;

import java.util.ArrayList;


public class Main {

    public static void main(String[] args) {
        try {
            //初始化插件
            AllTools.initUtil("包名");

            //设置内存范围
            AllTools.memRange = MemRange.CA;

            //范围搜索,拿到搜索到的值地址集
            System.err.println("开始范围搜索.....");
            ArrayList<Long> rangeSearchAddrs = MemorySearch.rangeSearch(12345, DataType.DWORD);
            System.err.println("范围搜索完毕!共: " + rangeSearchAddrs.size() + "个结果");

            System.err.println("开始偏移4匹配结果999...");
            ArrayList<Long> offsetSearchAddrs = MemorySearch.offsetSearch(999, 4, rangeSearchAddrs, DataType.DWORD);
            System.err.println("偏移搜索完成,共: " + offsetSearchAddrs.size() + "个结果!");

            //获取单个地址信息, 这里你传入什么类型数据就用什么类型接收
            int addrInfo = MemorySearch.getAddrInfo(offsetSearchAddrs.get(0), 0, DataType.DWORD);
            System.err.println("第一个数据为: " + addrInfo);

            //获取地址集数据信息
            ArrayList<Integer> addrInfos = MemorySearch.getAddrInfos(rangeSearchAddrs, 0, DataType.DWORD);
            System.err.println("范围搜索数据结果: ");
            for (int i = 0; i < addrInfos.size(); i++) {
                System.err.println(addrInfos.get(i));
            }

            // 开启socket程序写出结果集数据, 返回线程用于结束输出结果, 数据接收方填入相同的端口号来接收数据
            ServerThread serverThread = MemorySearch.putAddrInfos(rangeSearchAddrs, 0, DataType.DWORD, 8088);

            //设置为false表示结束此线程数据输出
            serverThread.setState(false);

            //写内存
            MemoryWrite.addrWrite(54321,0,rangeSearchAddrs,DataType.DWORD);

            //冻结内存
            MemoryWrite.one = true;//将线程状态设置为true
            MemoryWrite.freezeAddrWrite(54321,0,rangeSearchAddrs,DataType.DWORD,300,ThreadNumber.ONE);

            //关闭冻结
            MemoryWrite.one = false;//将对应的线程号设置为false即可关闭


        } catch (Exception e) {
            e.printStackTrace();
        }
    }


}

```

`src/jayne/memoryutils/MapsPrase.java`:

```java
package jayne.memoryutils;

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.InputStreamReader;

/**
 * @description: maps文件分析类
 * @author: Jayne
 * @date: 2020-02-09 15:27
 */
public class MapsPrase {
    static String PATHNAME = "/proc/" + AllTools.PID + "/maps";//maps文件路径

    /**
     * 将内存地址储存到范围集中
     *
     * @param temp
     */
    private static void addRangeAddr(String temp) {
        String[] s = temp.split(" ")[0].split("-");
        AllTools.rangeAddrs.add(s[0]);
        AllTools.rangeAddrs.add(s[1]);
        Long l = Long.parseLong(s[1], 16) - Long.parseLong(s[0], 16);
        AllTools.rangeAddrs.add(l.intValue() + "");
    }

    /**
     * 解析all内存地址数据
     */
    public static void praseAll() {
        try (InputStreamReader readStream = new InputStreamReader(new FileInputStream(PATHNAME));
             BufferedReader reader = new BufferedReader(readStream)) {
            String temp = null;
            int line = 0;//行号
            while ((temp = reader.readLine()) != null) {
                line++;
                System.out.println(line + ":" + temp);

                // all内存地址
                if (temp.indexOf(" r") != -1) {
                    addRangeAddr(temp);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

    }

    /**
     * 解析ca内存地址数据
     */
    public static void praseCa() {
        try (InputStreamReader readStream = new InputStreamReader(new FileInputStream(PATHNAME));
             BufferedReader reader = new BufferedReader(readStream)) {
            String temp = null;
            int line = 0;//行号
            while ((temp = reader.readLine()) != null) {
                line++;
                System.out.println(line + ":" + temp);

                // ca内存地址
                if (temp.indexOf("rw") != -1 && temp.indexOf("[anon:libc_malloc]") != -1) {
                    addRangeAddr(temp);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

    }

    /**
     * 解析cb内存地址数据
     */
    public static void praseCb() {
        try (InputStreamReader readStream = new InputStreamReader(new FileInputStream(PATHNAME));
             BufferedReader reader = new BufferedReader(readStream)) {
            String temp = null;
            int line = 0;//行号
            while ((temp = reader.readLine()) != null) {
                line++;
                System.out.println(line + ":" + temp);
                // cb内存地址
                if (temp.indexOf("rw") != -1 && temp.indexOf("[anon:.bss]") != -1) {
                    addRangeAddr(temp);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * 解析cd内存地址数据
     */
    public static void praseCd() {
        try (InputStreamReader readStream = new InputStreamReader(new FileInputStream(PATHNAME));
             BufferedReader reader = new BufferedReader(readStream)) {
            String temp = null;
            int line = 0;//行号
            while ((temp = reader.readLine()) != null) {
                line++;
                System.out.println(line + ":" + temp);
                // cd内存地址
                if ((temp.indexOf("r--p") != -1 || temp.indexOf("rw-p") != -1 ||
                        temp.indexOf("rwxp") != -1) && temp.indexOf(".so") != -1 &&
                        (temp.indexOf("/data/app") != -1 || temp.indexOf("/data/data") != -1)) {
                    addRangeAddr(temp);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * 解析ch内存地址数据
     */
    public static void praseCh() {
        try (InputStreamReader readStream = new InputStreamReader(new FileInputStream(PATHNAME));
             BufferedReader reader = new BufferedReader(readStream)) {
            String temp = null;
            int line = 0;//行号
            while ((temp = reader.readLine()) != null) {
                line++;
                System.out.println(line + ":" + temp);
                // ch内存地址
                if (temp.indexOf("rw") != -1 && temp.indexOf("[heap]") != -1) {
                    addRangeAddr(temp);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * 解析jh内存地址数据
     */
    public static void praseJh() {
        try (InputStreamReader readStream = new InputStreamReader(new FileInputStream(PATHNAME));
             BufferedReader reader = new BufferedReader(readStream)) {
            String temp = null;
            int line = 0;//行号
            while ((temp = reader.readLine()) != null) {
                line++;
                System.out.println(line + ":" + temp);
                // jh内存地址
                if (temp.indexOf("rw") != -1 && (temp.indexOf("[anon:dalvik-main") != -1 || temp.indexOf("[anon:dalvik-large") != -1)) {
                    addRangeAddr(temp);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * 解析a内存地址数据
     */
    public static void praseA() {
        try (InputStreamReader readStream = new InputStreamReader(new FileInputStream(PATHNAME));
             BufferedReader reader = new BufferedReader(readStream)) {
            String temp = null;
            int line = 0;//行号
            while ((temp = reader.readLine()) != null) {
                line++;
                System.out.println(line + ":" + temp);
                // a内存地址
                if ((temp.indexOf("r--p") != -1 || temp.indexOf("rw-p") != -1 ||
                        temp.indexOf("rwxp") != -1) && temp.length() < 42) {
                    addRangeAddr(temp);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * 解析s内存地址数据
     */
    public static void praseS() {
        try (InputStreamReader readStream = new InputStreamReader(new FileInputStream(PATHNAME));
             BufferedReader reader = new BufferedReader(readStream)) {
            String temp = null;
            int line = 0;//行号
            while ((temp = reader.readLine()) != null) {
                line++;
                System.out.println(line + ":" + temp);
                // s内存地址
                if (temp.indexOf("rw") != -1 && temp.indexOf("[stack") != -1) {
                    addRangeAddr(temp);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * 解析as内存地址数据
     */
    public static void praseAs() {
        try (InputStreamReader readStream = new InputStreamReader(new FileInputStream(PATHNAME));
             BufferedReader reader = new BufferedReader(readStream)) {
            String temp = null;
            int line = 0;//行号
            while ((temp = reader.readLine()) != null) {
                line++;
                System.out.println(line + ":" + temp);
                // as内存地址
                if ((temp.indexOf("r--s") != -1 || temp.indexOf("rw-s") != -1) &&
                        (temp.indexOf("dalvik") == -1 && temp.indexOf("/dev/ashmem") != -1)) {
                    addRangeAddr(temp);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * 解析v内存地址数据
     */
    public static void praseV() {
        try (InputStreamReader readStream = new InputStreamReader(new FileInputStream(PATHNAME));
             BufferedReader reader = new BufferedReader(readStream)) {
            String temp = null;
            int line = 0;//行号
            while ((temp = reader.readLine()) != null) {
                line++;
                System.out.println(line + ":" + temp);
                // v内存地址
                if (temp.indexOf("rw-s") != -1 && temp.indexOf("kgsl-3d0") != -1) {
                    addRangeAddr(temp);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * 解析xs内存地址数据
     */
    public static void praseXs() {
        try (InputStreamReader readStream = new InputStreamReader(new FileInputStream(PATHNAME));
             BufferedReader reader = new BufferedReader(readStream)) {
            String temp = null;
            int line = 0;//行号
            while ((temp = reader.readLine()) != null) {
                line++;
                System.out.println(line + ":" + temp);
                // xs内存地址
                if (temp.indexOf("r-xp") != -1 && (temp.indexOf("/system/") != -1 ||
                        temp.indexOf("/apex/") != -1 || temp.indexOf("[vectors]") != -1)) {
                    addRangeAddr(temp);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * 解析xa内存地址数据
     */
    public static void praseXa() {
        try (InputStreamReader readStream = new InputStreamReader(new FileInputStream(PATHNAME));
             BufferedReader reader = new BufferedReader(readStream)) {
            String temp = null;
            int line = 0;//行号
            while ((temp = reader.readLine()) != null) {
                line++;
                System.out.println(line + ":" + temp);

                // xa内存地址
                if (temp.indexOf("r-xp") != -1 && temp.indexOf("/data/app") != -1 &&
                        temp.length() < 42) {
                    addRangeAddr(temp);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

}

```

`src/jayne/memoryutils/MemorySearch.java`:

```java
package jayne.memoryutils;

import java.io.RandomAccessFile;
import java.net.ServerSocket;
import java.net.Socket;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.util.ArrayList;

/**
 * @description: 内存搜索类
 * @author: Jayne
 * @date: 2020-02-10 21:27
 */
public class MemorySearch {


    /**
     * 范围搜索
     *
     * @param data     要搜索的数据
     * @param dataType 数据类型
     * @param <T>      数据类型
     * @return 搜索到的数据地址集合
     */
    public static <T> ArrayList<Long> rangeSearch(T data, DataType dataType) {
        ArrayList<Long> results = null;
        //解析maps
        AllTools.rangeAddrs.clear();
        switch (AllTools.memRange) {
            case A:
                MapsPrase.praseA();
                break;
            case AS:
                MapsPrase.praseAs();
                break;
            case CA:
                MapsPrase.praseCa();
                break;
            case CB:
                MapsPrase.praseCb();
                break;
            case CD:
                MapsPrase.praseCd();
                break;
            case CH:
                MapsPrase.praseCh();
                break;
            case S:
                MapsPrase.praseS();
                break;
            case JH:
                MapsPrase.praseJh();
                break;
            case V:
                MapsPrase.praseV();
                break;
            case XA:
                MapsPrase.praseXa();
                break;
            case XS:
                MapsPrase.praseXs();
                break;
            case ALL:
                MapsPrase.praseAll();
                break;
        }

        int dataSize = dataType.getValue();
        byte[] bytes = null;
        byte[] temp = new byte[dataSize];

        try (RandomAccessFile raf = new RandomAccessFile(AllTools.MEMPATHNAME, "rw");
             FileChannel channel = raf.getChannel()) {

            for (int i = 0; i < AllTools.rangeAddrs.size() / 3; i++) {
                Long seek = Long.parseLong(AllTools.rangeAddrs.get(i * 3), 16);
                ByteBuffer buff = ByteBuffer.allocate(Integer.parseInt(AllTools.rangeAddrs.get(i * 3 + 2)));//分配字节空间
                channel.read(buff, seek);//从seek处开始读
                bytes = buff.array();
                for (int j = 0; j < bytes.length / dataSize; j++) {
                    System.arraycopy(bytes, j * dataSize, temp, 0, dataSize);
                    if (getDataInfo(temp, dataType) == data) {
                        //数据匹配成功,记录数据地址
                        results.add(seek + (j * dataSize));
                    }
                }
            }
        } catch (Exception e) {
            System.out.println("\033[31;0m范围搜索失败!\033[0m");
            e.printStackTrace();
        }
        return results;
    }

    /**
     * 偏移搜索: 传入地址集, 搜索指定偏移值是否为指定值, 保存是的地址集并返回
     *
     * @param data     要匹配的数据
     * @param offSet   偏移值
     * @param addrs    要匹配的地址集
     * @param dataType 数据类型
     * @param <T>      数据类型
     * @return 地址集
     */
    public static <T> ArrayList<Long> offsetSearch(T data, int offSet, ArrayList<Long> addrs, DataType dataType) {
        byte[] bytes = null;
        ArrayList<Long> resultAddrs = new ArrayList<>();
        try (RandomAccessFile raf = new RandomAccessFile(AllTools.MEMPATHNAME, "rw");
             FileChannel channel = raf.getChannel()) {
            int dataSize = dataType.getValue();
            ByteBuffer buff = ByteBuffer.allocate(dataSize);//分配字节空间
            for (int i = 0; i < addrs.size(); i++) {
                buff.clear();
                channel.read(buff, addrs.get(i) + offSet);//从seek处读字节出来
                bytes = buff.array();
                if (getDataInfo(bytes, dataType) == data) {
                    resultAddrs.add(addrs.get(i));
                }
            }

        } catch (Exception e) {
            System.out.println("\033[31;0m偏移搜索失败!\033[0m");
            e.printStackTrace();
        }
        return resultAddrs;
    }


    /**
     * 获取地址信息
     *
     * @param seek     指针
     * @param offset   偏移
     * @param dataType 数据类型
     * @return
     */
    public static <T> T getAddrInfo(Long seek, int offset, DataType dataType) {

        byte[] bytes = null;
        T data = null;

        try (RandomAccessFile raf = new RandomAccessFile(AllTools.MEMPATHNAME, "rw");
             FileChannel channel = raf.getChannel()) {
            ByteBuffer buff = ByteBuffer.allocate(dataType.getValue());//分配字节空间
            channel.read(buff, seek + offset);//从seek处读字节出来
            bytes = buff.array();

        } catch (Exception e) {
            e.printStackTrace();
        }

        data = getDataInfo(bytes, dataType);

        return data;

    }

    /**
     * 获取地址集信息
     *
     * @param seek     指针
     * @param offset   偏移
     * @param dataType 数据类型
     * @return
     */
    public static <T> ArrayList<T> getAddrInfos(ArrayList<Long> seek, int offset, DataType dataType) {

        byte[] bytes = null;
        ArrayList<T> data = new ArrayList<>();

        try (RandomAccessFile raf = new RandomAccessFile(AllTools.MEMPATHNAME, "rw");
             FileChannel channel = raf.getChannel()) {
            ByteBuffer buff = ByteBuffer.allocate(dataType.getValue());//分配字节空间
            for (int i = 0; i < seek.size(); i++) {
                buff.clear();
                channel.read(buff, seek.get(i) + offset);//从seek处读字节出来
                bytes = buff.array();
                data.add(getDataInfo(bytes, dataType));
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return data;
    }

    /**
     * 通过socket向指定端口持续传输地址集中的内容
     *
     * @param seek     地址集
     * @param offset   偏移
     * @param dataType 数据类型
     * @param port     端口
     * @return socket线程, 用于关闭线程
     */
    public static ServerThread putAddrInfos(ArrayList<Long> seek, int offset, DataType dataType, int port) {

        byte[] bytes = null;
        ServerThread thread = null;

        try (RandomAccessFile raf = new RandomAccessFile(AllTools.MEMPATHNAME, "rw");
             FileChannel channel = raf.getChannel();
             // 创建服务端socket
             ServerSocket serverSocket = new ServerSocket(port);
             // 等待客户端连接
             Socket socket = serverSocket.accept()) {
            ByteBuffer buff = ByteBuffer.allocate(dataType.getValue());//分配字节空间
            thread = new ServerThread(socket);
            thread.setState(true);
            thread.start();
            ArrayList dataList = new ArrayList();
            while (thread.isState()) {
                dataList.clear();
                for (int i = 0; i < seek.size(); i++) {
                    buff.clear();
                    channel.read(buff, seek.get(i) + offset);//从seek处读字节出来
                    bytes = buff.array();
                    dataList.add(getDataInfo(bytes, dataType));
                }
                thread.setBytes(dataList);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        return thread;
    }

    /**
     * 根据不同类型返回对应类型值
     *
     * @param bytes    要转换的字节
     * @param dataType 数据类型
     * @param <T>      返回结果类型
     * @return 结果信息
     */
    private static <T> T getDataInfo(byte[] bytes, DataType dataType) {
        T data = null;
        //根据不同类型返回对应类型值
        switch (dataType) {
            case BYTE:
                byte value = bytes[0];
                data = (T) AllTools.typeShift(value);
                break;
            case WORD:
                long l = ByteUtils.byteArrToLong(bytes);
                data = (T) AllTools.typeShift(l);
                break;
            case DWORD:
                int i = ByteUtils.byteArrToInt(bytes);
                data = (T) AllTools.typeShift(i);
                break;
            case FLOAT:
                float v = ByteUtils.byteArrToFloat(bytes);
                data = (T) AllTools.typeShift(v);
                break;
            case QWORD:
                short i1 = ByteUtils.byteArrToShort(bytes);
                data = (T) AllTools.typeShift(i1);
                break;
            case DOUBLE:
                double v1 = ByteUtils.byteArrToDouble(bytes);
                data = (T) AllTools.typeShift(v1);
                break;
            default:
                data = (T) AllTools.typeShift(0);
                break;
        }
        return data;
    }

}

```

`src/jayne/memoryutils/MemoryWrite.java`:

```java
package jayne.memoryutils;

import java.io.RandomAccessFile;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.util.ArrayList;

/**
 * @description: 内存写入类
 * @author: Jayne
 * @date: 2020-02-11 15:58
 */
public class MemoryWrite {

    static boolean one = true;
    static boolean two = true;
    static boolean three = true;
    static boolean four = true;
    static boolean five = true;

    /**
     * 内存写入
     *
     * @param data     要写入的值
     * @param offSet   偏移量
     * @param addrs    要写入的地址集
     * @param dataType 数据类型
     * @param <T>      数据类型
     */
    public static <T> void addrWrite(T data, int offSet, ArrayList<Long> addrs, DataType dataType) {
        byte[] bytes = null;
        try (RandomAccessFile raf = new RandomAccessFile(AllTools.MEMPATHNAME, "rw");
             FileChannel channel = raf.getChannel()) {
            ByteBuffer buff = ByteBuffer.wrap(getDataBytes(data, dataType));

            for (int i = 0; i < addrs.size(); i++) {
                channel.write(buff, addrs.get(i) + offSet);//从seek处开始写字节
            }

        } catch (Exception e) {
            System.out.println("\033[31;0m内存写入失败!\033[0m");
            e.printStackTrace();
        }
    }

    /**
     * 冻结数据
     *
     * @param data         要冻结的数据
     * @param offSet       偏移
     * @param addrs        地址集
     * @param dataType     数据类型
     * @param ms           冻结间隔(毫秒)
     * @param threadNumber 线程号,最多支持5条线程
     * @param <T>          数据类型
     */
    public static <T> void freezeAddrWrite(T data, int offSet, ArrayList<Long> addrs, DataType dataType,
                                           int ms, ThreadNumber threadNumber) {
        byte[] bytes = null;
        ArrayList<Long> addrList = addrs;
        ThreadNumber tn = threadNumber;
        try (RandomAccessFile raf = new RandomAccessFile(AllTools.MEMPATHNAME, "rw");
             FileChannel channel = raf.getChannel()) {
            ByteBuffer buff = ByteBuffer.wrap(getDataBytes(data, dataType));

            new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                        boolean threadState = true;
                        while (threadState) {
                            switch (tn) {
                                case ONE:
                                    threadState = one;
                                    break;
                                case TWO:
                                    threadState = two;
                                    break;
                                case THREE:
                                    threadState = three;
                                    break;
                                case FOUR:
                                    threadState = four;
                                    break;
                                case FIVE:
                                    threadState = five;
                                    break;
                            }
                            for (int i = 0; i < addrList.size(); i++) {
                                channel.write(buff, addrList.get(i) + offSet);//从seek处开始写字节
                            }
                            Thread.sleep(ms);
                        }

                    } catch (Exception e) {
                        System.err.println("内存冻结失败!");
                        e.printStackTrace();
                    }

                }
            }).start();


        } catch (Exception e) {
            System.err.println("内存冻结失败!");
            e.printStackTrace();
        }
    }

    /**
     * 将数据转化成byte数组
     *
     * @param data     要转化的数据
     * @param dataType 数据类型
     * @return 转化完的字节数组
     */
    public static byte[] getDataBytes(Object data, DataType dataType) {
        byte[] bytes = null;
        //根据不同类型返回对应类型值
        switch (dataType) {
            case BYTE:
                bytes = new byte[]{(byte) data};
                break;
            case WORD:
                bytes = ByteUtils.longToByteArr((long) data);
                break;
            case DWORD:
                bytes = ByteUtils.intToByteArr((int) data);
                break;
            case FLOAT:
                bytes = ByteUtils.floatToByteArr((float) data);
                break;
            case QWORD:
                bytes = ByteUtils.shortToByteArr((short) data);
                break;
            case DOUBLE:
                bytes = ByteUtils.doubleToByteArr((double) data);
                break;
            default:
                bytes = ByteUtils.longToByteArr((long) 0);
                break;
        }
        return bytes;
    }

}

```

`src/jayne/memoryutils/ServerThread.java`:

```java
package jayne.memoryutils;

import java.io.*;
import java.net.Socket;


public class ServerThread extends Thread {

    private Socket socket = null;

    private Object bytes = new Object();

    private boolean state = true;

    public void setState(boolean state) {
        this.state = state;
    }

    public void setBytes(Object bytes) {
        this.bytes = bytes;
    }

    public boolean isState() {
        return state;
    }

    public ServerThread(Socket socket) {
        this.socket = socket;
    }

    @Override
    public void run() {
        OutputStream os = null;
        ObjectOutputStream bos = null;
        try {
            os = socket.getOutputStream();
            bos = new ObjectOutputStream(os);
            while (state){
                bos.writeObject(bytes);
                bos.flush();
            }
        } catch (Exception e) {
            System.err.println("数据传输中出现错误!");
            e.printStackTrace();
            // TODO: handle exception
        } finally {
            //关闭资源
            try {
                if (bos != null)
                    bos.close();
                if (os != null)
                    os.close();
                if (socket != null)
                    socket.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

}
```