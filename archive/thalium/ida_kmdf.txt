Project Path: arc_thalium_ida_kmdf_6vq0leey

Source Tree:

```txt
arc_thalium_ida_kmdf_6vq0leey
├── README.md
├── img
│   ├── after_script.png
│   └── before_script.png
├── utils
│   └── run_ida_script.py
├── wdf_plugin
│   ├── wdf.py
│   ├── wdf_analysis.py
│   └── wdf_plugin.py
├── wdf_til
│   ├── wdf-1-15.til
│   ├── wdf-1-17.til
│   ├── wdf-1-19.til
│   ├── wdf-1-21.til
│   ├── wdf-1-23.til
│   ├── wdf-1-25.til
│   ├── wdf-1-27.til
│   ├── wdf-1-31.til
│   ├── wdf-1-33.til
│   ├── wdf64-1-15.til
│   ├── wdf64-1-17.til
│   ├── wdf64-1-19.til
│   ├── wdf64-1-21.til
│   ├── wdf64-1-23.til
│   ├── wdf64-1-25.til
│   ├── wdf64-1-27.til
│   ├── wdf64-1-31.til
│   └── wdf64-1-33.til
├── wdf_til_creation
│   ├── dev
│   │   ├── WDF
│   │   │   └── README.md
│   │   └── WDK
│   │       └── README.md
│   ├── include
│   │   ├── generated_pfn.h
│   │   ├── wdf_base.h
│   │   ├── wdf_global_header.h
│   │   └── wdfldr.h
│   └── wdf_til_creator.py
└── wdfalyzer.py

```

`README.md`:

```md
# IDA kmdf 

This plugin provides two main features:

* the .til (type library) file generation based on the WDK headers published by Microsoft
* the application of the types previously generated all along the IDB of a KMDF driver

This plugin helps the reverser and offers some comfort at the beginning of an analysis (particularly on the preliminary steps).

After the generation of the TIL files, no specific action is required to use the plugin, it is executed automatically during the IDB creation.

# Showcase

To show what the plugin can bring to your preferred IDB, here is an example.

![Before](img/before_script.png)

In the pseudocode generated by Hexrays, it is observed that some variables (specific to KMDF) are not typed. Thus, the function calls using function pointers are not easy to understand, yet.
It would be possible to use the WDK types to obtain a better readability.

Here is the same code after the plugin execution (and the automatic type application):

![After](img/after_script.png)

Finally, we clearly have a better pseudocode and the real analysis can start!

# Prerequisites

* IDA (tested from 8.2 to 8.4, might work on older versions, but untested)
* IDA Python
* IDA SDK (tilib)
* Microsoft WDK
* Microsoft SDK
* clone of Windows-Driver-Frameworks

# Repository

In the repository, there is five set of files :

* `wdfalyzer.py`: the main interface to generate TIL and apply them to an IDA database (headlessly).
* `wdf_plugin/`: the plugin that will be executed at the start of IDA to apply types transparently.
* `wdf_til_creation/`: the TIL creator is used to generate TIL files from the WDK and the KMDF. Having the TIL files is a prerequisite to apply its types to the database.
* `utils/`: a helpful generic script to execute IDA script headlessly.
* `wdf_til`: some pre-generated `KMDF` TIL files

# Installation

To set up the plugin, you will have to go through the following:

1. git clone https://github.com/microsoft/Windows-Driver-Frameworks 
2. set IDA_DIR variable to the folder where IDA is installed (e.g. `%PROGRAMFILES%/IDA Pro 8.3`) 
3. Accept IDA licence (execute at least one time IDA and accept)
4. Copy paste the plugin in `%IDA_DIR%/plugins`
5. Copy tilib utilities in `%IDA_DIR%`
6. Copy previously generated .til in `%IDA_DIR%/til`

# Usage

There are three different cases:

1. TIL file creation: `python wdfalyzer.py make_til [--wdf=<wdf_dir>] [--wdk=<wdk_dir>] [--til=<til_dir>] [--no_casts]` 

For instance:

```
python wdfalyzer.py make_til \
    --wdf="C:\Users\admin\Desktop\Windows-Driver-Frameworks" \
    --wdk="C:\Program Files (x86)\Windows Kits\10\Include\10.0.22621.0\"
    --til="C:\Users\admin\AppData\Roaming\Hex-Rays\IDA Pro\til"
```

Be careful, generating TIL files from headers is complex, and couple types might be missing.

Once generated, the TIL files must be copied in the IDA TIL folder `%IDA_DIR%/til`.

NB: you may put the `WDK` and the `KMDF` in `wdf_til_creation/dev/{folders}` so that they are used by default.

2. Ask for type application: `python wdfalyzer.py analyze <file(s)>`

For instance:

```
python wdfalyzer.py analyze \
    "C:\Users\admin\Desktop\winusb.sys.i64" \
    "C:\Users\admin\Desktop\acpiex.sys.i64"
```

3. automatic type application: `nothing to do here (:`

Just open you driver in IDA with the plugin installed and the TIL files generated (sometimes a pseudocode refresh helps)

```

`utils/run_ida_script.py`:

```py
import argparse
import inspect
import logging
import os
import platform
import random
import shutil
import string
import subprocess
import sys
import tempfile


def log(line):
    sys.stderr.write(line + "\n")


class Ctx:
    def __init__(self):
        if "IDA_DIR" not in os.environ.keys():
            errx(self, "missing IDA_DIR environment variable")

        self.ida_dir = os.path.abspath(os.environ["IDA_DIR"].strip('"\''))
        # log(f"* IDA_DIR:\t{self.ida_dir}")
        suffix = ".exe" if sys.platform == "win32" else ""
        self.ida32 = os.path.join(self.ida_dir, "idat" + suffix)
        self.ida64 = os.path.join(self.ida_dir, "idat64" + suffix)
        # log(f"* idat32:\t{self.ida32}")
        log(f"* idat64:\t{self.ida64}")


def errx(ctx, *args):
    args = "".join(args)
    log(f"error: {args}")
    sys.exit(-1)


def get_script_exec_args(ctx, input_file, database, script, script_args: [str]):
    """ Craft IDA command line to run script """
    _, input_filename = os.path.split(input_file)
    input_filename = input_filename.split(".")[0]
    fd, logfile = tempfile.mkstemp(prefix=f"{input_filename}_", suffix=".log")
    os.close(fd)
    os.remove(logfile)
    ctx.logfile = logfile
    log(f"* log:\t{ctx.logfile}")
    q = '\\"'
    quoted_args = ""
    if len(script_args):
        quoted_args = " " + q + (q + " " + q).join(script_args) + q
    return f'"{ctx.ida}" -A -L"{logfile}" -S"{q}{script}{q}{quoted_args}" "{database}"'


def run_ida_batchmode(ctx, filepath: str) -> bool:
    """ Use ida64 to create an IDB from a file """
    args = f'"{ctx.ida64}" -B "{filepath}"'
    is_windows = platform.system() == "Windows"
    process = subprocess.Popen(args, shell=not is_windows)
    code = process.wait()
    os.remove(filepath + ".asm")
    if code != 0:
        log("[-] failed.")
        return False

    log("* IDA batchmode success")
    return True


def get_random_string(size):
    letters = string.ascii_lowercase
    return "".join(random.choice(letters) for i in range(size))


def run_ida(ctx: Ctx, input_file: str, script: str, script_args: [str] = []):
    if not is_idb(input_file):
        log("warning: not an idb. Creating " + input_file + ".i64")
        run_ida_batchmode(ctx, input_file)
        input_file += ".i64"

    if len(script) == 0:
        return True

    if len(script_args) == 0:
        prefix = get_random_string(6)
        script_args = ["--quit", "--prefix", prefix]

    # Run `script` with args `script_args` in `ida_database`
    ctx.ida = ctx.ida64 if input_file.endswith(".i64") else ctx.ida32

    args = get_script_exec_args(ctx, input_file, input_file, script, script_args)
    log(f"* running:\t{args}")
    # different quoting behavior between linux & windows...
    is_windows = platform.system() == "Windows"
    process = subprocess.Popen(args, shell=not is_windows)
    code = process.wait()

    output = ""
    with open(ctx.logfile, "r", encoding = "UTF-8") as fh:
        output = fh.read()

    if code == 0:
        log("* IDA script success")
        for line in output.splitlines():
            if not line.startswith(prefix):
                continue

            line.strip()
            line = line[len(prefix) :]
            print(line)
        return True

    errx(ctx, f"Trace:\n{output}")
    log(f"[-] Status code:\t{hex(code)}")
    return False


def get_idb_suffix(filename: str) -> str:
    return ".idb" if filename.endswith(".idb") else ".i64"


def is_idb(filename: str) -> bool:
    return filename.endswith(".i64") or filename.endswith(".idb")


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("file", type=os.path.abspath, help="input file")
    parser.add_argument("script", type=os.path.abspath, help="IDA script")
    args = parser.parse_args()

    ctx = Ctx()
    ok = run_ida(ctx, args.file, args.script)

    if not ok:
        return 1

    return 0


if __name__ == "__main__":
    main()

```

`wdf_plugin/wdf.py`:

```py
import os

import ida_bytes
import ida_funcs
import ida_nalt
import ida_typeinf
import idaapi
import idautils
import idc

LOG_ERROR = "error"
LOG_WARN = "warn"
LOG_INFO = "info"
LOG_DEBUG = "debug"


def log(message: str, file=None, level=LOG_INFO, callee=LOG_DEBUG):
    log = f"[KMDF][{level}] {message}\n"
    if callee:
        import inspect

        try:
            callee = inspect.stack()[1][3]
        except BaseException:
            callee = "unk"

        log = f"[KMDF][{level}][{callee}] {message}\n"

    if file:  # or level != LOG_INFO:
        if not file:
            file = level + ".txt"

        filepath = os.path.join(LOG_PATH, file)
        with open(filepath, "a+") as fh:
            fh.write(f"{message}\n")

    if file is None:
        idaapi.msg(log)


def apply_driver_globals() -> bool:
    names = idautils.Names()

    version_bind_ea = None
    for (ea, name) in names:
        if "WdfVersionBind" in name and "Class" not in name:
            version_bind_ea = ea
            break

    if version_bind_ea is None:
        return False

    args_addrs = None
    for xref in idautils.XrefsTo(version_bind_ea):
        # There could be several xrefs, not all in section .text,
        # and not all being a call. So we iterate to get a call.
        frm = xref.frm
        args_addrs = idaapi.get_arg_addrs(frm)
        if args_addrs is not None:
            break

    if args_addrs is None:
        return False

    if len(args_addrs) != 4:
        return False

    insn = idautils.DecodeInstruction(
        args_addrs[3]
    )  # DriverGlobals is the 4th argument
    driver_globals = None
    for op in insn.ops:
        # I need to check both values and addr because IDA uses either one
        # in 32 bit or 64 bit
        if op.addr != 0:  # Registers and direct values don't have addresses
            driver_globals = op.addr
        elif op.value != 0:  # Registers and direct values don't have values
            driver_globals = op.value
            break

    if driver_globals is None:
        return False

    ok = idc.set_name(driver_globals, "WdfDriverGlobals", flags=idc.SN_NOCHECK|idc.SN_NON_WEAK)
    if not ok:
        # We need to unset a type because it seems to be wrong...
        to_unset = ida_bytes.prev_head(driver_globals, 0)
        ida_bytes.del_items(to_unset, 0, 1, None)
        idc.set_name(driver_globals, "WdfDriverGlobals", flags=idc.SN_NOCHECK|idc.SN_NON_WEAK)

    ok = ida_typeinf.apply_cdecl(None, driver_globals, "PWDF_DRIVER_GLOBALS;", ida_typeinf.TINFO_DEFINITE)
    if not ok:
        idaapi.warning("Failed to apply PWDF_DRIVERGLOBALS type")
        return False



    return True


def apply_wdffunctions_stroffs(tid, reg, ea):
    func = ida_funcs.get_func(ea)
    for ea in idautils.Heads(ea, func.end_ea):
        insn = idautils.DecodeInstruction(ea)
        for op in insn.ops:
            # This is a simple heuristic, we want an instruction of the for
            # mov reg, [reg + offset], so the instruction must have either
            # an operand of type phrase or displacement
            if op.type in [idaapi.o_phrase, idaapi.o_displ] and op.reg == reg:
                idaapi.op_stroff(insn, 1, tid, 1, 0)
                # For now, we stop at the first one in case the register changes
                # We do not want to mistype something
                # TODO: check if register changes and stop then?
                return


def apply_function_xrefs(wdf_functions_ea, wdffunctions_tid):
    tid = idaapi.tid_array(1)
    tid[0] = wdffunctions_tid
    xrefs = idautils.XrefsTo(wdf_functions_ea)
    for xref in xrefs:
        frm = xref.frm
        insn = idautils.DecodeInstruction(frm)
        if insn.Op1.type == idaapi.o_reg:
            # We want loading instruction, to the first operand
            # ought to be a register
            reg = insn.Op1.reg
            # tid.cast because op_stroff used in this function
            # wants a pointer
            apply_wdffunctions_stroffs(tid.cast(), reg, frm)


def apply_wdf_functions() -> bool:
    sid_found = False

    # Since ida 8.4, the _WDF_BIND_INFO structure is not imported automatically so we have to import it manually
    idc.import_type(-1, "_WDF_BIND_INFO")
    tid = idc.import_type(-1, "WDFFUNCTIONS")
    for idx, sid, name in idautils.Structs():

        if "_WDF_BIND_INFO" in name:
            tif = ida_typeinf.tinfo_t()
            sid_found = tif.get_type_by_tid(sid)
            xrefs = idautils.XrefsTo(sid)

            if xrefs is []:
                log(
                    "Failed to find xrefs to BIND_INFO sid",
                    level=LOG_ERROR,
                )
                idaapi.warning("Failed to find xrefs to BIND_INFO sid")
                return False

            # Find the offset of FuncTable
            members = idautils.StructMembers(sid)
            for soff, member_name, size in members:
                if member_name == "FuncTable":
                    offset = soff
                    break

            for xref in xrefs:
                ptr = idaapi.get_qword(xref.frm + offset)
                ok = idc.set_name(ptr, "WdfFunctions", flags=idc.SN_NOCHECK|idc.SN_NON_WEAK)
                if not ok:
                    # We need to unset a type because it seems to be wrong...
                    to_unset = ida_bytes.prev_head(ptr, 0)
                    ida_bytes.del_items(to_unset, 0, 1, None)
                    idc.set_name(ptr, "WdfFunctions", flags=idc.SN_NOCHECK|idc.SN_NON_WEAK)

                ok = ida_typeinf.apply_cdecl(None, ptr, "WDFFUNCTIONS *;", ida_typeinf.TINFO_DEFINITE)
                if not ok:
                    idaapi.warning("Failed to apply WDFFUNCTIONS * type")
                    # Continue because there might be other references, even though
                    # this would be surprising
                    continue
                apply_function_xrefs(ptr, tid)

    if not sid_found:
        log("Failed to find BIND_INFO tinfo", level=LOG_ERROR)
        idaapi.warning("Failed to find BIND_INFO tinfo")
        return False

    return True


def apply_wdf() -> bool:
    """
    Find the _WDF_BIND_INFO structure and set the WDFFUNCTIONS * type
    to replace all offsets with the proper WDF function and propagate the
    argument types.
    """

    ok = apply_driver_globals()
    if ok:
        apply_wdf_functions()

    return True


def find_wdf_version_via_str() -> str:
    """
    Tries to locate the customary utf-16le string 'KmdfLibrary'
    in the global WDF_bind_info structure and getting the
    next two dwords, which will be the major and the minor.
    """

    # XXX there's a bug here where ida fails to handle utf-16le encoding type
    # until after initial idb load (it will work if just running script again...)
    ea = ida_bytes.find_string("KmdfLibrary", 0, 0xffffffffffffffff, None, "utf-16le")
    if ea == idaapi.BADADDR:
        return None, None

    xrefs = list(idautils.XrefsTo(ea))
    if xrefs is []:
        return None, None

    for xref in xrefs:
        ptr_size = 8 if idaapi.inf_is_64bit() else 4
        major = idaapi.get_dword(xref.frm + ptr_size)
        minor = idaapi.get_dword(xref.frm + ptr_size + 4)
        bind_info = xref.frm - ptr_size
        break  # There should be only one ref in WDF_BIND_INFO

    return f"{major}-{minor}", bind_info


def get_version_from_call(frm) -> str:
    """
    Receives an adress containing a call to WdfVersinoBind
    and tries to get the third argument to locate the
    WDF_BIND_INFO structure and get the version via
    its offset.
    """
    args_addrs = idaapi.get_arg_addrs(frm)

    if args_addrs == None or len(args_addrs) != 4:
        return None, None

    insn = idautils.DecodeInstruction(args_addrs[2])  # BindInfo is the 3rd argument
    bind_info = None
    for op in insn.ops:
        if op.addr != 0:  # Registers and direct values don't have addresses
            bind_info = op.addr
            break

    if bind_info is None:
        return None, None

    ptr_size = 8 if idaapi.inf_is_64bit() else 4
    major = idaapi.get_dword(bind_info + ptr_size * 2)
    minor = idaapi.get_dword(bind_info + ptr_size * 2 + 4)

    return f"{major}-{minor}", bind_info


def find_wdf_version_via_version_bind() -> str:
    """
    Tries to locate a call to WdfVersionBind to get the
    global structure WDF_BIND_INFO (third argument) and
    get the version via the proper offset.
    """
    names = idautils.Names()

    version_bind_ea = None
    for (ea, name) in names:
        if "WdfVersionBind" in name and "Class" not in name:
            version_bind_ea = ea
            break

    if version_bind_ea is None:
        return None, None

    ok = ida_typeinf.apply_cdecl(
        None,
        version_bind_ea,
        "int WdfVersionBind(int, int, int, int);",  # Set type to allow argument recuperation
        ida_typeinf.TINFO_DEFINITE
    )
    if not ok:
        idaapi.warning("Could not change WdfVersionBind type to get its arguments")
        return None, None

    idaapi.auto_wait()  # Wait for the type propagation
    version = None

    for xref in idautils.XrefsTo(version_bind_ea):
        frm = xref.frm
        version, bind_info = get_version_from_call(frm)
        if version is not None:
            break

    idc.SetType(version_bind_ea, "")  # Remove our fake type
    return version, bind_info


def find_wdf_version():
    """
    Tries to find the WDF version used via two ways.

    First, locate a WdfVersionBind call and use the
    WDF_BIND_INFO global to get it via its offset.

    Second, if the first failed, find the customary string
    'KmdfLibrary' also located in the WDF_BIND_INFO global
    and find the version via the proper offset.
    """
    version, bind_info = find_wdf_version_via_version_bind()

    if version is None:
        version, bind_info = find_wdf_version_via_str()

    return version, bind_info


def load_wdf() -> bool:
    """
    Find the version of WDF and load the associated .til if it exists.
    """

    wdf_version, bind_info_ea = find_wdf_version()
    if wdf_version is None:
        log("Could not find WDF version. Is this a WDF driver?", level=LOG_INFO)
        return False

    if idaapi.inf_is_64bit():
        til_path = f"wdf64-{wdf_version}.til"
    else:
        til_path = f"wdf-{wdf_version}.til"

    ok = ida_typeinf.add_til(til_path, ida_typeinf.ADDTIL_DEFAULT)
    if ok != ida_typeinf.ADDTIL_OK:

        log("Failed to load WDF til", level=LOG_ERROR)
        return False

    # We need to wait for IDA to parse the prototype of WdfBindVersion and apply
    # the WDF_BIND_INFO struct type.
    idaapi.auto_wait()

    ok = idc.set_name(bind_info_ea, "BindInfo", flags=idc.SN_NOCHECK|idc.SN_NON_WEAK)
    if not ok:
        # We need to unset a type because it seems to be wrong...
        to_unset = ida_bytes.prev_head(bind_info_ea, 0)
        ida_bytes.del_items(to_unset, 0, 1, None)
        idc.set_name(bind_info_ea, "BindInfo", flags=idc.SN_NOCHECK|idc.SN_NON_WEAK)

    ok = ida_typeinf.apply_cdecl(None, bind_info_ea, "struct _WDF_BIND_INFO;", ida_typeinf.TINFO_DEFINITE)
    if not ok:
        idaapi.warning("Failed to apply WDF_BIND_INFO type")
    # Set bind info type in force to be sure the plugin will work

    log("WDF til successfully loaded", level=LOG_INFO)
    return True

```

`wdf_plugin/wdf_analysis.py`:

```py
import os

import wdf as wdf

if __name__ == "__main__":
    import idc

    ok = wdf.load_wdf()
    if not ok:
        idc.qexit(1)

    ok = wdf.apply_wdf()
    if not ok:
        idc.qexit(1)

    idc.qexit(0)

```

`wdf_plugin/wdf_plugin.py`:

```py
import idaapi
import idc
import wdf as wdf


class WdfPlugin(idaapi.plugin_t):
    flags = idaapi.PLUGIN_PROC
    comment = "Detect wdf version and apply associated wdf types"
    wanted_name = "Wdfalyzer"
    wanted_hotkey = "Alt-F11"

    def init(self):
        self.run()

    def run(self):
        if wdf.load_wdf():
            wdf.apply_wdf()
            idaapi.auto_wait()

    def term(self):
        pass


def PLUGIN_ENTRY():
    return WdfPlugin()

```

`wdf_til_creation/dev/WDF/README.md`:

```md
Please fill this folder with the WDF : 

* https://github.com/microsoft/Windows-Driver-Frameworks

```

`wdf_til_creation/dev/WDK/README.md`:

```md
Please fill this folder with the WDK.
The folder structure should be :

* winrt
* um
* ucrt
* shared
* km
* cppwinrt

```

`wdf_til_creation/include/generated_pfn.h`:

```h
typedef int (*PFN_WDFCHILDLISTCREATE)(void);
typedef int (*PFN_WDFCHILDLISTGETDEVICE)(void);
typedef int (*PFN_WDFCHILDLISTRETRIEVEPDO)(void);
typedef int (*PFN_WDFCHILDLISTRETRIEVEADDRESSDESCRIPTION)(void);
typedef int (*PFN_WDFCHILDLISTBEGINSCAN)(void);
typedef int (*PFN_WDFCHILDLISTENDSCAN)(void);
typedef int (*PFN_WDFCHILDLISTBEGINITERATION)(void);
typedef int (*PFN_WDFCHILDLISTRETRIEVENEXTDEVICE)(void);
typedef int (*PFN_WDFCHILDLISTENDITERATION)(void);
typedef int (*PFN_WDFCHILDLISTADDORUPDATECHILDDESCRIPTIONASPRESENT)(void);
typedef int (*PFN_WDFCHILDLISTUPDATECHILDDESCRIPTIONASMISSING)(void);
typedef int (*PFN_WDFCHILDLISTUPDATEALLCHILDDESCRIPTIONSASPRESENT)(void);
typedef int (*PFN_WDFCHILDLISTREQUESTCHILDEJECT)(void);
typedef int (*PFN_WDFCOLLECTIONCREATE)(void);
typedef int (*PFN_WDFCOLLECTIONGETCOUNT)(void);
typedef int (*PFN_WDFCOLLECTIONADD)(void);
typedef int (*PFN_WDFCOLLECTIONREMOVE)(void);
typedef int (*PFN_WDFCOLLECTIONREMOVEITEM)(void);
typedef int (*PFN_WDFCOLLECTIONGETITEM)(void);
typedef int (*PFN_WDFCOLLECTIONGETFIRSTITEM)(void);
typedef int (*PFN_WDFCOLLECTIONGETLASTITEM)(void);
typedef int (*PFN_WDFCOMMONBUFFERCREATE)(void);
typedef int (*PFN_WDFCOMMONBUFFERGETALIGNEDVIRTUALADDRESS)(void);
typedef int (*PFN_WDFCOMMONBUFFERGETALIGNEDLOGICALADDRESS)(void);
typedef int (*PFN_WDFCOMMONBUFFERGETLENGTH)(void);
typedef int (*PFN_WDFCONTROLDEVICEINITALLOCATE)(void);
typedef int (*PFN_WDFCONTROLDEVICEINITSETSHUTDOWNNOTIFICATION)(void);
typedef int (*PFN_WDFCONTROLFINISHINITIALIZING)(void);
typedef int (*PFN_WDFDEVICEGETDEVICESTATE)(void);
typedef int (*PFN_WDFDEVICESETDEVICESTATE)(void);
typedef int (*PFN_WDFWDMDEVICEGETWDFDEVICEHANDLE)(void);
typedef int (*PFN_WDFDEVICEWDMGETDEVICEOBJECT)(void);
typedef int (*PFN_WDFDEVICEWDMGETATTACHEDDEVICE)(void);
typedef int (*PFN_WDFDEVICEWDMGETPHYSICALDEVICE)(void);
typedef int (*PFN_WDFDEVICEWDMDISPATCHPREPROCESSEDIRP)(void);
typedef int (*PFN_WDFDEVICEADDDEPENDENTUSAGEDEVICEOBJECT)(void);
typedef int (*PFN_WDFDEVICEADDREMOVALRELATIONSPHYSICALDEVICE)(void);
typedef int (*PFN_WDFDEVICEREMOVEREMOVALRELATIONSPHYSICALDEVICE)(void);
typedef int (*PFN_WDFDEVICECLEARREMOVALRELATIONSDEVICES)(void);
typedef int (*PFN_WDFDEVICEGETDRIVER)(void);
typedef int (*PFN_WDFDEVICERETRIEVEDEVICENAME)(void);
typedef int (*PFN_WDFDEVICEASSIGNMOFRESOURCENAME)(void);
typedef int (*PFN_WDFDEVICEGETIOTARGET)(void);
typedef int (*PFN_WDFDEVICEGETDEVICEPNPSTATE)(void);
typedef int (*PFN_WDFDEVICEGETDEVICEPOWERSTATE)(void);
typedef int (*PFN_WDFDEVICEGETDEVICEPOWERPOLICYSTATE)(void);
typedef int (*PFN_WDFDEVICEASSIGNS0IDLESETTINGS)(void);
typedef int (*PFN_WDFDEVICEASSIGNSXWAKESETTINGS)(void);
typedef int (*PFN_WDFDEVICEOPENREGISTRYKEY)(void);
typedef int (*PFN_WDFDEVICESETSPECIALFILESUPPORT)(void);
typedef int (*PFN_WDFDEVICESETCHARACTERISTICS)(void);
typedef int (*PFN_WDFDEVICEGETCHARACTERISTICS)(void);
typedef int (*PFN_WDFDEVICEGETALIGNMENTREQUIREMENT)(void);
typedef int (*PFN_WDFDEVICESETALIGNMENTREQUIREMENT)(void);
typedef int (*PFN_WDFDEVICEINITFREE)(void);
typedef int (*PFN_WDFDEVICEINITSETPNPPOWEREVENTCALLBACKS)(void);
typedef int (*PFN_WDFDEVICEINITSETPOWERPOLICYEVENTCALLBACKS)(void);
typedef int (*PFN_WDFDEVICEINITSETPOWERPOLICYOWNERSHIP)(void);
typedef int (*PFN_WDFDEVICEINITREGISTERPNPSTATECHANGECALLBACK)(void);
typedef int (*PFN_WDFDEVICEINITREGISTERPOWERSTATECHANGECALLBACK)(void);
typedef int (*PFN_WDFDEVICEINITREGISTERPOWERPOLICYSTATECHANGECALLBACK)(void);
typedef int (*PFN_WDFDEVICEINITSETIOTYPE)(void);
typedef int (*PFN_WDFDEVICEINITSETEXCLUSIVE)(void);
typedef int (*PFN_WDFDEVICEINITSETPOWERNOTPAGEABLE)(void);
typedef int (*PFN_WDFDEVICEINITSETPOWERPAGEABLE)(void);
typedef int (*PFN_WDFDEVICEINITSETPOWERINRUSH)(void);
typedef int (*PFN_WDFDEVICEINITSETDEVICETYPE)(void);
typedef int (*PFN_WDFDEVICEINITASSIGNNAME)(void);
typedef int (*PFN_WDFDEVICEINITASSIGNSDDLSTRING)(void);
typedef int (*PFN_WDFDEVICEINITSETDEVICECLASS)(void);
typedef int (*PFN_WDFDEVICEINITSETCHARACTERISTICS)(void);
typedef int (*PFN_WDFDEVICEINITSETFILEOBJECTCONFIG)(void);
typedef int (*PFN_WDFDEVICEINITSETREQUESTATTRIBUTES)(void);
typedef int (*PFN_WDFDEVICEINITASSIGNWDMIRPPREPROCESSCALLBACK)(void);
typedef int (*PFN_WDFDEVICEINITSETIOINCALLERCONTEXTCALLBACK)(void);
typedef int (*PFN_WDFDEVICECREATE)(void);
typedef int (*PFN_WDFDEVICESETSTATICSTOPREMOVE)(void);
typedef int (*PFN_WDFDEVICECREATEDEVICEINTERFACE)(void);
typedef int (*PFN_WDFDEVICESETDEVICEINTERFACESTATE)(void);
typedef int (*PFN_WDFDEVICERETRIEVEDEVICEINTERFACESTRING)(void);
typedef int (*PFN_WDFDEVICECREATESYMBOLICLINK)(void);
typedef int (*PFN_WDFDEVICEQUERYPROPERTY)(void);
typedef int (*PFN_WDFDEVICEALLOCANDQUERYPROPERTY)(void);
typedef int (*PFN_WDFDEVICESETPNPCAPABILITIES)(void);
typedef int (*PFN_WDFDEVICESETPOWERCAPABILITIES)(void);
typedef int (*PFN_WDFDEVICESETBUSINFORMATIONFORCHILDREN)(void);
typedef int (*PFN_WDFDEVICEINDICATEWAKESTATUS)(void);
typedef int (*PFN_WDFDEVICESETFAILED)(void);
typedef int (*PFN_WDFDEVICESTOPIDLENOTRACK)(void);
typedef int (*PFN_WDFDEVICERESUMEIDLENOTRACK)(void);
typedef int (*PFN_WDFDEVICEGETFILEOBJECT)(void);
typedef int (*PFN_WDFDEVICEENQUEUEREQUEST)(void);
typedef int (*PFN_WDFDEVICEGETDEFAULTQUEUE)(void);
typedef int (*PFN_WDFDEVICECONFIGUREREQUESTDISPATCHING)(void);
typedef int (*PFN_WDFDMAENABLERCREATE)(void);
typedef int (*PFN_WDFDMAENABLERGETMAXIMUMLENGTH)(void);
typedef int (*PFN_WDFDMAENABLERGETMAXIMUMSCATTERGATHERELEMENTS)(void);
typedef int (*PFN_WDFDMAENABLERSETMAXIMUMSCATTERGATHERELEMENTS)(void);
typedef int (*PFN_WDFDMATRANSACTIONCREATE)(void);
typedef int (*PFN_WDFDMATRANSACTIONINITIALIZE)(void);
typedef int (*PFN_WDFDMATRANSACTIONINITIALIZEUSINGREQUEST)(void);
typedef int (*PFN_WDFDMATRANSACTIONEXECUTE)(void);
typedef int (*PFN_WDFDMATRANSACTIONRELEASE)(void);
typedef int (*PFN_WDFDMATRANSACTIONDMACOMPLETED)(void);
typedef int (*PFN_WDFDMATRANSACTIONDMACOMPLETEDWITHLENGTH)(void);
typedef int (*PFN_WDFDMATRANSACTIONDMACOMPLETEDFINAL)(void);
typedef int (*PFN_WDFDMATRANSACTIONGETBYTESTRANSFERRED)(void);
typedef int (*PFN_WDFDMATRANSACTIONSETMAXIMUMLENGTH)(void);
typedef int (*PFN_WDFDMATRANSACTIONGETREQUEST)(void);
typedef int (*PFN_WDFDMATRANSACTIONGETCURRENTDMATRANSFERLENGTH)(void);
typedef int (*PFN_WDFDMATRANSACTIONGETDEVICE)(void);
typedef int (*PFN_WDFDPCCREATE)(void);
typedef int (*PFN_WDFDPCENQUEUE)(void);
typedef int (*PFN_WDFDPCCANCEL)(void);
typedef int (*PFN_WDFDPCGETPARENTOBJECT)(void);
typedef int (*PFN_WDFDPCWDMGETDPC)(void);
typedef int (*PFN_WDFDRIVERCREATE)(void);
typedef int (*PFN_WDFDRIVERGETREGISTRYPATH)(void);
typedef int (*PFN_WDFDRIVERWDMGETDRIVEROBJECT)(void);
typedef int (*PFN_WDFDRIVEROPENPARAMETERSREGISTRYKEY)(void);
typedef int (*PFN_WDFWDMDRIVERGETWDFDRIVERHANDLE)(void);
typedef int (*PFN_WDFDRIVERREGISTERTRACEINFO)(void);
typedef int (*PFN_WDFDRIVERRETRIEVEVERSIONSTRING)(void);
typedef int (*PFN_WDFDRIVERISVERSIONAVAILABLE)(void);
typedef int (*PFN_WDFFDOINITWDMGETPHYSICALDEVICE)(void);
typedef int (*PFN_WDFFDOINITOPENREGISTRYKEY)(void);
typedef int (*PFN_WDFFDOINITQUERYPROPERTY)(void);
typedef int (*PFN_WDFFDOINITALLOCANDQUERYPROPERTY)(void);
typedef int (*PFN_WDFFDOINITSETEVENTCALLBACKS)(void);
typedef int (*PFN_WDFFDOINITSETFILTER)(void);
typedef int (*PFN_WDFFDOINITSETDEFAULTCHILDLISTCONFIG)(void);
typedef int (*PFN_WDFFDOQUERYFORINTERFACE)(void);
typedef int (*PFN_WDFFDOGETDEFAULTCHILDLIST)(void);
typedef int (*PFN_WDFFDOADDSTATICCHILD)(void);
typedef int (*PFN_WDFFDOLOCKSTATICCHILDLISTFORITERATION)(void);
typedef int (*PFN_WDFFDORETRIEVENEXTSTATICCHILD)(void);
typedef int (*PFN_WDFFDOUNLOCKSTATICCHILDLISTFROMITERATION)(void);
typedef int (*PFN_WDFFILEOBJECTGETFILENAME)(void);
typedef int (*PFN_WDFFILEOBJECTGETFLAGS)(void);
typedef int (*PFN_WDFFILEOBJECTGETDEVICE)(void);
typedef int (*PFN_WDFFILEOBJECTWDMGETFILEOBJECT)(void);
typedef int (*PFN_WDFINTERRUPTCREATE)(void);
typedef int (*PFN_WDFINTERRUPTQUEUEDPCFORISR)(void);
typedef int (*PFN_WDFINTERRUPTSYNCHRONIZE)(void);
typedef int (*PFN_WDFINTERRUPTACQUIRELOCK)(void);
typedef int (*PFN_WDFINTERRUPTRELEASELOCK)(void);
typedef int (*PFN_WDFINTERRUPTENABLE)(void);
typedef int (*PFN_WDFINTERRUPTDISABLE)(void);
typedef int (*PFN_WDFINTERRUPTWDMGETINTERRUPT)(void);
typedef int (*PFN_WDFINTERRUPTGETINFO)(void);
typedef int (*PFN_WDFINTERRUPTSETPOLICY)(void);
typedef int (*PFN_WDFINTERRUPTGETDEVICE)(void);
typedef int (*PFN_WDFIOQUEUECREATE)(void);
typedef int (*PFN_WDFIOQUEUEGETSTATE)(void);
typedef int (*PFN_WDFIOQUEUESTART)(void);
typedef int (*PFN_WDFIOQUEUESTOP)(void);
typedef int (*PFN_WDFIOQUEUESTOPSYNCHRONOUSLY)(void);
typedef int (*PFN_WDFIOQUEUEGETDEVICE)(void);
typedef int (*PFN_WDFIOQUEUERETRIEVENEXTREQUEST)(void);
typedef int (*PFN_WDFIOQUEUERETRIEVEREQUESTBYFILEOBJECT)(void);
typedef int (*PFN_WDFIOQUEUEFINDREQUEST)(void);
typedef int (*PFN_WDFIOQUEUERETRIEVEFOUNDREQUEST)(void);
typedef int (*PFN_WDFIOQUEUEDRAINSYNCHRONOUSLY)(void);
typedef int (*PFN_WDFIOQUEUEDRAIN)(void);
typedef int (*PFN_WDFIOQUEUEPURGESYNCHRONOUSLY)(void);
typedef int (*PFN_WDFIOQUEUEPURGE)(void);
typedef int (*PFN_WDFIOQUEUEREADYNOTIFY)(void);
typedef int (*PFN_WDFIOTARGETCREATE)(void);
typedef int (*PFN_WDFIOTARGETOPEN)(void);
typedef int (*PFN_WDFIOTARGETCLOSEFORQUERYREMOVE)(void);
typedef int (*PFN_WDFIOTARGETCLOSE)(void);
typedef int (*PFN_WDFIOTARGETSTART)(void);
typedef int (*PFN_WDFIOTARGETSTOP)(void);
typedef int (*PFN_WDFIOTARGETGETSTATE)(void);
typedef int (*PFN_WDFIOTARGETGETDEVICE)(void);
typedef int (*PFN_WDFIOTARGETQUERYTARGETPROPERTY)(void);
typedef int (*PFN_WDFIOTARGETALLOCANDQUERYTARGETPROPERTY)(void);
typedef int (*PFN_WDFIOTARGETQUERYFORINTERFACE)(void);
typedef int (*PFN_WDFIOTARGETWDMGETTARGETDEVICEOBJECT)(void);
typedef int (*PFN_WDFIOTARGETWDMGETTARGETPHYSICALDEVICE)(void);
typedef int (*PFN_WDFIOTARGETWDMGETTARGETFILEOBJECT)(void);
typedef int (*PFN_WDFIOTARGETWDMGETTARGETFILEHANDLE)(void);
typedef int (*PFN_WDFIOTARGETSENDREADSYNCHRONOUSLY)(void);
typedef int (*PFN_WDFIOTARGETFORMATREQUESTFORREAD)(void);
typedef int (*PFN_WDFIOTARGETSENDWRITESYNCHRONOUSLY)(void);
typedef int (*PFN_WDFIOTARGETFORMATREQUESTFORWRITE)(void);
typedef int (*PFN_WDFIOTARGETSENDIOCTLSYNCHRONOUSLY)(void);
typedef int (*PFN_WDFIOTARGETFORMATREQUESTFORIOCTL)(void);
typedef int (*PFN_WDFIOTARGETSENDINTERNALIOCTLSYNCHRONOUSLY)(void);
typedef int (*PFN_WDFIOTARGETFORMATREQUESTFORINTERNALIOCTL)(void);
typedef int (*PFN_WDFIOTARGETSENDINTERNALIOCTLOTHERSSYNCHRONOUSLY)(void);
typedef int (*PFN_WDFIOTARGETFORMATREQUESTFORINTERNALIOCTLOTHERS)(void);
typedef int (*PFN_WDFMEMORYCREATE)(void);
typedef int (*PFN_WDFMEMORYCREATEPREALLOCATED)(void);
typedef int (*PFN_WDFMEMORYGETBUFFER)(void);
typedef int (*PFN_WDFMEMORYASSIGNBUFFER)(void);
typedef int (*PFN_WDFMEMORYCOPYTOBUFFER)(void);
typedef int (*PFN_WDFMEMORYCOPYFROMBUFFER)(void);
typedef int (*PFN_WDFLOOKASIDELISTCREATE)(void);
typedef int (*PFN_WDFMEMORYCREATEFROMLOOKASIDE)(void);
typedef int (*PFN_WDFDEVICEMINIPORTCREATE)(void);
typedef int (*PFN_WDFDRIVERMINIPORTUNLOAD)(void);
typedef int (*PFN_WDFOBJECTGETTYPEDCONTEXTWORKER)(void);
typedef int (*PFN_WDFOBJECTALLOCATECONTEXT)(void);
typedef int (*PFN_WDFOBJECTCONTEXTGETOBJECT)(void);
typedef int (*PFN_WDFOBJECTREFERENCEACTUAL)(void);
typedef int (*PFN_WDFOBJECTDEREFERENCEACTUAL)(void);
typedef int (*PFN_WDFOBJECTCREATE)(void);
typedef int (*PFN_WDFOBJECTDELETE)(void);
typedef int (*PFN_WDFOBJECTQUERY)(void);
typedef int (*PFN_WDFPDOINITALLOCATE)(void);
typedef int (*PFN_WDFPDOINITSETEVENTCALLBACKS)(void);
typedef int (*PFN_WDFPDOINITASSIGNDEVICEID)(void);
typedef int (*PFN_WDFPDOINITASSIGNINSTANCEID)(void);
typedef int (*PFN_WDFPDOINITADDHARDWAREID)(void);
typedef int (*PFN_WDFPDOINITADDCOMPATIBLEID)(void);
typedef int (*PFN_WDFPDOINITADDDEVICETEXT)(void);
typedef int (*PFN_WDFPDOINITSETDEFAULTLOCALE)(void);
typedef int (*PFN_WDFPDOINITASSIGNRAWDEVICE)(void);
typedef int (*PFN_WDFPDOMARKMISSING)(void);
typedef int (*PFN_WDFPDOREQUESTEJECT)(void);
typedef int (*PFN_WDFPDOGETPARENT)(void);
typedef int (*PFN_WDFPDORETRIEVEIDENTIFICATIONDESCRIPTION)(void);
typedef int (*PFN_WDFPDORETRIEVEADDRESSDESCRIPTION)(void);
typedef int (*PFN_WDFPDOUPDATEADDRESSDESCRIPTION)(void);
typedef int (*PFN_WDFPDOADDEJECTIONRELATIONSPHYSICALDEVICE)(void);
typedef int (*PFN_WDFPDOREMOVEEJECTIONRELATIONSPHYSICALDEVICE)(void);
typedef int (*PFN_WDFPDOCLEAREJECTIONRELATIONSDEVICES)(void);
typedef int (*PFN_WDFDEVICEADDQUERYINTERFACE)(void);
typedef int (*PFN_WDFREGISTRYOPENKEY)(void);
typedef int (*PFN_WDFREGISTRYCREATEKEY)(void);
typedef int (*PFN_WDFREGISTRYCLOSE)(void);
typedef int (*PFN_WDFREGISTRYWDMGETHANDLE)(void);
typedef int (*PFN_WDFREGISTRYREMOVEKEY)(void);
typedef int (*PFN_WDFREGISTRYREMOVEVALUE)(void);
typedef int (*PFN_WDFREGISTRYQUERYVALUE)(void);
typedef int (*PFN_WDFREGISTRYQUERYMEMORY)(void);
typedef int (*PFN_WDFREGISTRYQUERYMULTISTRING)(void);
typedef int (*PFN_WDFREGISTRYQUERYUNICODESTRING)(void);
typedef int (*PFN_WDFREGISTRYQUERYSTRING)(void);
typedef int (*PFN_WDFREGISTRYQUERYULONG)(void);
typedef int (*PFN_WDFREGISTRYASSIGNVALUE)(void);
typedef int (*PFN_WDFREGISTRYASSIGNMEMORY)(void);
typedef int (*PFN_WDFREGISTRYASSIGNMULTISTRING)(void);
typedef int (*PFN_WDFREGISTRYASSIGNUNICODESTRING)(void);
typedef int (*PFN_WDFREGISTRYASSIGNSTRING)(void);
typedef int (*PFN_WDFREGISTRYASSIGNULONG)(void);
typedef int (*PFN_WDFREQUESTCREATE)(void);
typedef int (*PFN_WDFREQUESTCREATEFROMIRP)(void);
typedef int (*PFN_WDFREQUESTREUSE)(void);
typedef int (*PFN_WDFREQUESTCHANGETARGET)(void);
typedef int (*PFN_WDFREQUESTFORMATREQUESTUSINGCURRENTTYPE)(void);
typedef int (*PFN_WDFREQUESTWDMFORMATUSINGSTACKLOCATION)(void);
typedef int (*PFN_WDFREQUESTSEND)(void);
typedef int (*PFN_WDFREQUESTGETSTATUS)(void);
typedef int (*PFN_WDFREQUESTMARKCANCELABLE)(void);
typedef int (*PFN_WDFREQUESTUNMARKCANCELABLE)(void);
typedef int (*PFN_WDFREQUESTISCANCELED)(void);
typedef int (*PFN_WDFREQUESTCANCELSENTREQUEST)(void);
typedef int (*PFN_WDFREQUESTISFROM32BITPROCESS)(void);
typedef int (*PFN_WDFREQUESTSETCOMPLETIONROUTINE)(void);
typedef int (*PFN_WDFREQUESTGETCOMPLETIONPARAMS)(void);
typedef int (*PFN_WDFREQUESTALLOCATETIMER)(void);
typedef int (*PFN_WDFREQUESTCOMPLETE)(void);
typedef int (*PFN_WDFREQUESTCOMPLETEWITHPRIORITYBOOST)(void);
typedef int (*PFN_WDFREQUESTCOMPLETEWITHINFORMATION)(void);
typedef int (*PFN_WDFREQUESTGETPARAMETERS)(void);
typedef int (*PFN_WDFREQUESTRETRIEVEINPUTMEMORY)(void);
typedef int (*PFN_WDFREQUESTRETRIEVEOUTPUTMEMORY)(void);
typedef int (*PFN_WDFREQUESTRETRIEVEINPUTBUFFER)(void);
typedef int (*PFN_WDFREQUESTRETRIEVEOUTPUTBUFFER)(void);
typedef int (*PFN_WDFREQUESTRETRIEVEINPUTWDMMDL)(void);
typedef int (*PFN_WDFREQUESTRETRIEVEOUTPUTWDMMDL)(void);
typedef int (*PFN_WDFREQUESTRETRIEVEUNSAFEUSERINPUTBUFFER)(void);
typedef int (*PFN_WDFREQUESTRETRIEVEUNSAFEUSEROUTPUTBUFFER)(void);
typedef int (*PFN_WDFREQUESTSETINFORMATION)(void);
typedef int (*PFN_WDFREQUESTGETINFORMATION)(void);
typedef int (*PFN_WDFREQUESTGETFILEOBJECT)(void);
typedef int (*PFN_WDFREQUESTPROBEANDLOCKUSERBUFFERFORREAD)(void);
typedef int (*PFN_WDFREQUESTPROBEANDLOCKUSERBUFFERFORWRITE)(void);
typedef int (*PFN_WDFREQUESTGETREQUESTORMODE)(void);
typedef int (*PFN_WDFREQUESTFORWARDTOIOQUEUE)(void);
typedef int (*PFN_WDFREQUESTGETIOQUEUE)(void);
typedef int (*PFN_WDFREQUESTREQUEUE)(void);
typedef int (*PFN_WDFREQUESTSTOPACKNOWLEDGE)(void);
typedef int (*PFN_WDFREQUESTWDMGETIRP)(void);
typedef int (*PFN_WDFIORESOURCEREQUIREMENTSLISTSETSLOTNUMBER)(void);
typedef int (*PFN_WDFIORESOURCEREQUIREMENTSLISTSETINTERFACETYPE)(void);
typedef int (*PFN_WDFIORESOURCEREQUIREMENTSLISTAPPENDIORESLIST)(void);
typedef int (*PFN_WDFIORESOURCEREQUIREMENTSLISTINSERTIORESLIST)(void);
typedef int (*PFN_WDFIORESOURCEREQUIREMENTSLISTGETCOUNT)(void);
typedef int (*PFN_WDFIORESOURCEREQUIREMENTSLISTGETIORESLIST)(void);
typedef int (*PFN_WDFIORESOURCEREQUIREMENTSLISTREMOVE)(void);
typedef int (*PFN_WDFIORESOURCEREQUIREMENTSLISTREMOVEBYIORESLIST)(void);
typedef int (*PFN_WDFIORESOURCELISTCREATE)(void);
typedef int (*PFN_WDFIORESOURCELISTAPPENDDESCRIPTOR)(void);
typedef int (*PFN_WDFIORESOURCELISTINSERTDESCRIPTOR)(void);
typedef int (*PFN_WDFIORESOURCELISTUPDATEDESCRIPTOR)(void);
typedef int (*PFN_WDFIORESOURCELISTGETCOUNT)(void);
typedef int (*PFN_WDFIORESOURCELISTGETDESCRIPTOR)(void);
typedef int (*PFN_WDFIORESOURCELISTREMOVE)(void);
typedef int (*PFN_WDFIORESOURCELISTREMOVEBYDESCRIPTOR)(void);
typedef int (*PFN_WDFCMRESOURCELISTAPPENDDESCRIPTOR)(void);
typedef int (*PFN_WDFCMRESOURCELISTINSERTDESCRIPTOR)(void);
typedef int (*PFN_WDFCMRESOURCELISTGETCOUNT)(void);
typedef int (*PFN_WDFCMRESOURCELISTGETDESCRIPTOR)(void);
typedef int (*PFN_WDFCMRESOURCELISTREMOVE)(void);
typedef int (*PFN_WDFCMRESOURCELISTREMOVEBYDESCRIPTOR)(void);
typedef int (*PFN_WDFSTRINGCREATE)(void);
typedef int (*PFN_WDFSTRINGGETUNICODESTRING)(void);
typedef int (*PFN_WDFOBJECTACQUIRELOCK)(void);
typedef int (*PFN_WDFOBJECTRELEASELOCK)(void);
typedef int (*PFN_WDFWAITLOCKCREATE)(void);
typedef int (*PFN_WDFWAITLOCKACQUIRE)(void);
typedef int (*PFN_WDFWAITLOCKRELEASE)(void);
typedef int (*PFN_WDFSPINLOCKCREATE)(void);
typedef int (*PFN_WDFSPINLOCKACQUIRE)(void);
typedef int (*PFN_WDFSPINLOCKRELEASE)(void);
typedef int (*PFN_WDFTIMERCREATE)(void);
typedef int (*PFN_WDFTIMERSTART)(void);
typedef int (*PFN_WDFTIMERSTOP)(void);
typedef int (*PFN_WDFTIMERGETPARENTOBJECT)(void);
typedef int (*PFN_WDFUSBTARGETDEVICECREATE)(void);
typedef int (*PFN_WDFUSBTARGETDEVICERETRIEVEINFORMATION)(void);
typedef int (*PFN_WDFUSBTARGETDEVICEGETDEVICEDESCRIPTOR)(void);
typedef int (*PFN_WDFUSBTARGETDEVICERETRIEVECONFIGDESCRIPTOR)(void);
typedef int (*PFN_WDFUSBTARGETDEVICEQUERYSTRING)(void);
typedef int (*PFN_WDFUSBTARGETDEVICEALLOCANDQUERYSTRING)(void);
typedef int (*PFN_WDFUSBTARGETDEVICEFORMATREQUESTFORSTRING)(void);
typedef int (*PFN_WDFUSBTARGETDEVICEGETNUMINTERFACES)(void);
typedef int (*PFN_WDFUSBTARGETDEVICESELECTCONFIG)(void);
typedef int (*PFN_WDFUSBTARGETDEVICEWDMGETCONFIGURATIONHANDLE)(void);
typedef int (*PFN_WDFUSBTARGETDEVICERETRIEVECURRENTFRAMENUMBER)(void);
typedef int (*PFN_WDFUSBTARGETDEVICESENDCONTROLTRANSFERSYNCHRONOUSLY)(void);
typedef int (*PFN_WDFUSBTARGETDEVICEFORMATREQUESTFORCONTROLTRANSFER)(void);
typedef int (*PFN_WDFUSBTARGETDEVICEISCONNECTEDSYNCHRONOUS)(void);
typedef int (*PFN_WDFUSBTARGETDEVICERESETPORTSYNCHRONOUSLY)(void);
typedef int (*PFN_WDFUSBTARGETDEVICECYCLEPORTSYNCHRONOUSLY)(void);
typedef int (*PFN_WDFUSBTARGETDEVICEFORMATREQUESTFORCYCLEPORT)(void);
typedef int (*PFN_WDFUSBTARGETDEVICESENDURBSYNCHRONOUSLY)(void);
typedef int (*PFN_WDFUSBTARGETDEVICEFORMATREQUESTFORURB)(void);
typedef int (*PFN_WDFUSBTARGETPIPEGETINFORMATION)(void);
typedef int (*PFN_WDFUSBTARGETPIPEISINENDPOINT)(void);
typedef int (*PFN_WDFUSBTARGETPIPEISOUTENDPOINT)(void);
typedef int (*PFN_WDFUSBTARGETPIPEGETTYPE)(void);
typedef int (*PFN_WDFUSBTARGETPIPESETNOMAXIMUMPACKETSIZECHECK)(void);
typedef int (*PFN_WDFUSBTARGETPIPEWRITESYNCHRONOUSLY)(void);
typedef int (*PFN_WDFUSBTARGETPIPEFORMATREQUESTFORWRITE)(void);
typedef int (*PFN_WDFUSBTARGETPIPEREADSYNCHRONOUSLY)(void);
typedef int (*PFN_WDFUSBTARGETPIPEFORMATREQUESTFORREAD)(void);
typedef int (*PFN_WDFUSBTARGETPIPECONFIGCONTINUOUSREADER)(void);
typedef int (*PFN_WDFUSBTARGETPIPEABORTSYNCHRONOUSLY)(void);
typedef int (*PFN_WDFUSBTARGETPIPEFORMATREQUESTFORABORT)(void);
typedef int (*PFN_WDFUSBTARGETPIPERESETSYNCHRONOUSLY)(void);
typedef int (*PFN_WDFUSBTARGETPIPEFORMATREQUESTFORRESET)(void);
typedef int (*PFN_WDFUSBTARGETPIPESENDURBSYNCHRONOUSLY)(void);
typedef int (*PFN_WDFUSBTARGETPIPEFORMATREQUESTFORURB)(void);
typedef int (*PFN_WDFUSBINTERFACEGETINTERFACENUMBER)(void);
typedef int (*PFN_WDFUSBINTERFACEGETNUMENDPOINTS)(void);
typedef int (*PFN_WDFUSBINTERFACEGETDESCRIPTOR)(void);
typedef int (*PFN_WDFUSBINTERFACESELECTSETTING)(void);
typedef int (*PFN_WDFUSBINTERFACEGETENDPOINTINFORMATION)(void);
typedef int (*PFN_WDFUSBTARGETDEVICEGETINTERFACE)(void);
typedef int (*PFN_WDFUSBINTERFACEGETCONFIGUREDSETTINGINDEX)(void);
typedef int (*PFN_WDFUSBINTERFACEGETNUMCONFIGUREDPIPES)(void);
typedef int (*PFN_WDFUSBINTERFACEGETCONFIGUREDPIPE)(void);
typedef int (*PFN_WDFUSBTARGETPIPEWDMGETPIPEHANDLE)(void);
typedef int (*PFN_WDFVERIFIERDBGBREAKPOINT)(void);
typedef int (*PFN_WDFVERIFIERKEBUGCHECK)(void);
typedef int (*PFN_WDFWMIPROVIDERCREATE)(void);
typedef int (*PFN_WDFWMIPROVIDERGETDEVICE)(void);
typedef int (*PFN_WDFWMIPROVIDERISENABLED)(void);
typedef int (*PFN_WDFWMIPROVIDERGETTRACINGHANDLE)(void);
typedef int (*PFN_WDFWMIINSTANCECREATE)(void);
typedef int (*PFN_WDFWMIINSTANCEREGISTER)(void);
typedef int (*PFN_WDFWMIINSTANCEDEREGISTER)(void);
typedef int (*PFN_WDFWMIINSTANCEGETDEVICE)(void);
typedef int (*PFN_WDFWMIINSTANCEGETPROVIDER)(void);
typedef int (*PFN_WDFWMIINSTANCEFIREEVENT)(void);
typedef int (*PFN_WDFWORKITEMCREATE)(void);
typedef int (*PFN_WDFWORKITEMENQUEUE)(void);
typedef int (*PFN_WDFWORKITEMGETPARENTOBJECT)(void);
typedef int (*PFN_WDFWORKITEMFLUSH)(void);
typedef int (*PFN_WDFCOMMONBUFFERCREATEWITHCONFIG)(void);
typedef int (*PFN_WDFDMAENABLERGETFRAGMENTLENGTH)(void);
typedef int (*PFN_WDFDMAENABLERWDMGETDMAADAPTER)(void);
typedef int (*PFN_WDFUSBINTERFACEGETNUMSETTINGS)(void);
typedef int (*PFN_WDFDEVICEREMOVEDEPENDENTUSAGEDEVICEOBJECT)(void);
typedef int (*PFN_WDFDEVICEGETSYSTEMPOWERACTION)(void);
typedef int (*PFN_WDFINTERRUPTSETEXTENDEDPOLICY)(void);
typedef int (*PFN_WDFIOQUEUEASSIGNFORWARDPROGRESSPOLICY)(void);
typedef int (*PFN_WDFPDOINITASSIGNCONTAINERID)(void);
typedef int (*PFN_WDFPDOINITALLOWFORWARDINGREQUESTTOPARENT)(void);
typedef int (*PFN_WDFREQUESTMARKCANCELABLEEX)(void);
typedef int (*PFN_WDFREQUESTISRESERVED)(void);
typedef int (*PFN_WDFREQUESTFORWARDTOPARENTDEVICEIOQUEUE)(void);
typedef int (*PFN_WDFCXDEVICEINITALLOCATE)(void);
typedef int (*PFN_WDFCXDEVICEINITASSIGNWDMIRPPREPROCESSCALLBACK)(void);
typedef int (*PFN_WDFCXDEVICEINITSETIOINCALLERCONTEXTCALLBACK)(void);
typedef int (*PFN_WDFCXDEVICEINITSETREQUESTATTRIBUTES)(void);
typedef int (*PFN_WDFCXDEVICEINITSETFILEOBJECTCONFIG)(void);
typedef int (*PFN_WDFDEVICEWDMDISPATCHIRP)(void);
typedef int (*PFN_WDFDEVICEWDMDISPATCHIRPTOIOQUEUE)(void);
typedef int (*PFN_WDFDEVICEINITSETREMOVELOCKOPTIONS)(void);
typedef int (*PFN_WDFDEVICECONFIGUREWDMIRPDISPATCHCALLBACK)(void);
typedef int (*PFN_WDFDMAENABLERCONFIGURESYSTEMPROFILE)(void);
typedef int (*PFN_WDFDMATRANSACTIONINITIALIZEUSINGOFFSET)(void);
typedef int (*PFN_WDFDMATRANSACTIONGETTRANSFERINFO)(void);
typedef int (*PFN_WDFDMATRANSACTIONSETCHANNELCONFIGURATIONCALLBACK)(void);
typedef int (*PFN_WDFDMATRANSACTIONSETTRANSFERCOMPLETECALLBACK)(void);
typedef int (*PFN_WDFDMATRANSACTIONSETIMMEDIATEEXECUTION)(void);
typedef int (*PFN_WDFDMATRANSACTIONALLOCATERESOURCES)(void);
typedef int (*PFN_WDFDMATRANSACTIONSETDEVICEADDRESSOFFSET)(void);
typedef int (*PFN_WDFDMATRANSACTIONFREERESOURCES)(void);
typedef int (*PFN_WDFDMATRANSACTIONCANCEL)(void);
typedef int (*PFN_WDFDMATRANSACTIONWDMGETTRANSFERCONTEXT)(void);
typedef int (*PFN_WDFINTERRUPTQUEUEWORKITEMFORISR)(void);
typedef int (*PFN_WDFINTERRUPTTRYTOACQUIRELOCK)(void);
typedef int (*PFN_WDFIOQUEUESTOPANDPURGE)(void);
typedef int (*PFN_WDFIOQUEUESTOPANDPURGESYNCHRONOUSLY)(void);
typedef int (*PFN_WDFIOTARGETPURGE)(void);
typedef int (*PFN_WDFUSBTARGETDEVICECREATEWITHPARAMETERS)(void);
typedef int (*PFN_WDFUSBTARGETDEVICEQUERYUSBCAPABILITY)(void);
typedef int (*PFN_WDFUSBTARGETDEVICECREATEURB)(void);
typedef int (*PFN_WDFUSBTARGETDEVICECREATEISOCHURB)(void);
typedef int (*PFN_WDFDEVICEWDMASSIGNPOWERFRAMEWORKSETTINGS)(void);
typedef int (*PFN_WDFDMATRANSACTIONSTOPSYSTEMTRANSFER)(void);
typedef int (*PFN_WDFCXVERIFIERKEBUGCHECK)(void);
typedef int (*PFN_WDFINTERRUPTREPORTACTIVE)(void);
typedef int (*PFN_WDFINTERRUPTREPORTINACTIVE)(void);
typedef int (*PFN_WDFDEVICEINITSETRELEASEHARDWAREORDERONFAILURE)(void);
typedef int (*PFN_WDFGETTRIAGEINFO)(void);
typedef int (*PFN_WDFDEVICEINITSETIOTYPEEX)(void);
typedef int (*PFN_WDFDEVICEQUERYPROPERTYEX)(void);
typedef int (*PFN_WDFDEVICEALLOCANDQUERYPROPERTYEX)(void);
typedef int (*PFN_WDFDEVICEASSIGNPROPERTY)(void);
typedef int (*PFN_WDFFDOINITQUERYPROPERTYEX)(void);
typedef int (*PFN_WDFFDOINITALLOCANDQUERYPROPERTYEX)(void);
typedef int (*PFN_WDFDEVICESTOPIDLEACTUAL)(void);
typedef int (*PFN_WDFDEVICERESUMEIDLEACTUAL)(void);
typedef int (*PFN_WDFDEVICEGETSELFIOTARGET)(void);
typedef int (*PFN_WDFDEVICEINITALLOWSELFIOTARGET)(void);
typedef int (*PFN_WDFIOTARGETSELFASSIGNDEFAULTIOQUEUE)(void);
typedef int (*PFN_WDFDEVICEOPENDEVICEMAPKEY)(void);
typedef int (*PFN_WDFDMATRANSACTIONSETSINGLETRANSFERREQUIREMENT)(void);
typedef int (*PFN_WDFCXDEVICEINITSETPNPPOWEREVENTCALLBACKS)(void);
typedef int (*PFN_WDFFILEOBJECTGETINITIATORPROCESSID)(void);
typedef int (*PFN_WDFREQUESTGETREQUESTORPROCESSID)(void);
typedef int (*PFN_WDFDEVICERETRIEVECOMPANIONTARGET)(void);
typedef int (*PFN_WDFCOMPANIONTARGETSENDTASKSYNCHRONOUSLY)(void);
typedef int (*PFN_WDFCOMPANIONTARGETWDMGETCOMPANIONPROCESS)(void);
typedef int (*PFN_WDFDRIVEROPENPERSISTENTSTATEREGISTRYKEY)(void);
typedef int (*PFN_WDFDRIVERERRORREPORTAPIMISSING)(void);
typedef int (*PFN_WDFPDOINITREMOVEPOWERDEPENDENCYONPARENT)(void);
typedef int (*PFN_WDFCXDEVICEINITALLOCATECONTEXT)(void);
typedef int (*PFN_WDFCXDEVICEINITGETTYPEDCONTEXTWORKER)(void);
typedef int (*PFN_WDFCXDEVICEINITSETPOWERPOLICYEVENTCALLBACKS)(void);
typedef int (*PFN_WDFDEVICESETDEVICEINTERFACESTATEEX)(void);

```

`wdf_til_creation/include/wdf_base.h`:

```h
/*
** This header contains necessary defines and typedefs the absence of which
** would prevent tilib from generating the til files.
**
** Some of those defines and typedefs are from system headers which are not
** included in the wdf headers, or from wdf but without the proper includes
** or a bad order.
**
** Most wdf headers are automatically generated and the order of dependance
** might not be very rigorous.
**
** Besides, tilib allow a base .til to be used, but only one, and no .til
** contains everything necessary.
**
** Some of the definitions here are incomplete (simplified as void * for
** instance), but what counts is their proper definition for tilib to complete
** the .til creation.
*/


#define FORCEINLINE
#define __inline
#define WDFEXPORT(a) imp_ ## a
#define VFWDFEXPORT(a) imp_Vf ## a

typedef unsigned int size_t;

typedef enum {
    DmaComplete,
    DmaAborted,
    DmaError,
    DmaCancelled
} DMA_COMPLETION_STATUS;

typedef struct _GROUP_AFFINITY {
    int Mask;
    USHORT Group;
    USHORT Reserved[3];
} GROUP_AFFINITY, *PGROUP_AFFINITY;


DECLARE_HANDLE( WDFCOMPANIONTARGET );

typedef ULONG_PTR KAFFINITY;
typedef ULONG WDF_MAJOR_VERSION;
typedef ULONG WDF_MINOR_VERSION;
typedef ULONG WDF_BUILD_NUMBER;
typedef PVOID WDF_COMPONENT_GLOBALS, *PWDF_COMPONENT_GLOBALS;
typedef HANDLE POHANDLE;

typedef void* PPO_FX_COMPONENT_IDLE_STATE;
typedef void* PO_FX_COMPONENT_V1;
typedef void* PO_FX_COMPONENT_V2;
typedef void* PPO_FX_COMPONENT_ACTIVE_CONDITION_CALLBACK;
typedef void* PPO_FX_COMPONENT_IDLE_CONDITION_CALLBACK;
typedef void* PPO_FX_COMPONENT_IDLE_STATE_CALLBACK;
typedef void* PPO_FX_COMPONENT;
typedef void* PPO_FX_DEVICE_POWER_NOT_REQUIRED_CALLBACK;
typedef void* PPO_FX_DEVICE_POWER_REQUIRED_CALLBACK;
typedef void* PPO_FX_POWER_CONTROL_CALLBACK;

typedef int (*PWDFCX_FILEOBJECT_CONFIG)(void);
typedef int (*PWDFCX_PNPPOWER_EVENT_CALLBACKS)(void);


typedef int (*PFN_WDFCX_DEVICE_FILE_CREATE)(void);
typedef int (*PFN_WDFDEVICE_WDM_POST_PO_FX_REGISTER_DEVICE)(void);
typedef int (*PFN_WDFDEVICE_WDM_PRE_PO_FX_UNREGISTER_DEVICE)(void);
typedef int (*PFN_WDFCXDEVICE_WDM_IRP_PREPROCESS)(void);
typedef int (*PFN_WDF_CLASS_EXTENSIONIN_BIND)(void);
typedef int (*PFN_WDF_CLASS_EXTENSIONIN_UNBIND)(void);
typedef int (*PFN_WDF_CLASS_EXPORT)(void);
typedef int (*PFN_WDF_CLIENT_BIND_CLASS)(void);
typedef int (*PFN_WDF_CLIENT_UNBIND_CLASS)(void);
typedef int (*PFN_WDF_CLASS_LIBRARY_INITIALIZE)(void);
typedef int (*PFN_WDF_CLASS_LIBRARY_DEINITIALIZE)(void);
typedef int (*PFN_WDF_CLASS_LIBRARY_BIND_CLIENT)(void);
typedef int (*PFN_WDF_CLASS_LIBRARY_UNBIND_CLIENT)(void);

```

`wdf_til_creation/include/wdf_global_header.h`:

```h
#include "wdf_base.h"
#include "generated_pfn.h"
#include "sdkddkver.h"
#include "wdf.h"
#include "wdfassert.h"
#include "wdfbugcodes.h"
#include "wdfchildlist.h"
#include "wdfcollection.h"
#include "wdfcommonbuffer.h"
#include "wdfcompaniontarget.h"
#include "wdfcontrol.h"
#include "wdfcore.h"
#include "wdfdevice.h"
#include "wdfdmaenabler.h"
#include "wdfdmatransaction.h"
#include "wdfdpc.h"
#include "wdfdriver.h"
#include "wdffdo.h"
#include "wdffileobject.h"
#include "wdffuncenum.h"
#include "wdfglobals.h"
#include "wdfhwaccess.h"
#include "wdfinstaller.h"
#include "wdfinterrupt.h"
#include "wdfio.h"
#include "wdfiotarget.h"
#include "wdfmemory.h"
#include "wdfminiport.h"
#include "wdfobject.h"
#include "wdfpdo.h"
#include "wdfpool.h"
#include "wdfqueryinterface.h"
#include "wdfregistry.h"
#include "wdfrequest.h"
#include "wdfresource.h"
#include "wdfroletypes.h"
#include "wdfstatus.h"
#include "wdfstring.h"
#include "wdfsync.h"
#include "wdftimer.h"
#include "wdftraceenums.h"
#include "wdftypes.h"
#include "wdfusb.h"
#include "wdfverifier.h"
#include "wdfwmi.h"
#include "wdfworkitem.h"
#include "fxldr.h"
#include "device_common.h"
#include "fxglobalsum.h"
#include "fxverifierum.h"
#include "ufxverifier.h"
#include "umusb.h"
#include "wdffileobject_private.h"
#include "fxbugcheck.h"
#include "fxdynamics.h"
#include "fxdynamicswrapper.h"
#include "fxlibrarycommon.h"
#include "fxprobeandlock.h"

```

`wdf_til_creation/include/wdfldr.h`:

```h
/*
** This header is empty, but its presence is necessary because
** it is included by one of the wdf headers, even though apparently
** not used, or its original content is already present in other headers.
**
** Either way, without it, tilib returns an error and the .til is not
** generated.
*/
```

`wdf_til_creation/wdf_til_creator.py`:

```py
import inspect
import os
import subprocess
import sys

import ida_loader
import idaapi
import idc

FILE_PATH = inspect.getsourcefile(lambda: 0)
ROOT_DIR = os.path.dirname(os.path.abspath(FILE_PATH))

GLOBAL_HEADER = os.path.join(ROOT_DIR, "include", "wdf_global_header.h")
PFN_HEADER = os.path.join(ROOT_DIR, "include", "generated_pfn.h")

IDA_DIR = ida_dir = idc.idadir()


def import_types_to_change(wdf_til):
    """
    This function imports locally the types we want to change.
    The import seems mandatory if we want to access and thus modify
    their declaration.
    """

    name = idaapi.first_named_type(wdf_til, idaapi.NTF_TYPE)
    while name is not None:
        if "PFN_" in name:
            idaapi.import_type(wdf_til, -1, name, idaapi.IMPTYPE_OVERRIDE)

        name = idaapi.next_named_type(wdf_til, name, idaapi.NTF_TYPE)


def create_ntstatus64(wdf_til) -> bool:
    """
    Many WDF functions return an NTSTATUS type (4 btyes).
    In 64 bit mode, IDA will mistakenly set return types to 8 bytes.
    Because of that, our prototypes won't match what IDA has infered
    and a cast will be present.

    To avoid this cast while still having the information about  the
    NTSTATUS return type, we create an NTSTATUS64 (8 byes) which will
    remove the cast.
    """

    strtype = "typedef __int64 NTSTATUS64;"
    tif = idaapi.tinfo_t()
    idaapi.parse_decl(tif, None, strtype, 0)

    ok = tif.set_named_type(wdf_til, "NTSTATUS64", idaapi.NTF_REPLACE)
    if ok != idaapi.TERR_OK:
        print("Couldn't load modified type NTSTATUS64")
        return False

    # No need to import it locally, parse_decl() uses wdf_til as a base
    return True


def get_local_types():
    """
    This is an iterator to get all local types with their tinfo and
    associated data.
    """

    idati = idaapi.get_idati()
    ord_qty = idaapi.get_ordinal_qty(idati)
    ord_qty = 0 if ord_qty == 0xFFFFFFFF else ord_qty

    for ordinal in range(1, ord_qty):
        tinfo = idaapi.tinfo_t()

        ok = tinfo.get_numbered_type(idati, ordinal)
        if not ok:
            continue

        typeof, fields = idaapi.idc_get_local_type_raw(ordinal)
        if not typeof:
            continue

        yield tinfo, typeof, fields


def fix_local_type(wdf_til, tinfo, typeof, fields, ntstatus64: bool) -> bool:
    """
    This function adds the __fastcall convention to the function
    pointers.
    The ntstatus64 bool replace the NTSTATUS return
    types by NTSTATUS64 types to keep some of the information and
    remove all casts.
    """

    name = f"{tinfo}"
    flags = idaapi.PRTYPE_MULTI | idaapi.PRTYPE_TYPE
    strtype = idaapi.idc_print_type(typeof, fields, name, flags)
    idati = idaapi.get_idati()

    if strtype is not None and "(*PFN_" in strtype:

        if ntstatus64:
            strtype = strtype.replace("typedef NTSTATUS", "typedef NTSTATUS64")

        strtype = strtype.replace("(*PFN_", "(__fastcall *PFN_")
        strtype = strtype.replace("\n", ";")

        next_tif = idaapi.tinfo_t()

        ok = idaapi.parse_decl(next_tif, wdf_til, strtype, 0)
        if not ok:
            print(f"Could not parse declaration {name} -> {strtype}")
            return False

        ok = next_tif.set_named_type(wdf_til, name, idaapi.NTF_REPLACE)
        if ok != idaapi.TERR_OK:
            print(f"Couldn't load modified type {name} -> {strtype}")
            return False

        # Delete local type so that it can be overwritten upon reloading the .til
        idaapi.del_named_type(idati, name, idaapi.NTF_TYPE)

    return True


def modify_til(
    til_filename: str, is_64bit: bool, avoid_ida_casts: bool, wdf_til
) -> bool:
    """
    This function will import and change the WDF function pointer types
    of a given til and overwrite the old til with the new declarations.
    """
    ntstatus64 = is_64bit and avoid_ida_casts
    if ntstatus64:
        avoid_ida_casts = create_ntstatus64(wdf_til)

    import_types_to_change(wdf_til)

    for tinfo, typeof, fields in get_local_types():
        ok = fix_local_type(wdf_til, tinfo, typeof, fields, ntstatus64)
        if not ok:
            print(f"Could not change {tinfo}.")

    # The original til will be overwritten by its new version.
    ok = idaapi.store_til(wdf_til, None, til_filename)
    return ok


def polish_til(til_filename: str, is_64bit: bool, avoid_ida_casts: bool) -> bool:
    """
    This function changes all WDF function pointer types to avoid
    IDA casts. By default, it only adds the fastcall convention.

    On 64bit, IDA might set all return values to __int64, even those
    with 32 bit return type (NTSTATUS). The optionnal argument --no_casts
    creates a fake type NTSATUS64 which will be treated as an __int64
    and apply it to the WDF function.

    This new type is factually wrong, but will avoid all casts while still
    offering the information of the NTSTATUS return type, and is meant for
    better readability during the analysis.
    """

    wdf_til = idaapi.load_til(til_filename)
    if wdf_til is None:
        print(f"Error, couldn't load til {til_filename}.")
        return False

    ok = modify_til(til_filename, is_64bit, avoid_ida_casts, wdf_til)
    if not ok:
        print(f"Error: couldn't modify til {til_filename}.")
        return False

    return True


def validate_til(til_filepath: str) -> bool:
    wdf_til = idaapi.load_til(til_filepath)
    if wdf_til is None:
        print("Error, couldn't load til")
        return False

    bind_info_present = False
    wdf_functions_present = False

    name = idaapi.first_named_type(wdf_til, idaapi.NTF_TYPE)
    while name is not None:
        if name == "WDF_BIND_INFO":
            bind_info_present = True

        elif name == "WDFFUNCTIONS":
            wdf_functions_present = True

        name = idaapi.next_named_type(wdf_til, name, idaapi.NTF_TYPE)

    return bind_info_present and wdf_functions_present


def check_missing_files(*args):
    missing = []

    for file in args:
        if not os.path.exists(file):
            missing.append(file)

    return missing


def create_til(
    til_filepath: str,
    wdf_dir: str,
    wdk_dir: str,
    version: str,
    version_dir: str,
    is_64bit: bool,
    debug: bool,
) -> bool:
    """
    Create a global header with all necessary includes, and launch tilib
    as a subprocess to create a til.
    """

    create_global_header(wdf_dir, version, version_dir)

    if is_64bit:
        tilib = "tilib64.exe" if os.name == "nt" else "tilib64"
    else:
        tilib = "tilib.exe" if os.name == "nt" else "tilib"

    tilib_path = os.path.join(IDA_DIR, tilib)

    if not os.path.exists(tilib_path):
        print(f"Error, could not find tilib binary at {tilib_path}. Is it installed?")
        return False

    wdm_til = os.path.join(IDA_DIR, "til", "pc", "wdm.til")
    fx_dir = os.path.join(
        wdf_dir, "src", "framework", "shared", "inc", "private", "common"
    )
    kmdf_dir = os.path.join(wdf_dir, "src", "framework", "kmdf", "inc", "private")
    wdf_um_dir = os.path.join(
        wdf_dir, "src", "framework", "shared", "inc", "private", "um"
    )
    wdk_shared_dir = os.path.join(wdk_dir, "shared")
    wdk_km_dir = os.path.join(wdk_dir, "km")
    wdk_um_dir = os.path.join(wdk_dir, "um")

    missing = check_missing_files(
        fx_dir, kmdf_dir, wdk_shared_dir, wdk_km_dir, wdk_um_dir, wdf_um_dir, wdm_til
    )
    if missing != []:
        print(
            "Error, some necessary include files are missing, please check your includes."
        )
        print("Missing files and directories:")
        for file in missing:
            print(file)
        return False

    tilib_args = [
        tilib_path,
        "-c",  # Create til
        f"-I{version_dir}",  # Include directories
        f"-I{fx_dir}",
        f"-I{kmdf_dir}",
        f"-I{wdk_shared_dir}",
        f"-I{wdk_km_dir}",
        f"-I{wdf_um_dir}",
        f"-I{wdk_um_dir}",
        f"-I{os.path.join(ROOT_DIR, 'include')}",
        f"-h{GLOBAL_HEADER}",  # Header to parse
        f"-b{wdm_til}",  # Base til
        "-e",  # Ignore errors
        "-R",  # Allow redeclarations
        "-Cc1",  # Visual C++ compiler
        f"{til_filepath}",  # Output file,
    ]

    try:
        if debug:
            f = open(f"wdf_{version}_debug", "w")
            subprocess.check_call(tilib_args, stdout=f)

        else:
            subprocess.check_output(
                tilib_args
            )  # I want to display output only on exceptions.

    except subprocess.CalledProcessError as err:
        print(
            f"Failed to create til for WDF version {version}\n{err.output.decode()}",
            end="",
        )
        return False

    return True


def create_global_header(wdf_dir: str, version: str, version_dir: str):
    """
    Tilib can only parse one header file at a time. This function will
    create a global header containing all the necessary includes in order
    to parse everything in one go.

    The headers wdf_base.h and generated_pfn.h are custom made with necessary
    types which are not included by the wdf headers or the base til wdm.til.
    """

    global_header = open(GLOBAL_HEADER, "w")
    global_header.write('#include "wdf_base.h"\n')
    global_header.write('#include "generated_pfn.h"\n')
    global_header.write('#include "sdkddkver.h"\n')  # Needed for wdfcore.h

    wdf_headers = os.path.join(version_dir)
    files = sorted(os.listdir(wdf_headers))
    for f in files:
        if f.endswith(".h"):
            global_header.write(f'#include "{f}"\n')

    global_header.write('#include "fxldr.h"\n')  # For the WdfVersionBind prototype

    um_headers = os.path.join(
        wdf_dir, "src", "framework", "shared", "inc", "private", "um"
    )
    files = sorted(os.listdir(um_headers))
    for f in files:
        if f.endswith(".h") and f != "fxldrum.h":
            global_header.write(f'#include "{f}"\n')

    fx_headers = os.path.join(wdf_dir, "src", "framework", "kmdf", "inc", "private")
    files = sorted(os.listdir(fx_headers))
    for f in files:
        if (
            f.startswith("fx")
            and f.endswith(".h")
            or f == f"wdf{version.replace('.', '')}.h"
        ):
            global_header.write(f'#include "{f}"\n')


def create_pfn_header(wdf_dir: str) -> bool:
    """
    This function will parse all PFN types in fxdynamics.h
    and put them in a header with a bsic type. Since there are
    several wdf versions but only one fxdynamics.h for all,
    having a base with all PFN typedefs will avoid incompatibilities
    and unknown types during the .til creation.
    """

    pfn_header = open(PFN_HEADER, "w")
    fxdynamics_header = os.path.join(
        wdf_dir, "src", "framework", "kmdf", "inc", "private", "fxdynamics.h"
    )
    if not os.path.exists(fxdynamics_header):
        print(f"Error: missing necessary header {fxdynamics_header}")
        return False

    with open(fxdynamics_header, "r") as f:
        for line in f:
            split = line.split()

            # This simple heuristics will get the all the PFN types
            # used in the WDFFUNCTIONS struct
            if len(split) == 2 and split[1].startswith("pfnWdf"):
                pfn_header.write(f"typedef int (*{split[0]})(void);\n")

    return True


def make_til(
    version,
    version_dir,
    wdf_dir,
    wdk_dir,
    is_64bit,
    til_dir,
    avoid_ida_casts,
    debug=False,
) -> bool:
    if is_64bit:
        til_filename = f"wdf64-{version.replace('.', '-')}.til"
    else:
        til_filename = f"wdf-{version.replace('.', '-')}.til"

    til_filepath = os.path.join(til_dir, til_filename)
    arch = "64 bit" if is_64bit else "32 bit"

    ok = create_til(
        til_filepath,
        wdf_dir,
        wdk_dir,
        version,
        os.path.join(version_dir, version),
        is_64bit,
        debug,
    )
    if not ok:
        print(f"Could not create {arch} til for version {version}")
        return False

    print(f"Created {arch} til for version {version}")

    ok = validate_til(til_filepath)
    if not ok:
        print(
            f"Typelib is incomplete for {arch} version {version}.\nPerhaps some include files are missing.\nYou can try debug mode to have more logs."
        )
        return False
    polish_til(til_filepath, is_64bit, avoid_ida_casts)
    return True


def try_make_til(
    version,
    version_dir,
    wdf_dir,
    wdk_dir,
    is_64bit,
    til_dir,
    avoid_ida_casts,
    debug=False,
) -> bool:
    max_tries = 1 if idaapi.IDA_SDK_VERSION >= 750 else 16

    # IDA 7.4 and lower have memory bugs in their sdk which can throw exceptions during
    # the til creations. Those are rare but possible, so we try several times to make the
    # til before giving up.
    for i in range(max_tries):
        try:
            return make_til(
                version,
                version_dir,
                wdf_dir,
                wdk_dir,
                is_64bit,
                til_dir,
                avoid_ida_casts,
                debug,
            )
        except UnicodeDecodeError:
            continue

    print(f"Failed to create .til for verion {version} after {max_tries} tries")
    return False


def create_wdf_tils(
    wdf_dir: str,
    wdk_dir: str,
    til_dir: str = ROOT_DIR,
    avoid_ida_casts: bool = False,
) -> int:
    """
    This is the entry when used from IDA's GUI.
    It will create two .til for each version (32-bit and 64-bit).
    """

    ok = create_pfn_header(wdf_dir)
    if not ok:
        return 1

    nb_errors = 0
    version_dir = os.path.join(wdf_dir, "src", "publicinc", "wdf", "kmdf")

    for version in os.listdir(version_dir):
        for is_64bit in [False, True]:
            ok = try_make_til(
                version,
                version_dir,
                wdf_dir,
                wdk_dir,
                is_64bit,
                til_dir,
                avoid_ida_casts,
            )
            if not ok:
                nb_errors += 1

    return nb_errors


def main():
    """
    This script will parse the WDF sources in order to generate a .til for each
    version of it.

    The .til will then be polished for a better usage with IDA (__fastcall
    conventions will be added to function pointers for example).

    This is the entry from the command line script.
    """

    wdf_dir = os.path.join(ROOT_DIR, "dev", "WDF")
    wdk_dir = os.path.join(ROOT_DIR, "dev", "WDK")
    til_dir = os.path.abspath(os.path.join(ROOT_DIR, "..", "wdf_til"))

    try:
        os.mkdir(til_dir, 0o666)
    except FileExistsError:
        pass
    
    avoid_ida_casts = False
    debug = False
    for arg in idc.ARGV:
        if arg.startswith("--wdf"):
            wdf_dir = os.path.abspath(arg.split("=")[-1])
            if not os.path.exists(wdf_dir):
                print("\n\nInvalid path for WDF files\n\n")
                idc.qexit(1)
        elif arg.startswith("--wdk"):
            wdk_dir = os.path.abspath(arg.split("=")[-1])
            if not os.path.exists(wdk_dir):
                print("\n\nInvalid path for WDK headers\n\n")
                idc.qexit(1)
        elif arg.startswith("--til"):
            til_dir = os.path.abspath(arg.split("=")[-1])
            if not os.path.exists(til_dir):
                os.mkdir(til_dir, 0o666)
        elif arg == "--no_casts":
            avoid_ida_casts = True
        elif arg == "--debug":
            debug = True

    ok = create_pfn_header(wdf_dir)
    if not ok:
        idc.qexit(1)

    nb_errors = 0
    version_dir = os.path.join(wdf_dir, "src", "publicinc", "wdf", "kmdf")

    for version in os.listdir(version_dir):
        for is_64bit in [False, True]:
            ok = try_make_til(
                version,
                version_dir,
                wdf_dir,
                wdk_dir,
                is_64bit,
                til_dir,
                avoid_ida_casts,
                debug,
            )
            if not ok:
                nb_errors += 1

    ida_loader.set_database_flag(ida_loader.DBFL_KILL)  # Do not save database
    idc.qexit(nb_errors)


if __name__ == "__main__":
    main()

```

`wdfalyzer.py`:

```py
import inspect
import os
import subprocess
import sys

if "IDA_DIR" not in os.environ.keys():
    print("fatal: missing IDA_DIR environment variable")
    sys.exit(1)

ida_dir = os.path.abspath(os.environ["IDA_DIR"].strip('"\''))
ida_plugins_dir = os.path.abspath(os.path.join(ida_dir, "plugins"))
idat = "idat64.exe" if os.name == "nt" else "idat64"
idat_filepath = os.path.join(ida_dir, idat)

file_path = inspect.getsourcefile(lambda: 0)
root_dir = os.path.dirname(os.path.abspath(file_path))


def usage():
    print(
        f"Usage: \tpython {sys.argv[0]} analyze <file(s)> ... -> analyze WDF driver\
            \n\tpython {sys.argv[0]} make_til [--wdf=<wdf_dir>] [--wdk=<wdk_dir>] [--til=<til_dir>] [--no_casts] -> create .til files for WDF"
    )


def run_script(script: str):
    files = sys.argv[2:]

    if len(files) == 0:
        usage()
        return

    run_script = os.path.abspath(os.path.join(root_dir, "utils", "run_ida_script.py"))
    ida_script = os.path.abspath(os.path.join(root_dir, "wdf_plugin", script))

    for file in files:
        args = [sys.executable, run_script, file, ida_script]
        try:
            subprocess.check_call(args)
        except subprocess.CalledProcessError:
            print(f"Wdf analysis failed for {file}")
            sys.exit(1)
        print()


def analyze():
    run_script("wdf_analysis.py")


def make_til():

    file = file_path  # We do not need a real binary, so let's use this script

    if os.path.exists("til_creator_output.txt"):
        os.remove("til_creator_output.txt")

    til_creator = os.path.abspath(
        os.path.abspath(os.path.join(root_dir, "wdf_til_creation", "wdf_til_creator.py"))
    )
    script = f'"{til_creator}"'

    for arg in sys.argv[2:]:
        script += f' "{arg}"'

    idat_args = [idat_filepath, "-A", "-Ltil_creator_output.txt", f"-S{script}", file]

    try:
        subprocess.check_call(idat_args)
    except subprocess.CalledProcessError:
        print("Failed to create WDF typelibs. See til_creator_output.txt")
        sys.exit(1)

    with open("til_creator_output.txt", "r", encoding = "UTF-8") as f:
        for line in f:
            if line.startswith("Created"):
                print(line, end="")

options = {
    "analyze": analyze,
    "make_til": make_til,
}


def main():
    try:
        options[sys.argv[1]]()
    except (IndexError, KeyError):
        usage()

    return 0


if __name__ == "__main__":
    main()

```