Project Path: arc_ZehMatt_zyemu_kw8o21zr

Source Tree:

```txt
arc_ZehMatt_zyemu_kw8o21zr
├── CMakeLists.txt
├── LICENSE
├── README.md
├── cmake.toml
├── cmkr.cmake
├── include
│   └── zyemu
│       ├── registers.hpp
│       ├── types.hpp
│       └── zyemu.hpp
├── src
│   ├── playground
│   │   └── main.cpp
│   ├── tests
│   │   ├── main.cpp
│   │   ├── testdata.cpp
│   │   ├── testdata.hpp
│   │   └── tests
│   │       ├── emulation.controlflow.cpp
│   │       ├── emulation.flags.cpp
│   │       ├── emulation.memory.cpp
│   │       ├── emulation.testdata.cpp
│   │       ├── memory.hpp
│   │       └── registers.cpp
│   └── zyemu
│       ├── assembler.cpp
│       ├── assembler.hpp
│       ├── assembler.types.hpp
│       ├── codecache.cpp
│       ├── codecache.hpp
│       ├── codegen.cpp
│       ├── codegen.data.hpp
│       ├── codegen.handlers.cpp
│       ├── codegen.hpp
│       ├── cpu.cpp
│       ├── cpu.memory.cpp
│       ├── cpu.memory.hpp
│       ├── cpu.software.cpp
│       ├── cpu.software.hpp
│       ├── internal.hpp
│       ├── platform.cpp
│       ├── platform.hpp
│       ├── thread.cpp
│       └── thread.hpp
└── thirdparty
    ├── CMakeLists.txt
    └── cmake.toml

```

`CMakeLists.txt`:

```txt
# This file is automatically generated from cmake.toml - DO NOT EDIT
# See https://github.com/build-cpp/cmkr for more information

cmake_minimum_required(VERSION 3.25)

if(CMAKE_SOURCE_DIR STREQUAL CMAKE_BINARY_DIR)
	message(FATAL_ERROR "In-tree builds are not supported. Run CMake from a separate directory: cmake -B build")
endif()

set(CMKR_ROOT_PROJECT OFF)
if(CMAKE_CURRENT_SOURCE_DIR STREQUAL CMAKE_SOURCE_DIR)
	set(CMKR_ROOT_PROJECT ON)

	# Bootstrap cmkr and automatically regenerate CMakeLists.txt
	include(cmkr.cmake OPTIONAL RESULT_VARIABLE CMKR_INCLUDE_RESULT)
	if(CMKR_INCLUDE_RESULT)
		cmkr()
	endif()

	# Enable folder support
	set_property(GLOBAL PROPERTY USE_FOLDERS ON)

	# Create a configure-time dependency on cmake.toml to improve IDE support
	set_property(DIRECTORY APPEND PROPERTY CMAKE_CONFIGURE_DEPENDS cmake.toml)
endif()

project(zyemu)

# Subdirectory: thirdparty
set(CMKR_CMAKE_FOLDER ${CMAKE_FOLDER})
if(CMAKE_FOLDER)
	set(CMAKE_FOLDER "${CMAKE_FOLDER}/thirdparty")
else()
	set(CMAKE_FOLDER thirdparty)
endif()
add_subdirectory(thirdparty)
set(CMAKE_FOLDER ${CMKR_CMAKE_FOLDER})

# Target: zyemu
set(zyemu_SOURCES
	cmake.toml
	"include/zyemu/registers.hpp"
	"include/zyemu/types.hpp"
	"include/zyemu/zyemu.hpp"
	"src/zyemu/assembler.cpp"
	"src/zyemu/assembler.hpp"
	"src/zyemu/assembler.types.hpp"
	"src/zyemu/codecache.cpp"
	"src/zyemu/codecache.hpp"
	"src/zyemu/codegen.cpp"
	"src/zyemu/codegen.data.hpp"
	"src/zyemu/codegen.handlers.cpp"
	"src/zyemu/codegen.hpp"
	"src/zyemu/cpu.cpp"
	"src/zyemu/cpu.memory.cpp"
	"src/zyemu/cpu.memory.hpp"
	"src/zyemu/cpu.software.cpp"
	"src/zyemu/cpu.software.hpp"
	"src/zyemu/internal.hpp"
	"src/zyemu/platform.cpp"
	"src/zyemu/platform.hpp"
	"src/zyemu/thread.cpp"
	"src/zyemu/thread.hpp"
)

add_library(zyemu STATIC)

target_sources(zyemu PRIVATE ${zyemu_SOURCES})
source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${zyemu_SOURCES})

add_library(zyemu::zyemu ALIAS zyemu)
target_compile_features(zyemu PUBLIC
	cxx_std_23
)

if(MSVC) # msvc
	target_compile_options(zyemu PRIVATE
		"/MP"
		"$<$<CONFIG:Release>:/Oi>"
	)
endif()

target_include_directories(zyemu PUBLIC
	include
)

target_include_directories(zyemu PRIVATE
	"include/zyemu"
)

target_link_libraries(zyemu PUBLIC
	Zydis
	sfl::sfl
)

target_link_options(zyemu PRIVATE
	"$<$<CONFIG:Release>:/DEBUG>"
)

# Target: zyemu-playground
set(zyemu-playground_SOURCES
	cmake.toml
	"src/playground/main.cpp"
)

add_executable(zyemu-playground)

target_sources(zyemu-playground PRIVATE ${zyemu-playground_SOURCES})
source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${zyemu-playground_SOURCES})

target_compile_features(zyemu-playground PRIVATE
	cxx_std_23
)

target_link_libraries(zyemu-playground PRIVATE
	zyemu::zyemu
)

target_link_options(zyemu-playground PRIVATE
	"$<$<CONFIG:Release>:/DEBUG>"
)

get_directory_property(CMKR_VS_STARTUP_PROJECT DIRECTORY ${PROJECT_SOURCE_DIR} DEFINITION VS_STARTUP_PROJECT)
if(NOT CMKR_VS_STARTUP_PROJECT)
	set_property(DIRECTORY ${PROJECT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT zyemu-playground)
endif()

# Target: zyemu-tests
set(zyemu-tests_SOURCES
	cmake.toml
	"src/tests/main.cpp"
	"src/tests/testdata.cpp"
	"src/tests/testdata.hpp"
	"src/tests/tests/emulation.controlflow.cpp"
	"src/tests/tests/emulation.flags.cpp"
	"src/tests/tests/emulation.memory.cpp"
	"src/tests/tests/emulation.testdata.cpp"
	"src/tests/tests/memory.hpp"
	"src/tests/tests/registers.cpp"
)

add_executable(zyemu-tests)

target_sources(zyemu-tests PRIVATE ${zyemu-tests_SOURCES})
source_group(TREE ${CMAKE_CURRENT_SOURCE_DIR} FILES ${zyemu-tests_SOURCES})

target_compile_features(zyemu-tests PRIVATE
	cxx_std_23
)

if(MSVC) # msvc
	target_compile_options(zyemu-tests PRIVATE
		"/MP"
		"$<$<CONFIG:Release>:/Oi>"
	)
endif()

target_include_directories(zyemu-tests PRIVATE
	"src/tests"
	"src/zyemu"
)

target_link_libraries(zyemu-tests PRIVATE
	zyemu::zyemu
	GTest::gtest
)

target_link_options(zyemu-tests PRIVATE
	"$<$<CONFIG:Release>:/DEBUG>"
)

get_directory_property(CMKR_VS_STARTUP_PROJECT DIRECTORY ${PROJECT_SOURCE_DIR} DEFINITION VS_STARTUP_PROJECT)
if(NOT CMKR_VS_STARTUP_PROJECT)
	set_property(DIRECTORY ${PROJECT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT zyemu-tests)
endif()

```

`LICENSE`:

```
MIT License

Copyright (c) 2021 ζeh Matt

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

`README.md`:

```md
## x86-64 emulation using JIT 

WIP x86-64 user mode emulation using Zydis. Instead of writing code for each instruction zyemu
will generate a specific function for the emulator to execute. 

For an instruction such as `mov r12, rax` it would generate following function to emulate it:
```asm
0000021CF4CB0000  mov         r11, qword ptr [rcx+18h]  ; Load value of rax from virtual context.
0000021CF4CB0004  mov         r10, r11                  ; r10 is used for r12
0000021CF4CB0007  mov         qword ptr [rcx+78h], r10  ; Store value of r12 in virtual context.
0000021CF4CB000B  add         qword ptr [rcx+8], 3      ; Update IP, length of this instruction is 3 bytes.
0000021CF4CB0010  mov         rax, 0                    ; Status code.
0000021CF4CB0017  ret  
```


```

`cmake.toml`:

```toml
# Reference: https://build-cpp.github.io/cmkr/cmake-toml
[cmake]
version = "3.25"

[project]
name = "zyemu"

[subdir.thirdparty]

[target.zyemu]
type = "static"
alias = "zyemu::zyemu"
sources = [
    "src/zyemu/assembler.cpp",
    "src/zyemu/codecache.cpp",
    "src/zyemu/codegen.cpp",
    "src/zyemu/codegen.handlers.cpp",
    "src/zyemu/cpu.cpp",
    "src/zyemu/cpu.memory.cpp",
    "src/zyemu/cpu.software.cpp",
    "src/zyemu/platform.cpp",
    "src/zyemu/thread.cpp",
]
headers = [
    "include/zyemu/registers.hpp",
    "include/zyemu/types.hpp",
    "include/zyemu/zyemu.hpp",
    "src/zyemu/assembler.hpp",
    "src/zyemu/assembler.types.hpp",
    "src/zyemu/codecache.hpp",
    "src/zyemu/codegen.hpp",
    "src/zyemu/codegen.data.hpp",
    "src/zyemu/cpu.memory.hpp",
    "src/zyemu/cpu.software.hpp",
    "src/zyemu/internal.hpp",
    "src/zyemu/platform.hpp",
    "src/zyemu/thread.hpp",
]
include-directories = ["include"]
private-include-directories = ["include/zyemu"]
compile-features = ["cxx_std_23"]
link-libraries = ["Zydis", "sfl::sfl"]
msvc.private-compile-options = ["/MP", "$<$<CONFIG:Release>:/Oi>"]
private-link-options = ["$<$<CONFIG:Release>:/DEBUG>"]

[target.zyemu-playground]
type = "executable"
sources = [
    "src/playground/main.cpp"
]
compile-features = ["cxx_std_23"]
private-link-libraries = ["zyemu::zyemu"]
private-link-options = ["$<$<CONFIG:Release>:/DEBUG>"]

[target.zyemu-tests]
type = "executable"
sources = [
    "src/tests/main.cpp",
    "src/tests/testdata.cpp",
    "src/tests/tests/emulation.controlflow.cpp",
    "src/tests/tests/emulation.flags.cpp",
    "src/tests/tests/emulation.memory.cpp",
    "src/tests/tests/emulation.testdata.cpp",
    "src/tests/tests/registers.cpp",
]
headers = [
    "src/tests/testdata.hpp",
    "src/tests/tests/memory.hpp",
]
private-include-directories = ["src/tests", "src/zyemu"]
compile-features = ["cxx_std_23"]
msvc.private-compile-options = ["/MP", "$<$<CONFIG:Release>:/Oi>"]
private-link-libraries = ["zyemu::zyemu", "GTest::gtest"]
private-link-options = ["$<$<CONFIG:Release>:/DEBUG>"]
```

`cmkr.cmake`:

```cmake
include_guard()

# Change these defaults to point to your infrastructure if desired
set(CMKR_REPO "https://github.com/build-cpp/cmkr" CACHE STRING "cmkr git repository" FORCE)
set(CMKR_TAG "v0.2.43" CACHE STRING "cmkr git tag (this needs to be available forever)" FORCE)
set(CMKR_COMMIT_HASH "" CACHE STRING "cmkr git commit hash (optional)" FORCE)

# To bootstrap/generate a cmkr project: cmake -P cmkr.cmake
if(CMAKE_SCRIPT_MODE_FILE)
    set(CMAKE_BINARY_DIR "${CMAKE_BINARY_DIR}/build")
    set(CMAKE_CURRENT_BINARY_DIR "${CMAKE_BINARY_DIR}")
    file(MAKE_DIRECTORY "${CMAKE_BINARY_DIR}")
endif()

# Set these from the command line to customize for development/debugging purposes
set(CMKR_EXECUTABLE "" CACHE FILEPATH "cmkr executable")
set(CMKR_SKIP_GENERATION OFF CACHE BOOL "skip automatic cmkr generation")
set(CMKR_BUILD_TYPE "Debug" CACHE STRING "cmkr build configuration")
mark_as_advanced(CMKR_REPO CMKR_TAG CMKR_COMMIT_HASH CMKR_EXECUTABLE CMKR_SKIP_GENERATION CMKR_BUILD_TYPE)

# Disable cmkr if generation is disabled
if(DEFINED ENV{CI} OR CMKR_SKIP_GENERATION OR CMKR_BUILD_SKIP_GENERATION)
    message(STATUS "[cmkr] Skipping automatic cmkr generation")
    unset(CMKR_BUILD_SKIP_GENERATION CACHE)
    macro(cmkr)
    endmacro()
    return()
endif()

# Disable cmkr if no cmake.toml file is found
if(NOT CMAKE_SCRIPT_MODE_FILE AND NOT EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/cmake.toml")
    message(AUTHOR_WARNING "[cmkr] Not found: ${CMAKE_CURRENT_SOURCE_DIR}/cmake.toml")
    macro(cmkr)
    endmacro()
    return()
endif()

# Convert a Windows native path to CMake path
if(CMKR_EXECUTABLE MATCHES "\\\\")
    string(REPLACE "\\" "/" CMKR_EXECUTABLE_CMAKE "${CMKR_EXECUTABLE}")
    set(CMKR_EXECUTABLE "${CMKR_EXECUTABLE_CMAKE}" CACHE FILEPATH "" FORCE)
    unset(CMKR_EXECUTABLE_CMAKE)
endif()

# Helper macro to execute a process (COMMAND_ERROR_IS_FATAL ANY is 3.19 and higher)
function(cmkr_exec)
    execute_process(COMMAND ${ARGV} RESULT_VARIABLE CMKR_EXEC_RESULT)
    if(NOT CMKR_EXEC_RESULT EQUAL 0)
        message(FATAL_ERROR "cmkr_exec(${ARGV}) failed (exit code ${CMKR_EXEC_RESULT})")
    endif()
endfunction()

# Windows-specific hack (CMAKE_EXECUTABLE_PREFIX is not set at the moment)
if(WIN32)
    set(CMKR_EXECUTABLE_NAME "cmkr.exe")
else()
    set(CMKR_EXECUTABLE_NAME "cmkr")
endif()

# Use cached cmkr if found
if(DEFINED ENV{CMKR_CACHE})
    set(CMKR_DIRECTORY_PREFIX "$ENV{CMKR_CACHE}")
    string(REPLACE "\\" "/" CMKR_DIRECTORY_PREFIX "${CMKR_DIRECTORY_PREFIX}")
    if(NOT CMKR_DIRECTORY_PREFIX MATCHES "\\/$")
        set(CMKR_DIRECTORY_PREFIX "${CMKR_DIRECTORY_PREFIX}/")
    endif()
    # Build in release mode for the cache
    set(CMKR_BUILD_TYPE "Release")
else()
    set(CMKR_DIRECTORY_PREFIX "${CMAKE_CURRENT_BINARY_DIR}/_cmkr_")
endif()
set(CMKR_DIRECTORY "${CMKR_DIRECTORY_PREFIX}${CMKR_TAG}")
set(CMKR_CACHED_EXECUTABLE "${CMKR_DIRECTORY}/bin/${CMKR_EXECUTABLE_NAME}")

# Helper function to check if a string starts with a prefix
# Cannot use MATCHES, see: https://github.com/build-cpp/cmkr/issues/61
function(cmkr_startswith str prefix result)
    string(LENGTH "${prefix}" prefix_length)
    string(LENGTH "${str}" str_length)
    if(prefix_length LESS_EQUAL str_length)
        string(SUBSTRING "${str}" 0 ${prefix_length} str_prefix)
        if(prefix STREQUAL str_prefix)
            set("${result}" ON PARENT_SCOPE)
            return()
        endif()
    endif()
    set("${result}" OFF PARENT_SCOPE)
endfunction()

# Handle upgrading logic
if(CMKR_EXECUTABLE AND NOT CMKR_CACHED_EXECUTABLE STREQUAL CMKR_EXECUTABLE)
    cmkr_startswith("${CMKR_EXECUTABLE}" "${CMAKE_CURRENT_BINARY_DIR}/_cmkr" CMKR_STARTSWITH_BUILD)
    cmkr_startswith("${CMKR_EXECUTABLE}" "${CMKR_DIRECTORY_PREFIX}" CMKR_STARTSWITH_CACHE)
    if(CMKR_STARTSWITH_BUILD)
        if(DEFINED ENV{CMKR_CACHE})
            message(AUTHOR_WARNING "[cmkr] Switching to cached cmkr: '${CMKR_CACHED_EXECUTABLE}'")
            if(EXISTS "${CMKR_CACHED_EXECUTABLE}")
                set(CMKR_EXECUTABLE "${CMKR_CACHED_EXECUTABLE}" CACHE FILEPATH "Full path to cmkr executable" FORCE)
            else()
                unset(CMKR_EXECUTABLE CACHE)
            endif()
        else()
            message(AUTHOR_WARNING "[cmkr] Upgrading '${CMKR_EXECUTABLE}' to '${CMKR_CACHED_EXECUTABLE}'")
            unset(CMKR_EXECUTABLE CACHE)
        endif()
    elseif(DEFINED ENV{CMKR_CACHE} AND CMKR_STARTSWITH_CACHE)
        message(AUTHOR_WARNING "[cmkr] Upgrading cached '${CMKR_EXECUTABLE}' to '${CMKR_CACHED_EXECUTABLE}'")
        unset(CMKR_EXECUTABLE CACHE)
    endif()
endif()

if(CMKR_EXECUTABLE AND EXISTS "${CMKR_EXECUTABLE}")
    message(VERBOSE "[cmkr] Found cmkr: '${CMKR_EXECUTABLE}'")
elseif(CMKR_EXECUTABLE AND NOT CMKR_EXECUTABLE STREQUAL CMKR_CACHED_EXECUTABLE)
    message(FATAL_ERROR "[cmkr] '${CMKR_EXECUTABLE}' not found")
elseif(NOT CMKR_EXECUTABLE AND EXISTS "${CMKR_CACHED_EXECUTABLE}")
    set(CMKR_EXECUTABLE "${CMKR_CACHED_EXECUTABLE}" CACHE FILEPATH "Full path to cmkr executable" FORCE)
    message(STATUS "[cmkr] Found cached cmkr: '${CMKR_EXECUTABLE}'")
else()
    set(CMKR_EXECUTABLE "${CMKR_CACHED_EXECUTABLE}" CACHE FILEPATH "Full path to cmkr executable" FORCE)
    message(VERBOSE "[cmkr] Bootstrapping '${CMKR_EXECUTABLE}'")

    message(STATUS "[cmkr] Fetching cmkr...")
    if(EXISTS "${CMKR_DIRECTORY}")
        cmkr_exec("${CMAKE_COMMAND}" -E rm -rf "${CMKR_DIRECTORY}")
    endif()
    find_package(Git QUIET REQUIRED)
    cmkr_exec("${GIT_EXECUTABLE}"
        clone
        --config advice.detachedHead=false
        --branch ${CMKR_TAG}
        --depth 1
        ${CMKR_REPO}
        "${CMKR_DIRECTORY}"
    )
    if(CMKR_COMMIT_HASH)
        execute_process(
            COMMAND "${GIT_EXECUTABLE}" checkout -q "${CMKR_COMMIT_HASH}"
            RESULT_VARIABLE CMKR_EXEC_RESULT
            WORKING_DIRECTORY "${CMKR_DIRECTORY}"
        )
        if(NOT CMKR_EXEC_RESULT EQUAL 0)
            message(FATAL_ERROR "Tag '${CMKR_TAG}' hash is not '${CMKR_COMMIT_HASH}'")
        endif()
    endif()
    message(STATUS "[cmkr] Building cmkr (using system compiler)...")
    cmkr_exec("${CMAKE_COMMAND}"
        --no-warn-unused-cli
        "${CMKR_DIRECTORY}"
        "-B${CMKR_DIRECTORY}/build"
        "-DCMAKE_BUILD_TYPE=${CMKR_BUILD_TYPE}"
        "-DCMAKE_UNITY_BUILD=ON"
        "-DCMAKE_INSTALL_PREFIX=${CMKR_DIRECTORY}"
        "-DCMKR_GENERATE_DOCUMENTATION=OFF"
    )
    cmkr_exec("${CMAKE_COMMAND}"
        --build "${CMKR_DIRECTORY}/build"
        --config "${CMKR_BUILD_TYPE}"
        --parallel
    )
    cmkr_exec("${CMAKE_COMMAND}"
        --install "${CMKR_DIRECTORY}/build"
        --config "${CMKR_BUILD_TYPE}"
        --prefix "${CMKR_DIRECTORY}"
        --component cmkr
    )
    if(NOT EXISTS ${CMKR_EXECUTABLE})
        message(FATAL_ERROR "[cmkr] Failed to bootstrap '${CMKR_EXECUTABLE}'")
    endif()
    cmkr_exec("${CMKR_EXECUTABLE}" version)
    message(STATUS "[cmkr] Bootstrapped ${CMKR_EXECUTABLE}")
endif()
execute_process(COMMAND "${CMKR_EXECUTABLE}" version
    RESULT_VARIABLE CMKR_EXEC_RESULT
)
if(NOT CMKR_EXEC_RESULT EQUAL 0)
    message(FATAL_ERROR "[cmkr] Failed to get version, try clearing the cache and rebuilding")
endif()

# Use cmkr.cmake as a script
if(CMAKE_SCRIPT_MODE_FILE)
    if(NOT EXISTS "${CMAKE_SOURCE_DIR}/cmake.toml")
        execute_process(COMMAND "${CMKR_EXECUTABLE}" init
            RESULT_VARIABLE CMKR_EXEC_RESULT
        )
        if(NOT CMKR_EXEC_RESULT EQUAL 0)
            message(FATAL_ERROR "[cmkr] Failed to bootstrap cmkr project. Please report an issue: https://github.com/build-cpp/cmkr/issues/new")
        else()
            message(STATUS "[cmkr] Modify cmake.toml and then configure using: cmake -B build")
        endif()
    else()
        execute_process(COMMAND "${CMKR_EXECUTABLE}" gen
            RESULT_VARIABLE CMKR_EXEC_RESULT
        )
        if(NOT CMKR_EXEC_RESULT EQUAL 0)
            message(FATAL_ERROR "[cmkr] Failed to generate project.")
        else()
            message(STATUS "[cmkr] Configure using: cmake -B build")
        endif()
    endif()
endif()

# This is the macro that contains black magic
macro(cmkr)
    # When this macro is called from the generated file, fake some internal CMake variables
    get_source_file_property(CMKR_CURRENT_LIST_FILE "${CMAKE_CURRENT_LIST_FILE}" CMKR_CURRENT_LIST_FILE)
    if(CMKR_CURRENT_LIST_FILE)
        set(CMAKE_CURRENT_LIST_FILE "${CMKR_CURRENT_LIST_FILE}")
        get_filename_component(CMAKE_CURRENT_LIST_DIR "${CMAKE_CURRENT_LIST_FILE}" DIRECTORY)
    endif()

    # File-based include guard (include_guard is not documented to work)
    get_source_file_property(CMKR_INCLUDE_GUARD "${CMAKE_CURRENT_LIST_FILE}" CMKR_INCLUDE_GUARD)
    if(NOT CMKR_INCLUDE_GUARD)
        set_source_files_properties("${CMAKE_CURRENT_LIST_FILE}" PROPERTIES CMKR_INCLUDE_GUARD TRUE)

        file(SHA256 "${CMAKE_CURRENT_LIST_FILE}" CMKR_LIST_FILE_SHA256_PRE)

        # Generate CMakeLists.txt
        cmkr_exec("${CMKR_EXECUTABLE}" gen
            WORKING_DIRECTORY "${CMAKE_CURRENT_SOURCE_DIR}"
        )

        file(SHA256 "${CMAKE_CURRENT_LIST_FILE}" CMKR_LIST_FILE_SHA256_POST)

        # Delete the temporary file if it was left for some reason
        set(CMKR_TEMP_FILE "${CMAKE_CURRENT_SOURCE_DIR}/CMakerLists.txt")
        if(EXISTS "${CMKR_TEMP_FILE}")
            file(REMOVE "${CMKR_TEMP_FILE}")
        endif()

        if(NOT CMKR_LIST_FILE_SHA256_PRE STREQUAL CMKR_LIST_FILE_SHA256_POST)
            # Copy the now-generated CMakeLists.txt to CMakerLists.txt
            # This is done because you cannot include() a file you are currently in
            configure_file(CMakeLists.txt "${CMKR_TEMP_FILE}" COPYONLY)

            # Add the macro required for the hack at the start of the cmkr macro
            set_source_files_properties("${CMKR_TEMP_FILE}" PROPERTIES
                CMKR_CURRENT_LIST_FILE "${CMAKE_CURRENT_LIST_FILE}"
            )

            # 'Execute' the newly-generated CMakeLists.txt
            include("${CMKR_TEMP_FILE}")

            # Delete the generated file
            file(REMOVE "${CMKR_TEMP_FILE}")

            # Do not execute the rest of the original CMakeLists.txt
            return()
        endif()
        # Resume executing the unmodified CMakeLists.txt
    endif()
endmacro()

```

`include/zyemu/registers.hpp`:

```hpp
#pragma once

#include <Zydis/Register.h>
#include <cassert>
#include <compare>
#include <cstddef>

namespace zyemu
{
    struct Reg
    {
        ZydisRegister value{ ZYDIS_REGISTER_NONE };

        constexpr Reg() noexcept = default;

        constexpr Reg(ZydisRegister reg) noexcept
            : value{ reg }
        {
        }

        constexpr bool isGpFamily() const
        {
            return value >= ZYDIS_REGISTER_AL && value <= ZYDIS_REGISTER_R15;
        }

        constexpr bool isGp8() const
        {
            return value >= ZYDIS_REGISTER_AL && value <= ZYDIS_REGISTER_R15B;
        }

        constexpr bool isGp8Hi() const
        {
            return value == ZYDIS_REGISTER_AH || value == ZYDIS_REGISTER_CH || value == ZYDIS_REGISTER_DH
                || value == ZYDIS_REGISTER_BH;
        }

        constexpr bool isGp16() const
        {
            return value >= ZYDIS_REGISTER_AX && value <= ZYDIS_REGISTER_R15W;
        }

        constexpr bool isGp32() const
        {
            return value >= ZYDIS_REGISTER_EAX && value <= ZYDIS_REGISTER_R15D;
        }

        constexpr bool isGp64() const
        {
            return value >= ZYDIS_REGISTER_RAX && value <= ZYDIS_REGISTER_R15;
        }

        constexpr bool isSegFamily() const
        {
            return isSeg();
        }

        constexpr bool isSeg() const
        {
            return value == ZYDIS_REGISTER_ES || value == ZYDIS_REGISTER_CS || value == ZYDIS_REGISTER_SS
                || value == ZYDIS_REGISTER_DS || value == ZYDIS_REGISTER_FS || value == ZYDIS_REGISTER_GS;
        }

        constexpr bool isFlags() const
        {
            return value == ZYDIS_REGISTER_FLAGS || value == ZYDIS_REGISTER_EFLAGS || value == ZYDIS_REGISTER_RFLAGS;
        }

        constexpr bool isIP() const
        {
            return value == ZYDIS_REGISTER_RIP || value == ZYDIS_REGISTER_EIP;
        }

        constexpr bool isSimdFamily() const
        {
            return value >= ZYDIS_REGISTER_XMM0 && value <= ZYDIS_REGISTER_XMM31
                || value >= ZYDIS_REGISTER_YMM0 && value <= ZYDIS_REGISTER_YMM31
                || value >= ZYDIS_REGISTER_ZMM0 && value <= ZYDIS_REGISTER_ZMM31;
        }

        constexpr bool isMmx() const
        {
            return value >= ZYDIS_REGISTER_MM0 && value <= ZYDIS_REGISTER_MM7;
        }

        constexpr bool isXmm() const
        {
            return value >= ZYDIS_REGISTER_XMM0 && value <= ZYDIS_REGISTER_XMM31;
        }

        constexpr bool isYmm() const
        {
            return value >= ZYDIS_REGISTER_YMM0 && value <= ZYDIS_REGISTER_YMM31;
        }

        constexpr bool isZmm() const
        {
            return value >= ZYDIS_REGISTER_ZMM0 && value <= ZYDIS_REGISTER_ZMM31;
        }

        constexpr auto operator<=>(const Reg&) const = default;

        operator ZydisRegister() const noexcept
        {
            return value;
        }

        constexpr bool isValid() const
        {
            return value != ZYDIS_REGISTER_NONE;
        }
    };

    namespace x86
    {

        struct Gp : public Reg
        {
        };

        struct Gp8 : public Gp
        {
        };

        struct Gp16 : public Gp
        {
        };

        struct Gp32 : public Gp
        {
        };

        struct Gp64 : public Gp
        {
        };

        struct Seg : public Reg
        {
        };

        // Segment regs.
        static constexpr Seg es{ ZYDIS_REGISTER_ES };
        static constexpr Seg cs{ ZYDIS_REGISTER_CS };
        static constexpr Seg ss{ ZYDIS_REGISTER_SS };
        static constexpr Seg ds{ ZYDIS_REGISTER_DS };
        static constexpr Seg fs{ ZYDIS_REGISTER_FS };
        static constexpr Seg gs{ ZYDIS_REGISTER_GS };

        // Gp8-Low
        static constexpr Gp8 al{ ZYDIS_REGISTER_AL };
        static constexpr Gp8 cl{ ZYDIS_REGISTER_CL };
        static constexpr Gp8 dl{ ZYDIS_REGISTER_DL };
        static constexpr Gp8 bl{ ZYDIS_REGISTER_BL };
        static constexpr Gp8 spl{ ZYDIS_REGISTER_SPL };
        static constexpr Gp8 bpl{ ZYDIS_REGISTER_BPL };
        static constexpr Gp8 sil{ ZYDIS_REGISTER_SIL };
        static constexpr Gp8 dil{ ZYDIS_REGISTER_DIL };
        static constexpr Gp8 r8b{ ZYDIS_REGISTER_R8B };
        static constexpr Gp8 r9b{ ZYDIS_REGISTER_R9B };
        static constexpr Gp8 r10b{ ZYDIS_REGISTER_R10B };
        static constexpr Gp8 r11b{ ZYDIS_REGISTER_R11B };
        static constexpr Gp8 r12b{ ZYDIS_REGISTER_R12B };
        static constexpr Gp8 r13b{ ZYDIS_REGISTER_R13B };
        static constexpr Gp8 r14b{ ZYDIS_REGISTER_R14B };
        static constexpr Gp8 r15b{ ZYDIS_REGISTER_R15B };

        // Gp8-High
        static constexpr Gp8 ah{ ZYDIS_REGISTER_AH };
        static constexpr Gp8 ch{ ZYDIS_REGISTER_CH };
        static constexpr Gp8 dh{ ZYDIS_REGISTER_DH };
        static constexpr Gp8 bh{ ZYDIS_REGISTER_BH };

        // Gp16
        static constexpr Gp16 ax{ ZYDIS_REGISTER_AX };
        static constexpr Gp16 cx{ ZYDIS_REGISTER_CX };
        static constexpr Gp16 dx{ ZYDIS_REGISTER_DX };
        static constexpr Gp16 bx{ ZYDIS_REGISTER_BX };
        static constexpr Gp16 sp{ ZYDIS_REGISTER_SP };
        static constexpr Gp16 bp{ ZYDIS_REGISTER_BP };
        static constexpr Gp16 si{ ZYDIS_REGISTER_SI };
        static constexpr Gp16 di{ ZYDIS_REGISTER_DI };
        static constexpr Gp16 r8w{ ZYDIS_REGISTER_R8W };
        static constexpr Gp16 r9w{ ZYDIS_REGISTER_R9W };
        static constexpr Gp16 r10w{ ZYDIS_REGISTER_R10W };
        static constexpr Gp16 r11w{ ZYDIS_REGISTER_R11W };
        static constexpr Gp16 r12w{ ZYDIS_REGISTER_R12W };
        static constexpr Gp16 r13w{ ZYDIS_REGISTER_R13W };
        static constexpr Gp16 r14w{ ZYDIS_REGISTER_R14W };
        static constexpr Gp16 r15w{ ZYDIS_REGISTER_R15W };

        // Gp32
        static constexpr Gp32 eax{ ZYDIS_REGISTER_EAX };
        static constexpr Gp32 ecx{ ZYDIS_REGISTER_ECX };
        static constexpr Gp32 edx{ ZYDIS_REGISTER_EDX };
        static constexpr Gp32 ebx{ ZYDIS_REGISTER_EBX };
        static constexpr Gp32 esp{ ZYDIS_REGISTER_ESP };
        static constexpr Gp32 ebp{ ZYDIS_REGISTER_EBP };
        static constexpr Gp32 esi{ ZYDIS_REGISTER_ESI };
        static constexpr Gp32 edi{ ZYDIS_REGISTER_EDI };
        static constexpr Gp32 r8d{ ZYDIS_REGISTER_R8D };
        static constexpr Gp32 r9d{ ZYDIS_REGISTER_R9D };
        static constexpr Gp32 r10d{ ZYDIS_REGISTER_R10D };
        static constexpr Gp32 r11d{ ZYDIS_REGISTER_R11D };
        static constexpr Gp32 r12d{ ZYDIS_REGISTER_R12D };
        static constexpr Gp32 r13d{ ZYDIS_REGISTER_R13D };
        static constexpr Gp32 r14d{ ZYDIS_REGISTER_R14D };
        static constexpr Gp32 r15d{ ZYDIS_REGISTER_R15D };

        // Gp64
        static constexpr Gp64 rax{ ZYDIS_REGISTER_RAX };
        static constexpr Gp64 rcx{ ZYDIS_REGISTER_RCX };
        static constexpr Gp64 rdx{ ZYDIS_REGISTER_RDX };
        static constexpr Gp64 rbx{ ZYDIS_REGISTER_RBX };
        static constexpr Gp64 rsp{ ZYDIS_REGISTER_RSP };
        static constexpr Gp64 rbp{ ZYDIS_REGISTER_RBP };
        static constexpr Gp64 rsi{ ZYDIS_REGISTER_RSI };
        static constexpr Gp64 rdi{ ZYDIS_REGISTER_RDI };
        static constexpr Gp64 r8{ ZYDIS_REGISTER_R8 };
        static constexpr Gp64 r9{ ZYDIS_REGISTER_R9 };
        static constexpr Gp64 r10{ ZYDIS_REGISTER_R10 };
        static constexpr Gp64 r11{ ZYDIS_REGISTER_R11 };
        static constexpr Gp64 r12{ ZYDIS_REGISTER_R12 };
        static constexpr Gp64 r13{ ZYDIS_REGISTER_R13 };
        static constexpr Gp64 r14{ ZYDIS_REGISTER_R14 };
        static constexpr Gp64 r15{ ZYDIS_REGISTER_R15 };
        static constexpr Gp64 rip{ ZYDIS_REGISTER_RIP };

        // Mmx regs.
        static constexpr Reg mm0{ ZYDIS_REGISTER_MM0 };
        static constexpr Reg mm1{ ZYDIS_REGISTER_MM1 };
        static constexpr Reg mm2{ ZYDIS_REGISTER_MM2 };
        static constexpr Reg mm3{ ZYDIS_REGISTER_MM3 };
        static constexpr Reg mm4{ ZYDIS_REGISTER_MM4 };
        static constexpr Reg mm5{ ZYDIS_REGISTER_MM5 };
        static constexpr Reg mm6{ ZYDIS_REGISTER_MM6 };
        static constexpr Reg mm7{ ZYDIS_REGISTER_MM7 };

        // Xmm regs.
        static constexpr Reg xmm0{ ZYDIS_REGISTER_XMM0 };
        static constexpr Reg xmm1{ ZYDIS_REGISTER_XMM1 };
        static constexpr Reg xmm2{ ZYDIS_REGISTER_XMM2 };
        static constexpr Reg xmm3{ ZYDIS_REGISTER_XMM3 };
        static constexpr Reg xmm4{ ZYDIS_REGISTER_XMM4 };
        static constexpr Reg xmm5{ ZYDIS_REGISTER_XMM5 };
        static constexpr Reg xmm6{ ZYDIS_REGISTER_XMM6 };
        static constexpr Reg xmm7{ ZYDIS_REGISTER_XMM7 };
        static constexpr Reg xmm8{ ZYDIS_REGISTER_XMM8 };
        static constexpr Reg xmm9{ ZYDIS_REGISTER_XMM9 };
        static constexpr Reg xmm10{ ZYDIS_REGISTER_XMM10 };
        static constexpr Reg xmm11{ ZYDIS_REGISTER_XMM11 };
        static constexpr Reg xmm12{ ZYDIS_REGISTER_XMM12 };
        static constexpr Reg xmm13{ ZYDIS_REGISTER_XMM13 };
        static constexpr Reg xmm14{ ZYDIS_REGISTER_XMM14 };
        static constexpr Reg xmm15{ ZYDIS_REGISTER_XMM15 };
        static constexpr Reg xmm16{ ZYDIS_REGISTER_XMM16 };
        static constexpr Reg xmm17{ ZYDIS_REGISTER_XMM17 };
        static constexpr Reg xmm18{ ZYDIS_REGISTER_XMM18 };
        static constexpr Reg xmm19{ ZYDIS_REGISTER_XMM19 };
        static constexpr Reg xmm20{ ZYDIS_REGISTER_XMM20 };
        static constexpr Reg xmm21{ ZYDIS_REGISTER_XMM21 };
        static constexpr Reg xmm22{ ZYDIS_REGISTER_XMM22 };
        static constexpr Reg xmm23{ ZYDIS_REGISTER_XMM23 };
        static constexpr Reg xmm24{ ZYDIS_REGISTER_XMM24 };
        static constexpr Reg xmm25{ ZYDIS_REGISTER_XMM25 };
        static constexpr Reg xmm26{ ZYDIS_REGISTER_XMM26 };
        static constexpr Reg xmm27{ ZYDIS_REGISTER_XMM27 };
        static constexpr Reg xmm28{ ZYDIS_REGISTER_XMM28 };
        static constexpr Reg xmm29{ ZYDIS_REGISTER_XMM29 };
        static constexpr Reg xmm30{ ZYDIS_REGISTER_XMM30 };
        static constexpr Reg xmm31{ ZYDIS_REGISTER_XMM31 };

        // Ymm regs.
        static constexpr Reg ymm0{ ZYDIS_REGISTER_YMM0 };
        static constexpr Reg ymm1{ ZYDIS_REGISTER_YMM1 };
        static constexpr Reg ymm2{ ZYDIS_REGISTER_YMM2 };
        static constexpr Reg ymm3{ ZYDIS_REGISTER_YMM3 };
        static constexpr Reg ymm4{ ZYDIS_REGISTER_YMM4 };
        static constexpr Reg ymm5{ ZYDIS_REGISTER_YMM5 };
        static constexpr Reg ymm6{ ZYDIS_REGISTER_YMM6 };
        static constexpr Reg ymm7{ ZYDIS_REGISTER_YMM7 };
        static constexpr Reg ymm8{ ZYDIS_REGISTER_YMM8 };
        static constexpr Reg ymm9{ ZYDIS_REGISTER_YMM9 };
        static constexpr Reg ymm10{ ZYDIS_REGISTER_YMM10 };
        static constexpr Reg ymm11{ ZYDIS_REGISTER_YMM11 };
        static constexpr Reg ymm12{ ZYDIS_REGISTER_YMM12 };
        static constexpr Reg ymm13{ ZYDIS_REGISTER_YMM13 };
        static constexpr Reg ymm14{ ZYDIS_REGISTER_YMM14 };
        static constexpr Reg ymm15{ ZYDIS_REGISTER_YMM15 };
        static constexpr Reg ymm16{ ZYDIS_REGISTER_YMM16 };
        static constexpr Reg ymm17{ ZYDIS_REGISTER_YMM17 };
        static constexpr Reg ymm18{ ZYDIS_REGISTER_YMM18 };
        static constexpr Reg ymm19{ ZYDIS_REGISTER_YMM19 };
        static constexpr Reg ymm20{ ZYDIS_REGISTER_YMM20 };
        static constexpr Reg ymm21{ ZYDIS_REGISTER_YMM21 };
        static constexpr Reg ymm22{ ZYDIS_REGISTER_YMM22 };
        static constexpr Reg ymm23{ ZYDIS_REGISTER_YMM23 };
        static constexpr Reg ymm24{ ZYDIS_REGISTER_YMM24 };
        static constexpr Reg ymm25{ ZYDIS_REGISTER_YMM25 };
        static constexpr Reg ymm26{ ZYDIS_REGISTER_YMM26 };
        static constexpr Reg ymm27{ ZYDIS_REGISTER_YMM27 };
        static constexpr Reg ymm28{ ZYDIS_REGISTER_YMM28 };
        static constexpr Reg ymm29{ ZYDIS_REGISTER_YMM29 };
        static constexpr Reg ymm30{ ZYDIS_REGISTER_YMM30 };
        static constexpr Reg ymm31{ ZYDIS_REGISTER_YMM31 };

        // Ymm regs.
        static constexpr Reg zmm0{ ZYDIS_REGISTER_ZMM0 };
        static constexpr Reg zmm1{ ZYDIS_REGISTER_ZMM1 };
        static constexpr Reg zmm2{ ZYDIS_REGISTER_ZMM2 };
        static constexpr Reg zmm3{ ZYDIS_REGISTER_ZMM3 };
        static constexpr Reg zmm4{ ZYDIS_REGISTER_ZMM4 };
        static constexpr Reg zmm5{ ZYDIS_REGISTER_ZMM5 };
        static constexpr Reg zmm6{ ZYDIS_REGISTER_ZMM6 };
        static constexpr Reg zmm7{ ZYDIS_REGISTER_ZMM7 };
        static constexpr Reg zmm8{ ZYDIS_REGISTER_ZMM8 };
        static constexpr Reg zmm9{ ZYDIS_REGISTER_ZMM9 };
        static constexpr Reg zmm10{ ZYDIS_REGISTER_ZMM10 };
        static constexpr Reg zmm11{ ZYDIS_REGISTER_ZMM11 };
        static constexpr Reg zmm12{ ZYDIS_REGISTER_ZMM12 };
        static constexpr Reg zmm13{ ZYDIS_REGISTER_ZMM13 };
        static constexpr Reg zmm14{ ZYDIS_REGISTER_ZMM14 };
        static constexpr Reg zmm15{ ZYDIS_REGISTER_ZMM15 };
        static constexpr Reg zmm16{ ZYDIS_REGISTER_ZMM16 };
        static constexpr Reg zmm17{ ZYDIS_REGISTER_ZMM17 };
        static constexpr Reg zmm18{ ZYDIS_REGISTER_ZMM18 };
        static constexpr Reg zmm19{ ZYDIS_REGISTER_ZMM19 };
        static constexpr Reg zmm20{ ZYDIS_REGISTER_ZMM20 };
        static constexpr Reg zmm21{ ZYDIS_REGISTER_ZMM21 };
        static constexpr Reg zmm22{ ZYDIS_REGISTER_ZMM22 };
        static constexpr Reg zmm23{ ZYDIS_REGISTER_ZMM23 };
        static constexpr Reg zmm24{ ZYDIS_REGISTER_ZMM24 };
        static constexpr Reg zmm25{ ZYDIS_REGISTER_ZMM25 };
        static constexpr Reg zmm26{ ZYDIS_REGISTER_ZMM26 };
        static constexpr Reg zmm27{ ZYDIS_REGISTER_ZMM27 };
        static constexpr Reg zmm28{ ZYDIS_REGISTER_ZMM28 };
        static constexpr Reg zmm29{ ZYDIS_REGISTER_ZMM29 };
        static constexpr Reg zmm30{ ZYDIS_REGISTER_ZMM30 };
        static constexpr Reg zmm31{ ZYDIS_REGISTER_ZMM31 };

        // Flags
        static constexpr Reg flags{ ZYDIS_REGISTER_FLAGS };
        static constexpr Reg eflags{ ZYDIS_REGISTER_EFLAGS };
        static constexpr Reg rflags{ ZYDIS_REGISTER_RFLAGS };

    } // namespace x86

} // namespace zyemu
```

`include/zyemu/types.hpp`:

```hpp
#pragma once

#include <cstddef>
#include <cstdint>
#include <ostream>
#include <variant>

namespace zyemu
{
    enum class StatusCode : std::uint32_t
    {
        success,
        invalidOperation,
        invalidArgument,
        invalidState,
        invalidInstruction,
        invalidRegister,
        invalidMemory,
        invalidThread,
        invalidCallback,
        invalidMode,
        invalidAddress,
        invalidSize,
        invalidAccess,
        invalidAlignment,
        invalidLength,
        invalidBuffer,
        invalidUserData,
        invalidInstructionPointer,
        invalidStackPointer,
        invalidFramePointer,
        invalidBasePointer,
        invalidSegment,
        invalidFlags,
        invalidRounding,
        invalidMasking,
        invalidBroadcast,
        missingMemoryHandler,
        labelAlreadyBound,
        bufferTooSmall,
        outOfMemory,
        // Code generation errors.
        noFreeRegisters,
        // Execution errors.
        exceptionIntDivideError,
        exceptionIntOverflow,
    };

    inline std::ostream& operator<<(std::ostream& os, const StatusCode& status)
    {
        switch (status)
        {
            case StatusCode::success:
                os << "StatusCode::success";
                break;
            case StatusCode::invalidOperation:
                os << "StatusCode::invalidOperation";
                break;
            case StatusCode::invalidArgument:
                os << "StatusCode::invalidArgument";
                break;
            case StatusCode::invalidState:
                os << "StatusCode::invalidState";
                break;
            case StatusCode::invalidInstruction:
                os << "StatusCode::invalidInstruction";
                break;
            case StatusCode::invalidRegister:
                os << "StatusCode::invalidRegister";
                break;
            case StatusCode::invalidMemory:
                os << "StatusCode::invalidMemory";
                break;
            case StatusCode::invalidThread:
                os << "StatusCode::invalidThread";
                break;
            case StatusCode::invalidCallback:
                os << "StatusCode::invalidCallback";
                break;
            case StatusCode::invalidMode:
                os << "StatusCode::invalidMode";
                break;
            case StatusCode::invalidAddress:
                os << "StatusCode::invalidAddress";
                break;
            case StatusCode::invalidSize:
                os << "StatusCode::invalidSize";
                break;
            case StatusCode::invalidAccess:
                os << "StatusCode::invalidAccess";
                break;
            case StatusCode::invalidAlignment:
                os << "StatusCode::invalidAlignment";
                break;
            case StatusCode::invalidLength:
                os << "StatusCode::invalidLength";
                break;
            case StatusCode::invalidBuffer:
                os << "StatusCode::invalidBuffer";
                break;
            case StatusCode::invalidUserData:
                os << "StatusCode::invalidUserData";
                break;
            case StatusCode::invalidInstructionPointer:
                os << "StatusCode::invalidInstructionPointer";
                break;
            case StatusCode::invalidStackPointer:
                os << "StatusCode::invalidStackPointer";
                break;
            case StatusCode::invalidFramePointer:
                os << "StatusCode::invalidFramePointer";
                break;
            case StatusCode::invalidBasePointer:
                os << "StatusCode::invalidBasePointer";
                break;
            case StatusCode::invalidSegment:
                os << "StatusCode::invalidSegment";
                break;
            case StatusCode::invalidFlags:
                os << "StatusCode::invalidFlags";
                break;
            case StatusCode::invalidRounding:
                os << "StatusCode::invalidRounding";
                break;
            case StatusCode::invalidMasking:
                os << "StatusCode::invalidMasking";
                break;
            case StatusCode::invalidBroadcast:
                os << "StatusCode::invalidBroadcast";
                break;
            case StatusCode::labelAlreadyBound:
                os << "StatusCode::labelAlreadyBound";
                break;
            case StatusCode::bufferTooSmall:
                os << "StatusCode::bufferTooSmall";
                break;
            case StatusCode::outOfMemory:
                os << "StatusCode::outOfMemory";
                break;
            case StatusCode::exceptionIntDivideError:
                os << "StatusCode::exceptionIntDivideError";
                break;
            case StatusCode::exceptionIntOverflow:
                os << "StatusCode::exceptionIntOverflow";
                break;
            default:
                assert(false);
                break;
        }
        return os;
    }

    template<typename TResult> struct Result
    {
        using TResultReal = std::conditional_t<std::is_void_v<TResult>, std::monostate, TResult>;

        std::variant<TResultReal, StatusCode> value{};

        constexpr Result() = default;

        constexpr Result(const TResult& value)
            : value(value)
        {
        }

        constexpr Result(TResult&& value)
            : value(std::move(value))
        {
        }

        constexpr Result(StatusCode error)
            : value{ error }
        {
        }

        constexpr bool hasValue() const
        {
            return !hasError();
        }

        constexpr bool hasError() const
        {
            return std::holds_alternative<StatusCode>(value);
        }

        constexpr TResult& getValue()
        {
            assert(hasValue());
            return std::get<TResult>(value);
        }

        constexpr const TResult& getValue() const
        {
            return std::get<TResult>(value);
        }

        constexpr StatusCode& getError()
        {
            return std::get<StatusCode>(value);
        }

        constexpr const StatusCode& getError() const
        {
            return std::get<StatusCode>(value);
        }

        constexpr operator bool() const
        {
            return hasValue();
        }

        constexpr TResult& operator*()
        {
            return getValue();
        }

        constexpr const TResult& operator*() const
        {
            return getValue();
        }

        constexpr TResult* operator->()
        {
            return &getValue();
        }

        constexpr const TResult* operator->() const
        {
            return &getValue();
        }
    };

    enum class ThreadId : std::uint32_t
    {
        invalid = 0xFFFFFFFFU,
    };

    // TODO: Move this into platform.hpp
#ifdef _WIN32
#    ifdef _MSC_VER
#        define ZYEMU_FASTCALL __fastcall
#    else
#        define ZYEMU_FASTCALL __attribute__((fastcall))
#    endif
#else
#    define ZYEMU_FASTCALL
    static_assert(false, "Unsupported platform");
#endif

    using MemoryReadHandler = StatusCode(ZYEMU_FASTCALL*)(
        ThreadId tid, uint64_t address, void* buffer, size_t length, void* userData);

    using MemoryWriteHandler = StatusCode(ZYEMU_FASTCALL*)(
        ThreadId tid, uint64_t address, const void* buffer, size_t length, void* userData);

} // namespace zyemu
```

`include/zyemu/zyemu.hpp`:

```hpp
#pragma once

#include <Zydis/SharedTypes.h>
#include <cstddef>
#include <cstdint>
#include <span>
#include <zyemu/registers.hpp>
#include <zyemu/types.hpp>

namespace zyemu
{
    namespace detail
    {
        struct CPUState;
    }

    class CPU
    {
        detail::CPUState* state{};

    public:
        CPU();
        ~CPU();

        StatusCode setMode(ZydisMachineMode mode);

        void setMemReadHandler(MemoryReadHandler callback, void* userData);

        void setMemWriteHandler(MemoryWriteHandler callback, void* userData);

        void clearCodeCache();

        ThreadId createThread();

        void destroyThread(ThreadId tid);

        StatusCode setRegData(ThreadId tid, Reg reg, std::span<const std::byte> data);

        template<typename T> StatusCode setRegValue(ThreadId tid, Reg reg, T value)
        {
            return setRegData(tid, reg, { reinterpret_cast<const std::byte*>(&value), sizeof(T) });
        }

        StatusCode getRegData(ThreadId tid, Reg reg, std::span<std::byte> buffer);

        template<typename T> StatusCode getRegValue(ThreadId tid, Reg reg, T& value)
        {
            return getRegData(tid, reg, { reinterpret_cast<std::byte*>(&value), sizeof(T) });
        }

        StatusCode step(ThreadId tid);

        StatusCode writeMem(std::uint64_t address, std::span<const std::byte> data);
        StatusCode writeMem(std::uint64_t address, std::span<const std::uint8_t> data)
        {
            return writeMem(address, std::span<const std::byte>(reinterpret_cast<const std::byte*>(data.data()), data.size()));
        }
        template<typename T> StatusCode writeMemValue(std::uint64_t address, const T& value)
        {
            return writeMem(address, { reinterpret_cast<const std::byte*>(&value), sizeof(T) });
        }

        StatusCode readMem(std::uint64_t address, std::span<std::byte> buffer);
        StatusCode readMem(std::uint64_t address, std::span<std::uint8_t> buffer)
        {
            return readMem(address, std::span<std::byte>(reinterpret_cast<std::byte*>(buffer.data()), buffer.size()));
        }
        template<typename T> StatusCode readMemValue(std::uint64_t address, T& value)
        {
            return readMem(address, { reinterpret_cast<std::byte*>(&value), sizeof(T) });
        }
    };

} // namespace zyemu

```

`src/playground/main.cpp`:

```cpp
#include <array>
#include <chrono>
#include <print>
#include <zyemu/zyemu.hpp>

static constexpr std::uint64_t kShellCodeAddress = 0x0000000140007314;
static std::uint8_t kShellCode[0x1000] = {};

static constexpr std::uint64_t kStackAddress = 0x00007FFB67A49000;
static constexpr std::uint64_t kStackBaseOffset = 0x500;
static constexpr std::uint64_t kStackBase = kStackAddress + kStackBaseOffset;
static std::uint8_t kStackSpace[0x1000] = {};

zyemu::StatusCode memReadHandler(zyemu::ThreadId tid, std::uint64_t readAddress, void* dst, std::size_t size, void* userData)
{
    if (readAddress >= kShellCodeAddress && (readAddress + size) <= (kShellCodeAddress + std::size(kShellCode)))
    {
        const auto offset = readAddress - kShellCodeAddress;
        std::memcpy(dst, kShellCode + offset, size);
        return zyemu::StatusCode::success;
    }
    else if (readAddress >= kStackAddress && (readAddress + size) <= (kStackAddress + std::size(kStackSpace)))
    {
        const auto offset = readAddress - kStackAddress;
        std::memcpy(dst, kStackSpace + offset, size);
        return zyemu::StatusCode::success;
    }

    return zyemu::StatusCode::invalidMemory;
}

zyemu::StatusCode memWriteHandler(
    zyemu::ThreadId tid, std::uint64_t writeAddress, const void* src, std::size_t size, void* userData)
{
    if (writeAddress >= kShellCodeAddress && (writeAddress + size) <= (kShellCodeAddress + std::size(kShellCode)))
    {
        const auto offset = writeAddress - kShellCodeAddress;
        std::memcpy(kShellCode + offset, src, size);
        return zyemu::StatusCode::success;
    }
    else if (writeAddress >= kStackAddress && (writeAddress + size) <= (kStackAddress + std::size(kStackSpace)))
    {
        const auto offset = writeAddress - kStackAddress;
        std::memcpy(kStackSpace + offset, src, size);
        return zyemu::StatusCode::success;
    }

    return zyemu::StatusCode::invalidMemory;
}

static void testBasicMov()
{
    using namespace zyemu;

    constexpr std::uint8_t kTestShellCode[] = {
        0x49, 0x89, 0xC4, // mov r12, rax
    };

    std::memcpy(kShellCode, kTestShellCode, sizeof(kTestShellCode));

    std::uint64_t testValue{ 0x1AF20384ECAB27F };

    zyemu::CPU ctx{};
    ctx.setMode(ZydisMachineMode::ZYDIS_MACHINE_MODE_LONG_64);
    ctx.setMemReadHandler(memReadHandler, nullptr);
    ctx.setMemWriteHandler(memWriteHandler, nullptr);

    auto th1 = ctx.createThread();

    ctx.setRegValue(th1, x86::rsp, kStackBase);
    ctx.setRegValue(th1, x86::rip, kShellCodeAddress);
    ctx.setRegValue(th1, x86::rax, testValue);

    auto status = ctx.step(th1);
    if (status != zyemu::StatusCode::success)
    {
        assert(false);
    }

    std::uint64_t rip{};
    ctx.getRegValue(th1, x86::rip, rip);

    assert(rip == kShellCodeAddress + sizeof(kTestShellCode));

    std::uint64_t r12{};
    ctx.getRegValue(th1, ZYDIS_REGISTER_R12, r12);

    assert(r12 == testValue);
}

static void testMemoryRead()
{
    using namespace zyemu;

    constexpr std::uint8_t kTestShellCode[] = {
        0x48, 0x8B, 0x04, 0x24, // mov rax, qword ptr ss:[rsp]
    };

    std::memcpy(kShellCode, kTestShellCode, sizeof(kTestShellCode));

    std::uint64_t testValue{ 0x1AF20384ECAB27F };
    std::memcpy(kStackSpace + kStackBaseOffset, &testValue, sizeof(testValue));

    zyemu::CPU ctx{};
    ctx.setMode(ZydisMachineMode::ZYDIS_MACHINE_MODE_LONG_64);
    ctx.setMemReadHandler(memReadHandler, nullptr);
    ctx.setMemWriteHandler(memWriteHandler, nullptr);

    auto th1 = ctx.createThread();

    ctx.setRegValue(th1, x86::rsp, kStackBase);
    ctx.setRegValue(th1, x86::rip, kShellCodeAddress);

    auto status = ctx.step(th1);
    if (status != zyemu::StatusCode::success)
    {
        assert(false);
    }

    std::uint64_t rip{};
    ctx.getRegValue(th1, x86::rip, rip);

    assert(rip == kShellCodeAddress + sizeof(kTestShellCode));

    std::uint64_t rax{};
    ctx.getRegValue(th1, x86::rax, rax);

    assert(rax == testValue);
}

static void testMemoryWrite()
{
    using namespace zyemu;

    constexpr std::uint8_t kTestShellCode[] = {
        0x48, 0x89, 0x04, 0x24, // mov qword ptr ss:[rsp], rax
    };

    std::memcpy(kShellCode, kTestShellCode, sizeof(kTestShellCode));

    std::memset(kStackSpace, 0xCC, sizeof(kStackSpace));

    zyemu::CPU ctx{};
    ctx.setMode(ZydisMachineMode::ZYDIS_MACHINE_MODE_LONG_64);
    ctx.setMemReadHandler(memReadHandler, nullptr);
    ctx.setMemWriteHandler(memWriteHandler, nullptr);

    auto th1 = ctx.createThread();

    ctx.setRegValue(th1, x86::rsp, kStackBase);
    ctx.setRegValue(th1, x86::rip, kShellCodeAddress);

    std::uint64_t testValue{ 0x1AF20384ECAB27F };
    ctx.setRegValue(th1, x86::rax, testValue);

    auto status = ctx.step(th1);
    if (status != zyemu::StatusCode::success)
    {
        assert(false);
    }

    std::uint64_t rip{};
    ctx.getRegValue(th1, x86::rip, rip);

    assert(rip == kShellCodeAddress + sizeof(kTestShellCode));

    std::uint64_t rax{};
    ctx.getRegValue(th1, x86::rax, rax);

    assert(rax == testValue);

    std::uint64_t stackValue{};
    std::memcpy(&stackValue, kStackSpace + kStackBaseOffset, sizeof(stackValue));

    assert(stackValue == testValue);
}

static void testBranchJnz()
{
    using namespace zyemu;

    constexpr std::uint8_t kTestShellCode[] = {
        0x0F, 0x85, 0x7E, 0xFE, 0xFF, 0xFF, // jnz 0x0000000140007198
    };

    std::memcpy(kShellCode, kTestShellCode, sizeof(kTestShellCode));

    zyemu::CPU ctx{};
    ctx.setMode(ZydisMachineMode::ZYDIS_MACHINE_MODE_LONG_64);
    ctx.setMemReadHandler(memReadHandler, nullptr);
    ctx.setMemWriteHandler(memWriteHandler, nullptr);

    auto th1 = ctx.createThread();

    // Test with ZF == 0.
    {
        std::uint32_t flags = 0;

        ctx.setRegValue(th1, x86::rsp, kStackBase);
        ctx.setRegValue(th1, x86::rip, kShellCodeAddress);
        ctx.setRegValue(th1, ZYDIS_REGISTER_EFLAGS, flags);

        auto status = ctx.step(th1);
        if (status != zyemu::StatusCode::success)
        {
            assert(false);
        }

        std::uint64_t rip{};
        ctx.getRegValue(th1, x86::rip, rip);

        assert(rip == 0x0000000140007198);
    }

    // Test with ZF == 1.
    {
        std::uint32_t flags = (1U << 6);

        ctx.setRegValue(th1, x86::rsp, kStackBase);
        ctx.setRegValue(th1, x86::rip, kShellCodeAddress);
        ctx.setRegValue(th1, ZYDIS_REGISTER_EFLAGS, flags);

        auto status = ctx.step(th1);
        if (status != zyemu::StatusCode::success)
        {
            assert(false);
        }

        std::uint64_t rip{};
        ctx.getRegValue(th1, x86::rip, rip);

        assert(rip == kShellCodeAddress + sizeof(kTestShellCode));
    }
}

static void testPushReg64()
{
    using namespace zyemu;

    constexpr std::uint8_t kTestShellCode[] = {
        0x50, // push rax
    };

    std::memcpy(kShellCode, kTestShellCode, sizeof(kTestShellCode));

    std::uint64_t testValue{ 0x1AF20384ECAB27F };

    zyemu::CPU ctx{};
    ctx.setMode(ZydisMachineMode::ZYDIS_MACHINE_MODE_LONG_64);
    ctx.setMemReadHandler(memReadHandler, nullptr);
    ctx.setMemWriteHandler(memWriteHandler, nullptr);

    auto th1 = ctx.createThread();
    ctx.setRegValue(th1, x86::rsp, kStackBase);
    ctx.setRegValue(th1, x86::rip, kShellCodeAddress);
    ctx.setRegValue(th1, x86::rax, testValue);

    auto status = ctx.step(th1);
    if (status != zyemu::StatusCode::success)
    {
        assert(false);
    }

    std::uint64_t rip{};
    ctx.getRegValue(th1, x86::rip, rip);
    assert(rip == kShellCodeAddress + sizeof(kTestShellCode));

    std::uint64_t rsp{};
    ctx.getRegValue(th1, x86::rsp, rsp);
    assert(rsp == kStackBase - 8);

    std::uint64_t stackValue{};
    memReadHandler(th1, rsp, &stackValue, sizeof(stackValue), nullptr);
    assert(stackValue == testValue);
}

static void testPopReg64()
{
    using namespace zyemu;

    constexpr std::uint8_t kTestShellCode[] = {
        0x58, // pop rax
    };

    std::memcpy(kShellCode, kTestShellCode, sizeof(kTestShellCode));

    std::uint64_t testValue{ 0x1AF20384ECAB27F };

    zyemu::CPU ctx{};
    ctx.setMode(ZydisMachineMode::ZYDIS_MACHINE_MODE_LONG_64);
    ctx.setMemReadHandler(memReadHandler, nullptr);
    ctx.setMemWriteHandler(memWriteHandler, nullptr);

    auto th1 = ctx.createThread();
    ctx.setRegValue(th1, x86::rsp, kStackBase);
    ctx.setRegValue(th1, x86::rip, kShellCodeAddress);

    memWriteHandler(th1, kStackBase, &testValue, sizeof(testValue), nullptr);
    auto status = ctx.step(th1);
    if (status != zyemu::StatusCode::success)
    {
        assert(false);
    }

    std::uint64_t rip{};
    ctx.getRegValue(th1, x86::rip, rip);
    assert(rip == kShellCodeAddress + sizeof(kTestShellCode));

    std::uint64_t rsp{};
    ctx.getRegValue(th1, x86::rsp, rsp);
    assert(rsp == kStackBase + 8);

    std::uint64_t rax{};
    ctx.getRegValue(th1, x86::rax, rax);
    assert(rax == testValue);
}

static void testCall()
{
    using namespace zyemu;

    constexpr std::uint8_t kTestShellCode[] = {
        0xE8, 0x00, 0x00, 0x00, 0x00, // call 0x0000000140007198
    };

    std::memcpy(kShellCode, kTestShellCode, sizeof(kTestShellCode));

    zyemu::CPU ctx{};
    ctx.setMode(ZydisMachineMode::ZYDIS_MACHINE_MODE_LONG_64);
    ctx.setMemReadHandler(memReadHandler, nullptr);
    ctx.setMemWriteHandler(memWriteHandler, nullptr);

    auto th1 = ctx.createThread();
    ctx.setRegValue(th1, x86::rsp, kStackBase);
    ctx.setRegValue(th1, x86::rip, kShellCodeAddress);

    auto status = ctx.step(th1);
    if (status != zyemu::StatusCode::success)
    {
        assert(false);
    }

    std::uint64_t rip{};
    ctx.getRegValue(th1, x86::rip, rip);
    assert(rip == kShellCodeAddress + sizeof(kTestShellCode));

    std::uint64_t rsp{};
    ctx.getRegValue(th1, x86::rsp, rsp);
    assert(rsp == kStackBase - 8);

    std::uint64_t stackValue{};
    memReadHandler(th1, rsp, &stackValue, sizeof(stackValue), nullptr);
    assert(stackValue == kShellCodeAddress + sizeof(kTestShellCode));
}

static void testRet()
{
    using namespace zyemu;

    constexpr std::uint8_t kTestShellCode[] = {
        0xC3, // ret
    };

    std::memcpy(kShellCode, kTestShellCode, sizeof(kTestShellCode));

    zyemu::CPU ctx{};
    ctx.setMode(ZydisMachineMode::ZYDIS_MACHINE_MODE_LONG_64);
    ctx.setMemReadHandler(memReadHandler, nullptr);
    ctx.setMemWriteHandler(memWriteHandler, nullptr);

    auto th1 = ctx.createThread();
    ctx.setRegValue(th1, x86::rsp, kStackBase);
    ctx.setRegValue(th1, x86::rip, kShellCodeAddress);

    // Push return address.
    const std::uint64_t testRetAddr = 0x0000000150007198;
    memWriteHandler(th1, kStackBase, &testRetAddr, sizeof(testRetAddr), nullptr);

    auto status = ctx.step(th1);
    if (status != zyemu::StatusCode::success)
    {
        assert(false);
    }

    std::uint64_t rip{};
    ctx.getRegValue(th1, x86::rip, rip);
    assert(rip == testRetAddr);

    std::uint64_t rsp{};
    ctx.getRegValue(th1, x86::rsp, rsp);
    assert(rsp == kStackBase + 8);
}

static void testStepSpeed()
{
    using namespace zyemu;

    constexpr std::uint8_t kTestShellCode[] = {
        0x48, 0x01, 0xD0, // add rax, rdx
        0x48, 0xFF, 0xC2, // inc rdx
        0xEB, 0xF8,       // jmp $-8
    };

    std::memcpy(kShellCode, kTestShellCode, sizeof(kTestShellCode));

    zyemu::CPU ctx{};
    ctx.setMode(ZydisMachineMode::ZYDIS_MACHINE_MODE_LONG_64);
    ctx.setMemReadHandler(memReadHandler, nullptr);
    ctx.setMemWriteHandler(memWriteHandler, nullptr);

    auto th1 = ctx.createThread();
    ctx.setRegValue(th1, x86::rsp, kStackBase);
    ctx.setRegValue(th1, x86::rip, kShellCodeAddress);

    // Push return address.
    const std::uint64_t testRetAddr = 0x0000000150007198;
    memWriteHandler(th1, kStackBase, &testRetAddr, sizeof(testRetAddr), nullptr);

    std::uint64_t rax{};
    ctx.setRegValue(th1, x86::rax, rax);

    std::uint64_t rdx{};
    ctx.setRegValue(th1, x86::rdx, rdx);

    std::size_t stepCount = 0;

    const auto startTime = std::chrono::high_resolution_clock::now();
    for (;;)
    {
        auto status = ctx.step(th1);
        if (status != zyemu::StatusCode::success)
        {
            assert(false);
        }

        stepCount++;

        ctx.getRegValue(th1, x86::rax, rax);
        if (rax > 0xFFFFFFFFFFULL)
        {
            break;
        }
    }
    const auto endTime = std::chrono::high_resolution_clock::now();

    const auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime).count();

    std::print("Executed {} steps in {} ms ({} steps/sec)\n", stepCount, duration, (stepCount * 1000) / duration);
}

int main()
{
    testStepSpeed();
    testRet();
    testCall();
    testPopReg64();
    testPushReg64();
    testMemoryRead();
    testBranchJnz();
    testBasicMov();
    testMemoryWrite();

    return 0;
}
```

`src/tests/main.cpp`:

```cpp
#include <chrono>
#include <cstdlib>
#include <gtest/gtest.h>

int main(int argc, char** argv)
{
    ::testing::InitGoogleTest(&argc, argv);

    return RUN_ALL_TESTS();
}

```

`src/tests/testdata.cpp`:

```cpp
#pragma once

#include "testdata.hpp"

#include <array>
#include <charconv>
#include <iostream>
#include <map>

namespace zyemu::tests
{
    // Static file stream cache to avoid reopening files multiple times.
    static std::map<std::string, std::ifstream> _fileStreams;

    namespace detail
    {
        static constexpr std::string_view kInstrPrefix = "instr:";
        static constexpr std::string_view kInPrefix = "in:";
        static constexpr std::string_view kOutPrefix = "out:";
        static constexpr std::string_view kExceptionPrefix = "exception:";
        static constexpr std::string_view kSegmentSeparator = "|";
        static constexpr std::string_view kDataSeparator = ",";
        static constexpr std::string_view kGroupSeparator = ";";

        inline sfl::small_vector<std::string_view, 8> split(std::string_view haystack, std::string_view delim)
        {
            sfl::small_vector<std::string_view, 8> tokens{};
            std::size_t pos{};
            while ((pos = haystack.find(delim)) != std::string::npos)
            {
                tokens.push_back(haystack.substr(0, pos));
                haystack.remove_prefix(pos + delim.size());
            }
            if (!haystack.empty())
                tokens.push_back(haystack);
            return tokens;
        }

        static inline std::optional<std::uint64_t> decodeHexValue(std::string_view str)
        {
            if (!str.starts_with("0x"))
                return std::nullopt;

            str.remove_prefix(2);

            std::uint64_t value{};
            auto [ptr, ec] = std::from_chars(str.data(), str.data() + str.size(), value, 16);

            if (ec != std::errc{} || ptr != str.data() + str.size())
                return std::nullopt;

            return value;
        }

        static inline std::optional<std::uint32_t> decodeNumber(std::string_view str)
        {
            std::uint32_t value{};
            auto [ptr, ec] = std::from_chars(str.data(), str.data() + str.size(), value, 10);

            if (ec != std::errc{} || ptr != str.data() + str.size())
                return std::nullopt;

            return value;
        }

        static inline std::optional<RawData> decodeHexData(std::string_view str)
        {
            if (!str.starts_with("#"))
                return std::nullopt;

            str.remove_prefix(1);

            if (str.size() % 2 != 0) // must be even length for full bytes
                return std::nullopt;

            RawData data;
            data.reserve(str.size() / 2);

            while (!str.empty())
            {
                std::uint32_t byte{};
                auto [ptr, ec] = std::from_chars(str.data(), str.data() + 2, byte, 16);
                if (ec != std::errc{})
                    return std::nullopt;

                data.push_back(static_cast<std::byte>(byte));
                str.remove_prefix(2);
            }

            return data;
        }

        static inline std::string_view trim(std::string_view str)
        {
            while (str.starts_with(" ") || str.starts_with("\t"))
            {
                str.remove_prefix(1);
            }
            while (str.ends_with(" ") || str.ends_with("\t"))
            {
                str.remove_suffix(1);
            }
            return str;
        }

        static constexpr auto kStringToRegMap = []() {
            auto map = std::to_array<std::pair<std::string_view, ZydisRegister>>({
                // General purpose.
                { "rax", ZYDIS_REGISTER_RAX },
                { "rbx", ZYDIS_REGISTER_RBX },
                { "rcx", ZYDIS_REGISTER_RCX },
                { "rdx", ZYDIS_REGISTER_RDX },
                { "rsi", ZYDIS_REGISTER_RSI },
                { "rdi", ZYDIS_REGISTER_RDI },
                { "rbp", ZYDIS_REGISTER_RBP },
                { "rsp", ZYDIS_REGISTER_RSP },
                { "r8", ZYDIS_REGISTER_R8 },
                { "r9", ZYDIS_REGISTER_R9 },
                { "r10", ZYDIS_REGISTER_R10 },
                { "r11", ZYDIS_REGISTER_R11 },
                { "r12", ZYDIS_REGISTER_R12 },
                { "r13", ZYDIS_REGISTER_R13 },
                { "r14", ZYDIS_REGISTER_R14 },
                { "r15", ZYDIS_REGISTER_R15 },
                // Simd.
                { "xmm0", ZYDIS_REGISTER_XMM0 },
                { "xmm1", ZYDIS_REGISTER_XMM1 },
                { "xmm2", ZYDIS_REGISTER_XMM2 },
                { "xmm3", ZYDIS_REGISTER_XMM3 },
                { "xmm4", ZYDIS_REGISTER_XMM4 },
                { "xmm5", ZYDIS_REGISTER_XMM5 },
                { "xmm6", ZYDIS_REGISTER_XMM6 },
                { "xmm7", ZYDIS_REGISTER_XMM7 },
                { "xmm8", ZYDIS_REGISTER_XMM8 },
                { "xmm9", ZYDIS_REGISTER_XMM9 },
                { "xmm10", ZYDIS_REGISTER_XMM10 },
                { "xmm11", ZYDIS_REGISTER_XMM11 },
                { "xmm12", ZYDIS_REGISTER_XMM12 },
                { "xmm13", ZYDIS_REGISTER_XMM13 },
                { "xmm14", ZYDIS_REGISTER_XMM14 },
                { "xmm15", ZYDIS_REGISTER_XMM15 },
                // MM
                { "mm0", ZYDIS_REGISTER_MM0 },
                { "mm1", ZYDIS_REGISTER_MM1 },
                { "mm2", ZYDIS_REGISTER_MM2 },
                { "mm3", ZYDIS_REGISTER_MM3 },
                { "mm4", ZYDIS_REGISTER_MM4 },
                { "mm5", ZYDIS_REGISTER_MM5 },
                { "mm6", ZYDIS_REGISTER_MM6 },
                { "mm7", ZYDIS_REGISTER_MM7 },
                // Special.
                { "flags", ZYDIS_REGISTER_EFLAGS },
            });

            std::sort(map.begin(), map.end(), [](const auto& a, const auto& b) { return a.first < b.first; });

            return map;
        }();

        inline ZydisRegister parseReg(std::string_view regName)
        {
            auto it = std::lower_bound(
                kStringToRegMap.begin(), kStringToRegMap.end(), regName,
                [](const auto& p, std::string_view sv) { return p.first < sv; });
            if (it != kStringToRegMap.end() && it->first == regName)
            {
                return it->second;
            }
            return ZYDIS_REGISTER_NONE;
        }

#ifdef _DEBUG
        std::string getDebugValue(const RawData& data)
        {
            std::string debugStr;
            if (data.size() == 8)
            {
                std::uint64_t value{};
                std::memcpy(&value, data.data(), sizeof(value));
                debugStr = std::format("{:X}", value);
            }
            else if (data.size() == 4)
            {
                std::uint32_t value{};
                std::memcpy(&value, data.data(), sizeof(value));
                debugStr = std::format("{:X}", value);
            }
            else
            {
                debugStr = "Invalid size";
            }
            return debugStr;
        }
#endif

        inline std::optional<sfl::small_vector<RegData, 4>> parseRegData(std::string_view pairsStr)
        {
            sfl::small_vector<RegData, 4> entries;

            const auto pairs = detail::split(pairsStr, kDataSeparator);
            for (auto& pair : pairs)
            {
                const auto regPair = detail::split(pair, ":");
                if (regPair.size() != 2)
                {
                    return std::nullopt;
                }

                const auto reg = detail::parseReg(regPair[0]);
                if (reg == ZYDIS_REGISTER_NONE)
                {
                    // Invalid line.
                    return std::nullopt;
                }

                auto data = detail::decodeHexData(regPair[1]);
                if (data.has_value() == false)
                {
                    // Invalid line.
                    return std::nullopt;
                }

                RegData regData{};
                regData.reg = reg;
                regData.data = std::move(data.value());
#ifdef _DEBUG
                regData.debugData = detail::getDebugValue(regData.data);
#endif

                entries.push_back(std::move(regData));
            }

            return entries;
        }

        inline std::optional<ExceptionType> parseExceptionType(std::string_view str)
        {
            if (str == "INT_DIVIDE_ERROR")
                return ExceptionType::kIntDivideError;
            else if (str == "INT_OVERFLOW")
                return ExceptionType::kIntOverflow;

            return std::nullopt;
        }

    } // namespace detail

    std::optional<InstrEntry> parseSingleInstrEntry(
        const std::string& filePath, std::streampos startOffset, std::uint64_t expectedRip)
    {
        std::ifstream& fs = _fileStreams[filePath];
        if (!fs.is_open())
        {
            std::cerr << "File is not open: " << filePath << std::endl;
            return std::nullopt;
        }

        fs.seekg(startOffset);
        if (fs.fail())
        {
            return std::nullopt;
        }

        std::string line;
        line.reserve(512);

        if (!std::getline(fs, line))
        {
            return std::nullopt;
        }

        if (line.empty() || !line.starts_with(detail::kInstrPrefix))
        {
            return std::nullopt; // Mismatch
        }

        const auto lineView = std::string_view(line);
        const auto instrSegments = detail::split(lineView.substr(6), detail::kGroupSeparator);
        if (instrSegments.size() != 4)
        {
            return std::nullopt;
        }

        const auto rip = detail::decodeHexValue(instrSegments[0]);
        if (!rip || rip.value() != expectedRip)
        {
            return std::nullopt; // Mismatch on RIP (safety check)
        }

        const auto instrBytes = detail::decodeHexData(instrSegments[1]);
        if (!instrBytes)
        {
            return std::nullopt;
        }

        const auto instrText = std::string(instrSegments[2]);

        const auto testEntryCount = detail::decodeNumber(instrSegments[3]);
        if (!testEntryCount)
        {
            return std::nullopt;
        }

        InstrEntry entry{};
        entry.rip = rip.value();
        entry.instrText = instrText;
        entry.instrBytes.length = static_cast<uint8_t>(instrBytes.value().size());
        std::memcpy(entry.instrBytes.bytes, instrBytes.value().data(), entry.instrBytes.length);

        for (std::uint32_t i = 0; i < testEntryCount.value(); ++i)
        {
            if (!std::getline(fs, line))
            {
                return std::nullopt;
            }

            InstrTestData testData{};

            const auto testDataSegments = detail::split(line, detail::kSegmentSeparator);
            for (auto seg : testDataSegments)
            {
                seg = detail::trim(seg);

                if (seg.starts_with(detail::kInPrefix))
                {
                    auto entries = detail::parseRegData(seg.substr(detail::kInPrefix.size()));
                    if (!entries)
                    {
                        return std::nullopt;
                    }
                    testData.inputs = std::move(entries.value());
                }
                else if (seg.starts_with(detail::kOutPrefix))
                {
                    auto entries = detail::parseRegData(seg.substr(detail::kOutPrefix.size()));
                    if (!entries)
                    {
                        return std::nullopt;
                    }
                    testData.outputs = std::move(entries.value());
                }
                else if (seg.starts_with(detail::kExceptionPrefix))
                {
                    auto exceptionType = detail::parseExceptionType(seg.substr(detail::kExceptionPrefix.size()));
                    if (!exceptionType)
                    {
                        return std::nullopt;
                    }
                    testData.exceptionType = exceptionType.value();
                }
                else
                {
                    return std::nullopt;
                }
            }

            entry.testEntries.push_back(std::move(testData));
        }

        // Reset state.
        fs.clear();

        return entry;
    }

    TestParameters collectAllTestParams(const std::vector<std::string>& filePaths)
    {
        TestParameters params;

        std::ios::sync_with_stdio(false);

        // Open all files and collect test parameters
        for (const auto& filePath : filePaths)
        {
            if (_fileStreams.contains(filePath) == false)
            {
                std::ifstream inFile;
                inFile.open(filePath);

                if (!inFile.is_open())
                {
                    std::cerr << "Failed to open file: " << filePath << std::endl;
                }

                inFile.tie(nullptr); // Disable synchronization with std::cin/std::cout

                _fileStreams.emplace(filePath, std::move(inFile));
            }
        }

        for (auto& [filePath, fs] : _fileStreams)
        {
            if (!fs.is_open())
            {
                continue;
            }

            std::string line;
            line.reserve(512);

            while (true)
            {
                std::streampos pos = fs.tellg();
                if (pos == std::streampos(-1) || !std::getline(fs, line))
                {
                    break;
                }

                if (line.empty() || !line.starts_with(detail::kInstrPrefix))
                {
                    continue;
                }

                const auto lineView = std::string_view(line);
                const auto instrSegments = detail::split(lineView.substr(6), detail::kGroupSeparator); // Skip "instr:"
                if (instrSegments.size() != 4)
                {
                    continue;
                }

                const auto ripOpt = detail::decodeHexValue(instrSegments[0]);
                if (!ripOpt)
                {
                    continue;
                }

                // Skip decoding instrBytes (heavy, not needed for metadata)

                const auto instrText = std::string(instrSegments[2]);

                const auto testEntryCountOpt = detail::decodeNumber(instrSegments[3]);
                if (!testEntryCountOpt)
                {
                    continue;
                }

                // Add param (lightweight)
                params.push_back({ filePath, instrText, ripOpt.value(), pos });

                // Skip the test lines without parsing
                const auto newLine = fs.widen('\n');
                for (std::uint32_t i = 0; i < testEntryCountOpt.value(); ++i)
                {
                    fs.ignore(std::numeric_limits<std::streamsize>::max(), newLine);
                }
            }

            // Reset file stream.
            fs.clear();
        }
        return params;
    }

} // namespace zyemu::tests
```

`src/tests/testdata.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <fstream>
#include <functional>
#include <optional>
#include <sfl/segmented_vector.hpp>
#include <sfl/small_vector.hpp>
#include <sfl/static_vector.hpp>
#include <string>
#include <vector>
#include <zydis/zydis.h>

namespace zyemu::tests
{
    enum class ExceptionType
    {
        kNone,
        kIntDivideError,
        kIntOverflow,
    };

    using RawData = sfl::small_vector<std::byte, 8>;

    struct InstrBytes
    {
        uint8_t length{};
        std::byte bytes[15]{};

        constexpr std::span<const std::byte> data() const
        {
            return std::span<const std::byte>(bytes, length);
        }

        constexpr std::span<std::byte> data()
        {
            return std::span<std::byte>(bytes, length);
        }
    };

    struct RegData
    {
        ZydisRegister reg{};
        RawData data;
#ifdef _DEBUG
        std::string debugData;
#endif
    };

    struct InstrTestData
    {
        sfl::small_vector<RegData, 4> inputs;
        sfl::small_vector<RegData, 4> outputs;
        ExceptionType exceptionType{};
    };

    struct InstrEntry
    {
        std::uint64_t rip;
        std::string instrText;
        InstrBytes instrBytes;
        sfl::small_vector<InstrTestData, 128> testEntries;
    };

    using InstrEntries = std::vector<InstrEntry>;

    struct TestParam
    {
        std::string filePath;
        std::string instrText;
        std::uint64_t rip;          // For unique identification and matching during lazy load
        std::streampos startOffset; // Byte offset where the "instr:" line starts
    };

    std::optional<InstrEntry> parseSingleInstrEntry(
        const std::string& filePath, std::streampos startOffset, std::uint64_t expectedRip);

    using TestParameters = sfl::segmented_vector<TestParam, 256>;

    TestParameters collectAllTestParams(const std::vector<std::string>& filePaths);

    inline std::ostream& operator<<(std::ostream& os, const InstrEntry& entry)
    {
        os << entry.instrText;
        return os;
    }

} // namespace zyemu::tests
```

`src/tests/tests/emulation.controlflow.cpp`:

```cpp
#include "memory.hpp"

#include <array>
#include <gtest/gtest.h>
#include <string>
#include <zyemu/zyemu.hpp>

namespace zyemu::tests
{
    struct JumpTestParam
    {
        std::string name;
        std::uint8_t opcode;
        std::uint32_t flags;
        std::uint64_t expectedRip;
    };

    static constexpr std::uint64_t kBase = memory::kShellCodeBaseAddress;
    static constexpr std::uint64_t kFallthrough = kBase + 2;
    static constexpr std::int8_t kDisplacement = 5;

    class EmulationCondJumpTests : public ::testing::TestWithParam<JumpTestParam>
    {
    };

    TEST_P(EmulationCondJumpTests, Jcc)
    {
        const auto& p = GetParam();

        const auto kTestShellCode = std::to_array<std::uint8_t>({
            p.opcode, //
            0x05      //
        });

        zyemu::CPU ctx{};
        ASSERT_EQ(ctx.setMode(ZydisMachineMode::ZYDIS_MACHINE_MODE_LONG_64), StatusCode::success);
        ctx.setMemReadHandler(memory::readHandler, nullptr);
        ctx.setMemWriteHandler(memory::writeHandler, nullptr);
        ASSERT_EQ(ctx.writeMem(kBase, kTestShellCode), StatusCode::success);

        auto th1 = ctx.createThread();
        ASSERT_EQ(ctx.setRegValue(th1, x86::rsp, memory::kStackBase), StatusCode::success);
        ASSERT_EQ(ctx.setRegValue(th1, x86::rip, kBase), StatusCode::success);
        ASSERT_EQ(ctx.setRegValue(th1, x86::eflags, p.flags), StatusCode::success);

        ASSERT_EQ(ctx.step(th1), StatusCode::success);

        std::uint64_t rip{};
        ASSERT_EQ(ctx.getRegValue(th1, x86::rip, rip), StatusCode::success);
        ASSERT_EQ(rip, p.expectedRip) << p.name;
    }

    // clang-format off
    INSTANTIATE_TEST_SUITE_P(
        AllConditionalJumps, EmulationCondJumpTests,
        ::testing::Values(
            // JO (0x70) - overflow flag
            JumpTestParam{ "JO_OF0", 0x70, 0, kFallthrough },
            JumpTestParam{ "JO_OF1", 0x70, 1u << 11, kFallthrough + kDisplacement },

            // JNO (0x71)
            JumpTestParam{ "JNO_OF0", 0x71, 0, kFallthrough + kDisplacement },
            JumpTestParam{ "JNO_OF1", 0x71, 1u << 11, kFallthrough },

            // JC (0x72)
            JumpTestParam{ "JC_CF0", 0x72, 0, kFallthrough },
            JumpTestParam{ "JC_CF1", 0x72, 1u << 0, kFallthrough + kDisplacement },

            // JNC (0x73)
            JumpTestParam{ "JNC_CF0", 0x73, 0, kFallthrough + kDisplacement },
            JumpTestParam{ "JNC_CF1", 0x73, 1u << 0, kFallthrough },

            // JZ (0x74)
            JumpTestParam{ "JZ_ZF0", 0x74, 0, kFallthrough },
            JumpTestParam{ "JZ_ZF1", 0x74, 1u << 6, kFallthrough + kDisplacement },

            // JNZ (0x75)
            JumpTestParam{ "JNZ_ZF0", 0x75, 0, kFallthrough + kDisplacement },
            JumpTestParam{ "JNZ_ZF1", 0x75, 1u << 6, kFallthrough },

            // JBE (0x76) - CF || ZF
            JumpTestParam{ "JBE_CF0ZF0", 0x76, 0, kFallthrough },
            JumpTestParam{ "JBE_CF1", 0x76, 1u << 0, kFallthrough + kDisplacement },
            JumpTestParam{ "JBE_ZF1", 0x76, 1u << 6, kFallthrough + kDisplacement },

            // JA (0x77) - !(CF || ZF)
            JumpTestParam{ "JA_CF0ZF0", 0x77, 0, kFallthrough + kDisplacement },
            JumpTestParam{ "JA_CF1", 0x77, 1u << 0, kFallthrough }, 
            JumpTestParam{ "JA_ZF1", 0x77, 1u << 6, kFallthrough },

            // JS (0x78) - sign flag
            JumpTestParam{ "JS_SF0", 0x78, 0, kFallthrough },
            JumpTestParam{ "JS_SF1", 0x78, 1u << 7, kFallthrough + kDisplacement },

            // JNS (0x79)
            JumpTestParam{ "JNS_SF0", 0x79, 0, kFallthrough + kDisplacement },
            JumpTestParam{ "JNS_SF1", 0x79, 1u << 7, kFallthrough },

            // JP (0x7A) - parity flag
            JumpTestParam{ "JP_PF0", 0x7A, 0, kFallthrough },
            JumpTestParam{ "JP_PF1", 0x7A, 1u << 2, kFallthrough + kDisplacement },

            // JNP (0x7B)
            JumpTestParam{ "JNP_PF0", 0x7B, 0, kFallthrough + kDisplacement },
            JumpTestParam{ "JNP_PF1", 0x7B, 1u << 2, kFallthrough },

            // JL (0x7C) - SF != OF
            JumpTestParam{ "JL_SF0OF0", 0x7C, 0, kFallthrough },
            JumpTestParam{ "JL_SF1OF0", 0x7C, 1u << 7, kFallthrough + kDisplacement },
            JumpTestParam{ "JL_SF0OF1", 0x7C, 1u << 11, kFallthrough + kDisplacement },

            // JGE (0x7D) - SF == OF
            JumpTestParam{ "JGE_SF0OF0", 0x7D, 0, kFallthrough + kDisplacement },
            JumpTestParam{ "JGE_SF1OF1", 0x7D, (1u << 7) | (1u << 11), kFallthrough + kDisplacement },
            JumpTestParam{ "JGE_SF1OF0", 0x7D, 1u << 7, kFallthrough },

            // JLE (0x7E) - ZF || (SF != OF)
            JumpTestParam{ "JLE_ZF1", 0x7E, 1u << 6, kFallthrough + kDisplacement },
            JumpTestParam{ "JLE_SF1OF0", 0x7E, 1u << 7, kFallthrough + kDisplacement },
            JumpTestParam{ "JLE_SF0OF1", 0x7E, 1u << 11, kFallthrough + kDisplacement },
            JumpTestParam{ "JLE_SF0OF0ZF0", 0x7E, 0, kFallthrough },

            // JG (0x7F) - !ZF && (SF == OF)
            JumpTestParam{ "JG_SF0OF0ZF0", 0x7F, 0, kFallthrough + kDisplacement },
            JumpTestParam{ "JG_SF1OF1ZF0", 0x7F, (1u << 7) | (1u << 11), kFallthrough + kDisplacement },
            JumpTestParam{ "JG_ZF1", 0x7F, 1u << 6, kFallthrough }),

        [](const ::testing::TestParamInfo<JumpTestParam>& info) { 
            return info.param.name; 
        });

    // clang-format on

    TEST(EmulationTests, testJmpRel8)
    {
        constexpr std::uint8_t kTestShellCode[] = {
            0xEB, 0x0E, // jmp 0x0000000004001010
        };

        std::memcpy(memory::kShellCode, kTestShellCode, sizeof(kTestShellCode));

        zyemu::CPU ctx{};
        ctx.setMode(ZydisMachineMode::ZYDIS_MACHINE_MODE_LONG_64);
        ctx.setMemReadHandler(memory::readHandler, nullptr);
        ctx.setMemWriteHandler(memory::writeHandler, nullptr);

        auto th1 = ctx.createThread();
        ASSERT_EQ(ctx.setRegValue(th1, x86::rip, memory::kShellCodeBaseAddress), zyemu::StatusCode::success);

        auto status = ctx.step(th1);
        ASSERT_EQ(status, zyemu::StatusCode::success);

        std::uint64_t rip{};
        ASSERT_EQ(ctx.getRegValue(th1, x86::rip, rip), zyemu::StatusCode::success);

        ASSERT_EQ(rip, memory::kShellCodeBaseAddress + 0x10);
    }

    TEST(EmulationTests, testJmpRel32)
    {
        constexpr std::uint8_t kTestShellCode[] = {
            0xE9, 0xFB, 0x00, 0x00, 0x00, // jmp 0x0000000004001100
        };

        std::memcpy(memory::kShellCode, kTestShellCode, sizeof(kTestShellCode));

        zyemu::CPU ctx{};
        ctx.setMode(ZydisMachineMode::ZYDIS_MACHINE_MODE_LONG_64);
        ctx.setMemReadHandler(memory::readHandler, nullptr);
        ctx.setMemWriteHandler(memory::writeHandler, nullptr);

        auto th1 = ctx.createThread();
        ASSERT_EQ(ctx.setRegValue(th1, x86::rip, memory::kShellCodeBaseAddress), zyemu::StatusCode::success);

        auto status = ctx.step(th1);
        ASSERT_EQ(status, zyemu::StatusCode::success);

        std::uint64_t rip{};
        ASSERT_EQ(ctx.getRegValue(th1, x86::rip, rip), zyemu::StatusCode::success);

        ASSERT_EQ(rip, memory::kShellCodeBaseAddress + 0x100);
    }

    TEST(EmulationTests, testJmpMem)
    {
        constexpr std::uint8_t kTestShellCode[] = {
            0xFF, 0x25, 0x00, 0x00, 0x00, 0x00,             // jmp qword ptr ds:[0x0000000004000006]
            0x00, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, // dq 4000100
        };

        std::memcpy(memory::kShellCode, kTestShellCode, sizeof(kTestShellCode));

        zyemu::CPU ctx{};
        ctx.setMode(ZydisMachineMode::ZYDIS_MACHINE_MODE_LONG_64);
        ctx.setMemReadHandler(memory::readHandler, nullptr);
        ctx.setMemWriteHandler(memory::writeHandler, nullptr);

        auto th1 = ctx.createThread();
        ASSERT_EQ(ctx.setRegValue(th1, x86::rip, memory::kShellCodeBaseAddress), zyemu::StatusCode::success);

        auto status = ctx.step(th1);
        ASSERT_EQ(status, zyemu::StatusCode::success);

        std::uint64_t rip{};
        ASSERT_EQ(ctx.getRegValue(th1, x86::rip, rip), zyemu::StatusCode::success);

        ASSERT_EQ(rip, memory::kShellCodeBaseAddress + 0x100);
    }

    TEST(EmulationTests, testCallRel32)
    {
        constexpr std::uint8_t kTestShellCode[] = {
            0xE8, 0x00, 0x00, 0x00, 0x00, // call 0x0000000004000005
        };

        std::memcpy(memory::kShellCode, kTestShellCode, sizeof(kTestShellCode));

        std::uint64_t testValue{ 0x1AF20384ECAB27F };
        std::memcpy(memory::kStackSpace + memory::kStackBaseOffset, &testValue, sizeof(testValue));

        zyemu::CPU ctx{};
        ctx.setMode(ZydisMachineMode::ZYDIS_MACHINE_MODE_LONG_64);
        ctx.setMemReadHandler(memory::readHandler, nullptr);
        ctx.setMemWriteHandler(memory::writeHandler, nullptr);

        auto th1 = ctx.createThread();

        ASSERT_EQ(ctx.setRegValue(th1, x86::rsp, memory::kStackBase), zyemu::StatusCode::success);
        ASSERT_EQ(ctx.setRegValue(th1, x86::rip, memory::kShellCodeBaseAddress), zyemu::StatusCode::success);

        auto status = ctx.step(th1);
        ASSERT_EQ(status, zyemu::StatusCode::success);

        std::uint64_t rip{};
        ASSERT_EQ(ctx.getRegValue(th1, x86::rip, rip), zyemu::StatusCode::success);

        ASSERT_EQ(rip, memory::kShellCodeBaseAddress + sizeof(kTestShellCode));

        std::uint64_t regSp{};
        ASSERT_EQ(ctx.getRegValue(th1, x86::rsp, regSp), zyemu::StatusCode::success);

        ASSERT_EQ(regSp, memory::kStackBase - 0x08);

        std::uint64_t stackValue{};
        ASSERT_EQ(ctx.readMemValue(regSp, stackValue), zyemu::StatusCode::success);

        ASSERT_EQ(stackValue, memory::kShellCodeBaseAddress + sizeof(kTestShellCode));
    }

    TEST(EmulationTests, testRetImm16)
    {
        constexpr std::uint16_t kImm = 0x10;
        constexpr std::uint8_t kTestShellCode[] = {
            0xC2,
            static_cast<std::uint8_t>(kImm & 0xFF),
            static_cast<std::uint8_t>((kImm >> 8) & 0xFF),
        };

        std::memcpy(memory::kShellCode, kTestShellCode, sizeof(kTestShellCode));

        std::uint64_t returnAddr{ memory::kShellCodeBaseAddress + sizeof(kTestShellCode) };
        std::memcpy(memory::kStackSpace + memory::kStackBaseOffset, &returnAddr, sizeof(returnAddr));

        zyemu::CPU ctx{};
        ctx.setMode(ZydisMachineMode::ZYDIS_MACHINE_MODE_LONG_64);
        ctx.setMemReadHandler(memory::readHandler, nullptr);
        ctx.setMemWriteHandler(memory::writeHandler, nullptr);

        auto th1 = ctx.createThread();
        ASSERT_EQ(ctx.setRegValue(th1, x86::rsp, memory::kStackBase), zyemu::StatusCode::success);
        ASSERT_EQ(ctx.setRegValue(th1, x86::rip, memory::kShellCodeBaseAddress), zyemu::StatusCode::success);

        auto status = ctx.step(th1);
        ASSERT_EQ(status, zyemu::StatusCode::success);

        std::uint64_t rip{};
        ASSERT_EQ(ctx.getRegValue(th1, x86::rip, rip), zyemu::StatusCode::success);

        ASSERT_EQ(rip, returnAddr);
        std::uint64_t regSp{};

        ASSERT_EQ(ctx.getRegValue(th1, x86::rsp, regSp), zyemu::StatusCode::success);
        ASSERT_EQ(regSp, memory::kStackBase + 0x08 + kImm);
    }

} // namespace zyemu::tests

```

`src/tests/tests/emulation.flags.cpp`:

```cpp
#include "memory.hpp"

#include <gtest/gtest.h>
#include <zyemu/zyemu.hpp>

namespace zyemu::tests
{
    TEST(EmulationTests, testPushfq)
    {
        constexpr std::uint8_t kTestShellCode[] = {
            0x9C // pushfq
        };

        std::memcpy(memory::kShellCode, kTestShellCode, sizeof(kTestShellCode));
        std::memset(memory::kStackSpace, 0xCC, sizeof(memory::kStackSpace));

        zyemu::CPU ctx{};
        ctx.setMode(ZydisMachineMode::ZYDIS_MACHINE_MODE_LONG_64);
        ctx.setMemReadHandler(memory::readHandler, nullptr);
        ctx.setMemWriteHandler(memory::writeHandler, nullptr);

        auto th1 = ctx.createThread();

        ASSERT_EQ(ctx.setRegValue(th1, x86::rsp, memory::kStackBase), zyemu::StatusCode::success);
        ASSERT_EQ(ctx.setRegValue(th1, x86::rip, memory::kShellCodeBaseAddress), zyemu::StatusCode::success);

        std::uint64_t testFlags{ 0x202 };
        ASSERT_EQ(ctx.setRegValue(th1, x86::rflags, testFlags), zyemu::StatusCode::success);

        auto status = ctx.step(th1);
        ASSERT_EQ(status, zyemu::StatusCode::success);

        std::uint64_t rsp{};
        ASSERT_EQ(ctx.getRegValue(th1, x86::rsp, rsp), zyemu::StatusCode::success);
        ASSERT_EQ(rsp, memory::kStackBase - 8);

        std::uint64_t stackValue{};
        std::memcpy(&stackValue, memory::kStackSpace + memory::kStackBaseOffset - 8, sizeof(stackValue));
        ASSERT_EQ(stackValue, testFlags);
    }

    TEST(EmulationTests, testPopfq)
    {
        constexpr std::uint8_t kTestShellCode[] = {
            0x9D // popfq
        };

        std::memcpy(memory::kShellCode, kTestShellCode, sizeof(kTestShellCode));
        std::memset(memory::kStackSpace, 0xCC, sizeof(memory::kStackSpace));

        zyemu::CPU ctx{};
        ctx.setMode(ZydisMachineMode::ZYDIS_MACHINE_MODE_LONG_64);
        ctx.setMemReadHandler(memory::readHandler, nullptr);
        ctx.setMemWriteHandler(memory::writeHandler, nullptr);

        auto th1 = ctx.createThread();

        std::uint64_t testFlags{ 0x202 };
        std::memcpy(memory::kStackSpace + memory::kStackBaseOffset - 8, &testFlags, sizeof(testFlags));

        ASSERT_EQ(ctx.setRegValue(th1, x86::rsp, memory::kStackBase - 8), zyemu::StatusCode::success);
        ASSERT_EQ(ctx.setRegValue(th1, x86::rip, memory::kShellCodeBaseAddress), zyemu::StatusCode::success);

        auto status = ctx.step(th1);
        ASSERT_EQ(status, zyemu::StatusCode::success);

        std::uint64_t rsp{};
        ASSERT_EQ(ctx.getRegValue(th1, x86::rsp, rsp), zyemu::StatusCode::success);
        ASSERT_EQ(rsp, memory::kStackBase);

        std::uint64_t flagsValue{};
        ASSERT_EQ(ctx.getRegValue(th1, x86::rflags, flagsValue), zyemu::StatusCode::success);
        ASSERT_EQ(flagsValue, testFlags);
    }

} // namespace zyemu::tests

```

`src/tests/tests/emulation.memory.cpp`:

```cpp
#include "memory.hpp"

#include <gtest/gtest.h>
#include <zyemu/zyemu.hpp>

namespace zyemu::tests
{
    TEST(EmulationTests, testMemoryRead)
    {
        constexpr std::uint8_t kTestShellCode[] = {
            0x48, 0x8B, 0x04, 0x24, // mov rax, qword ptr ss:[rsp]
        };

        std::memcpy(memory::kShellCode, kTestShellCode, sizeof(kTestShellCode));

        std::uint64_t testValue{ 0x1AF20384ECAB27F };
        std::memcpy(memory::kStackSpace + memory::kStackBaseOffset, &testValue, sizeof(testValue));

        zyemu::CPU ctx{};
        ctx.setMode(ZydisMachineMode::ZYDIS_MACHINE_MODE_LONG_64);
        ctx.setMemReadHandler(memory::readHandler, nullptr);
        ctx.setMemWriteHandler(memory::writeHandler, nullptr);

        auto th1 = ctx.createThread();

        ASSERT_EQ(ctx.setRegValue(th1, x86::rsp, memory::kStackBase), zyemu::StatusCode::success);
        ASSERT_EQ(ctx.setRegValue(th1, x86::rip, memory::kShellCodeBaseAddress), zyemu::StatusCode::success);

        auto status = ctx.step(th1);
        ASSERT_EQ(status, zyemu::StatusCode::success);

        std::uint64_t rip{};
        ASSERT_EQ(ctx.getRegValue(th1, x86::rip, rip), zyemu::StatusCode::success);

        ASSERT_EQ(rip, memory::kShellCodeBaseAddress + sizeof(kTestShellCode));

        std::uint64_t rax{};
        ASSERT_EQ(ctx.getRegValue(th1, x86::rax, rax), zyemu::StatusCode::success);

        ASSERT_EQ(rax, testValue);
    }

    TEST(EmulationTests, testMemoryReadInvalid)
    {
        constexpr std::uint8_t kTestShellCode[] = {
            0x48, 0x8B, 0x04, 0x24, // mov rax, qword ptr ss:[rsp]
        };

        std::memcpy(memory::kShellCode, kTestShellCode, sizeof(kTestShellCode));

        zyemu::CPU ctx{};
        ctx.setMode(ZydisMachineMode::ZYDIS_MACHINE_MODE_LONG_64);
        ctx.setMemReadHandler(memory::readHandler, nullptr);
        ctx.setMemWriteHandler(memory::writeHandler, nullptr);

        auto th1 = ctx.createThread();

        std::uint64_t val{};
        ASSERT_EQ(ctx.getRegValue(th1, x86::rax, val), zyemu::StatusCode::success);

        ASSERT_EQ(ctx.setRegValue(th1, x86::rsp, 0ULL), zyemu::StatusCode::success);
        ASSERT_EQ(ctx.setRegValue(th1, x86::rip, memory::kShellCodeBaseAddress), zyemu::StatusCode::success);

        auto status = ctx.step(th1);
        ASSERT_EQ(status, zyemu::StatusCode::invalidMemory);

        std::uint64_t rip{};
        ASSERT_EQ(ctx.getRegValue(th1, x86::rip, rip), zyemu::StatusCode::success);

        ASSERT_EQ(rip, memory::kShellCodeBaseAddress);

        std::uint64_t rax{};
        ASSERT_EQ(ctx.getRegValue(th1, x86::rax, rax), zyemu::StatusCode::success);

        ASSERT_EQ(rax, 0);
    }

    TEST(EmulationTests, testMemoryWrite)
    {
        constexpr std::uint8_t kTestShellCode[] = {
            0x48, 0x89, 0x04, 0x24, // mov qword ptr ss:[rsp], rax
        };

        std::memcpy(memory::kShellCode, kTestShellCode, sizeof(kTestShellCode));

        std::memset(memory::kStackSpace, 0xCC, sizeof(memory::kStackSpace));

        zyemu::CPU ctx{};
        ctx.setMode(ZydisMachineMode::ZYDIS_MACHINE_MODE_LONG_64);
        ctx.setMemReadHandler(memory::readHandler, nullptr);
        ctx.setMemWriteHandler(memory::writeHandler, nullptr);

        auto th1 = ctx.createThread();

        ASSERT_EQ(ctx.setRegValue(th1, x86::rsp, memory::kStackBase), zyemu::StatusCode::success);
        ASSERT_EQ(ctx.setRegValue(th1, x86::rip, memory::kShellCodeBaseAddress), zyemu::StatusCode::success);

        std::uint64_t testValue{ 0x1AF20384ECAB27F };
        ASSERT_EQ(ctx.setRegValue(th1, x86::rax, testValue), zyemu::StatusCode::success);

        auto status = ctx.step(th1);
        ASSERT_EQ(status, zyemu::StatusCode::success);

        std::uint64_t rip{};
        ASSERT_EQ(ctx.getRegValue(th1, x86::rip, rip), zyemu::StatusCode::success);

        ASSERT_EQ(rip, memory::kShellCodeBaseAddress + sizeof(kTestShellCode));

        std::uint64_t rax{};
        ASSERT_EQ(ctx.getRegValue(th1, x86::rax, rax), zyemu::StatusCode::success);

        ASSERT_EQ(rax, testValue);

        std::uint64_t stackValue{};
        std::memcpy(&stackValue, memory::kStackSpace + memory::kStackBaseOffset, sizeof(stackValue));

        ASSERT_EQ(stackValue, testValue);
    }

    TEST(EmulationTests, testMemoryReadWrite)
    {
        constexpr std::uint8_t kTestShellCode[] = {
            0x48, 0x01, 0x04, 0x24, // add qword ptr ss:[rsp], rax
        };

        std::memcpy(memory::kShellCode, kTestShellCode, sizeof(kTestShellCode));

        std::memset(memory::kStackSpace, 0xCC, sizeof(memory::kStackSpace));

        zyemu::CPU ctx{};
        ctx.setMode(ZydisMachineMode::ZYDIS_MACHINE_MODE_LONG_64);
        ctx.setMemReadHandler(memory::readHandler, nullptr);
        ctx.setMemWriteHandler(memory::writeHandler, nullptr);

        auto th1 = ctx.createThread();

        ASSERT_EQ(ctx.setRegValue(th1, x86::rsp, memory::kStackBase), zyemu::StatusCode::success);
        ASSERT_EQ(ctx.setRegValue(th1, x86::rip, memory::kShellCodeBaseAddress), zyemu::StatusCode::success);

        std::uint64_t testValueRax{ 0x1AF20384ECAB27F };
        ASSERT_EQ(ctx.setRegValue(th1, x86::rax, testValueRax), zyemu::StatusCode::success);

        std::uint64_t testValueStack{ 0x1234567890ABCDEF };
        ASSERT_EQ(ctx.writeMemValue(memory::kStackBase, testValueStack), zyemu::StatusCode::success);

        auto status = ctx.step(th1);
        ASSERT_EQ(status, zyemu::StatusCode::success);

        std::uint64_t rip{};
        ASSERT_EQ(ctx.getRegValue(th1, x86::rip, rip), zyemu::StatusCode::success);

        ASSERT_EQ(rip, memory::kShellCodeBaseAddress + sizeof(kTestShellCode));

        std::uint64_t rax{};
        ASSERT_EQ(ctx.getRegValue(th1, x86::rax, rax), zyemu::StatusCode::success);

        ASSERT_EQ(rax, testValueRax);

        std::uint64_t stackValue{};
        std::memcpy(&stackValue, memory::kStackSpace + memory::kStackBaseOffset, sizeof(stackValue));

        std::uint64_t expectedValue = testValueStack + testValueRax;
        ASSERT_EQ(stackValue, expectedValue);
    }

    TEST(EmulationTests, testPushRax)
    {
        constexpr std::uint8_t kTestShellCode[] = {
            0x50 // push rax
        };

        std::memcpy(memory::kShellCode, kTestShellCode, sizeof(kTestShellCode));
        std::memset(memory::kStackSpace, 0xCC, sizeof(memory::kStackSpace));

        zyemu::CPU ctx{};
        ctx.setMode(ZydisMachineMode::ZYDIS_MACHINE_MODE_LONG_64);
        ctx.setMemReadHandler(memory::readHandler, nullptr);
        ctx.setMemWriteHandler(memory::writeHandler, nullptr);

        auto th1 = ctx.createThread();

        ASSERT_EQ(ctx.setRegValue(th1, x86::rsp, memory::kStackBase), zyemu::StatusCode::success);
        ASSERT_EQ(ctx.setRegValue(th1, x86::rip, memory::kShellCodeBaseAddress), zyemu::StatusCode::success);

        std::uint64_t testValue{ 0x1122334455667788ULL };
        ASSERT_EQ(ctx.setRegValue(th1, x86::rax, testValue), zyemu::StatusCode::success);

        auto status = ctx.step(th1);
        ASSERT_EQ(status, zyemu::StatusCode::success);

        std::uint64_t rsp{};
        ASSERT_EQ(ctx.getRegValue(th1, x86::rsp, rsp), zyemu::StatusCode::success);
        ASSERT_EQ(rsp, memory::kStackBase - 8);

        std::uint64_t stackValue{};
        std::memcpy(&stackValue, memory::kStackSpace + memory::kStackBaseOffset - 8, sizeof(stackValue));
        ASSERT_EQ(stackValue, testValue);
    }

    TEST(EmulationTests, testPopRax)
    {
        constexpr std::uint8_t kTestShellCode[] = {
            0x58 // pop rax
        };

        std::memcpy(memory::kShellCode, kTestShellCode, sizeof(kTestShellCode));
        std::memset(memory::kStackSpace, 0xCC, sizeof(memory::kStackSpace));

        zyemu::CPU ctx{};
        ctx.setMode(ZydisMachineMode::ZYDIS_MACHINE_MODE_LONG_64);
        ctx.setMemReadHandler(memory::readHandler, nullptr);
        ctx.setMemWriteHandler(memory::writeHandler, nullptr);

        auto th1 = ctx.createThread();

        std::uint64_t testValue{ 0xAABBCCDDEEFF0011ULL };
        std::memcpy(memory::kStackSpace + memory::kStackBaseOffset - 8, &testValue, sizeof(testValue));

        ASSERT_EQ(ctx.setRegValue(th1, x86::rsp, memory::kStackBase - 8), zyemu::StatusCode::success);
        ASSERT_EQ(ctx.setRegValue(th1, x86::rip, memory::kShellCodeBaseAddress), zyemu::StatusCode::success);

        auto status = ctx.step(th1);
        ASSERT_EQ(status, zyemu::StatusCode::success);

        std::uint64_t rsp{};
        ASSERT_EQ(ctx.getRegValue(th1, x86::rsp, rsp), zyemu::StatusCode::success);
        ASSERT_EQ(rsp, memory::kStackBase);

        std::uint64_t rax{};
        ASSERT_EQ(ctx.getRegValue(th1, x86::rax, rax), zyemu::StatusCode::success);
        ASSERT_EQ(rax, testValue);
    }

    TEST(EmulationTests, testLodsb)
    {
        constexpr std::uint8_t kTestShellCode[] = {
            0xAC, // lodsb
        };

        std::memcpy(memory::kShellCode, kTestShellCode, sizeof(kTestShellCode));

        zyemu::CPU ctx{};
        ctx.setMode(ZydisMachineMode::ZYDIS_MACHINE_MODE_LONG_64);
        ctx.setMemReadHandler(memory::readHandler, nullptr);
        ctx.setMemWriteHandler(memory::writeHandler, nullptr);

        auto th1 = ctx.createThread();

        std::uint8_t testValue = 0x42;
        std::uint64_t sourceAddr = memory::kStackBase + 0x100;
        std::memcpy(memory::kStackSpace + 0x100 + memory::kStackBaseOffset, &testValue, sizeof(testValue));

        ASSERT_EQ(ctx.setRegValue(th1, x86::rsi, sourceAddr), zyemu::StatusCode::success);
        ASSERT_EQ(ctx.setRegValue(th1, x86::rip, memory::kShellCodeBaseAddress), zyemu::StatusCode::success);
        ASSERT_EQ(ctx.setRegValue(th1, x86::rax, 0xFFFFFFFFFFFFFF00ULL), zyemu::StatusCode::success);

        auto status = ctx.step(th1);
        ASSERT_EQ(status, zyemu::StatusCode::success);

        std::uint64_t rip{};
        ASSERT_EQ(ctx.getRegValue(th1, x86::rip, rip), zyemu::StatusCode::success);
        ASSERT_EQ(rip, memory::kShellCodeBaseAddress + sizeof(kTestShellCode));

        std::uint64_t rax{};
        ASSERT_EQ(ctx.getRegValue(th1, x86::rax, rax), zyemu::StatusCode::success);
        ASSERT_EQ(static_cast<std::uint8_t>(rax), testValue);
        ASSERT_EQ(rax & 0xFFFFFFFFFFFFFF00ULL, 0xFFFFFFFFFFFFFF00ULL);

        std::uint64_t rsi{};
        ASSERT_EQ(ctx.getRegValue(th1, x86::rsi, rsi), zyemu::StatusCode::success);
        ASSERT_EQ(rsi, sourceAddr + 1);
    }

    TEST(EmulationTests, testLodsbDf)
    {
        constexpr std::uint8_t kTestShellCode[] = {
            0xAC, // lodsb
        };

        std::memcpy(memory::kShellCode, kTestShellCode, sizeof(kTestShellCode));

        zyemu::CPU ctx{};
        ctx.setMode(ZydisMachineMode::ZYDIS_MACHINE_MODE_LONG_64);
        ctx.setMemReadHandler(memory::readHandler, nullptr);
        ctx.setMemWriteHandler(memory::writeHandler, nullptr);

        auto th1 = ctx.createThread();

        std::uint8_t testValue = 0x42;
        std::uint64_t sourceAddr = memory::kStackBase + 0x100;
        std::memcpy(memory::kStackSpace + 0x100 + memory::kStackBaseOffset, &testValue, sizeof(testValue));

        ASSERT_EQ(ctx.setRegValue(th1, x86::rip, memory::kShellCodeBaseAddress), zyemu::StatusCode::success);
        ASSERT_EQ(ctx.setRegValue(th1, x86::rsi, sourceAddr), zyemu::StatusCode::success);
        ASSERT_EQ(ctx.setRegValue(th1, x86::rax, 0xFFFFFFFFFFFFFF00ULL), zyemu::StatusCode::success);

        std::uint32_t flags = (1u << 10); // DF.
        ASSERT_EQ(ctx.setRegValue(th1, x86::eflags, flags), zyemu::StatusCode::success);

        auto status = ctx.step(th1);
        ASSERT_EQ(status, zyemu::StatusCode::success);

        std::uint64_t rip{};
        ASSERT_EQ(ctx.getRegValue(th1, x86::rip, rip), zyemu::StatusCode::success);
        ASSERT_EQ(rip, memory::kShellCodeBaseAddress + sizeof(kTestShellCode));

        std::uint64_t rax{};
        ASSERT_EQ(ctx.getRegValue(th1, x86::rax, rax), zyemu::StatusCode::success);
        ASSERT_EQ(static_cast<std::uint8_t>(rax), testValue);
        ASSERT_EQ(rax & 0xFFFFFFFFFFFFFF00ULL, 0xFFFFFFFFFFFFFF00ULL);

        std::uint64_t rsi{};
        ASSERT_EQ(ctx.getRegValue(th1, x86::rsi, rsi), zyemu::StatusCode::success);
        ASSERT_EQ(rsi, sourceAddr - 1);
    }

    TEST(EmulationTests, testStosb)
    {
        constexpr std::uint8_t kTestShellCode[] = {
            0xAA, // stosb
        };
        std::memcpy(memory::kShellCode, kTestShellCode, sizeof(kTestShellCode));
        zyemu::CPU ctx{};
        ctx.setMode(ZydisMachineMode::ZYDIS_MACHINE_MODE_LONG_64);
        ctx.setMemReadHandler(memory::readHandler, nullptr);
        ctx.setMemWriteHandler(memory::writeHandler, nullptr);
        auto th1 = ctx.createThread();

        std::uint8_t testValue = 0x42;
        std::uint64_t destAddr = memory::kStackBase + 0x200;

        // Clear destination area
        std::memset(memory::kStackSpace + 0x200 + memory::kStackBaseOffset, 0xCC, 16);

        ASSERT_EQ(ctx.setRegValue(th1, x86::rip, memory::kShellCodeBaseAddress), zyemu::StatusCode::success);
        ASSERT_EQ(ctx.setRegValue(th1, x86::rdi, destAddr), zyemu::StatusCode::success);
        ASSERT_EQ(ctx.setRegValue(th1, x86::al, testValue), zyemu::StatusCode::success);

        auto status = ctx.step(th1);
        ASSERT_EQ(status, zyemu::StatusCode::success);

        std::uint64_t rip{};
        ASSERT_EQ(ctx.getRegValue(th1, x86::rip, rip), zyemu::StatusCode::success);
        ASSERT_EQ(rip, memory::kShellCodeBaseAddress + sizeof(kTestShellCode));

        // Check that the value was stored at the destination
        std::uint8_t storedValue{};
        ASSERT_EQ(ctx.readMemValue(destAddr, storedValue), zyemu::StatusCode::success);
        ASSERT_EQ(storedValue, testValue);

        // Check that RDI was incremented by 1
        std::uint64_t rdi{};
        ASSERT_EQ(ctx.getRegValue(th1, x86::rdi, rdi), zyemu::StatusCode::success);
        ASSERT_EQ(rdi, destAddr + 1);

        // Verify RAX wasn't modified
        std::uint64_t rax{};
        ASSERT_EQ(ctx.getRegValue(th1, x86::rax, rax), zyemu::StatusCode::success);
        ASSERT_EQ(static_cast<std::uint8_t>(rax), testValue);
    }

    TEST(EmulationTests, testStosbDf)
    {
        constexpr std::uint8_t kTestShellCode[] = {
            0xAA, // stosb
        };
        std::memcpy(memory::kShellCode, kTestShellCode, sizeof(kTestShellCode));
        zyemu::CPU ctx{};
        ctx.setMode(ZydisMachineMode::ZYDIS_MACHINE_MODE_LONG_64);
        ctx.setMemReadHandler(memory::readHandler, nullptr);
        ctx.setMemWriteHandler(memory::writeHandler, nullptr);
        auto th1 = ctx.createThread();

        std::uint8_t testValue = 0x42;
        std::uint64_t destAddr = memory::kStackBase + 0x200;

        // Clear destination area
        std::memset(memory::kStackSpace + 0x200 + memory::kStackBaseOffset, 0xCC, 16);

        ASSERT_EQ(ctx.setRegValue(th1, x86::rip, memory::kShellCodeBaseAddress), zyemu::StatusCode::success);
        ASSERT_EQ(ctx.setRegValue(th1, x86::rdi, destAddr), zyemu::StatusCode::success);
        ASSERT_EQ(ctx.setRegValue(th1, x86::al, testValue), zyemu::StatusCode::success);

        std::uint32_t flags = (1u << 10); // DF
        ASSERT_EQ(ctx.setRegValue(th1, x86::eflags, flags), zyemu::StatusCode::success);

        auto status = ctx.step(th1);
        ASSERT_EQ(status, zyemu::StatusCode::success);

        std::uint64_t rip{};
        ASSERT_EQ(ctx.getRegValue(th1, x86::rip, rip), zyemu::StatusCode::success);
        ASSERT_EQ(rip, memory::kShellCodeBaseAddress + sizeof(kTestShellCode));

        // Check that the value was stored at the destination
        std::uint8_t storedValue{};
        std::memcpy(&storedValue, memory::kStackSpace + 0x200 + memory::kStackBaseOffset, sizeof(storedValue));
        ASSERT_EQ(storedValue, testValue);

        // Check that RDI was decremented by 1 (due to direction flag)
        std::uint64_t rdi{};
        ASSERT_EQ(ctx.getRegValue(th1, x86::rdi, rdi), zyemu::StatusCode::success);
        ASSERT_EQ(rdi, destAddr - 1);

        // Verify RAX wasn't modified
        std::uint64_t rax{};
        ASSERT_EQ(ctx.getRegValue(th1, x86::rax, rax), zyemu::StatusCode::success);
        ASSERT_EQ(static_cast<std::uint8_t>(rax), testValue);
    }

} // namespace zyemu::tests

```

`src/tests/tests/emulation.testdata.cpp`:

```cpp
#include "memory.hpp"
#include "testdata.hpp"

#include <Zydis/Decoder.h>
#include <algorithm>
#include <gtest/gtest.h>
#include <print>
#include <zyemu/zyemu.hpp>

namespace zyemu::tests
{
    static uint32_t getUndefinedFlags(const InstrEntry& entry)
    {
        ZydisDecoder decoder;
        ZydisDecoderInit(&decoder, ZydisMachineMode::ZYDIS_MACHINE_MODE_LONG_64, ZydisStackWidth::ZYDIS_STACK_WIDTH_64);

        ZydisDecodedInstruction instruction{};
        if (ZydisDecoderDecodeInstruction(&decoder, nullptr, entry.instrBytes.bytes, entry.instrBytes.length, &instruction)
            != ZYAN_STATUS_SUCCESS)
        {
            return 0;
        }

#ifdef _MSC_VER
        // Never null.
        __assume(instruction.cpu_flags != nullptr);
#endif
        return instruction.cpu_flags->undefined;
    }

    static void runInstrChecks(const InstrEntry& entry)
    {
        zyemu::CPU ctx{};

        ctx.setMode(ZydisMachineMode::ZYDIS_MACHINE_MODE_LONG_64);
        ctx.setMemReadHandler(memory::readHandler, nullptr);
        ctx.setMemWriteHandler(memory::writeHandler, nullptr);

        const auto th1 = ctx.createThread();

        // Write instruction.
        const auto instrBytes = entry.instrBytes.data();
        memory::writeHandler(ThreadId::invalid, entry.rip, instrBytes.data(), instrBytes.size(), nullptr);

        for (std::size_t entryIdx = 0; entryIdx < entry.testEntries.size(); ++entryIdx)
        {
#if defined(_DEBUG) && 0
            std::println("Test Entry: {}", entryIdx);
#endif

            const auto testEntry = entry.testEntries[entryIdx];

            if (testEntry.exceptionType != ExceptionType::kNone)
            {
                // TODO: Not all handlers properly implement exception handling, skip for now.
                //continue;
            }

            ASSERT_EQ(ctx.setRegValue(th1, x86::rip, entry.rip), zyemu::StatusCode::success);

            // Clear output regs.
            for (const auto& regData : testEntry.outputs)
            {
                sfl::small_vector<std::byte, 16> zeroData(regData.data.size(), {});
                ASSERT_EQ(ctx.setRegData(th1, regData.reg, zeroData), zyemu::StatusCode::success);
            }

            // Assign all reg inputs.
            for (const auto& regData : testEntry.inputs)
            {
                ASSERT_EQ(ctx.setRegData(th1, regData.reg, regData.data), zyemu::StatusCode::success);
            }

            // Step.
            auto status = ctx.step(th1);

            if (testEntry.exceptionType == ExceptionType::kIntDivideError)
            {
                ASSERT_EQ(status, zyemu::StatusCode::exceptionIntDivideError);
                continue;
            }
            else if (testEntry.exceptionType == ExceptionType::kIntOverflow)
            {
                ASSERT_EQ(status, zyemu::StatusCode::exceptionIntOverflow);
                continue;
            }

            ASSERT_EQ(status, zyemu::StatusCode::success) << "Entry: " << entryIdx;

            std::uint64_t rip{};
            ASSERT_EQ(ctx.getRegValue(th1, x86::rip, rip), zyemu::StatusCode::success);

            ASSERT_EQ(rip, entry.rip + instrBytes.size());

            // Check outputs.
            for (const auto& regData : testEntry.outputs)
            {
                if (regData.reg == ZYDIS_REGISTER_EFLAGS)
                {
                    std::uint32_t expectedFlags{};
                    std::memcpy(&expectedFlags, regData.data.data(), sizeof(expectedFlags));

                    std::uint32_t actualFlags{};
                    ASSERT_EQ(ctx.getRegValue(th1, ZYDIS_REGISTER_EFLAGS, actualFlags), zyemu::StatusCode::success);

                    // Remove IF and reserved.
                    actualFlags &= ~(ZYDIS_CPUFLAG_IF | (1u << 1));

                    // Remove undefined flags.
                    const auto undefinedFlags = getUndefinedFlags(entry);
                    actualFlags &= ~undefinedFlags;
                    expectedFlags &= ~undefinedFlags;

                    ASSERT_EQ(actualFlags, expectedFlags) << "Entry: " << entryIdx;
                }
                else
                {
                    RawData actualData{};
                    actualData.resize(regData.data.size());

                    ASSERT_EQ(ctx.getRegData(th1, regData.reg, actualData), zyemu::StatusCode::success)
                        << ZydisRegisterGetString(regData.reg) << ", Entry: " << entryIdx;
                    ASSERT_EQ(actualData, regData.data) << ZydisRegisterGetString(regData.reg) << ", Entry: " << entryIdx;
                }
            }
        }
    }

    class EmulationParameterizedTest : public testing::TestWithParam<TestParam>
    {
    };

    TEST_P(EmulationParameterizedTest, RunInstrTests)
    {
        const auto& param = GetParam();
        auto entryOpt = parseSingleInstrEntry(param.filePath, param.startOffset, param.rip);
        ASSERT_TRUE(entryOpt.has_value()) << "Failed to parse entry from " << param.filePath << " at offset "
                                          << param.startOffset;

        const auto& entry = entryOpt.value();
        runInstrChecks(entry);
    }

    struct PrintToStringParamName
    {
        static std::string sanitizeTestName(const std::string& instrText)
        {
            std::string name = instrText;
            std::replace(name.begin(), name.end(), ' ', '_');
            std::replace(name.begin(), name.end(), ',', '_');
            std::replace(name.begin(), name.end(), '*', 's');
            std::replace(name.begin(), name.end(), '-', 'm');
            std::replace(name.begin(), name.end(), '+', 'p');
            std::replace(name.begin(), name.end(), '[', '_');
            std::replace(name.begin(), name.end(), ']', '_');
            return name;
        }

        std::string operator()(const testing::TestParamInfo<TestParam>& info) const
        {
            return sanitizeTestName(info.param.instrText);
        }
    };

    // clang-format off
#if defined(_DEBUG) || 0
    static const std::vector<std::string> allTestFiles = {
        "testdata/idiv.txt",
        "testdata/sub.txt",
        //"testdata/and.txt",
        //"testdata/shld.txt",
        //"testdata/mul.txt",
        //"testdata/div.txt",
        //"testdata/cmppd.txt",
    };
#else
    static const std::vector<std::string> allTestFiles = {
        // SIMD
        "testdata/xorps.txt",
        "testdata/xorpd.txt",
        "testdata/unpckhpd.txt",
        "testdata/unpckhps.txt",
        "testdata/unpcklpd.txt",
        "testdata/unpcklps.txt",
        "testdata/ucomisd.txt",
        "testdata/ucomiss.txt",
        "testdata/subss.txt",
        "testdata/subsd.txt",
        "testdata/subps.txt",
        "testdata/subpd.txt",
        "testdata/sqrtss.txt",
        "testdata/sqrtsd.txt",
        "testdata/sqrtps.txt",
        "testdata/sqrtpd.txt",
        "testdata/shufps.txt",
        "testdata/shufpd.txt",
        "testdata/roundss.txt",
        "testdata/roundsd.txt",
        "testdata/roundps.txt",
        "testdata/roundpd.txt",
        //"testdata/rsqrtss.txt", // Not same on all CPUs
        //"testdata/rsqrtps.txt", // Not same on all CPUs
        //"testdata/rcpps.txt", // Not same on all CPUs
        //"testdata/rcpss.txt", // Not same on all CPUs
        "testdata/orps.txt",
        "testdata/orpd.txt",
        "testdata/mulss.txt",
        "testdata/mulsd.txt",
        "testdata/mulps.txt",
        "testdata/mulpd.txt",
        "testdata/mpsadbw.txt", 
        "testdata/movups.txt", 
        "testdata/movupd.txt", 
        "testdata/movsldup.txt", 
        "testdata/movshdup.txt", 
        "testdata/movmskps.txt",
        "testdata/movmskpd.txt",
        "testdata/movlhps.txt",
        "testdata/movhlps.txt",
        "testdata/movdqu.txt",
        "testdata/movdqa.txt",
        "testdata/movddup.txt",
        "testdata/movaps.txt",
        "testdata/movapd.txt",
        "testdata/minss.txt",
        "testdata/minsd.txt",
        "testdata/minps.txt",
        "testdata/minpd.txt",
        "testdata/minss.txt",
        "testdata/maxsd.txt",
        "testdata/maxps.txt",
        "testdata/maxpd.txt",
        //"testdata/insertq.txt",  // Needs CPU checking.
        "testdata/insertps.txt",
        "testdata/hsubps.txt",
        "testdata/hsubpd.txt",
        "testdata/haddps.txt",
        "testdata/haddpd.txt",
        "testdata/extractps.txt",
        "testdata/dpps.txt",
        "testdata/dppd.txt",
        "testdata/divss.txt",
        "testdata/divsd.txt",
        "testdata/divps.txt",
        "testdata/divpd.txt",
        "testdata/cvttss2si.txt",
        "testdata/cvttsd2si.txt",
        "testdata/cvttps2dq.txt",
        "testdata/cvttpd2dq.txt",
        "testdata/cvtss2si.txt",
        "testdata/cvtss2sd.txt",
        "testdata/cvtsi2ss.txt",
        "testdata/cvtsi2sd.txt",
        "testdata/cvtsd2ss.txt",
        "testdata/cvtsd2si.txt",
        "testdata/cvtps2pd.txt",
        "testdata/cvtps2dq.txt",
        //"testdata/movq2dq.txt", // MMX
        //"testdata/cvtpi2ps.txt", // MMX
        //"testdata/cvtpi2pd.txt", // MMX
        "testdata/cvtpd2ps.txt",
        "testdata/cvtpd2dq.txt",
        "testdata/cvtdq2ps.txt",
        "testdata/cvtdq2pd.txt",
        "testdata/comiss.txt",
        "testdata/comisd.txt",
        "testdata/cmpps.txt",
        "testdata/cmppd.txt",
        "testdata/blendvps.txt",
        "testdata/blendvpd.txt",
        "testdata/blendps.txt",
        "testdata/blendpd.txt",
        "testdata/andps.txt",
        "testdata/andpd.txt",
        "testdata/andnps.txt",
        "testdata/andnpd.txt",
        "testdata/aeskeygenassist.txt",
        "testdata/aesimc.txt",
        "testdata/aesenclast.txt",
        "testdata/aesenc.txt",
        "testdata/aesdeclast.txt",
        "testdata/aesdec.txt",
        "testdata/addsubps.txt",
        "testdata/addsubpd.txt",
        "testdata/addss.txt",
        "testdata/addsd.txt",
        "testdata/addpd.txt",
        // General Purpose.
        // 
        //"testdata/cmpsb.txt",
        "testdata/div.txt",
        //"testdata/idiv.txt",
        //"testdata/lar.txt", // fails
        "testdata/mul.txt",
        //"testdata/scasb.txt",
        //"testdata/scasd.txt",
        //"testdata/scasq.txt",
        "testdata/shld.txt",
        "testdata/adc.txt",
        "testdata/adcx.txt",
        "testdata/add.txt",
        "testdata/adox.txt",
        "testdata/and.txt",
        "testdata/andn.txt",
        "testdata/bextr.txt",
        "testdata/blsi.txt",
        "testdata/blsmsk.txt",
        "testdata/blsr.txt",
        "testdata/bsf.txt",
        "testdata/bsr.txt",
        "testdata/bswap.txt",
        "testdata/bt.txt",
        "testdata/btc.txt",
        "testdata/btr.txt",
        "testdata/bts.txt",
        "testdata/bzhi.txt",
        "testdata/cbw.txt",
        "testdata/cdq.txt",
        "testdata/cdqe.txt",
        "testdata/clc.txt",
        "testdata/cld.txt",
        "testdata/cmc.txt",
        "testdata/cmovb.txt",
        "testdata/cmovbe.txt",
        "testdata/cmovl.txt",
        "testdata/cmovle.txt",
        "testdata/cmovnb.txt",
        "testdata/cmovnbe.txt",
        "testdata/cmovnl.txt",
        "testdata/cmovnle.txt",
        "testdata/cmovno.txt",
        "testdata/cmovnp.txt",
        "testdata/cmovns.txt",
        "testdata/cmovnz.txt",
        "testdata/cmovo.txt",
        "testdata/cmovp.txt",
        "testdata/cmovs.txt",
        "testdata/cmovz.txt",
        "testdata/cmp.txt",
        "testdata/cmpxchg.txt",
        "testdata/cqo.txt",
        "testdata/cwd.txt",
        "testdata/cwde.txt",
        "testdata/dec.txt",
        "testdata/inc.txt",
        "testdata/lahf.txt",
        "testdata/lea.txt",
        "testdata/lzcnt.txt",
        "testdata/mov.txt",
        "testdata/movsx.txt",
        "testdata/movsxd.txt",
        "testdata/movzx.txt",
        "testdata/neg.txt",
        "testdata/not.txt",
        "testdata/or.txt",
        "testdata/rcl.txt",
        "testdata/rcr.txt",
        "testdata/rol.txt",
        "testdata/ror.txt",
        "testdata/rorx.txt",
        "testdata/sahf.txt",
        "testdata/sar.txt",
        "testdata/sarx.txt",
        "testdata/sbb.txt",
        "testdata/setb.txt",
        "testdata/setbe.txt",
        "testdata/setl.txt",
        "testdata/setle.txt",
        "testdata/setnb.txt",
        "testdata/setnbe.txt",
        "testdata/setnl.txt",
        "testdata/setnle.txt",
        "testdata/setno.txt",
        "testdata/setnp.txt",
        "testdata/setns.txt",
        "testdata/setnz.txt",
        "testdata/seto.txt",
        "testdata/setp.txt",
        "testdata/sets.txt",
        "testdata/setz.txt",
        "testdata/shl.txt",
        "testdata/shl.txt",
        "testdata/shlx.txt",
        "testdata/shr.txt",
        "testdata/stc.txt",
        "testdata/std.txt",
        "testdata/sub.txt",
        "testdata/test.txt",
        "testdata/xadd.txt",
        "testdata/xchg.txt",
        "testdata/xor.txt",
    };
#endif
    // clang-format on

    INSTANTIATE_TEST_SUITE_P(
        AllInstrs, EmulationParameterizedTest, testing::ValuesIn(collectAllTestParams(allTestFiles)), PrintToStringParamName());

} // namespace zyemu::tests

```

`src/tests/tests/memory.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <cstring>
#include <zyemu/zyemu.hpp>

namespace zyemu::tests::memory
{
    static constexpr std::uint64_t kShellCodeBaseAddress = 0x0000000004000000;
    static std::uint8_t kShellCode[0x1000] = {};

    static constexpr std::uint64_t kStackAddress = 0x0000000008000000;
    static constexpr std::uint64_t kStackBaseOffset = 0x500;
    static constexpr std::uint64_t kStackBase = kStackAddress + kStackBaseOffset;
    static std::uint8_t kStackSpace[0x1000] = {};

    static zyemu::StatusCode readHandler(
        zyemu::ThreadId tid, std::uint64_t readAddress, void* dst, std::size_t size, void* userData)
    {
        if (readAddress >= kShellCodeBaseAddress && (readAddress + size) <= (kShellCodeBaseAddress + std::size(kShellCode)))
        {
            const auto offset = readAddress - kShellCodeBaseAddress;
            std::memcpy(dst, kShellCode + offset, size);
            return zyemu::StatusCode::success;
        }
        else if (readAddress >= kStackAddress && (readAddress + size) <= (kStackAddress + std::size(kStackSpace)))
        {
            const auto offset = readAddress - kStackAddress;
            std::memcpy(dst, kStackSpace + offset, size);
            return zyemu::StatusCode::success;
        }

        return zyemu::StatusCode::invalidMemory;
    }

    static zyemu::StatusCode writeHandler(
        zyemu::ThreadId tid, std::uint64_t writeAddress, const void* src, std::size_t size, void* userData)
    {
        if (writeAddress >= kShellCodeBaseAddress && (writeAddress + size) <= (kShellCodeBaseAddress + std::size(kShellCode)))
        {
            const auto offset = writeAddress - kShellCodeBaseAddress;
            std::memcpy(kShellCode + offset, src, size);
            return zyemu::StatusCode::success;
        }
        else if (writeAddress >= kStackAddress && (writeAddress + size) <= (kStackAddress + std::size(kStackSpace)))
        {
            const auto offset = writeAddress - kStackAddress;
            std::memcpy(kStackSpace + offset, src, size);
            return zyemu::StatusCode::success;
        }

        return zyemu::StatusCode::invalidMemory;
    }

} // namespace zyemu::tests::memory
```

`src/tests/tests/registers.cpp`:

```cpp
#include "memory.hpp"

#include <assembler.hpp>
#include <gtest/gtest.h>
#include <zyemu/zyemu.hpp>

namespace zyemu::tests
{
    struct RegChangeCase
    {
        Reg input;
        int size;
        bool high;
        Reg expected;
    };

    class ChangeRegSizeTest : public ::testing::TestWithParam<RegChangeCase>
    {
    };

    TEST_P(ChangeRegSizeTest, MatchesExpected)
    {
        auto param = GetParam();
        ASSERT_EQ(x86::changeRegSize(param.input, param.size, param.high), param.expected);
    }

    INSTANTIATE_TEST_SUITE_P(
        AllRegisters, ChangeRegSizeTest,
        ::testing::Values(
            // rax family
            RegChangeCase{ x86::rax, 8, false, x86::al },   //
            RegChangeCase{ x86::rax, 8, true, x86::ah },    //
            RegChangeCase{ x86::rax, 16, false, x86::ax },  //
            RegChangeCase{ x86::rax, 32, false, x86::eax }, //
            RegChangeCase{ x86::rax, 64, false, x86::rax }, //

            // rbx family
            RegChangeCase{ x86::rbx, 8, false, x86::bl },   //
            RegChangeCase{ x86::rbx, 8, true, x86::bh },    //
            RegChangeCase{ x86::rbx, 16, false, x86::bx },  //
            RegChangeCase{ x86::rbx, 32, false, x86::ebx }, //
            RegChangeCase{ x86::rbx, 64, false, x86::rbx }, //

            // rcx family
            RegChangeCase{ x86::rcx, 8, false, x86::cl },   //
            RegChangeCase{ x86::rcx, 8, true, x86::ch },    //
            RegChangeCase{ x86::rcx, 16, false, x86::cx },  //
            RegChangeCase{ x86::rcx, 32, false, x86::ecx }, //
            RegChangeCase{ x86::rcx, 64, false, x86::rcx }, //

            // rdx family
            RegChangeCase{ x86::rdx, 8, false, x86::dl },   //
            RegChangeCase{ x86::rdx, 8, true, x86::dh },    //
            RegChangeCase{ x86::rdx, 16, false, x86::dx },  //
            RegChangeCase{ x86::rdx, 32, false, x86::edx }, //
            RegChangeCase{ x86::rdx, 64, false, x86::rdx }, //

            // rsi family
            RegChangeCase{ x86::rsi, 8, false, x86::sil },  //
            RegChangeCase{ x86::rsi, 16, false, x86::si },  //
            RegChangeCase{ x86::rsi, 32, false, x86::esi }, //
            RegChangeCase{ x86::rsi, 64, false, x86::rsi }, //

            // rdi family
            RegChangeCase{ x86::rdi, 8, false, x86::dil },  //
            RegChangeCase{ x86::rdi, 16, false, x86::di },  //
            RegChangeCase{ x86::rdi, 32, false, x86::edi }, //
            RegChangeCase{ x86::rdi, 64, false, x86::rdi }, // 

            // rbp family
            RegChangeCase{ x86::rbp, 8, false, x86::bpl },  //
            RegChangeCase{ x86::rbp, 16, false, x86::bp },  //
            RegChangeCase{ x86::rbp, 32, false, x86::ebp }, //
            RegChangeCase{ x86::rbp, 64, false, x86::rbp }, //

            // rsp family
            RegChangeCase{ x86::rsp, 8, false, x86::spl },  //
            RegChangeCase{ x86::rsp, 16, false, x86::sp },  //
            RegChangeCase{ x86::rsp, 32, false, x86::esp }, //
            RegChangeCase{ x86::rsp, 64, false, x86::rsp }, //

            // r8 family
            RegChangeCase{ x86::r8, 8, false, x86::r8b },  //
            RegChangeCase{ x86::r8, 16, false, x86::r8w }, //
            RegChangeCase{ x86::r8, 32, false, x86::r8d }, //
            RegChangeCase{ x86::r8, 64, false, x86::r8 },  //

            // r9 family
            RegChangeCase{ x86::r9, 8, false, x86::r9b },  //
            RegChangeCase{ x86::r9, 16, false, x86::r9w }, //
            RegChangeCase{ x86::r9, 32, false, x86::r9d }, //
            RegChangeCase{ x86::r9, 64, false, x86::r9 },  //

            // r10 family
            RegChangeCase{ x86::r10, 8, false, x86::r10b },  //
            RegChangeCase{ x86::r10, 16, false, x86::r10w }, //
            RegChangeCase{ x86::r10, 32, false, x86::r10d }, //
            RegChangeCase{ x86::r10, 64, false, x86::r10 },  //

            // r11 family
            RegChangeCase{ x86::r11, 8, false, x86::r11b },  //
            RegChangeCase{ x86::r11, 16, false, x86::r11w }, //
            RegChangeCase{ x86::r11, 32, false, x86::r11d }, //
            RegChangeCase{ x86::r11, 64, false, x86::r11 },  //

            // r12 family
            RegChangeCase{ x86::r12, 8, false, x86::r12b },  //
            RegChangeCase{ x86::r12, 16, false, x86::r12w }, //
            RegChangeCase{ x86::r12, 32, false, x86::r12d }, //
            RegChangeCase{ x86::r12, 64, false, x86::r12 },  //

            // r13 family
            RegChangeCase{ x86::r13, 8, false, x86::r13b },  //
            RegChangeCase{ x86::r13, 16, false, x86::r13w }, //
            RegChangeCase{ x86::r13, 32, false, x86::r13d }, //
            RegChangeCase{ x86::r13, 64, false, x86::r13 },  //

            // r14 family
            RegChangeCase{ x86::r14, 8, false, x86::r14b },  //
            RegChangeCase{ x86::r14, 16, false, x86::r14w }, //
            RegChangeCase{ x86::r14, 32, false, x86::r14d }, //
            RegChangeCase{ x86::r14, 64, false, x86::r14 },  //

            // r15 family
            RegChangeCase{ x86::r15, 8, false, x86::r15b },  //
            RegChangeCase{ x86::r15, 16, false, x86::r15w }, //
            RegChangeCase{ x86::r15, 32, false, x86::r15d }, //
            RegChangeCase{ x86::r15, 64, false, x86::r15 }   //
            ));

} // namespace zyemu::tests

```

`src/zyemu/assembler.cpp`:

```cpp
#include "assembler.hpp"

#include <Zydis/Encoder.h>
#include <cassert>
#include <format>
#include <iostream>
#include <map>

namespace zyemu::x86
{
    struct NodeData
    {
        std::uint64_t address{};
        std::uint8_t size{};
    };

    struct EncodeState
    {
        ZydisMachineMode mode{};
        std::map<std::int32_t, std::size_t> labelMap{};
        std::vector<std::uint32_t> nodeSize{};
        std::uint64_t baseAddress{};
        std::uint64_t currentAddress{};
        std::vector<std::uint8_t> buffer;
    };

    struct EncodeInfo
    {
        std::uint32_t size{};
        bool needsPass{};
    };

    static Result<EncodeInfo> handleNode(EncodeState& state, const Label& label)
    {
        assert(label.isValid());

        state.labelMap[label.id] = state.currentAddress;
        return EncodeInfo{ 0, false };
    }

    static inline bool isBranchingInstr(ZydisMnemonic mnemonic)
    {
        switch (mnemonic)
        {
            case ZYDIS_MNEMONIC_CALL:
            case ZYDIS_MNEMONIC_JB:
            case ZYDIS_MNEMONIC_JBE:
            case ZYDIS_MNEMONIC_JCXZ:
            case ZYDIS_MNEMONIC_JECXZ:
            case ZYDIS_MNEMONIC_JKNZD:
            case ZYDIS_MNEMONIC_JKZD:
            case ZYDIS_MNEMONIC_JL:
            case ZYDIS_MNEMONIC_JLE:
            case ZYDIS_MNEMONIC_JMP:
            case ZYDIS_MNEMONIC_JNB:
            case ZYDIS_MNEMONIC_JNBE:
            case ZYDIS_MNEMONIC_JNL:
            case ZYDIS_MNEMONIC_JNLE:
            case ZYDIS_MNEMONIC_JNO:
            case ZYDIS_MNEMONIC_JNP:
            case ZYDIS_MNEMONIC_JNS:
            case ZYDIS_MNEMONIC_JNZ:
            case ZYDIS_MNEMONIC_JO:
            case ZYDIS_MNEMONIC_JP:
            case ZYDIS_MNEMONIC_JRCXZ:
            case ZYDIS_MNEMONIC_JS:
            case ZYDIS_MNEMONIC_JZ:
                return true;
        }
        return false;
    }

    static Result<EncodeInfo> handleNode(EncodeState& state, const Instruction& instr)
    {
        ZydisEncoderRequest request{};
        request.machine_mode = state.mode;
        request.mnemonic = instr.mnemonic;
        request.operand_count = instr.operands.size();
        request.branch_type = ZYDIS_BRANCH_TYPE_NONE;

        bool needsPass = false;
        for (std::size_t i = 0; i < instr.operands.size(); i++)
        {
            const auto op = instr.operands[i];
            auto& dstOp = request.operands[i];
            if (const auto* opReg = std::get_if<Reg>(&op); opReg != nullptr)
            {
                dstOp.type = ZYDIS_OPERAND_TYPE_REGISTER;
                dstOp.reg.value = opReg->value;

                assert(opReg->value != ZYDIS_REGISTER_NONE);
            }
            else if (const auto* opMem = std::get_if<Mem>(&op); opMem != nullptr)
            {
                dstOp.type = ZYDIS_OPERAND_TYPE_MEMORY;
                dstOp.mem.size = opMem->bitSize / 8;
                dstOp.mem.base = opMem->base.value;
                dstOp.mem.index = opMem->index.value;
                dstOp.mem.scale = opMem->scale;
                dstOp.mem.displacement = opMem->disp;
                if (opMem->label.id != -1)
                {
                    if (auto it = state.labelMap.find(opMem->label.id); it == state.labelMap.end())
                    {
                        dstOp.mem.displacement += state.currentAddress + 0x12345;
                        needsPass = true;
                    }
                    else
                    {
                        dstOp.mem.displacement += it->second;
                    }
                }
            }
            else if (const auto* opImm = std::get_if<Imm>(&op); opImm != nullptr)
            {
                dstOp.type = ZYDIS_OPERAND_TYPE_IMMEDIATE;
                dstOp.imm.s = opImm->value;
            }
            else if (const auto* opLabel = std::get_if<Label>(&op); opLabel != nullptr)
            {
                dstOp.type = ZYDIS_OPERAND_TYPE_IMMEDIATE;
                assert(opLabel->isValid());

                if (auto it = state.labelMap.find(opLabel->id); it == state.labelMap.end())
                {
                    needsPass = true;
                    dstOp.imm.s = state.currentAddress + 0x12345;
                }
                else
                {
                    dstOp.imm.s = it->second;
                }
            }
        }

        std::uint8_t buf[16]{};
        std::size_t bufSize = sizeof(buf);

        auto res = ZydisEncoderEncodeInstructionAbsolute(&request, buf, &bufSize, state.currentAddress);
        if (res != ZYAN_STATUS_SUCCESS)
        {
            return StatusCode::invalidInstruction;
        }

        state.buffer.insert(state.buffer.end(), buf, buf + bufSize);

        return EncodeInfo{ static_cast<std::uint32_t>(bufSize), needsPass };
    }

    static std::string getNodeString(const Label& label)
    {
        return std::format("L_{0}", static_cast<size_t>(label.id));
    }

    static std::string getNodeString(const Instruction& instr)
    {
        std::string_view mnemonicName = ZydisMnemonicGetString(instr.mnemonic);

        std::string prefixesStr;
        // TODO: Prefix handling.
        /*
        if (instr.data.prefixes & ZYDIS_INSTRUCTION_PREFIX_LOCK)
        {
            prefixesStr += "lock ";
        }
        */

        std::string operandsStr;
        for (const auto& op : instr.operands)
        {
            if (!operandsStr.empty())
            {
                std::format_to(std::back_inserter(operandsStr), ", ");
            }
            if (const auto* reg = std::get_if<Reg>(&op); reg != nullptr)
            {
                std::format_to(std::back_inserter(operandsStr), "{}", ZydisRegisterGetString(reg->value));
            }
            else if (const auto* mem = std::get_if<Mem>(&op); mem != nullptr)
            {
                constexpr auto sizePrefixes = std::array{ "byte ptr", "word ptr", "dword ptr", "qword ptr", "tword ptr" };
                const auto sizeIndex = mem->bitSize / 8 - 1;
                if (sizeIndex < std::size(sizePrefixes))
                {
                    std::format_to(std::back_inserter(operandsStr), "{} ", sizePrefixes[sizeIndex]);
                }

                if (mem->seg.value != ZYDIS_REGISTER_NONE)
                {
                    std::format_to(std::back_inserter(operandsStr), "{}:", ZydisRegisterGetString(mem->seg.value));
                }

                std::format_to(std::back_inserter(operandsStr), "[");

                bool hasBase = false;
                if (mem->base.value != ZYDIS_REGISTER_NONE)
                {
                    std::format_to(std::back_inserter(operandsStr), "{}", ZydisRegisterGetString(mem->base.value));
                    hasBase = true;
                }

                bool hasIndex = false;
                if (mem->index.value != ZYDIS_REGISTER_NONE)
                {
                    if (hasBase)
                    {
                        std::format_to(std::back_inserter(operandsStr), "+");
                    }
                    operandsStr += ZydisRegisterGetString(mem->index.value);

                    if (mem->scale >= 1)
                    {
                        std::format_to(std::back_inserter(operandsStr), "*{}", mem->scale);
                    }
                    hasIndex = true;
                }

                if (mem->disp != 0)
                {
                    if (hasBase || hasIndex)
                    {
                        std::format_to(std::back_inserter(operandsStr), "{}", mem->disp < 0 ? "-" : "+");
                    }
                    std::format_to(std::back_inserter(operandsStr), "{0:X}", std::abs(mem->disp));
                }

                std::format_to(std::back_inserter(operandsStr), "]");
            }
            else if (const auto* imm = std::get_if<Imm>(&op); imm != nullptr)
            {
                std::format_to(std::back_inserter(operandsStr), "{0:X}", imm->value);
            }
            else if (const auto* label = std::get_if<Label>(&op); label != nullptr)
            {
                std::format_to(std::back_inserter(operandsStr), "L_{0}", static_cast<size_t>(label->id));
            }
        }

        std::string result;
        std::format_to(std::back_inserter(result), "{}", prefixesStr);
        std::format_to(std::back_inserter(result), "{}", mnemonicName);
        if (!operandsStr.empty())
        {
            std::format_to(std::back_inserter(result), " {}", operandsStr);
        }
        return result;
    }

    static std::string getNodeString(const Assembler::Node& node)
    {
        return std::visit([](const auto& data) { return getNodeString(data); }, node);
    }

    Result<std::size_t> Assembler::finalize(
        ZydisMachineMode mode, std::uint64_t baseAddress, std::byte* buffer, std::size_t bufSize)
    {
        EncodeState state{};
        state.mode = mode;
        state.baseAddress = baseAddress;
        state.nodeSize.resize(_nodes.size());

        bool needsPass = true;
        while (needsPass)
        {
            needsPass = false;

            state.currentAddress = baseAddress;
            state.buffer.clear();

            for (std::size_t i = 0; i < _nodes.size(); i++)
            {
                const auto& node = this->_nodes[i];

                auto encodeInfo = std::visit([&](const auto& data) { return handleNode(state, data); }, node);
                if (!encodeInfo)
                {
                    std::println(std::cout, "Failed to encode: {}", getNodeString(node));
                    return encodeInfo.getError();
                }

                needsPass |= encodeInfo->needsPass;

                const auto oldNodeSize = state.nodeSize[i];
                if (oldNodeSize != 0 && oldNodeSize != encodeInfo->size)
                {
                    needsPass = true;
                }

                state.nodeSize[i] = encodeInfo->size;
                state.currentAddress += encodeInfo->size;
            }
        }

        if (state.buffer.size() > bufSize)
        {
            return StatusCode::bufferTooSmall;
        }

        std::memcpy(buffer, state.buffer.data(), state.buffer.size());

        return state.buffer.size();
    }

} // namespace zyemu::x86
```

`src/zyemu/assembler.hpp`:

```hpp
#pragma once

#include "assembler.types.hpp"

#include <Zydis/Encoder.h>
#include <Zydis/Mnemonic.h>
#include <Zydis/Register.h>
#include <array>
#include <cstddef>
#include <cstdint>
#include <sfl/small_vector.hpp>
#include <sfl/static_vector.hpp>
#include <variant>
#include <vector>
#include <zyemu/registers.hpp>
#include <zyemu/types.hpp>

namespace zyemu::x86
{
    class Assembler
    {
    public:
        using Node = std::variant<Instruction, Label>;

    private:
        std::int32_t _insertPos{};
        std::int32_t labelId{};
        sfl::small_vector<Node, 64> _nodes;

    public:
        void setInsertPos(std::int32_t pos)
        {
            assert(pos <= _nodes.size());
            _insertPos = pos;
        }

        std::int32_t getInsertPos() const
        {
            return _insertPos;
        }

        std::int32_t getNodeCount() const
        {
            return static_cast<std::int32_t>(_nodes.size());
        }

        void clear()
        {
            _nodes.clear();
            _insertPos = 0;
            labelId = 0;
        }

        Label createLabel()
        {
            return Label{ labelId++ };
        }

        Assembler& bind(Label label)
        {
            _nodes.insert(_nodes.begin() + _insertPos, label);
            _insertPos++;
            return *this;
        }

        template<typename... TOperands> Assembler& emit(const Instruction& instr)
        {
            _nodes.insert(_nodes.begin() + _insertPos, instr);
            _insertPos++;
            return *this;
        }

        template<typename... TOperands> Assembler& emit(ZydisMnemonic mnemonic, TOperands&&... operands)
        {
            _nodes.insert(_nodes.begin() + _insertPos, Instruction{ mnemonic, { std::forward<TOperands>(operands)... } });
            _insertPos++;
            return *this;
        }

        Assembler& cld()
        {
            return emit(ZYDIS_MNEMONIC_CLD);
        }

        Assembler& nop()
        {
            return emit(ZYDIS_MNEMONIC_NOP);
        }

        template<typename TOperand> Assembler& not_(const TOperand& target)
        {
            return emit(ZYDIS_MNEMONIC_NOT, target);
        }

        template<typename TOperand> Assembler& dec(const TOperand& target)
        {
            return emit(ZYDIS_MNEMONIC_DEC, target);
        }

        Assembler& cmp(const Reg& lhs, const Reg& rhs)
        {
            return emit(ZYDIS_MNEMONIC_CMP, lhs, rhs);
        }

        Assembler& cmp(const Mem& lhs, const Reg& rhs)
        {
            return emit(ZYDIS_MNEMONIC_CMP, lhs, rhs);
        }

        Assembler& cmp(const Mem& lhs, const Imm& rhs)
        {
            return emit(ZYDIS_MNEMONIC_CMP, lhs, rhs);
        }

        Assembler& cmp(const Operand& lhs, const Operand& rhs)
        {
            return emit(ZYDIS_MNEMONIC_CMP, lhs, rhs);
        }

        template<typename TOp0, typename TOp1> Assembler& mov(const TOp0& dst, const TOp1& src)
        {
            return emit(ZYDIS_MNEMONIC_MOV, dst, src);
        }

        template<typename TOp0, typename TOp1> Assembler& xchg(const TOp0& dst, const TOp1& src)
        {
            return emit(ZYDIS_MNEMONIC_XCHG, dst, src);
        }

        Assembler& movd(const Reg& dst, const Reg& src)
        {
            return emit(ZYDIS_MNEMONIC_MOVD, dst, src);
        }

        Assembler& movd(const Reg& dst, const Mem& src)
        {
            return emit(ZYDIS_MNEMONIC_MOVD, dst, src);
        }

        Assembler& movd(const Mem& dst, const Reg& src)
        {
            return emit(ZYDIS_MNEMONIC_MOVD, dst, src);
        }

        Assembler& movq(const Reg& dst, const Reg& src)
        {
            return emit(ZYDIS_MNEMONIC_MOVQ, dst, src);
        }

        Assembler& movq(const Reg& dst, const Mem& src)
        {
            return emit(ZYDIS_MNEMONIC_MOVQ, dst, src);
        }

        Assembler& movq(const Mem& dst, const Reg& src)
        {
            return emit(ZYDIS_MNEMONIC_MOVQ, dst, src);
        }

        Assembler& movups(const Reg& dst, const Reg& src)
        {
            return emit(ZYDIS_MNEMONIC_MOVUPS, dst, src);
        }

        Assembler& movups(const Reg& dst, const Mem& src)
        {
            return emit(ZYDIS_MNEMONIC_MOVUPS, dst, src);
        }

        Assembler& movups(const Mem& dst, const Reg& src)
        {
            return emit(ZYDIS_MNEMONIC_MOVUPS, dst, src);
        }

        Assembler& vmovups(const Reg& dst, const Reg& src)
        {
            return emit(ZYDIS_MNEMONIC_VMOVUPS, dst, src);
        }

        Assembler& vmovups(const Reg& dst, const Mem& src)
        {
            return emit(ZYDIS_MNEMONIC_VMOVUPS, dst, src);
        }

        Assembler& vmovups(const Mem& dst, const Reg& src)
        {
            return emit(ZYDIS_MNEMONIC_VMOVUPS, dst, src);
        }

        template<typename Op0, typename Op1> Assembler& sub(const Op0& dst, const Op1& src)
        {
            return emit(ZYDIS_MNEMONIC_SUB, dst, src);
        }

        template<typename Op0, typename Op1> Assembler& add(const Op0& dst, const Op1& src)
        {
            return emit(ZYDIS_MNEMONIC_ADD, dst, src);
        }

        template<typename Op0, typename Op1> Assembler& xor_(const Op0& dst, const Op1& src)
        {
            return emit(ZYDIS_MNEMONIC_XOR, dst, src);
        }

        template<typename Op0, typename Op1> Assembler& and_(const Op0& dst, const Op1& src)
        {
            return emit(ZYDIS_MNEMONIC_AND, dst, src);
        }

        template<typename Op0, typename Op1> Assembler& ror(const Op0& dst, const Op1& src)
        {
            return emit(ZYDIS_MNEMONIC_ROR, dst, src);
        }

        template<typename Op0, typename Op1> Assembler& rol(const Op0& dst, const Op1& src)
        {
            return emit(ZYDIS_MNEMONIC_ROL, dst, src);
        }

        template<typename Op0> Assembler& lea(const Op0& dst, const Mem& src)
        {
            return emit(ZYDIS_MNEMONIC_LEA, dst, src);
        }

        template<typename Op0, typename Op1> Assembler& test(const Op0& dst, const Op1& src)
        {
            return emit(ZYDIS_MNEMONIC_TEST, dst, src);
        }

        template<typename Op0> Assembler& neg(const Op0& dst)
        {
            return emit(ZYDIS_MNEMONIC_NEG, dst);
        }

        template<typename Op0, typename Op1> Assembler& sbb(const Op0& dst, const Op1& src)
        {
            return emit(ZYDIS_MNEMONIC_SBB, dst, src);
        }

        template<typename Op0, typename Op1> Assembler& adc(const Op0& dst, const Op1& src)
        {
            return emit(ZYDIS_MNEMONIC_ADC, dst, src);
        }

        template<typename Op0, typename Op1> Assembler& sar(const Op0& dst, const Op1& src)
        {
            return emit(ZYDIS_MNEMONIC_SAR, dst, src);
        }

        template<typename Op0, typename Op1> Assembler& shl(const Op0& dst, const Op1& src)
        {
            return emit(ZYDIS_MNEMONIC_SHL, dst, src);
        }

        template<typename Op0, typename Op1> Assembler& shr(const Op0& dst, const Op1& src)
        {
            return emit(ZYDIS_MNEMONIC_SHR, dst, src);
        }

        template<typename Op0, typename Op1> Assembler& or_(const Op0& dst, const Op1& src)
        {
            return emit(ZYDIS_MNEMONIC_OR, dst, src);
        }

        template<typename Op0, typename Op1> Assembler& imul(const Op0& dst, const Op1& src, const Imm& imm)
        {
            return emit(ZYDIS_MNEMONIC_IMUL, dst, src, imm);
        }

        template<typename Op0, typename Op1> Assembler& imul(const Op0& dst, const Op1& src, const Reg& imm)
        {
            return emit(ZYDIS_MNEMONIC_IMUL, dst, src, imm);
        }

        template<typename Op0, typename Op1> Assembler& imul(const Op0& dst, const Op1& src)
        {
            return emit(ZYDIS_MNEMONIC_IMUL, dst, src);
        }

        template<typename Op0> Assembler& imul(const Op0& dst)
        {
            return emit(ZYDIS_MNEMONIC_IMUL, dst);
        }

        template<typename Op0, typename Op1> Assembler& bt(const Op0& dst, const Op1& src)
        {
            return emit(ZYDIS_MNEMONIC_BT, dst, src);
        }

        Assembler& jz(const Label& label)
        {
            return emit(ZYDIS_MNEMONIC_JZ, label);
        }

        Assembler& je(const Label& label)
        {
            return emit(ZYDIS_MNEMONIC_JZ, label);
        }

        Assembler& jnz(const Label& label)
        {
            return emit(ZYDIS_MNEMONIC_JNZ, label);
        }

        Assembler& jb(const Label& label)
        {
            return emit(ZYDIS_MNEMONIC_JB, label);
        }

        Assembler& jc(const Label& label)
        {
            return emit(ZYDIS_MNEMONIC_JB, label);
        }

        Assembler& jle(const Label& label)
        {
            return emit(ZYDIS_MNEMONIC_JLE, label);
        }

        Assembler& ja(const Label& label)
        {
            return emit(ZYDIS_MNEMONIC_JNBE, label);
        }

        Assembler& jns(const Label& label)
        {
            return emit(ZYDIS_MNEMONIC_JNS, label);
        }

        Assembler& jne(const Label& label)
        {
            return emit(ZYDIS_MNEMONIC_JZ, label);
        }

        Assembler& jge(const Label& label)
        {
            return emit(ZYDIS_MNEMONIC_JNL, label);
        }

        Assembler& jae(const Label& label)
        {
            return emit(ZYDIS_MNEMONIC_JNB, label);
        }

        Assembler& js(const Label& label)
        {
            return emit(ZYDIS_MNEMONIC_JS, label);
        }

        Assembler& jl(const Label& label)
        {
            return emit(ZYDIS_MNEMONIC_JL, label);
        }

        Assembler& jg(const Label& label)
        {
            return emit(ZYDIS_MNEMONIC_JNLE, label);
        }

        template<typename Op0, typename Op1> Assembler& movsx(const Op0& dst, const Op1& src)
        {
            return emit(ZYDIS_MNEMONIC_MOVSX, dst, src);
        }

        template<typename Op0, typename Op1> Assembler& movsxd(const Op0& dst, const Op1& src)
        {
            return emit(ZYDIS_MNEMONIC_MOVSXD, dst, src);
        }

        Assembler& movzx(const Reg& dst, const Reg& src)
        {
            return emit(ZYDIS_MNEMONIC_MOVZX, dst, src);
        }

        Assembler& movzx(const Reg& dst, const Mem& src)
        {
            return emit(ZYDIS_MNEMONIC_MOVZX, dst, src);
        }

        Assembler& call(Imm imm)
        {
            return emit(ZYDIS_MNEMONIC_CALL, imm);
        }

        Assembler& call(Reg reg)
        {
            return emit(ZYDIS_MNEMONIC_CALL, reg);
        }

        Assembler& ret()
        {
            return emit(ZYDIS_MNEMONIC_RET);
        }

        Assembler& ret(Imm imm)
        {
            return emit(ZYDIS_MNEMONIC_RET, imm);
        }

        Assembler& jmp(const Label& label)
        {
            return emit(ZYDIS_MNEMONIC_JMP, label);
        }

        template<typename Op0> Assembler& push(const Op0& src)
        {
            return emit(ZYDIS_MNEMONIC_PUSH, src);
        }

        template<typename Op0> Assembler& pop(const Op0& dst)
        {
            return emit(ZYDIS_MNEMONIC_POP, dst);
        }

        Assembler& pushfq()
        {
            return emit(ZYDIS_MNEMONIC_PUSHFQ);
        }

        Assembler& popfq()
        {
            return emit(ZYDIS_MNEMONIC_POPFQ);
        }

        Result<std::size_t> finalize(ZydisMachineMode mode, std::uint64_t baseAddress, std::byte* buffer, std::size_t bufSize);
    };

    inline Reg changeRegSize(Reg reg, std::int32_t newBitWidth, bool isHigh = false)
    {
        if (reg == Reg{})
        {
            return { ZYDIS_REGISTER_NONE };
        }

        if (isHigh)
        {
            assert(newBitWidth == 8);
        }

        const ZydisRegisterClass regClass = ZydisRegisterGetClass(reg);
        std::int32_t regId = ZydisRegisterGetId(reg);

        switch (regClass)
        {
            case ZYDIS_REGCLASS_GPR8:
            case ZYDIS_REGCLASS_GPR16:
            case ZYDIS_REGCLASS_GPR32:
            case ZYDIS_REGCLASS_GPR64:
            {
                switch (newBitWidth)
                {
                    case 8:
                        if (isHigh)
                        {
                            if (regId > 3)
                            {
                                assert(false);
                            }
                            return ZydisRegisterEncode(ZYDIS_REGCLASS_GPR8, regId + 4);
                        }
                        else
                        {
                            if (regId >= 4)
                            {
                                // Because hi gp8 are in the list starting at 4 we need to skip them.
                                regId = regId + 4;
                            }
                            return ZydisRegisterEncode(ZYDIS_REGCLASS_GPR8, regId);
                        }
                    case 16:
                        return ZydisRegisterEncode(ZYDIS_REGCLASS_GPR16, regId);
                    case 32:
                        return ZydisRegisterEncode(ZYDIS_REGCLASS_GPR32, regId);
                    case 64:
                        return ZydisRegisterEncode(ZYDIS_REGCLASS_GPR64, regId);
                }
                break;
            }
            case ZYDIS_REGCLASS_XMM:
            case ZYDIS_REGCLASS_YMM:
            case ZYDIS_REGCLASS_ZMM:
            {
                switch (newBitWidth)
                {
                    case 128:
                        return ZydisRegisterEncode(ZYDIS_REGCLASS_XMM, regId);
                    case 256:
                        return ZydisRegisterEncode(ZYDIS_REGCLASS_YMM, regId);
                    case 512:
                        return ZydisRegisterEncode(ZYDIS_REGCLASS_ZMM, regId);
                }
                break;
            }
            case ZYDIS_REGCLASS_MMX:
            {
                if (newBitWidth == 64)
                {
                    return ZydisRegisterEncode(ZYDIS_REGCLASS_MMX, regId);
                }
                else
                {
                    assert(false);
                }
                break;
            }
        }

        assert(false);
        return { ZYDIS_REGISTER_NONE };
    }

} // namespace zyemu::x86
```

`src/zyemu/assembler.types.hpp`:

```hpp
#pragma once

#include <Zydis/Mnemonic.h>
#include <Zydis/SharedTypes.h>
#include <cstdint>
#include <sfl/static_vector.hpp>
#include <variant>
#include <zyemu/registers.hpp>

namespace zyemu
{
    struct Imm
    {
        std::int64_t value{};

        constexpr Imm() noexcept
            : value{}
        {
        }
        Imm(const void* ptr) noexcept
            : value{ reinterpret_cast<std::int64_t>(ptr) }
        {
        }
        constexpr Imm(std::uint32_t imm) noexcept
            : value{ static_cast<std::int32_t>(imm) }
        {
        }
        constexpr Imm(std::int32_t imm) noexcept
            : value{ imm }
        {
        }
        constexpr Imm(std::int64_t imm) noexcept
            : value{ imm }
        {
        }
        constexpr Imm(std::uint64_t imm) noexcept
            : value{ static_cast<std::int64_t>(imm) }
        {
        }
        template<typename T, typename = std::enable_if_t<std::is_enum_v<T>>>
        constexpr Imm(T imm)
            : Imm(static_cast<std::underlying_type_t<T>>(imm))
        {
        }
    };

    namespace detail
    {

        template<typename T> struct ImmT : public Imm
        {
            static_assert(std::is_integral_v<T> || std::is_enum_v<T>, "ImmT can only be used with integral or enum types");
            constexpr ImmT(T imm) noexcept
                : Imm(static_cast<std::int64_t>(imm))
            {
            }
            constexpr operator T() const noexcept
            {
                return static_cast<T>(value);
            }
        };

    } // namespace detail

    using Imm8 = detail::ImmT<std::int8_t>;
    using Imm16 = detail::ImmT<std::int16_t>;
    using Imm32 = detail::ImmT<std::int32_t>;
    using Imm64 = detail::ImmT<std::int64_t>;

    struct Label
    {
        std::int32_t id{ -1 };

        constexpr bool isValid() const
        {
            return id != -1;
        }
    };

    struct Mem
    {
        std::uint16_t bitSize{};
        Reg seg{};
        Reg base{};
        Reg index{};
        std::int64_t disp{};
        std::uint8_t scale{};
        Label label{};
    };

    namespace x86
    {
        inline Mem byte_ptr(const Reg& base, std::int64_t disp = 0)
        {
            return Mem{ 8, ds, base, {}, disp, 0, {} };
        }

        inline Mem word_ptr(const Reg& base, std::int64_t disp = 0)
        {
            return Mem{ 16, ds, base, {}, disp, 0, {} };
        }

        inline Mem qword_ptr(const Reg& base, std::int64_t disp = 0)
        {
            return Mem{ 64, ds, base, {}, disp, 0, {} };
        }

        inline Mem dword_ptr(const Reg& base, std::int64_t disp = 0)
        {
            return Mem{ 32, ds, base, {}, disp, 0, {} };
        }

        inline Mem ptr(std::uint16_t bitSize, const Reg& base, std::int64_t disp = 0)
        {
            return Mem{ bitSize, ds, base, {}, disp, 0, {} };
        }

    } // namespace x86

    using Operand = std::variant<Reg, Mem, Label, Imm>;

    struct Instruction
    {
        ZydisMnemonic mnemonic{};
        sfl::static_vector<Operand, 5 /*ZYDIS_ENCODER_MAX_OPERANDS*/> operands{};
    };

} // namespace zyemu
```

`src/zyemu/codecache.cpp`:

```cpp
#include "codecache.hpp"

#include <format>
#include <print>

#ifndef WIN32_LEAN_AND_MEAN
#    define WIN32_LEAN_AND_MEAN
#endif
#include <Windows.h>

#define CODECACHE_ENABLE_LOGGING 0

namespace zyemu::codecache
{
    static constexpr std::size_t kCacheRegionSize = 0x100000; // 1 MB

    static Result<std::byte*> allocExecutableMem(std::size_t size)
    {
        // Allocate a new region.
        auto* codeCacheMem = VirtualAlloc(nullptr, size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
        if (!codeCacheMem)
        {
            return StatusCode::outOfMemory;
        }

#ifdef _DEBUG
        std::memset(codeCacheMem, 0xCC, size);
#endif

        return static_cast<std::byte*>(codeCacheMem);
    }

    static StatusCode deallocExecutableMem(std::byte* codeCacheMem, std::size_t size)
    {
        if (!codeCacheMem)
        {
            return StatusCode::invalidArgument;
        }

        if (VirtualFree(codeCacheMem, 0, MEM_RELEASE) == 0)
        {
            return StatusCode::invalidMemory;
        }

        return StatusCode::success;
    }

    Result<detail::CacheRegion*> getCacheRegion(detail::CPUState* cpuState, std::size_t estimatedSize)
    {
        auto& cacheRegions = cpuState->cacheRegions;

        const auto allocRegion = [&]() -> StatusCode {
            // Allocate a new region.
            auto codeCacheMem = allocExecutableMem(kCacheRegionSize);
            if (!codeCacheMem)
            {
                return codeCacheMem.getError();
            }

            detail::CacheRegion entry{};
            entry.data = *codeCacheMem;
            entry.base = reinterpret_cast<std::uint64_t>(entry.data);
            entry.capacity = kCacheRegionSize;
            entry.size = 0;

#ifdef _DEBUG
            std::memset(entry.data, 0xCC, entry.capacity);
#endif

#if defined(CODECACHE_ENABLE_LOGGING) && CODECACHE_ENABLE_LOGGING
            std::println("Allocating new code cache region at 0x{:X} with size {} bytes", entry.base, entry.capacity);
#endif

            cacheRegions.push_back(entry);

            return StatusCode::success;
        };

        if (cacheRegions.empty())
        {
            if (auto status = allocRegion(); status != StatusCode::success)
            {
                return status;
            }
        }

        // Check if we have enough space otherwise allocate a new region.
        {
            const auto& lastRegion = cacheRegions.back();
            const auto remaining = lastRegion.capacity - lastRegion.size;
            if (remaining < estimatedSize)
            {
                if (auto status = allocRegion(); status != StatusCode::success)
                {
                    return status;
                }
            }
        }

        auto& lastRegion = cacheRegions.back();
        return &lastRegion;
    }

    StatusCode destroyCodeCache(detail::CPUState* cpuState)
    {
        for (auto& region : cpuState->cacheRegions)
        {
            if (auto res = deallocExecutableMem(region.data, region.capacity); res != StatusCode::success)
            {
                return res;
            }
            else
            {
#if defined(CODECACHE_ENABLE_LOGGING) && CODECACHE_ENABLE_LOGGING
                std::print("Deallocated code cache region at 0x{:X} with size {} bytes\n", region.base, region.capacity);
#endif
            }
        }

        cpuState->cacheRegions.clear();
        cpuState->cacheEntries.clear();

        return StatusCode::success;
    }

} // namespace zyemu::codecache
```

`src/zyemu/codecache.hpp`:

```hpp
#pragma once

#include "internal.hpp"

#include <zyemu/types.hpp>

namespace zyemu::codecache
{

    Result<detail::CacheRegion*> getCacheRegion(detail::CPUState* cpuState, std::size_t estimatedSize);

    StatusCode destroyCodeCache(detail::CPUState* cpuState);

} // namespace zyemu::codecache
```

`src/zyemu/codegen.cpp`:

```cpp
#include "codegen.hpp"

#include "assembler.hpp"
#include "codecache.hpp"
#include "codegen.data.hpp"
#include "internal.hpp"
#include "platform.hpp"
#include "registers.hpp"
#include "thread.hpp"

#include <Zydis/Decoder.h>
#include <cassert>
#include <set>
#include <sfl/static_flat_map.hpp>
#include <sfl/static_flat_set.hpp>
#include <sfl/static_vector.hpp>

namespace zyemu::codegen
{
    BodyGeneratorHandler getBodyGenerator(ZydisMnemonic mnemonic);

    static inline std::span<const Reg> getLargestAvailableSimdRegs() noexcept
    {
        if (platform::supportsAVX512())
        {
            return kAvailableZmmRegs;
        }
        else if (platform::supportsAVX())
        {
            return kAvailableYmmRegs;
        }
        else if (platform::supportsSSE2())
        {
            return kAvailableXmmRegs;
        }
        assert(false);
        return {};
    }

    static inline std::span<const Reg> getLargestNonVolatileSimdRegs() noexcept
    {
        if (platform::supportsAVX512())
        {
            return kNonVolatileZmmRegs;
        }
        else if (platform::supportsAVX())
        {
            return kNonVolatileYmmRegs;
        }
        else if (platform::supportsSSE2())
        {
            return kNonVolatileXmmRegs;
        }
        assert(false);
        return {};
    }

    static inline Reg getLargestSupportedReg(ZydisMachineMode mode, Reg reg)
    {
        if (!reg.isValid())
        {
            return {};
        }

        Reg regOut = ZydisRegisterGetLargestEnclosing(mode, reg);

        if (regOut.isZmm() && !platform::supportsAVX512())
        {
            const auto regIndex = regOut.value - ZYDIS_REGISTER_ZMM0;

            if (platform::supportsAVX())
            {
                // Convert to ymm.
                return Reg{ static_cast<ZydisRegister>(ZYDIS_REGISTER_YMM0 + regIndex) };
            }
            else if (platform::supportsSSE2())
            {
                // Convert to xmm.
                return Reg{ static_cast<ZydisRegister>(ZYDIS_REGISTER_XMM0 + regIndex) };
            }
            else
            {
                assert(false);
                return {};
            }
        }

        return regOut;
    }

    static inline RegSet getRegsRead(const DecodedInstruction& instr)
    {
        RegSet regs{};
        for (std::size_t i = 0; i < instr.decoded.operand_count; ++i)
        {
            const auto& op = instr.operands[i];
            if (op.type == ZYDIS_OPERAND_TYPE_REGISTER)
            {
                bool isRead = false;
                if ((op.actions & ZYDIS_OPERAND_ACTION_MASK_READ) != 0)
                {
                    isRead = true;
                }
                if ((op.actions & ZYDIS_OPERAND_ACTION_CONDWRITE) != 0)
                {
                    // If its a conditional write, we consider it as read. For example a conditional move would be
                    // r = cond ? a : b;
                    // So we require both sources to be synced in the virtual registers.
                    isRead = true;
                }
                if ((op.actions & ZYDIS_OPERAND_ACTION_MASK_WRITE))
                {
                    // Partial read, this means we need the remaining data to be synced.
                    if (op.size < 32)
                    {
                        isRead = true;
                    }
                }
                if (isRead)
                {
                    regs.insert(op.reg.value);
                }
            }
            else if (op.type == ZYDIS_OPERAND_TYPE_MEMORY)
            {
                if (op.mem.base != ZYDIS_REGISTER_NONE)
                {
                    regs.insert(op.mem.base);
                }
                if (op.mem.index != ZYDIS_REGISTER_NONE)
                {
                    regs.insert(op.mem.index);
                }
            }
        }
        return regs;
    }

    // Returns the registers modified by the instruction, it will always use the largest size of the register.
    static inline RegSet getRegsModified(const DecodedInstruction& instr)
    {
        RegSet regs{};
        for (std::size_t i = 0; i < instr.decoded.operand_count; ++i)
        {
            const auto& op = instr.operands[i];
            if (op.type == ZYDIS_OPERAND_TYPE_REGISTER && (op.actions & ZYDIS_OPERAND_ACTION_MASK_WRITE) != 0)
            {
                regs.insert(op.reg.value);
            }
        }
        return regs;
    }

    static StatusCode initFreeRegs(GeneratorState& state)
    {
        state.freeGpRegs.insert(state.freeGpRegs.end(), kAvailableGpRegs64.begin(), kAvailableGpRegs64.end());

        const auto simdRegs = getLargestAvailableSimdRegs();
        state.freeSimdRegs.insert(state.freeSimdRegs.end(), simdRegs.begin(), simdRegs.end());

        state.freeMmxRegs.insert(state.freeMmxRegs.end(), kAvailableMmxRegs.begin(), kAvailableMmxRegs.end());

        return StatusCode::success;
    }

    Result<Reg> allocateGpReg(GeneratorState& state, Reg preferredReg /*= {}*/)
    {
        if (state.freeGpRegs.empty())
        {
            assert(false);
            return StatusCode::noFreeRegisters;
        }

        Reg res{};

        // If we have a preferred register, try to allocate it first.
        if (preferredReg != Reg{})
        {
            auto it = std::find(state.freeGpRegs.begin(), state.freeGpRegs.end(), preferredReg);
            if (it != state.freeGpRegs.end())
            {
                res = *it;
                state.freeGpRegs.erase(it);
            }
        }

        if (!res.isValid())
        {
            // No preferred register, just take the first one.
            res = state.freeGpRegs.front();
            state.freeGpRegs.erase(state.freeGpRegs.begin());
        }

        state.usedGpRegs.insert(res);

        return { res };
    }

    Result<Reg> allocateSimdReg(GeneratorState& state, Reg preferredReg /*= {}*/)
    {
        if (state.freeSimdRegs.empty())
        {
            assert(false);
            return StatusCode::noFreeRegisters;
        }

        Reg res{};

        // If we have a preferred register, try to allocate it first.
        if (preferredReg != Reg{})
        {
            auto it = std::find(state.freeSimdRegs.begin(), state.freeSimdRegs.end(), preferredReg);
            if (it != state.freeSimdRegs.end())
            {
                res = *it;
                state.freeSimdRegs.erase(it);
            }
        }

        if (!res.isValid())
        {
            // No preferred register, just take the first one.
            res = state.freeSimdRegs.front();
            state.freeSimdRegs.erase(state.freeSimdRegs.begin());
        }

        state.usedSimdRegs.insert(res);
        return { res };
    }

    static Result<Reg> allocateMmxReg(GeneratorState& state, Reg preferredReg = {})
    {
        if (state.freeMmxRegs.empty())
        {
            assert(false);
            return StatusCode::noFreeRegisters;
        }

        Reg res{};

        // If we have a preferred register, try to allocate it first.
        if (preferredReg != Reg{})
        {
            auto it = std::find(state.freeMmxRegs.begin(), state.freeMmxRegs.end(), preferredReg);
            if (it != state.freeMmxRegs.end())
            {
                res = *it;
                state.freeMmxRegs.erase(it);
            }
        }

        if (!res.isValid())
        {
            // No preferred register, just take the first one.
            res = state.freeMmxRegs.front();
            state.freeMmxRegs.erase(state.freeMmxRegs.begin());
        }

        state.usedMmxRegs.insert(res);
        return { res };
    }

    static StatusCode initGenerateState(GeneratorState& state, const DecodedInstruction& instr)
    {
        state.mode = instr.decoded.machine_mode;
        state.lblPrologue = state.assembler.createLabel();
        state.lblExit = state.assembler.createLabel();
        state.lblExitFailure = state.assembler.createLabel();

        if (auto res = initFreeRegs(state); res != StatusCode::success)
        {
            return res;
        }

        // Allocate the context register.
        {
            if (auto reg = allocateGpReg(state, x86::r12); reg.hasError())
            {
                return reg.getError();
            }
            else
            {
                state.regCtx = *reg;
            }
        }

        // Allocate the frame register.
        {
            if (auto reg = allocateGpReg(state, x86::r13); reg.hasError())
            {
                return reg.getError();
            }
            else
            {
                state.regStackFrame = *reg;
            }
        }

        // Get the largest registers used.
        {
            for (const auto regRead : instr.regsRead)
            {
                if (!isAddressableReg(regRead))
                    continue;

                auto regIn = getLargestSupportedReg(state.mode, regRead);
                state.regsIn.insert(regIn);
            }

            for (const auto regWrite : instr.regsModified)
            {
                if (!isAddressableReg(regWrite))
                    continue;

                auto regOut = getLargestSupportedReg(state.mode, regWrite);
                state.regsOut.insert(regOut);
            }
        }

        // Remap registers from instruction to virtual.
        {
            RegSet regsUsed = state.regsIn;
            regsUsed.insert(state.regsOut.begin(), state.regsOut.end());

            for (const auto reg : regsUsed)
            {
                if (reg.isGpFamily())
                {
                    auto remappedReg = allocateGpReg(state, reg);
                    if (remappedReg.hasError())
                    {
                        return remappedReg.getError();
                    }

                    state.regRemap[reg] = *remappedReg;
                }
                else if (reg.isSimdFamily())
                {
                    auto remappedReg = allocateSimdReg(state, reg);
                    if (remappedReg.hasError())
                    {
                        return remappedReg.getError();
                    }
                    state.regRemap[reg] = *remappedReg;
                }
                else if (reg.isMmx())
                {
                    auto remappedReg = allocateMmxReg(state, reg);
                    if (remappedReg.hasError())
                    {
                        return remappedReg.getError();
                    }
                    state.regRemap[reg] = *remappedReg;
                }
                else
                {
                    assert(false); // Unsupported register type.
                }
            }
        }

        // Allocate registers for memory operations.
        for (std::size_t i = 0; i < instr.decoded.operand_count; ++i)
        {
            const auto& op = instr.operands[i];
            if (op.type == ZYDIS_OPERAND_TYPE_MEMORY)
            {
                if (op.actions & ZYDIS_OPERAND_ACTION_MASK_WRITE)
                {
                    if (instr.operandKind[i] == OperandKind::Gp)
                    {
                        if (auto reg = allocateGpReg(state); reg.hasError())
                        {
                            return reg.getError();
                        }
                        else
                        {
                            state.memRegs[i] = *reg;
                        }
                    }
                    else if (instr.operandKind[i] == OperandKind::Simd)
                    {
                        if (auto reg = allocateSimdReg(state); reg.hasError())
                        {
                            return reg.getError();
                        }
                        else
                        {
                            state.memRegs[i] = *reg;
                        }
                    }
                    else if (instr.operandKind[i] == OperandKind::Mmx)
                    {
                        if (auto reg = allocateMmxReg(state); reg.hasError())
                        {
                            return reg.getError();
                        }
                        else
                        {
                            state.memRegs[i] = *reg;
                        }
                    }
                    else
                    {
                        assert(false); // Unsupported memory operand type.
                    }
                }
            }
        }

        // Select register for status.
        if (auto regStatus = allocateGpReg(state, x86::rax); regStatus.hasError())
        {
            return regStatus.getError();
        }
        else
        {
            state.regStatus = *regStatus;
        }

        return StatusCode::success;
    }

    Reg getRemappedReg(GeneratorState& state, Reg reg)
    {
        if (!reg.isValid())
        {
            return Reg{};
        }

        const auto inputRegSize = ZydisRegisterGetWidth(state.mode, reg);
        const auto largeReg = getLargestSupportedReg(state.mode, reg);

        assert(state.regRemap.contains(largeReg));
        const auto remappedRegRoot = state.regRemap[largeReg];

        const auto resizedReg = x86::changeRegSize(remappedRegRoot, inputRegSize, reg.isGp8Hi());

        return resizedReg;
    }

    static StatusCode generateEntry(GeneratorState& state, const DecodedInstruction& instr)
    {
        auto& ar = state.assembler;

        // ecx/rcx is the context register upon entry.
        const auto baseReg = state.regCtx;
        const auto frameReg = state.regStackFrame;

        state.stackFrameSize = 256;

        // Home area prologue.
        ar.bind(state.lblPrologue);

        // Setup stack frame.
        ar.push(frameReg);
        ar.lea(x86::rsp, x86::qword_ptr(x86::rsp, -state.stackFrameSize));
        ar.mov(frameReg, x86::rsp); // Save the stack frame pointer.

        // Save non-volatile GP registers.
        state.volatileRegArea = 64;

        std::int32_t savedOffset = state.volatileRegArea;
        for (const auto reg : state.usedGpRegs)
        {
            if (std::ranges::contains(kNonVolatileGpRegs64, reg))
            {
                const auto regBitSize = ZydisRegisterGetWidth(state.mode, reg);
                ar.mov(x86::ptr(regBitSize, frameReg, savedOffset), reg);
                savedOffset += regBitSize / 8;
            }
        }

        // Save non-volatile SIMD registers.
        const auto nonVolatileSimdRegs = getLargestNonVolatileSimdRegs();
        for (const auto reg : state.usedSimdRegs)
        {
            if (std::ranges::contains(nonVolatileSimdRegs, reg))
            {
                const auto regBitSize = ZydisRegisterGetWidth(state.mode, reg);
                if (reg.isXmm())
                {
                    ar.movups(x86::ptr(regBitSize, frameReg, savedOffset), reg);
                }
                else if (reg.isYmm())
                {
                    ar.vmovups(x86::ptr(regBitSize, frameReg, savedOffset), reg);
                }
                savedOffset += regBitSize / 8;
            }
        }

        // Save the spill area offset.
        state.memoryRWArea = savedOffset + 16;

        // rcx is the parameter holding the context pointer.
        ar.mov(state.regCtx, x86::rcx);

        // Synchronize virtual context into remapped registers.
        for (auto regIn : state.regsIn)
        {
            if (regIn.isGpFamily())
            {
                assert(state.regRemap.contains(regIn));
                const auto remappedReg = state.regRemap[regIn];

                const auto ctxRegInfo = getContextRegInfo(state.mode, regIn);
                ar.mov(remappedReg, x86::ptr(ctxRegInfo.bitSize, baseReg, ctxRegInfo.offset));
            }
            else if (regIn.isSimdFamily())
            {
                assert(state.regRemap.contains(regIn));
                const auto remappedReg = state.regRemap[regIn];
                const auto ctxRegInfo = getContextRegInfo(state.mode, regIn);
                if (remappedReg.isXmm())
                {
                    ar.movups(remappedReg, x86::ptr(ctxRegInfo.bitSize, baseReg, ctxRegInfo.offset));
                }
                else if (remappedReg.isYmm())
                {
                    ar.vmovups(remappedReg, x86::ptr(ctxRegInfo.bitSize, baseReg, ctxRegInfo.offset));
                }
            }
            else if (regIn.isMmx())
            {
                assert(state.regRemap.contains(regIn));
                const auto remappedReg = state.regRemap[regIn];
                const auto ctxRegInfo = getContextRegInfo(state.mode, regIn);
                ar.movq(remappedReg, x86::ptr(ctxRegInfo.bitSize, baseReg, ctxRegInfo.offset));
            }
            else
            {
                assert(false); // Unsupported register type.
            }
        }

        return StatusCode::success;
    }

    static StatusCode generateExit(GeneratorState& state, const DecodedInstruction& instr)
    {
        auto& ar = state.assembler;

        const auto baseReg = state.regCtx;
        const auto frameReg = state.regStackFrame;
        const auto ctxStatusReg = getContextStatusReg(state.mode);

        ar.bind(state.lblExit);

        // Synchronize remapped registers back into the virtual context.
        if (state.exitSyncRegs)
        {
            for (auto regOut : state.regsOut)
            {
                if (regOut.isGpFamily())
                {
                    assert(state.regRemap.contains(regOut));
                    const auto remappedReg = state.regRemap[regOut];
                    const auto ctxRegInfo = getContextRegInfo(state.mode, regOut);
                    ar.mov(x86::ptr(ctxRegInfo.bitSize, baseReg, ctxRegInfo.offset), remappedReg);
                }
                else if (regOut.isSimdFamily())
                {
                    assert(state.regRemap.contains(regOut));
                    const auto remappedReg = state.regRemap[regOut];
                    const auto ctxRegInfo = getContextRegInfo(state.mode, regOut);
                    if (remappedReg.isXmm())
                    {
                        ar.movups(x86::ptr(ctxRegInfo.bitSize, baseReg, ctxRegInfo.offset), remappedReg);
                    }
                    else if (remappedReg.isYmm())
                    {
                        ar.vmovups(x86::ptr(ctxRegInfo.bitSize, baseReg, ctxRegInfo.offset), remappedReg);
                    }
                }
                else if (regOut.isMmx())
                {
                    assert(state.regRemap.contains(regOut));
                    const auto remappedReg = state.regRemap[regOut];
                    const auto ctxRegInfo = getContextRegInfo(state.mode, regOut);
                    ar.movq(x86::ptr(ctxRegInfo.bitSize, baseReg, ctxRegInfo.offset), remappedReg);
                }
                else
                {
                    assert(false);
                }
            }
        }
        
        ar.bind(state.lblExitFailure);

        // Move status into eax/rax.
        if (state.regStatus != x86::rax)
        {
            ar.mov(x86::rax, state.regStatus);
        }

        // Restore non-volatile GP registers.
        std::int32_t savedOffset = state.volatileRegArea;
        for (const auto reg : state.usedGpRegs)
        {
            if (std::ranges::contains(kNonVolatileGpRegs64, reg))
            {
                const auto regBitSize = ZydisRegisterGetWidth(state.mode, reg);
                ar.mov(reg, x86::ptr(regBitSize, frameReg, savedOffset));
                savedOffset += regBitSize / 8;
            }
        }

        // Restore non-volatile SIMD registers.
        const auto nonVolatileSimdRegs = getLargestNonVolatileSimdRegs();
        for (const auto reg : state.usedSimdRegs)
        {
            if (std::ranges::contains(nonVolatileSimdRegs, reg))
            {
                const auto regBitSize = ZydisRegisterGetWidth(state.mode, reg);
                if (reg.isXmm())
                {
                    ar.movups(reg, x86::ptr(regBitSize, frameReg, savedOffset));
                }
                else if (reg.isYmm())
                {
                    ar.vmovups(reg, x86::ptr(regBitSize, frameReg, savedOffset));
                }
                savedOffset += regBitSize / 8;
            }
        }

        if (instr.flagsModified != 0 || instr.flagsRead != 0)
        {
            // This flag must be cleared. We don't use popf if instruction does not use flags in any way.
            ar.cld();
        }

        // Restore stack frame.
        ar.mov(x86::rsp, frameReg);
        ar.lea(x86::rsp, x86::qword_ptr(x86::rsp, +state.stackFrameSize));
        ar.pop(frameReg);

        ar.ret();

        return StatusCode::success;
    }

    static StatusCode generateHandlerBody(GeneratorState& state, const DecodedInstruction& instr)
    {
        auto generator = getBodyGenerator(instr.decoded.mnemonic);
        if (!generator)
        {
            return StatusCode::invalidInstruction;
        }

        // Generate the body of the instruction handler.
        if (auto res = generator(state, instr); res != StatusCode::success)
        {
            assert(false);
            return res;
        }

        return StatusCode::success;
    }

    static StatusCode generateInstructionHandler(GeneratorState& state, const DecodedInstruction& instr)
    {
        auto& ar = state.assembler;

        // Setup the generator state.
        if (auto res = initGenerateState(state, instr); res != StatusCode::success)
        {
            return res;
        }

        // Generate the body of the instruction handler.
        if (auto res = generateHandlerBody(state, instr); res != StatusCode::success)
        {
            return res;
        }

        // Emit before the body.
        ar.setInsertPos(0);

        if (auto res = generateEntry(state, instr); res != StatusCode::success)
        {
            return res;
        }

        // Emit after the body.
        ar.setInsertPos(ar.getNodeCount());

        if (auto res = generateExit(state, instr); res != StatusCode::success)
        {
            return res;
        }

        return StatusCode::success;
    }

    static Result<DecodedInstruction> decodeInstruction(
        detail::CPUState* cpuState, std::uint64_t ip, const detail::InstructionData& instrData)
    {
        DecodedInstruction instr{};

        const auto instrBytes = instrData.buffer();

        if (auto status = ZydisDecoderDecodeFull(
                &cpuState->decoder, instrBytes.data(), instrBytes.size(), &instr.decoded, instr.operands);
            status != ZYAN_STATUS_SUCCESS)
        {
            return StatusCode::invalidInstruction;
        }

        // Handle some Zydis inaccuracies, before extracting the information.
        switch (instr.decoded.mnemonic)
        {
            case ZYDIS_MNEMONIC_BSR:
            case ZYDIS_MNEMONIC_BSF:
            {
                // Mark first operand as conditional write given that if source is zero the operand will
                // not be written.
                if (instr.decoded.operand_count > 0)
                {
                    instr.operands[0].actions = ZYDIS_OPERAND_ACTION_CONDWRITE;
                }
                break;
            }
            case ZYDIS_MNEMONIC_CVTSD2SS:
            case ZYDIS_MNEMONIC_CVTSS2SD:
            case ZYDIS_MNEMONIC_RCPPS:
            case ZYDIS_MNEMONIC_RCPSS:
            {
                // First operand is partial write so we need to add read.
                if (instr.decoded.operand_count > 0)
                {
                    instr.operands[0].actions |= ZYDIS_OPERAND_ACTION_READ;
                }
                break;
            }
        }

        // Adjust rip-rel memory operands to have absolute immediate.
        for (std::size_t i = 0; i < instr.decoded.operand_count; ++i)
        {
            auto& op = instr.operands[i];
            if (op.type == ZYDIS_OPERAND_TYPE_MEMORY && op.mem.base == ZYDIS_REGISTER_RIP)
            {
                op.mem.base = ZYDIS_REGISTER_NONE;

                // Adjust disp.
                op.mem.disp.value += ip + instr.decoded.length;
            }
        }

        // This heuristic kind of sucks but we require to know what register must be used to substitute the memory operand.
        {
            OperandKind usedOperandKind = OperandKind::Invalid;
            for (std::size_t i = 0; i < instr.decoded.operand_count; ++i)
            {
                const auto& op = instr.operands[i];
                if (op.type == ZYDIS_OPERAND_TYPE_REGISTER)
                {
                    if (!isAddressableReg(op.reg.value))
                    {
                        instr.operandKind[i] = OperandKind::Invalid;
                        continue;
                    }

                    const auto regClass = ZydisRegisterGetClass(op.reg.value);
                    switch (regClass)
                    {
                        case ZYDIS_REGCLASS_GPR8:
                        case ZYDIS_REGCLASS_GPR16:
                        case ZYDIS_REGCLASS_GPR32:
                        case ZYDIS_REGCLASS_GPR64:
                            usedOperandKind = instr.operandKind[i] = OperandKind::Gp;
                            break;
                        case ZYDIS_REGCLASS_MMX:
                            usedOperandKind = instr.operandKind[i] = OperandKind::Mmx;
                            break;
                        case ZYDIS_REGCLASS_XMM:
                        case ZYDIS_REGCLASS_YMM:
                        case ZYDIS_REGCLASS_ZMM:
                            usedOperandKind = instr.operandKind[i] = OperandKind::Simd;
                            break;
                        case ZYDIS_REGCLASS_X87:
                            usedOperandKind = instr.operandKind[i] = OperandKind::X87;
                            break;
                    }
                }
            }

            // Handle memory operands.
            for (std::size_t i = 0; i < instr.decoded.operand_count; ++i)
            {
                const auto& op = instr.operands[i];
                if (op.type == ZYDIS_OPERAND_TYPE_MEMORY)
                {
                    instr.operandKind[i] = usedOperandKind;
                }
            }
        }

        instr.address = ip;
        instr.regsRead = getRegsRead(instr);
        instr.regsModified = getRegsModified(instr);
        instr.regsUsed = instr.regsRead;
        instr.regsUsed.insert(instr.regsModified.begin(), instr.regsModified.end());

#ifdef _MSC_VER
        // Never null.
        __assume(instr.decoded.cpu_flags != nullptr);
#endif
        instr.flagsRead = instr.decoded.cpu_flags->tested;
        instr.flagsModified = instr.decoded.cpu_flags->modified | instr.decoded.cpu_flags->set_0
            | instr.decoded.cpu_flags->set_1 | instr.decoded.cpu_flags->undefined;

        return instr;
    }

    Result<detail::CodeCacheFunc> generate(
        detail::CPUState* cpuState, std::uint64_t ip, const detail::InstructionData& instrData)
    {
        // TODO: Avoid decoding again.
        auto decoded = decodeInstruction(cpuState, ip, instrData);

        if (decoded.hasError())
        {
            return decoded.getError();
        }

        // Generate instruction handler.
        GeneratorState state{};
        if (auto res = generateInstructionHandler(state, *decoded); res != StatusCode::success)
        {
            return res;
        }

        // FIXME: Proper estimate of the size.
        auto cacheRegionRes = codecache::getCacheRegion(cpuState, 64);
        if (!cacheRegionRes)
        {
            return cacheRegionRes.getError();
        }

        auto* cacheRegion = *cacheRegionRes;
        const auto baseAddress = cacheRegion->base + cacheRegion->size;
        const auto cacheData = cacheRegion->data + cacheRegion->size;
        const auto remainingSize = cacheRegion->capacity - cacheRegion->size;

        // Encode all instructions.
        auto encodeRes = state.assembler.finalize(cpuState->mode, baseAddress, cacheData, remainingSize);
        if (!encodeRes)
        {
            return StatusCode::invalidInstruction;
        }

        // Commit to the cache region.
        cacheRegion->size += *encodeRes;

        // Map the instruction handler.
        detail::CacheEntry entry{};
        entry.address = ip;
        entry.cacheAddress = baseAddress;
        entry.size = *encodeRes;
        entry.func = reinterpret_cast<detail::CodeCacheFunc>(baseAddress);

        cpuState->cacheEntries[instrData] = entry;

        return entry.func;
    }

} // namespace zyemu::codegen
```

`src/zyemu/codegen.data.hpp`:

```hpp
#pragma once

#include "registers.hpp"

#include <array>

namespace zyemu::codegen
{
    static constexpr std::array kAvailableMmxRegs = {
        x86::mm0, x86::mm1, x86::mm2, x86::mm3, x86::mm4, x86::mm5, x86::mm6, x86::mm7,
    };

    // 32 bit mode.
    // NOTE: We start with rcx as that is the first allocated register for the context.
    static constexpr std::array kVolatileGpRegs32 = {
        x86::ecx,
        x86::eax,
        x86::edx,
    };

    static constexpr std::array kNonVolatileGpRegs32 = {
        x86::ebx,
        x86::esi,
        x86::edi,
        x86::ebp,
    };

    // 64 bit mode.
    static constexpr std::array kVolatileGpRegs64 = {
        x86::rax, x86::rcx, x86::rdx, x86::r8, x86::r9, x86::r10, x86::r11,
    };

    static constexpr std::array kNonVolatileGpRegs64 = {
        x86::rbx, x86::rsi, x86::rdi, x86::rbp, x86::r12, x86::r13, x86::r14, x86::r15,
    };

    static constexpr std::array kAvailableGpRegs64 = { x86::rax, x86::rcx, x86::rdx, x86::r8,  x86::r9,
                                                       x86::r10, x86::r11, x86::rbx, x86::rsi, x86::rdi,
                                                       x86::rbp, x86::r12, x86::r13, x86::r14, x86::r15 };

    static const std::array kVolatileXmmRegs = {
        x86::xmm0, x86::xmm1, x86::xmm2, x86::xmm3, x86::xmm4, x86::xmm5,
    };

    static const std::array kNonVolatileXmmRegs = {
        x86::xmm6, x86::xmm7, x86::xmm8, x86::xmm9, x86::xmm10, x86::xmm11, x86::xmm12, x86::xmm13, x86::xmm14, x86::xmm15,
    };

    static constexpr std::array kAvailableXmmRegs = {
        x86::xmm0, x86::xmm1, x86::xmm2,  x86::xmm3,  x86::xmm4,  x86::xmm5,  x86::xmm6,  x86::xmm7,
        x86::xmm8, x86::xmm9, x86::xmm10, x86::xmm11, x86::xmm12, x86::xmm13, x86::xmm14, x86::xmm15,
    };

    static const std::array kVolatileYmmRegs = {
        x86::ymm0, x86::ymm1, x86::ymm2, x86::ymm3, x86::ymm4, x86::ymm5,
    };

    static const std::array kNonVolatileYmmRegs = {
        x86::ymm6, x86::ymm7, x86::ymm8, x86::ymm9, x86::ymm10, x86::ymm11, x86::ymm12, x86::ymm13, x86::ymm14, x86::ymm15,
    };

    static constexpr std::array kAvailableYmmRegs = {
        x86::ymm0, x86::ymm1, x86::ymm2,  x86::ymm3,  x86::ymm4,  x86::ymm5,  x86::ymm6,  x86::ymm7,
        x86::ymm8, x86::ymm9, x86::ymm10, x86::ymm11, x86::ymm12, x86::ymm13, x86::ymm14, x86::ymm15,
    };

    static const std::array kVolatileZmmRegs = {
        x86::zmm0, x86::zmm1, x86::zmm2, x86::zmm3, x86::zmm4, x86::zmm5,
    };

    static const std::array kNonVolatileZmmRegs = {
        x86::zmm6, x86::zmm7, x86::zmm8, x86::zmm9, x86::zmm10, x86::zmm11, x86::zmm12, x86::zmm13, x86::zmm14, x86::zmm15,
    };

    static constexpr std::array kAvailableZmmRegs = {
        x86::zmm0, x86::zmm1, x86::zmm2,  x86::zmm3,  x86::zmm4,  x86::zmm5,  x86::zmm6,  x86::zmm7,
        x86::zmm8, x86::zmm9, x86::zmm10, x86::zmm11, x86::zmm12, x86::zmm13, x86::zmm14, x86::zmm15,
    };

    static bool isAddressableReg(ZydisRegister reg)
    {
        switch (reg)
        {
            case ZYDIS_REGISTER_FLAGS:
            case ZYDIS_REGISTER_EFLAGS:
            case ZYDIS_REGISTER_RFLAGS:
            case ZYDIS_REGISTER_RIP:
            case ZYDIS_REGISTER_EIP:
                return false;
            default:
                break;
        }
        return true;
    }

} // namespace zyemu::codegen
```

`src/zyemu/codegen.handlers.cpp`:

```cpp
#include "codegen.hpp"

#include "assembler.hpp"
#include "codegen.data.hpp"
#include "cpu.memory.hpp"
#include "cpu.software.hpp"
#include "thread.hpp"

#include <array>
#include <functional>

namespace zyemu::codegen
{
    class CallSaveRestore
    {
    private:
        GeneratorState& state;
        sfl::static_vector<Reg, 8> savedRegs;

    public:
        explicit CallSaveRestore(GeneratorState& state)
            : state(state)
        {
        }

        void saveIfNeeded(Reg reg)
        {
            if (!state.usedGpRegs.contains(reg))
                return;
            if (!std::ranges::contains(kVolatileGpRegs64, reg))
                return;

            state.assembler.push(reg);
            savedRegs.push_back(reg);
        }

        void saveRaxIfNeeded()
        {
            if (state.regStatus != x86::rax)
            {
                state.assembler.push(x86::rax);
            }
        }

        void saveRegsForCall()
        {
            saveIfNeeded(x86::rcx);
            saveIfNeeded(x86::rdx);
            saveIfNeeded(x86::r8);
            saveIfNeeded(x86::r9);
            saveIfNeeded(state.regCtx);
            saveIfNeeded(state.regStackFrame);
        }

        void restore()
        {
            // Restore in reverse order
            for (const auto& reg : std::ranges::reverse_view(savedRegs))
            {
                state.assembler.pop(reg);
            }
            savedRegs.clear();

            if (state.regStatus != x86::rax)
            {
                state.assembler.mov(state.regStatus, x86::rax);
                state.assembler.pop(x86::rax);
            }
        }
    };

    // Memory operation helper functions
    static StatusCode performMemoryRead(GeneratorState& state, const Mem& memSrc, std::int32_t bitSize)
    {
        auto& ar = state.assembler;
        CallSaveRestore callSave(state);

        callSave.saveRaxIfNeeded();
        callSave.saveRegsForCall();

        const auto regFrame = state.regStackFrame;

        // Setup call parameters
        ar.lea(x86::rdx, memSrc);                                      // Address
        ar.lea(x86::r8, x86::qword_ptr(regFrame, state.memoryRWArea)); // Buffer
        ar.mov(x86::rcx, state.regCtx);                                // Context
        ar.mov(x86::r9, Imm(bitSize / 8));                             // Size in bytes

        // Call memory::read
        ar.lea(x86::rsp, x86::qword_ptr(x86::rsp, -32));
        ar.mov(x86::rax, Imm(&memory::read));
        ar.call(x86::rax);
        ar.lea(x86::rsp, x86::qword_ptr(x86::rsp, 32));

        callSave.restore();

        // Error handling
        ar.test(state.regStatus, state.regStatus);
        ar.jnz(state.lblExitFailure);

        return StatusCode::success;
    }

    static StatusCode performMemoryWrite(GeneratorState& state, const Mem& memDst, const Operand& src, std::int32_t bitSize)
    {
        auto& ar = state.assembler;
        const auto regFrame = state.regStackFrame;

#ifdef _DEBUG
        ar.nop();
#endif

        // Write source value to buffer first
        if (std::holds_alternative<Reg>(src))
        {
            const auto& reg = std::get<Reg>(src);

            if (reg.isGpFamily())
            {
                ar.mov(x86::ptr(bitSize, regFrame, state.memoryRWArea), reg);
            }
            else if (reg.isXmm())
            {
                ar.movups(x86::ptr(bitSize, regFrame, state.memoryRWArea), reg);
            }
            else if (reg.isYmm())
            {
                ar.vmovups(x86::ptr(bitSize, regFrame, state.memoryRWArea), reg);
            }
            else if (reg.isMmx())
            {
                ar.movq(x86::ptr(bitSize, regFrame, state.memoryRWArea), reg);
            }
            else
            {
                assert(false);
            }
        }
        else if (std::holds_alternative<Imm>(src))
        {
            const auto& imm = std::get<Imm>(src);
            // For immediate values, we need a temporary register
            auto tempReg = allocateGpReg(state);
            if (tempReg.hasError())
                return tempReg.getError();

            ar.mov(*tempReg, imm);
            ar.mov(x86::ptr(bitSize, regFrame, state.memoryRWArea), x86::changeRegSize(*tempReg, memDst.bitSize));
        }
        else if (std::holds_alternative<Mem>(src))
        {
            const auto& mem = std::get<Mem>(src);
            // Need temporary register to move from memory to memory
            auto tempReg = allocateGpReg(state);
            if (tempReg.hasError())
                return tempReg.getError();

            ar.mov(x86::changeRegSize(*tempReg, mem.bitSize), mem);
            ar.mov(x86::ptr(bitSize, regFrame, state.memoryRWArea), x86::changeRegSize(*tempReg, memDst.bitSize));
        }
        else
        {
            assert(false);
        }

        CallSaveRestore saver(state);
        saver.saveRaxIfNeeded();
        saver.saveRegsForCall();

        // Setup call parameters
        ar.lea(x86::rdx, memDst);                                      // Address
        ar.lea(x86::r8, x86::qword_ptr(regFrame, state.memoryRWArea)); // Buffer
        ar.mov(x86::rcx, state.regCtx);                                // Context
        ar.mov(x86::r9, Imm(bitSize / 8));                             // Size in bytes

        // Call memory::write
        ar.lea(x86::rsp, x86::qword_ptr(x86::rsp, -32));
        ar.mov(x86::rax, Imm(&memory::write));
        ar.call(x86::rax);
        ar.lea(x86::rsp, x86::qword_ptr(x86::rsp, 32));

        saver.restore();

        // Error handling
        ar.test(state.regStatus, state.regStatus);
        ar.jnz(state.lblExitFailure);

        return StatusCode::success;
    }

    // Convenient wrapper for stack operations
    static StatusCode pushToStack(GeneratorState& state, const Operand& value, std::int32_t bitSize = 64)
    {
        auto& ar = state.assembler;
        const auto baseReg = state.regCtx;
        const auto ctxSpInfo = getContextRegInfo(state.mode, x86::rsp);
        const auto regSp = getRemappedReg(state, ZYDIS_REGISTER_RSP);

        // Adjust SP.
        ar.sub(regSp, Imm(bitSize / 8));

        // Create memory operand for stack location
        Mem stackMem{};
        stackMem.base = regSp;
        stackMem.bitSize = bitSize;

        // Perform the write
        return performMemoryWrite(state, stackMem, value, bitSize);
    }

    static Result<Operand> popFromStack(GeneratorState& state, std::int32_t bitSize = 64)
    {
        auto& ar = state.assembler;
        const auto baseReg = state.regCtx;
        const auto ctxSpInfo = getContextRegInfo(state.mode, x86::rsp);
        const auto regSp = getRemappedReg(state, ZYDIS_REGISTER_RSP);

        // Create memory operand for stack location
        Mem stackMem{};
        stackMem.base = regSp;
        stackMem.bitSize = bitSize;

        // Read from stack
        auto status = performMemoryRead(state, stackMem, bitSize);
        if (status != StatusCode::success)
            return status;

        // Adjust SP
        ar.add(regSp, Imm(bitSize / 8));

        // Return memory operand pointing to the buffer
        Mem bufferMem{};
        bufferMem.base = state.regStackFrame;
        bufferMem.disp = state.memoryRWArea;
        bufferMem.bitSize = bitSize;

        return Operand{ bufferMem };
    }

    static void loadReadFlags(GeneratorState& state, const DecodedInstruction& instr)
    {
        if (instr.flagsRead == 0 && instr.flagsModified == 0)
            return;

        auto& ar = state.assembler;
        const auto baseReg = state.regCtx;

        const auto ctxFlagsInfo = getContextRegInfo(state.mode, ZYDIS_REGISTER_RFLAGS);
        ar.push(x86::qword_ptr(baseReg, ctxFlagsInfo.offset));
        ar.popfq();
    }

    static void storeModifiedFlags(GeneratorState& state, const DecodedInstruction& instr)
    {
        if (instr.flagsModified == 0)
            return;

        auto& ar = state.assembler;
        const auto baseReg = state.regCtx;

        const auto ctxFlagsInfo = getContextRegInfo(state.mode, ZYDIS_REGISTER_RFLAGS);
        ar.pushfq();
        ar.pop(x86::qword_ptr(baseReg, ctxFlagsInfo.offset));
    }

    static StatusCode handleMemoryWrites(GeneratorState& state, const DecodedInstruction& instr)
    {
        // Process deferred memory writes from register substitution
        for (const auto& [regSrc, memDst] : state.memWrites)
        {
            auto status = performMemoryWrite(state, memDst, Operand{ regSrc }, memDst.bitSize);
            if (status != StatusCode::success)
                return status;
        }

        return StatusCode::success;
    }

    static Result<Operand> loadOperand(GeneratorState& state, const DecodedInstruction& instr, size_t operandIdx)
    {
        auto& ar = state.assembler;

        const auto& op = instr.operands[operandIdx];

        if (op.type == ZydisOperandType::ZYDIS_OPERAND_TYPE_REGISTER)
        {
            const auto srcReg = Reg{ op.reg.value };
            const auto remappedReg = getRemappedReg(state, srcReg);
            return { remappedReg };
        }
        else if (op.type == ZydisOperandType::ZYDIS_OPERAND_TYPE_MEMORY)
        {
            Mem memOpSrc{};
            memOpSrc.bitSize = op.size;
            memOpSrc.seg = x86::Seg{ op.mem.segment };
            memOpSrc.base = getRemappedReg(state, op.mem.base);
            memOpSrc.index = getRemappedReg(state, op.mem.index);
            memOpSrc.scale = op.mem.scale;
            memOpSrc.disp = op.mem.disp.value;

            if (op.actions & ZYDIS_OPERAND_ACTION_MASK_READ)
            {
                auto status = performMemoryRead(state, memOpSrc, memOpSrc.bitSize);
                if (status != StatusCode::success)
                    return status;

                if (op.actions & ZYDIS_OPERAND_ACTION_MASK_WRITE)
                {
                    // Substitute memory operand with a register and defer the write.
                    const auto regSubstitute = state.memRegs[operandIdx];
                    const auto opReg = x86::changeRegSize(regSubstitute, op.size);

                    // Load value from buffer into register
                    const auto regFrame = state.regStackFrame;
                    ar.mov(opReg, x86::ptr(memOpSrc.bitSize, regFrame, state.memoryRWArea));

                    state.memWrites.emplace_back(opReg, memOpSrc);
                    return { opReg };
                }
                else
                {
                    // Return memory operand pointing to buffer
                    Mem memSrc{};
                    memSrc.base = state.regStackFrame;
                    memSrc.disp = state.memoryRWArea;
                    memSrc.bitSize = memOpSrc.bitSize;
                    return { memSrc };
                }
            }
            else if (op.actions & ZYDIS_OPERAND_ACTION_MASK_WRITE)
            {
                // Substitute memory operand with a register and defer the write.
                const auto regSubstitute = state.memRegs[operandIdx];
                const auto opReg = x86::changeRegSize(regSubstitute, op.size);

                state.memWrites.emplace_back(opReg, memOpSrc);
                return { opReg };
            }
            else
            {
                // Possible agen.
                if (op.mem.type == ZydisMemoryOperandType::ZYDIS_MEMOP_TYPE_AGEN)
                {
                    return { memOpSrc };
                }
                else
                {
                    // This should not happen.
                    assert(false);
                }
            }
        }
        else if (op.type == ZydisOperandType::ZYDIS_OPERAND_TYPE_IMMEDIATE)
        {
            if (op.imm.is_relative)
            {
                const auto val = op.imm.value.s + instr.address + instr.decoded.length;
                return { Imm{ val } };
            }

            return { Imm{ op.imm.value.s } };
        }

        assert(false); // Unsupported operand type.
        return StatusCode::invalidOperation;
    }

    static StatusCode generateHandlerGeneric(GeneratorState& state, const DecodedInstruction& instr)
    {
        auto& ar = state.assembler;

        const auto baseReg = state.regCtx;
        const auto ctxIpInfo = getContextRegInfo(state.mode, ZYDIS_REGISTER_RIP);
        const auto ctxFlagsInfo = getContextRegInfo(state.mode, ZYDIS_REGISTER_RFLAGS);
        const auto ctxStatusReg = getContextStatusReg(state.mode);
        const auto regStatus = state.regStatus;

        // Synchronize flags read, we also do that when it modifies flags as we need the current state.
        loadReadFlags(state, instr);

        // Handle the instruction
        {
            Instruction newInstr{};
            newInstr.mnemonic = instr.decoded.mnemonic;

            for (std::size_t i = 0; i < instr.decoded.operand_count_visible; ++i)
            {
                const auto newOp = loadOperand(state, instr, i);
                if (newOp.hasError())
                {
                    return newOp.getError();
                }
                else
                {
                    newInstr.operands.push_back(*newOp);
                }
            }

            ar.emit(newInstr);
        }

        if (auto status = handleMemoryWrites(state, instr); status != StatusCode::success)
        {
            return status;
        }

        // Synchronize flags output.
        storeModifiedFlags(state, instr);

        // Update IP.
        ar.add(x86::qword_ptr(baseReg, ctxIpInfo.offset), Imm(instr.decoded.length));

        // Status.
        ar.mov(regStatus, Imm(StatusCode::success));

        return StatusCode::success;
    }

    static StatusCode generateHandlerCall(GeneratorState& state, const DecodedInstruction& instr)
    {
        auto& ar = state.assembler;

        const auto baseReg = state.regCtx;
        const auto ctxIpInfo = getContextRegInfo(state.mode, ZYDIS_REGISTER_RIP);
        const auto regStatus = state.regStatus;

        const auto targetAddr = loadOperand(state, instr, 0);
        if (targetAddr.hasError())
        {
            return targetAddr.getError();
        }

        // Push return address on stack
        const auto returnAddr = Imm{ instr.address + instr.decoded.length };
        auto pushStatus = pushToStack(state, returnAddr, 64);
        if (pushStatus != StatusCode::success)
        {
            return pushStatus;
        }

        // Update IP to target address
        auto regTemp = allocateGpReg(state);
        if (regTemp.hasError())
        {
            return regTemp.getError();
        }

        ar.mov(*regTemp, *targetAddr);
        ar.mov(x86::qword_ptr(baseReg, ctxIpInfo.offset), *regTemp);

        // Status.
        ar.mov(regStatus, Imm(StatusCode::success));

        return StatusCode::success;
    }

    static StatusCode generateHandlerRet(GeneratorState& state, const DecodedInstruction& instr)
    {
        auto& ar = state.assembler;

        const auto baseReg = state.regCtx;
        const auto ctxIpInfo = getContextRegInfo(state.mode, ZYDIS_REGISTER_RIP);
        const auto ctxSpInfo = getContextRegInfo(state.mode, ZYDIS_REGISTER_RSP);
        const auto regSp = getRemappedReg(state, ZYDIS_REGISTER_RSP);
        const auto regStatus = state.regStatus;

        // Pop return address from stack
        auto poppedValue = popFromStack(state, 64);
        if (poppedValue.hasError())
        {
            return poppedValue.getError();
        }

        // Load popped value into temp register and set IP
        auto tempReg = allocateGpReg(state);
        if (tempReg.hasError())
        {
            return tempReg.getError();
        }

        if (std::holds_alternative<Mem>(*poppedValue))
        {
            ar.mov(*tempReg, std::get<Mem>(*poppedValue));
        }
        ar.mov(x86::qword_ptr(baseReg, ctxIpInfo.offset), *tempReg);

        // If immediate operand exists, adjust SP further
        if (instr.decoded.operand_count_visible > 0)
        {
            const auto& op = instr.operands[0];
            if (op.type == ZYDIS_OPERAND_TYPE_IMMEDIATE)
            {
                ar.add(regSp, Imm(op.imm.value.u));
            }
        }

        // Set status
        ar.mov(regStatus, Imm(StatusCode::success));

        return StatusCode::success;
    }

    static StatusCode generateHandlerPush(GeneratorState& state, const DecodedInstruction& instr)
    {
        auto& ar = state.assembler;

        const auto regStatus = state.regStatus;
        const auto baseReg = state.regCtx;
        const auto ctxIpInfo = getContextRegInfo(state.mode, ZYDIS_REGISTER_RIP);

        const auto src = loadOperand(state, instr, 0);
        if (src.hasError())
        {
            return src.getError();
        }

        auto status = pushToStack(state, *src, instr.decoded.operand_width);
        if (status != StatusCode::success)
        {
            return status;
        }

        // Update IP
        ar.add(x86::qword_ptr(baseReg, ctxIpInfo.offset), Imm(instr.decoded.length));

        // Status
        ar.mov(regStatus, Imm(StatusCode::success));

        return StatusCode::success;
    }

    static StatusCode generateHandlerPop(GeneratorState& state, const DecodedInstruction& instr)
    {
        auto& ar = state.assembler;

        const auto regStatus = state.regStatus;
        const auto baseReg = state.regCtx;
        const auto ctxIpInfo = getContextRegInfo(state.mode, ZYDIS_REGISTER_RIP);

        // Pop value from stack
        auto poppedValue = popFromStack(state, instr.decoded.operand_width);
        if (poppedValue.hasError())
        {
            return poppedValue.getError();
        }

        // Store to destination
        const auto& op = instr.operands[0];
        if (op.type == ZydisOperandType::ZYDIS_OPERAND_TYPE_REGISTER)
        {
            const auto dstReg = getRemappedReg(state, op.reg.value);
            const auto sizedReg = x86::changeRegSize(dstReg, op.size);

            if (std::holds_alternative<Mem>(*poppedValue))
            {
                ar.mov(sizedReg, std::get<Mem>(*poppedValue));
            }
        }
        else if (op.type == ZydisOperandType::ZYDIS_OPERAND_TYPE_MEMORY)
        {
            // Handle memory destination - this would need the deferred write mechanism
            // For now, just handle register destinations
            assert(false && "POP to memory not yet implemented");
        }

        // Update IP
        ar.add(x86::qword_ptr(baseReg, ctxIpInfo.offset), Imm(instr.decoded.length));

        // Status
        ar.mov(regStatus, Imm(StatusCode::success));

        return StatusCode::success;
    }

    static StatusCode generateHandlerPushFlags(GeneratorState& state, const DecodedInstruction& instr)
    {
        auto& ar = state.assembler;

        const auto baseReg = state.regCtx;
        const auto ctxIpInfo = getContextRegInfo(state.mode, ZYDIS_REGISTER_RIP);
        const auto ctxFlagsInfo = getContextRegInfo(state.mode, ZYDIS_REGISTER_RFLAGS);
        const auto regStatus = state.regStatus;

        const auto regTemp = x86::changeRegSize(regStatus, instr.decoded.operand_width);
        ar.mov(regTemp, x86::ptr(instr.decoded.operand_width, baseReg, ctxFlagsInfo.offset));

        auto status = pushToStack(state, regTemp, instr.decoded.operand_width);
        if (status != StatusCode::success)
        {
            return status;
        }

        // Update IP
        ar.add(x86::qword_ptr(baseReg, ctxIpInfo.offset), Imm(instr.decoded.length));

        // Status
        ar.mov(regStatus, Imm(StatusCode::success));

        return StatusCode::success;
    }

    static StatusCode generateHandlerPopFlags(GeneratorState& state, const DecodedInstruction& instr)
    {
        auto& ar = state.assembler;

        const auto baseReg = state.regCtx;
        const auto ctxIpInfo = getContextRegInfo(state.mode, ZYDIS_REGISTER_RIP);
        const auto ctxFlagsInfo = getContextRegInfo(state.mode, ZYDIS_REGISTER_RFLAGS);
        const auto regStatus = state.regStatus;

        auto poppedValue = popFromStack(state, instr.decoded.operand_width);
        if (poppedValue.hasError())
        {
            return poppedValue.getError();
        }

        const auto regTemp = x86::changeRegSize(regStatus, instr.decoded.operand_width);
        ar.mov(regTemp, *poppedValue);

        ar.mov(x86::ptr(instr.decoded.operand_width, baseReg, ctxFlagsInfo.offset), regTemp);

        // Update IP
        ar.add(x86::qword_ptr(baseReg, ctxIpInfo.offset), Imm(instr.decoded.length));

        // Status
        ar.mov(regStatus, Imm(StatusCode::success));

        return StatusCode::success;
    }

    template<ZydisMnemonic TCmovCond>
    static StatusCode generateHandlerJcc(GeneratorState& state, const DecodedInstruction& instr)
    {
        auto& ar = state.assembler;

        const auto baseReg = state.regCtx;
        const auto ctxIpInfo = getContextRegInfo(state.mode, ZYDIS_REGISTER_RIP);
        const auto ctxFlagsInfo = getContextRegInfo(state.mode, ZYDIS_REGISTER_RFLAGS);
        const auto ctxStatusReg = getContextStatusReg(state.mode);
        const auto regStatus = state.regStatus;
        const auto regTemp = allocateGpReg(state);
        if (regTemp.hasError())
        {
            return regTemp.getError();
        }

        const auto targetAddr = loadOperand(state, instr, 0);
        if (targetAddr.hasError())
        {
            return targetAddr.getError();
        }

        // Load current flags.
        loadReadFlags(state, instr);

        // Update IP.
        ar.mov(*regTemp, x86::qword_ptr(baseReg, ctxIpInfo.offset));
        ar.lea(*regTemp, x86::qword_ptr(*regTemp, instr.decoded.length));

        // Abusing regStatus for target address.
        ar.mov(regStatus, *targetAddr);
        ar.emit(TCmovCond, *regTemp, regStatus);

        ar.mov(x86::qword_ptr(baseReg, ctxIpInfo.offset), *regTemp);

        // Status.
        ar.mov(regStatus, Imm(StatusCode::success));

        return StatusCode::success;
    }

    static StatusCode generateHandlerJmp(GeneratorState& state, const DecodedInstruction& instr)
    {
        auto& ar = state.assembler;

        const auto baseReg = state.regCtx;
        const auto ctxIpInfo = getContextRegInfo(state.mode, ZYDIS_REGISTER_RIP);
        const auto ctxStatusReg = getContextStatusReg(state.mode);
        const auto regStatus = state.regStatus;
        const auto regTemp = allocateGpReg(state);

        if (regTemp.hasError())
        {
            return regTemp.getError();
        }

        const auto targetAddr = loadOperand(state, instr, 0);
        if (targetAddr.hasError())
        {
            return targetAddr.getError();
        }

        // Update IP.
        ar.mov(*regTemp, *targetAddr);
        ar.mov(x86::qword_ptr(baseReg, ctxIpInfo.offset), *regTemp);

        // Status.
        ar.mov(regStatus, Imm(StatusCode::success));
        return StatusCode::success;
    }

    static StatusCode generateHandlerDiv(GeneratorState& state, const DecodedInstruction& instr)
    {
        // Unsigned divide RDX:RAX by r/m64, with result stored in RAX := Quotient, RDX := Remainder.

        auto& ar = state.assembler;

        const auto baseReg = state.regCtx;
        const auto regStatus = state.regStatus;
        const auto ctxIpInfo = getContextRegInfo(state.mode, ZYDIS_REGISTER_RIP);

        const auto lblDivideByZero = ar.createLabel();
        const auto lblQuotientTooLarge = ar.createLabel();

        // Check if the divisor is zero.
        auto opDivisor = loadOperand(state, instr, 0);
        if (opDivisor.hasError())
        {
            return opDivisor.getError();
        }

        ar.cmp(*opDivisor, Imm(0U));
        ar.jz(lblDivideByZero);

        // Check if the quotient is too large.
        if (instr.decoded.operand_width == 8)
        {
            const auto regDividendA = x86::ah;

            // NOTE: Sub-optimal code, this is just to avoid an impossible encoding of cmp gp8hi, rex-gp8
            ar.push(x86::rax);
            ar.cmp(x86::byte_ptr(x86::rsp, 1), *opDivisor);
            ar.pop(x86::rax);

            ar.jae(lblQuotientTooLarge);
        }
        else
        {
            const auto regDividendA = x86::changeRegSize(x86::rdx, instr.decoded.operand_width);

            ar.cmp(regDividendA, *opDivisor);
            ar.jae(lblQuotientTooLarge);
        }

        // div.
        Instruction divIns;
        divIns.operands.push_back(*opDivisor);
        divIns.mnemonic = ZYDIS_MNEMONIC_DIV;
        ar.emit(divIns);

        // Update IP.
        ar.add(x86::qword_ptr(baseReg, ctxIpInfo.offset), Imm(instr.decoded.length));

        // Status.
        ar.mov(regStatus, Imm(StatusCode::success));

        ar.jmp(state.lblExit);

        // Failure path.
        ar.bind(lblDivideByZero);
        ar.mov(state.regStatus, Imm(StatusCode::exceptionIntDivideError));
        ar.jmp(state.lblExitFailure);

        ar.bind(lblQuotientTooLarge);
        ar.mov(state.regStatus, Imm(StatusCode::exceptionIntOverflow));
        ar.jmp(state.lblExitFailure);

        return StatusCode::success;
    }

    static StatusCode generateHandlerIdiv(GeneratorState& state, const DecodedInstruction& instr)
    {
        // Signed divide RDX:RAX by r/m, with result stored in RAX := Quotient, RDX := Remainder.
        auto& ar = state.assembler;

        const auto baseReg = state.regCtx;
        const auto regStatus = state.regStatus;
        const auto ctxIpInfo = getContextRegInfo(state.mode, ZYDIS_REGISTER_RIP);

        // Load divisor operand
        auto opDivisor = loadOperand(state, instr, 0);
        if (opDivisor.hasError())
        {
            return opDivisor.getError();
        }

        {
            CallSaveRestore callSave(state);

            callSave.saveRaxIfNeeded();
            callSave.saveRegsForCall();

            const auto regFrame = state.regStackFrame;

            // NOTE: Order is important, we assign the value first as rcx could be the input.
            switch (instr.decoded.operand_width)
            {
                case 8:
                    ar.mov(x86::dl, *opDivisor);
                    ar.mov(x86::rax, Imm(&software::idiv8));
                    break;
                case 16:
                    ar.mov(x86::dx, *opDivisor);
                    ar.mov(x86::rax, Imm(&software::idiv16));
                    break;
                case 32:
                    ar.mov(x86::edx, *opDivisor);
                    ar.mov(x86::rax, Imm(&software::idiv32));
                    break;
                case 64:
                    ar.mov(x86::rdx, *opDivisor);
                    ar.mov(x86::rax, Imm(&software::idiv64));
                    break;
            }

            // Setup call parameters
            ar.mov(x86::rcx, baseReg);

            ar.lea(x86::rsp, x86::qword_ptr(x86::rsp, -32));
            ar.call(x86::rax);
            ar.lea(x86::rsp, x86::qword_ptr(x86::rsp, 32));

            callSave.restore();
        }

        // Already written into context.
        state.exitSyncRegs = false;

        // Error handling
        ar.test(state.regStatus, state.regStatus);
        ar.jnz(state.lblExitFailure);

        // Update IP.
        ar.add(x86::qword_ptr(baseReg, ctxIpInfo.offset), Imm(instr.decoded.length));

        // Status.
        ar.mov(regStatus, Imm(StatusCode::success));

        return StatusCode::success;
    }

    static StatusCode generateHandlerLods(GeneratorState& state, const DecodedInstruction& instr)
    {
        auto& ar = state.assembler;

        const auto baseReg = state.regCtx;
        const auto ctxIpInfo = getContextRegInfo(state.mode, ZYDIS_REGISTER_RIP);
        const auto ctxFlagsInfo = getContextRegInfo(state.mode, ZYDIS_REGISTER_RFLAGS);
        const auto regStatus = state.regStatus;

        const auto regSi = getRemappedReg(state, ZYDIS_REGISTER_RSI);
        const auto regAx = getRemappedReg(state, ZYDIS_REGISTER_RAX);

        const auto bitSize = instr.decoded.operand_width;
        const auto byteSize = bitSize / 8;

        const auto sizedAx = x86::changeRegSize(regAx, bitSize);

        bool hasRep = (instr.decoded.attributes & ZYDIS_ATTRIB_HAS_REP) != 0;

        // Load flags for DF
        loadReadFlags(state, instr);

        Label lblEnd, lblLoop, lblDec, lblCont;
        if (hasRep)
        {
            const auto regCx = getRemappedReg(state, ZYDIS_REGISTER_RCX);

            lblEnd = ar.createLabel();
            lblLoop = ar.createLabel();

            ar.test(regCx, regCx);
            ar.jz(lblEnd);

            ar.bind(lblLoop);
        }

        // Define memory source: [RSI]
        Mem memSrc{};
        memSrc.base = regSi;
        memSrc.bitSize = instr.decoded.address_width;

        // Perform memory read
        auto status = performMemoryRead(state, memSrc, bitSize);
        if (status != StatusCode::success)
            return status;

        // Load from buffer to sized AX
        Mem bufferMem{};
        bufferMem.base = state.regStackFrame;
        bufferMem.disp = state.memoryRWArea;
        bufferMem.bitSize = bitSize;

        ar.mov(sizedAx, bufferMem);

        // Adjust RSI based on DF
        lblDec = ar.createLabel();
        lblCont = ar.createLabel();

        ar.pushfq();
        ar.pop(regStatus);
        ar.bt(regStatus, 10); // DF bit.
        ar.jc(lblDec);

        ar.add(regSi, Imm(byteSize));
        ar.jmp(lblCont);

        ar.bind(lblDec);
        ar.sub(regSi, Imm(byteSize));

        ar.bind(lblCont);

        if (hasRep)
        {
            const auto regCx = getRemappedReg(state, ZYDIS_REGISTER_RCX);
            ar.dec(regCx);
            ar.jnz(lblLoop);

            ar.bind(lblEnd);
        }

        // Update IP
        ar.add(x86::qword_ptr(baseReg, ctxIpInfo.offset), Imm(instr.decoded.length));

        // Status
        ar.mov(regStatus, Imm(StatusCode::success));

        return StatusCode::success;
    }

    static StatusCode generateHandlerStos(GeneratorState& state, const DecodedInstruction& instr)
    {
        auto& ar = state.assembler;

        const auto baseReg = state.regCtx;
        const auto ctxIpInfo = getContextRegInfo(state.mode, ZYDIS_REGISTER_RIP);
        const auto ctxFlagsInfo = getContextRegInfo(state.mode, ZYDIS_REGISTER_RFLAGS);
        const auto regStatus = state.regStatus;

        const auto regDi = getRemappedReg(state, ZYDIS_REGISTER_RDI);
        const auto regAx = getRemappedReg(state, ZYDIS_REGISTER_RAX);

        const auto bitSize = instr.decoded.operand_width;
        const auto byteSize = bitSize / 8;

        const auto sizedAx = x86::changeRegSize(regAx, bitSize);

        bool hasRep = (instr.decoded.attributes & ZYDIS_ATTRIB_HAS_REP) != 0;

        // Load flags for DF
        loadReadFlags(state, instr);

        Label lblEnd, lblLoop, lblDec, lblCont;
        if (hasRep)
        {
            const auto regCx = getRemappedReg(state, ZYDIS_REGISTER_RCX);

            lblEnd = ar.createLabel();
            lblLoop = ar.createLabel();

            ar.test(regCx, regCx);
            ar.jz(lblEnd);

            ar.bind(lblLoop);
        }

        // Define memory destination: [RDI]
        Mem memDst{};
        memDst.base = regDi;
        memDst.bitSize = instr.decoded.address_width;

        // Perform memory write
        auto status = performMemoryWrite(state, memDst, sizedAx, instr.decoded.operand_width);
        if (status != StatusCode::success)
            return status;

        // Adjust RDI based on DF
        lblDec = ar.createLabel();
        lblCont = ar.createLabel();

        ar.pushfq();
        ar.pop(regStatus);
        ar.bt(regStatus, 10); // DF bit.
        ar.jc(lblDec);

        ar.add(regDi, Imm(byteSize));
        ar.jmp(lblCont);

        ar.bind(lblDec);
        ar.sub(regDi, Imm(byteSize));

        ar.bind(lblCont);

        if (hasRep)
        {
            const auto regCx = getRemappedReg(state, ZYDIS_REGISTER_RCX);
            ar.dec(regCx);
            ar.jnz(lblLoop);

            ar.bind(lblEnd);
        }

        // STOS does not modify flags, so no storeModifiedFlags needed

        // Update IP
        ar.add(x86::qword_ptr(baseReg, ctxIpInfo.offset), Imm(instr.decoded.length));

        // Status
        ar.mov(regStatus, Imm(StatusCode::success));

        return StatusCode::success;
    }

    static constexpr auto kBodyHandlers = std::invoke([]() {
        //
        std::array<BodyGeneratorHandler, ZYDIS_MNEMONIC_MAX_VALUE> handlers{};

        // By default we use the generic handler.
        std::ranges::fill(handlers, generateHandlerGeneric);

        const auto assignHandler = [&](ZydisMnemonic mnemonic, BodyGeneratorHandler handler) {
            handlers[static_cast<std::size_t>(mnemonic)] = handler;
        };

        // Specific handlers.
        assignHandler(ZYDIS_MNEMONIC_DIV, generateHandlerDiv);
        assignHandler(ZYDIS_MNEMONIC_IDIV, generateHandlerIdiv);

        assignHandler(ZYDIS_MNEMONIC_PUSHF, generateHandlerPushFlags);
        assignHandler(ZYDIS_MNEMONIC_PUSHFD, generateHandlerPushFlags);
        assignHandler(ZYDIS_MNEMONIC_PUSHFQ, generateHandlerPushFlags);

        assignHandler(ZYDIS_MNEMONIC_POPF, generateHandlerPopFlags);
        assignHandler(ZYDIS_MNEMONIC_POPFD, generateHandlerPopFlags);
        assignHandler(ZYDIS_MNEMONIC_POPFQ, generateHandlerPopFlags);

        assignHandler(ZYDIS_MNEMONIC_CALL, generateHandlerCall);
        assignHandler(ZYDIS_MNEMONIC_RET, generateHandlerRet);

        assignHandler(ZYDIS_MNEMONIC_PUSH, generateHandlerPush);
        assignHandler(ZYDIS_MNEMONIC_POP, generateHandlerPop);

        assignHandler(ZYDIS_MNEMONIC_JMP, generateHandlerJmp);

        assignHandler(ZYDIS_MNEMONIC_JO, generateHandlerJcc<ZYDIS_MNEMONIC_CMOVO>);
        assignHandler(ZYDIS_MNEMONIC_JNO, generateHandlerJcc<ZYDIS_MNEMONIC_CMOVNO>);

        assignHandler(ZYDIS_MNEMONIC_JB, generateHandlerJcc<ZYDIS_MNEMONIC_CMOVB>);
        assignHandler(ZYDIS_MNEMONIC_JNB, generateHandlerJcc<ZYDIS_MNEMONIC_CMOVNB>);

        assignHandler(ZYDIS_MNEMONIC_JZ, generateHandlerJcc<ZYDIS_MNEMONIC_CMOVZ>);
        assignHandler(ZYDIS_MNEMONIC_JNZ, generateHandlerJcc<ZYDIS_MNEMONIC_CMOVNZ>);

        assignHandler(ZYDIS_MNEMONIC_JBE, generateHandlerJcc<ZYDIS_MNEMONIC_CMOVBE>);
        assignHandler(ZYDIS_MNEMONIC_JNBE, generateHandlerJcc<ZYDIS_MNEMONIC_CMOVNBE>);

        assignHandler(ZYDIS_MNEMONIC_JS, generateHandlerJcc<ZYDIS_MNEMONIC_CMOVS>);
        assignHandler(ZYDIS_MNEMONIC_JNS, generateHandlerJcc<ZYDIS_MNEMONIC_CMOVNS>);

        assignHandler(ZYDIS_MNEMONIC_JP, generateHandlerJcc<ZYDIS_MNEMONIC_CMOVP>);
        assignHandler(ZYDIS_MNEMONIC_JNP, generateHandlerJcc<ZYDIS_MNEMONIC_CMOVNP>);

        assignHandler(ZYDIS_MNEMONIC_JL, generateHandlerJcc<ZYDIS_MNEMONIC_CMOVL>);
        assignHandler(ZYDIS_MNEMONIC_JNL, generateHandlerJcc<ZYDIS_MNEMONIC_CMOVNL>);

        assignHandler(ZYDIS_MNEMONIC_JLE, generateHandlerJcc<ZYDIS_MNEMONIC_CMOVLE>);
        assignHandler(ZYDIS_MNEMONIC_JNLE, generateHandlerJcc<ZYDIS_MNEMONIC_CMOVNLE>);

        assignHandler(ZYDIS_MNEMONIC_LODSB, generateHandlerLods);
        assignHandler(ZYDIS_MNEMONIC_LODSW, generateHandlerLods);
        assignHandler(ZYDIS_MNEMONIC_LODSD, generateHandlerLods);
        assignHandler(ZYDIS_MNEMONIC_LODSQ, generateHandlerLods);

        assignHandler(ZYDIS_MNEMONIC_STOSB, generateHandlerStos);
        assignHandler(ZYDIS_MNEMONIC_STOSW, generateHandlerStos);
        assignHandler(ZYDIS_MNEMONIC_STOSD, generateHandlerStos);
        assignHandler(ZYDIS_MNEMONIC_STOSQ, generateHandlerStos);

        return handlers;
    });

    BodyGeneratorHandler getBodyGenerator(ZydisMnemonic mnemonic)
    {
        if (mnemonic < ZYDIS_MNEMONIC_MAX_VALUE)
        {
            return kBodyHandlers[static_cast<std::size_t>(mnemonic)];
        }
        else
        {
            assert(false);
            return generateHandlerGeneric; // Default handler.
        }
    }

} // namespace zyemu::codegen
```

`src/zyemu/codegen.hpp`:

```hpp
#pragma once

#include "assembler.hpp"
#include "internal.hpp"
#include "registers.hpp"

#include <Zydis/SharedTypes.h>
#include <sfl/static_flat_map.hpp>
#include <sfl/static_flat_set.hpp>
#include <sfl/static_vector.hpp>
#include <zyemu/types.hpp>

namespace zyemu::codegen
{
    using RegSet = sfl::static_flat_set<Reg, 32>;

    struct GeneratorState
    {
        ZydisMachineMode mode{};
        x86::Assembler assembler;
        Label lblPrologue{};
        Label lblExit{};
        Label lblExitFailure{};

        Reg regCtx{};
        Reg regStackFrame{};
        Reg regStatus{};

        bool exitSyncRegs{ true };

        // Register allocation state.
        sfl::static_vector<Reg, 16> freeGpRegs{};
        sfl::static_vector<Reg, 16> freeSimdRegs{};
        sfl::static_vector<Reg, 8> freeMmxRegs{};
        RegSet usedGpRegs{};
        RegSet usedSimdRegs{};
        RegSet usedMmxRegs{};

        // Registers as largest used by the instruction.
        RegSet regsIn{};
        RegSet regsOut{};

        // Size of stack frame.
        std::int32_t stackFrameSize{};

        // Offset in stack where volatile regs are saved.
        std::int32_t volatileRegArea{};

        // Offset of memory spill area, right after saved non-volatile registers.
        std::int32_t memoryRWArea{};

        // Mapping from instruction to host.
        sfl::static_flat_map<Reg, Reg, 8> regRemap{};

        // Remapped memory to register operand.
        std::array<Reg, ZYDIS_MAX_OPERAND_COUNT> memRegs{};

        sfl::static_vector<std::pair<Reg, Mem>, 2> memWrites{};
    };

    enum class OperandKind
    {
        Invalid,
        Gp,
        Simd,
        Mmx,
        Mm,
        X87,
        Flags,
        Mask,
    };

    struct DecodedInstruction
    {
        std::uint64_t address{};
        ZydisDecodedInstruction decoded{};
        ZydisDecodedOperand operands[ZYDIS_MAX_OPERAND_COUNT]{};
        OperandKind operandKind[ZYDIS_MAX_OPERAND_COUNT]{};
        RegSet regsRead{};
        RegSet regsModified{};
        RegSet regsUsed{};
        std::uint32_t flagsRead{};
        std::uint32_t flagsModified{};
    };

    using BodyGeneratorHandler = StatusCode (*)(GeneratorState& state, const DecodedInstruction& instr);

    Reg getRemappedReg(GeneratorState& state, Reg reg);

    Result<Reg> allocateGpReg(GeneratorState& state, Reg preferredReg = {});
    Result<Reg> allocateSimdReg(GeneratorState& state, Reg preferredReg = {});

    Result<detail::CodeCacheFunc> generate(
        detail::CPUState* state, std::uint64_t rip, const detail::InstructionData& instrData);

} // namespace zyemu::codegen
```

`src/zyemu/cpu.cpp`:

```cpp
#include "codecache.hpp"
#include "codegen.hpp"
#include "internal.hpp"
#include "registers.hpp"
#include "thread.hpp"

#include <zyemu/zyemu.hpp>

namespace zyemu
{
    using namespace detail;

    CPU::CPU()
    {
        state = new detail::CPUState{};
    }

    CPU::~CPU()
    {
        assert(state != nullptr);

        if (auto res = codecache::destroyCodeCache(state); res != StatusCode::success)
        {
            assert(false);
        }

        delete state;
        state = nullptr;
    }

    StatusCode CPU::setMode(ZydisMachineMode mode)
    {
        ZydisStackWidth stackWidth{};
        switch (mode)
        {
            case ZydisMachineMode::ZYDIS_MACHINE_MODE_LONG_64:
                stackWidth = ZydisStackWidth::ZYDIS_STACK_WIDTH_64;
                break;
            case ZydisMachineMode::ZYDIS_MACHINE_MODE_LEGACY_32:
                [[fallthrough]];
            case ZydisMachineMode::ZYDIS_MACHINE_MODE_LONG_COMPAT_32:
                stackWidth = ZydisStackWidth::ZYDIS_STACK_WIDTH_32;
                break;
            case ZydisMachineMode::ZYDIS_MACHINE_MODE_LEGACY_16:
                [[fallthrough]];
            case ZydisMachineMode::ZYDIS_MACHINE_MODE_LONG_COMPAT_16:
                stackWidth = ZydisStackWidth::ZYDIS_STACK_WIDTH_16;
                break;
            default:
                return StatusCode::invalidMode;
        }

        if (auto status = ZydisDecoderInit(&state->decoder, mode, stackWidth); status != ZYAN_STATUS_SUCCESS)
        {
            return StatusCode::invalidMode;
        }

        if (auto status = ZydisDecoderInit(&state->ldeDecoder, mode, stackWidth); status != ZYAN_STATUS_SUCCESS)
        {
            return StatusCode::invalidMode;
        }

        ZydisDecoderEnableMode(&state->ldeDecoder, ZYDIS_DECODER_MODE_MINIMAL, true);

        state->mode = mode;
        return StatusCode::success;
    }

    void CPU::setMemReadHandler(MemoryReadHandler callback, void* userData)
    {
        state->memReadHandler = callback;
        state->memReadUserData = userData;
    }

    void CPU::setMemWriteHandler(MemoryWriteHandler callback, void* userData)
    {
        state->memWriteHandler = callback;
        state->memWriteUserData = userData;
    }

    void CPU::clearCodeCache()
    {
        state->cacheEntries.clear();
        for (auto& region : state->cacheRegions)
        {
            region.size = 0;
#ifdef _DEBUG
            std::memset(region.data, 0xCC, region.capacity);
#endif
        }
    }

    ThreadId CPU::createThread()
    {
        const auto initThread = [&](ThreadData& th, ThreadId tid) {
            th.state = ThreadState::idle;
            th.context = {};
            th.context.cpuState = state;
            th.context.tid = tid;
        };

        for (std::size_t i = 0; i < this->state->threads.size(); ++i)
        {
            ThreadData& th = state->threads[i];
            if (th.state != detail::ThreadState::dead)
            {
                continue;
            }

            const auto tid = static_cast<ThreadId>(i);
            initThread(th, tid);

            return tid;
        }

        const auto tid = static_cast<ThreadId>(state->threads.size());
        auto& th = state->threads.emplace_back();

        initThread(th, tid);

        return tid;
    }

    static ThreadData* getThread(detail::CPUState* state, ThreadId tid)
    {
        const auto idx = static_cast<std::size_t>(tid);
        if (idx >= state->threads.size())
        {
            return nullptr;
        }
        return &state->threads[idx];
    }

    void CPU::destroyThread(ThreadId tid)
    {
        const auto idx = static_cast<std::size_t>(tid);
        if (idx >= state->threads.size())
        {
            return;
        }

        ThreadData& th = state->threads[idx];
        th.state = ThreadState::dead;
    }

    StatusCode CPU::setRegData(ThreadId tid, Reg reg, std::span<const std::byte> data)
    {
        auto* th = getThread(state, tid);
        if (!th)
        {
            return StatusCode::invalidThread;
        }

        const auto regInfo = getContextRegInfo(state->mode, reg);
        if (regInfo.offset == 0)
        {
            return StatusCode::invalidRegister;
        }

        if (data.size() != regInfo.bitSize / 8)
        {
            return StatusCode::invalidRegister;
        }

        std::memcpy(reinterpret_cast<std::byte*>(&th->context) + regInfo.offset, data.data(), data.size());

        return StatusCode::success;
    }

    StatusCode CPU::getRegData(ThreadId tid, Reg reg, std::span<std::byte> buffer)
    {
        auto* th = getThread(state, tid);
        if (!th)
        {
            return StatusCode::invalidThread;
        }

        const auto regInfo = getContextRegInfo(state->mode, reg);
        if (regInfo.offset == 0)
        {
            return StatusCode::invalidRegister;
        }

        if (buffer.size() != regInfo.bitSize / 8)
        {
            return StatusCode::invalidRegister;
        }

        std::memcpy(buffer.data(), reinterpret_cast<std::byte*>(&th->context) + regInfo.offset, buffer.size());

        return StatusCode::success;
    }

    static Result<InstructionData> getInstructionData(CPUState* state, ThreadId tid, std::uint64_t address)
    {
        InstructionData instrData{};
        ZydisDecodedInstruction instr;

        // TODO: Make this an option on how much memory we read at once, we have to also consider page boundaries.
        const auto fastDecode = false;
        const auto optimalReadSize = fastDecode ? 8 : 1;

        for (std::uint8_t i = 0U; i < 15U;)
        {
            // Try to read i bytes.
            if (auto status = state->memReadHandler(
                    tid, address + i, instrData.buffer().data() + i, optimalReadSize, state->memReadUserData);
                status != StatusCode::success)
            {
                return status;
            }

            auto status = ZydisDecoderDecodeInstruction(
                &state->ldeDecoder, nullptr, instrData.buffer().data(), i + optimalReadSize, &instr);
            if (status == ZYAN_STATUS_SUCCESS)
            {
                instrData.length = i + optimalReadSize;
                return instrData;
            }
            else if (status == ZYDIS_STATUS_NO_MORE_DATA)
            {
                continue;
            }
            else
            {
                return StatusCode::invalidInstruction;
            }
        }

        return StatusCode::invalidInstruction;
    }

    StatusCode CPU::step(ThreadId tid)
    {
        auto* th = getThread(state, tid);
        if (!th)
        {
            return StatusCode::invalidThread;
        }

        auto& ctx = th->context;

        const auto rip = ctx.rip;

        auto instrDataRes = getInstructionData(state, tid, rip);
        if (!instrDataRes)
        {
            return instrDataRes.getError();
        }

        auto cacheIt = state->cacheEntries.find(*instrDataRes);
        if (cacheIt != state->cacheEntries.end())
        {
            const auto& func = cacheIt->second.func;
            return func(&ctx);
        }

        // Generate code cache entry
        auto result = codegen::generate(state, rip, *instrDataRes);
        if (!result)
        {
            return result.getError();
        }

        const auto execRes = result.getValue()(&ctx);
        if (execRes != StatusCode::success)
        {
            return execRes;
        }

        return StatusCode::success;
    }

    StatusCode CPU::writeMem(std::uint64_t address, std::span<const std::byte> data)
    {
        if (state->memWriteHandler == nullptr)
        {
            return StatusCode::missingMemoryHandler;
        }

        if (data.empty())
        {
            return StatusCode::success;
        }

        return state->memWriteHandler(ThreadId::invalid, address, data.data(), data.size(), state->memWriteUserData);
    }

    StatusCode CPU::readMem(std::uint64_t address, std::span<std::byte> buffer)
    {
        if (state->memReadHandler == nullptr)
        {
            return StatusCode::missingMemoryHandler;
        }

        if (buffer.empty())
        {
            return StatusCode::success;
        }

        return state->memReadHandler(ThreadId::invalid, address, buffer.data(), buffer.size(), state->memReadUserData);
    }

} // namespace zyemu

```

`src/zyemu/cpu.memory.cpp`:

```cpp
#include "cpu.memory.hpp"

namespace zyemu::memory
{

    StatusCode read(detail::ThreadContext* ctx, std::uint64_t address, void* buffer, std::size_t length)
    {
        const auto* cpuState = ctx->cpuState;

        if (cpuState->memReadHandler != nullptr)
        {
            return cpuState->memReadHandler(ctx->tid, address, buffer, length, cpuState->memReadUserData);
        }

        return StatusCode::success;
    }

    StatusCode write(detail::ThreadContext* ctx, std::uint64_t address, const void* buffer, std::size_t length)
    {
        const auto* cpuState = ctx->cpuState;

        if (cpuState->memWriteHandler != nullptr)
        {
            return cpuState->memWriteHandler(ctx->tid, address, buffer, length, cpuState->memWriteUserData);
        }

        return StatusCode::success;
    }

} // namespace zyemu::memory
```

`src/zyemu/cpu.memory.hpp`:

```hpp
#pragma once

#include "internal.hpp"

#include <cstdint>
#include <zyemu/types.hpp>

namespace zyemu::memory
{
    StatusCode ZYEMU_FASTCALL read(detail::ThreadContext* ctx, std::uint64_t address, void* buffer, std::size_t length);

    StatusCode ZYEMU_FASTCALL write(detail::ThreadContext* ctx, std::uint64_t address, const void* buffer, std::size_t length);

} // namespace zyemu::memory
```

`src/zyemu/cpu.software.cpp`:

```cpp
#include "cpu.software.hpp"

#include "internal.hpp"
#include "thread.hpp"
#include "registers.hpp"

#ifdef _MSC_VER
#include <__msvc_int128.hpp>

using int128 = std::_Signed128;
#endif

namespace zyemu::software
{
    using namespace detail;

    template<typename T> inline T readReg(const detail::ThreadContext& ctx, ZydisRegister reg)
    {
        const auto regInfo = getContextRegInfo(ctx.cpuState->mode, reg);
        if (regInfo.offset == 0 || regInfo.bitSize < 16)
        {
            return 0;
        }

        T value{};
        std::memcpy(&value, reinterpret_cast<const std::byte*>(&ctx) + regInfo.offset, sizeof(value));

        return value;
    }

    template<typename T> inline void writeReg(detail::ThreadContext& ctx, ZydisRegister reg, T value)
    {
        const auto regInfo = getContextRegInfo(ctx.cpuState->mode, reg);

        if (regInfo.offset == 0 || regInfo.bitSize < 16)
        {
            return;
        }

        std::memcpy(reinterpret_cast<std::byte*>(&ctx) + regInfo.offset, &value, sizeof(value));
    }

    // Signed divide AX by r/m8, with result stored in: AL := Quotient, AH := Remainder.
    StatusCode ZYEMU_FASTCALL idiv8(detail::ThreadContext& ctx, int8_t divisor)
    {
        if (divisor == 0)
        {
            return StatusCode::exceptionIntDivideError; // #DE: divide by zero
        }

        const auto dividend = readReg<std::int16_t>(ctx, x86::ax);

        // Perform division in 32-bit space to catch overflow
        const int32_t quotient = dividend / divisor;
        const int32_t remainder = dividend % divisor;

        // Check quotient fits in signed 8-bit
        if (quotient < INT8_MIN || quotient > INT8_MAX)
        {
            return StatusCode::exceptionIntOverflow; // #DE: quotient overflow
        }

        // Write back to AL (quotient) and AH (remainder)
        auto result = static_cast<uint16_t>(
            (static_cast<uint8_t>(remainder) << 8) | // AH
            (static_cast<uint8_t>(quotient))         // AL
        );

        writeReg(ctx, x86::ax, result);

        return StatusCode::success;
    }

    // Signed divide DX:AX by r/m16, with result stored in AX := Quotient, DX := Remainder.
    StatusCode ZYEMU_FASTCALL idiv16(detail::ThreadContext& ctx, int16_t divisor)
    {
        if (divisor == 0)
        {
            return StatusCode::exceptionIntDivideError; // #DE: divide by zero
        }

        // Dividend = DX:AX as signed 32-bit
        const auto ax = readReg<std::uint16_t>(ctx, x86::ax);
        const auto dx = readReg<std::uint16_t>(ctx, x86::dx);

        const int32_t dividend = (static_cast<int32_t>(static_cast<int16_t>(dx)) << 16) | static_cast<uint16_t>(ax);

        const int32_t q = dividend / divisor;
        const int32_t r = dividend % divisor;

        if (q < INT16_MIN || q > INT16_MAX)
        {
            return StatusCode::exceptionIntOverflow;
        }

        writeReg<std::uint16_t>(ctx, x86::ax, static_cast<uint16_t>(q));
        writeReg<std::uint16_t>(ctx, x86::dx, static_cast<uint16_t>(r));

        return StatusCode::success;
    }


    // Signed divide EDX:EAX by r/m32, with result stored in EAX := Quotient, EDX := Remainder.
    StatusCode ZYEMU_FASTCALL idiv32(detail::ThreadContext& ctx, int32_t divisor)
    {
        if (divisor == 0)
        {
            return StatusCode::exceptionIntDivideError; // #DE: divide by zero
        }

        // Dividend is EDX:EAX, a signed 64-bit integer
        const auto eax = readReg<std::uint32_t>(ctx, x86::eax);
        const auto edx = readReg<std::uint32_t>(ctx, x86::edx);

        const int64_t dividend = (static_cast<int64_t>(static_cast<int32_t>(edx)) << 32) | static_cast<uint64_t>(eax);

        const int64_t q = dividend / divisor;
        const int64_t r = dividend % divisor;

        if (q < INT32_MIN || q > INT32_MAX)
        {
            return StatusCode::exceptionIntOverflow;
        }

        // Zero extend to 64-bit registers
        const uint64_t rax = static_cast<uint32_t>(q);
        const uint64_t rdx = static_cast<uint32_t>(r);

        writeReg(ctx, x86::rax, rax);
        writeReg(ctx, x86::rdx, rdx);

        return StatusCode::success;
    }

    // Signed divide RDX:RAX by r/m64, with result stored in RAX := Quotient, RDX := Remainder.
    StatusCode ZYEMU_FASTCALL idiv64(detail::ThreadContext& ctx, int64_t divisor)
    {
        if (divisor == 0)
        {
            return StatusCode::exceptionIntDivideError; // #DE: divide by zero
        }

        const auto rax = readReg<std::uint64_t>(ctx, x86::rax);
        const auto rdx = readReg<std::uint64_t>(ctx, x86::rdx);
        const int128 dividend = (static_cast<int128>(rdx) << 64) | rax;

        const int128 q = dividend / divisor;
        const int128 r = dividend % divisor;

        if (q < INT64_MIN || q > INT64_MAX)
        {
            return StatusCode::exceptionIntOverflow;
        }

        writeReg<std::uint64_t>(ctx, x86::rax, static_cast<uint64_t>(q));
        writeReg<std::uint64_t>(ctx, x86::rdx, static_cast<uint64_t>(r));

        return StatusCode::success;
    }

} // namespace zyemu::software
```

`src/zyemu/cpu.software.hpp`:

```hpp
#pragma once

#include "internal.hpp"

#include <cstdint>
#include <zyemu/types.hpp>

namespace zyemu::software
{
    StatusCode ZYEMU_FASTCALL idiv8(detail::ThreadContext& ctx, int8_t divisor);

    StatusCode ZYEMU_FASTCALL idiv16(detail::ThreadContext& ctx, int16_t divisor);

    StatusCode ZYEMU_FASTCALL idiv32(detail::ThreadContext& ctx, int32_t divisor);

    StatusCode ZYEMU_FASTCALL idiv64(detail::ThreadContext& ctx, int64_t divisor);

} // namespace zyemu::memory
```

`src/zyemu/internal.hpp`:

```hpp
#pragma once

#include <Zydis/Decoder.h>
#include <array>
#include <map>
#include <sfl/map.hpp>
#include <sfl/segmented_vector.hpp>
#include <sfl/small_vector.hpp>
#include <zyemu/types.hpp>

namespace zyemu
{
    namespace detail
    {
        struct CPUState;

        enum class ThreadState
        {
            dead = 0,
            idle,
            running,
        };

        struct ThreadContext
        {
            // We use the largest possible size as its backwards compatible with smaller registers.
            using GpReg = std::array<std::byte, 8>;
            using MmxReg = std::array<std::byte, 8>;
            using X87Reg = std::array<std::byte, 10>;
            using TmmReg = std::array<std::byte, 16>;
            using ZmmReg = std::array<std::byte, 64>;
            using KReg = std::array<std::byte, 64>;

            // Not really part of the context but can be useful for callbacks.
            CPUState* cpuState{};
            ThreadId tid{ ThreadId::invalid };
            StatusCode status{ StatusCode::success };

            std::uint64_t rip{};
            std::uint64_t flags{};
            std::array<GpReg, 16> gpRegs{};
            std::array<MmxReg, 8> mmxRegs{};
            std::array<X87Reg, 8> x87Regs{};
            std::array<ZmmReg, 32> zmmRegs{};
            std::array<TmmReg, 8> tmmRegs{};
            std::array<KReg, 8> kRegs{};
        };

        struct ThreadData
        {
            ThreadState state{};
            ThreadContext context{};
        };

        struct CacheRegion
        {
            std::uint64_t base{};
            std::size_t size{};
            std::size_t capacity{};
            std::byte* data{};
        };

        using CodeCacheFunc = StatusCode(ZYEMU_FASTCALL*)(ThreadContext* th);

        struct CacheEntry
        {
            std::uint64_t address{};
            std::uint64_t cacheAddress{};
            std::uint64_t size{};
            CodeCacheFunc func{};
        };

        // First byte is the length of the instruction followed by the instruction data.
        union InstructionData
        {
            struct
            {
                std::uint64_t low;
                std::uint64_t high;
            };

            struct
            {
                std::uint8_t length;
                std::array<std::byte, 15> data;
            };

            constexpr bool operator==(const InstructionData& other) const
            {
                return low == other.low && high == other.high;
            }

            constexpr bool operator<(const InstructionData& other) const
            {
                return std::tie(low, high) < std::tie(other.low, other.high);
            }

            constexpr std::span<std::byte> buffer()
            {
                return { data.data(), length };
            }

            constexpr std::span<const std::byte> buffer() const
            {
                return { data.data(), length };
            }
        };

        struct InstructionDataHash
        {
            using is_transparent = void; // enable heterogeneous overloads
            using is_avalanching = void; // mark class as high quality avalanching hash

            constexpr std::size_t operator()(const InstructionData& data) const noexcept
            {
                std::size_t hash = data.low >> 32;
                hash ^= data.low & 0xFFFFFFF;
                hash ^= data.high >> 32;
                hash ^= data.high & 0xFFFFFFF;
                return hash;
            }
        };

        struct CPUState
        {
            ZydisMachineMode mode{};
            ZydisDecoder decoder{};
            ZydisDecoder ldeDecoder{};

            sfl::segmented_vector<ThreadData, 16> threads{};

            MemoryReadHandler memReadHandler{};
            void* memReadUserData{};

            MemoryWriteHandler memWriteHandler{};
            void* memWriteUserData{};

            sfl::small_vector<CacheRegion, 64> cacheRegions{};
            std::map<InstructionData, CacheEntry> cacheEntries{};
        };

    } // namespace detail

} // namespace zyemu
```

`src/zyemu/platform.cpp`:

```cpp
#include "platform.hpp"

#include <cstdint>
#include <functional>

#ifdef _MSC_VER
#    include <intrin.h>
#elif defined(__GNUC__) || defined(__clang__)
#    include <x86intrin.h>
#else
#    error "cpuid not supported on this compiler"
#endif

namespace zyemu::platform
{
    enum class HostCapabilities : std::uint32_t
    {
        none = 0,
        sse2 = 1 << 8,
        sse4_2 = 1 << 3,
        avx = 1 << 0,
        avx2 = 1 << 1,
        avx512 = 1 << 2,
        popcnt = 1 << 4,
        bmi1 = 1 << 5,
        bmi2 = 1 << 6,
        lzcnt = 1 << 7,
    };

    inline HostCapabilities operator|(HostCapabilities lhs, HostCapabilities rhs) noexcept
    {
        return static_cast<HostCapabilities>(static_cast<int>(lhs) | static_cast<int>(rhs));
    }

    inline HostCapabilities operator&(HostCapabilities lhs, HostCapabilities rhs) noexcept
    {
        return static_cast<HostCapabilities>(static_cast<int>(lhs) & static_cast<int>(rhs));
    }

    inline bool operator!(HostCapabilities value) noexcept
    {
        return static_cast<int>(value) == 0;
    }

    static inline void cpuid(int regs[4], int leaf, int subleaf = 0) noexcept
    {
#if defined(_MSC_VER)
        __cpuidex(regs, leaf, subleaf);
#elif defined(__GNUC__) || defined(__clang__)
        __cpuid_count(leaf, subleaf, regs[0], regs[1], regs[2], regs[3]);
#else
#    error "cpuid not supported on this compiler"
#endif
    }

    static inline std::uint64_t xgetbv(unsigned int index) noexcept
    {
        return _xgetbv(index);
    }

    static const HostCapabilities _hostCapabilities = std::invoke([]() -> HostCapabilities {
        HostCapabilities caps = HostCapabilities::none;

        int regs[4] = {};
        cpuid(regs, 1);

        // SSE2 (EDX bit 26)
        if (regs[3] & (1 << 26))
        {
            caps = caps | HostCapabilities::sse2;
        }

        // SSE4.2 (ECX bit 20)
        if (regs[2] & (1 << 20))
        {
            caps = caps | HostCapabilities::sse4_2;
        }

        // POPCNT (ECX bit 23)
        if (regs[2] & (1 << 23))
            caps = caps | HostCapabilities::popcnt;

        // OSXSAVE (ECX bit 27) + AVX (ECX bit 28)
        bool hasOSXSAVE = (regs[2] & (1 << 27)) != 0;
        bool hasAVX = (regs[2] & (1 << 28)) != 0;
        if (hasAVX && hasOSXSAVE)
        {
            uint64_t xcr0 = xgetbv(0);
            if ((xcr0 & 0x6) == 0x6)
            { // XMM (bit 1) and YMM (bit 2) enabled
                caps = caps | HostCapabilities::avx;
            }
        }

        // Extended features (leaf 7, subleaf 0)
        cpuid(regs, 7, 0);

        // AVX2 (EBX bit 5)
        if (regs[1] & (1 << 5))
        {
            caps = caps | HostCapabilities::avx2;
        }

        // BMI1 (EBX bit 3), BMI2 (EBX bit 8)
        if (regs[1] & (1 << 3))
        {
            caps = caps | HostCapabilities::bmi1;
        }
        if (regs[1] & (1 << 8))
        {
            caps = caps | HostCapabilities::bmi2;
        }

        // AVX-512 Foundation (EBX bit 16)
        bool hasAVX512F = (regs[1] & (1 << 16)) != 0;
        if (hasAVX512F && hasOSXSAVE)
        {
            uint64_t xcr0 = xgetbv(0);
            // Need XMM (bit 1), YMM (bit 2), ZMM_Hi256 (bit 5), and Hi16_ZMM (bit 6)
            if ((xcr0 & 0xE6) == 0xE6)
            {
                caps = caps | HostCapabilities::avx512;
            }
        }

        // LZCNT (leaf 0x80000001, ECX bit 5)
        cpuid(regs, 0x80000001);
        if (regs[2] & (1 << 5))
        {
            caps = caps | HostCapabilities::lzcnt;
        }

        return caps;
    });

    static inline bool hasCapability(HostCapabilities cap) noexcept
    {
        return (_hostCapabilities & cap) != HostCapabilities::none;
    }

    bool supportsAVX() noexcept
    {
        return hasCapability(HostCapabilities::avx);
    }

    bool supportsAVX2() noexcept
    {
        return hasCapability(HostCapabilities::avx2);
    }

    bool supportsAVX512() noexcept
    {
        return hasCapability(HostCapabilities::avx512);
    }

    bool supportsSSE2() noexcept
    {
        return hasCapability(HostCapabilities::sse2);
    }

    bool supportsSSE42() noexcept
    {
        return hasCapability(HostCapabilities::sse4_2);
    }

    bool supportsPopcnt() noexcept
    {
        return hasCapability(HostCapabilities::popcnt);
    }

    bool supportsBMI1() noexcept
    {
        return hasCapability(HostCapabilities::bmi1);
    }

    bool supportsBMI2() noexcept
    {
        return hasCapability(HostCapabilities::bmi2);
    }

    bool supportsLZCNT() noexcept
    {
        return hasCapability(HostCapabilities::lzcnt);
    }

} // namespace zyemu::platform
```

`src/zyemu/platform.hpp`:

```hpp
#pragma once

namespace zyemu::platform
{

#ifdef _WIN32
#    ifdef _MSC_VER
#        define ZYEMU_FASTCALL __fastcall
#    else
#        define ZYEMU_FASTCALL __attribute__((fastcall))
#    endif
#else
#    define ZYEMU_FASTCALL
    static_assert(false, "Unsupported platform");
#endif

    bool supportsSSE2() noexcept;

    bool supportsSSE42() noexcept;

    bool supportsAVX() noexcept;

    bool supportsAVX2() noexcept;

    bool supportsAVX512() noexcept;

    bool supportsPopcnt() noexcept;

    bool supportsBMI1() noexcept;

    bool supportsBMI2() noexcept;

    bool supportsLZCNT() noexcept;

} // namespace zyemu::platform
```

`src/zyemu/thread.hpp`:

```hpp
#pragma once

#include "internal.hpp"

namespace zyemu
{
    struct RegInfo
    {
        std::uint16_t offset;
        std::uint16_t bitSize;
        std::uint16_t base;
        std::uint16_t largeBitSize;
    };

    namespace detail
    {
        inline bool isGp8Hi(ZydisRegister reg)
        {
            switch (reg)
            {
                case ZYDIS_REGISTER_AH:
                case ZYDIS_REGISTER_CH:
                case ZYDIS_REGISTER_DH:
                case ZYDIS_REGISTER_BH:
                    return true;
                default:
                    break;
            }
            return false;
        }

    } // namespace detail

    inline RegInfo getContextStatusReg([[maybe_unused]] ZydisMachineMode mode)
    {
        constexpr std::uint16_t byteSize = static_cast<std::uint16_t>(sizeof(StatusCode));
        constexpr std::uint16_t regOffset = offsetof(detail::ThreadContext, status);
        constexpr std::uint16_t regSize = byteSize * 8U; // Convert to bits.

        return RegInfo{
            .offset = regOffset,
            .bitSize = regSize,
            .base = regOffset,
            .largeBitSize = regSize,
        };
    }

    inline RegInfo getContextTID([[maybe_unused]] ZydisMachineMode mode)
    {
        constexpr std::uint16_t byteSize = static_cast<std::uint16_t>(sizeof(ThreadId));
        constexpr std::uint16_t regOffset = offsetof(detail::ThreadContext, tid);
        constexpr std::uint16_t regSize = byteSize * 8U; // Convert to bits.
        return RegInfo{
            .offset = regOffset,
            .bitSize = regSize,
            .base = regOffset,
            .largeBitSize = regSize,
        };
    }

    inline RegInfo getContextRegInfo(ZydisMachineMode mode, ZydisRegister reg)
    {
        const std::uint16_t regSize = ZydisRegisterGetWidth(mode, reg);
        const ZydisRegister largeReg = ZydisRegisterGetLargestEnclosing(mode, reg);
        const std::uint16_t largeBitSize = ZydisRegisterGetWidth(mode, largeReg);
        const std::uint16_t largeByteSize = largeBitSize / 8U;

        const auto getLocalOffset = [](ZydisRegister reg) {
            if (detail::isGp8Hi(reg))
            {
                return 1;
            }
            return 0;
        };

        switch (ZydisRegisterGetClass(largeReg))
        {
            case ZydisRegisterClass::ZYDIS_REGCLASS_GPR8:
            case ZydisRegisterClass::ZYDIS_REGCLASS_GPR16:
            case ZydisRegisterClass::ZYDIS_REGCLASS_GPR32:
            case ZydisRegisterClass::ZYDIS_REGCLASS_GPR64:
            {
                const std::uint16_t baseOffset = offsetof(detail::ThreadContext, gpRegs);
                const std::uint16_t regId = ZydisRegisterGetId(largeReg);
                const std::uint16_t regOffset = baseOffset + (regId * largeByteSize);
                const std::uint16_t regOffsetWithLocal = regOffset + getLocalOffset(reg);

                assert(regOffset - baseOffset < sizeof(detail::ThreadContext::gpRegs));

                return RegInfo{
                    .offset = regOffsetWithLocal,
                    .bitSize = regSize,
                    .base = regOffset,
                    .largeBitSize = largeBitSize,
                };
            }
            case ZydisRegisterClass::ZYDIS_REGCLASS_IP:
            {
                return RegInfo{
                    .offset = offsetof(detail::ThreadContext, rip),
                    .bitSize = regSize,
                    .base = offsetof(detail::ThreadContext, rip),
                    .largeBitSize = largeBitSize,
                };
            }
            case ZydisRegisterClass::ZYDIS_REGCLASS_FLAGS:
            {
                return RegInfo{
                    .offset = offsetof(detail::ThreadContext, flags),
                    .bitSize = regSize,
                    .base = offsetof(detail::ThreadContext, flags),
                    .largeBitSize = largeBitSize,
                };
            }
            case ZydisRegisterClass::ZYDIS_REGCLASS_MMX:
            {
                const std::uint16_t baseOffset = offsetof(detail::ThreadContext, mmxRegs);
                const std::uint16_t regId = ZydisRegisterGetId(reg);
                const std::uint16_t regOffset = baseOffset + (regId * largeByteSize);
                const std::uint16_t regOffsetWithLocal = regOffset;

                assert(regOffset - baseOffset < sizeof(detail::ThreadContext::mmxRegs));

                return RegInfo{
                    .offset = regOffsetWithLocal,
                    .bitSize = regSize,
                    .base = regOffset,
                    .largeBitSize = largeByteSize,
                };
            }
            case ZydisRegisterClass::ZYDIS_REGCLASS_X87:
            {
                const std::uint16_t baseOffset = offsetof(detail::ThreadContext, x87Regs);
                const std::uint16_t regId = ZydisRegisterGetId(reg);
                const std::uint16_t regOffset = baseOffset + (regId * largeByteSize);
                const std::uint16_t regOffsetWithLocal = regOffset;

                assert(regOffset - baseOffset < sizeof(detail::ThreadContext::x87Regs));

                return RegInfo{
                    .offset = regOffsetWithLocal,
                    .bitSize = regSize,
                    .base = regOffset,
                    .largeBitSize = largeBitSize,
                };
            }
            case ZydisRegisterClass::ZYDIS_REGCLASS_XMM:
            case ZydisRegisterClass::ZYDIS_REGCLASS_YMM:
            case ZydisRegisterClass::ZYDIS_REGCLASS_ZMM:
            {
                const std::uint16_t baseOffset = offsetof(detail::ThreadContext, zmmRegs);
                const std::uint16_t regId = ZydisRegisterGetId(reg);
                const std::uint16_t regOffset = baseOffset + (regId * largeByteSize);
                const std::uint16_t regOffsetWithLocal = regOffset;

                assert(regOffset - baseOffset < sizeof(detail::ThreadContext::zmmRegs));

                return RegInfo{
                    .offset = regOffsetWithLocal,
                    .bitSize = regSize,
                    .base = regOffset,
                    .largeBitSize = largeBitSize,
                };
            }
        }

        assert(false);
        return {};
    }

} // namespace zyemu
```

`thirdparty/CMakeLists.txt`:

```txt
# This file is automatically generated from cmake.toml - DO NOT EDIT
# See https://github.com/build-cpp/cmkr for more information

# Create a configure-time dependency on cmake.toml to improve IDE support
if(CMKR_ROOT_PROJECT)
	set_property(DIRECTORY APPEND PROPERTY CMAKE_CONFIGURE_DEPENDS cmake.toml)
endif()

# Options
option(INSTALL_GTEST "" OFF)
option(BUILD_GMOCK "" OFF)
option(BENCHMARK_ENABLE_TESTING "" OFF)
option(BENCHMARK_ENABLE_INSTALL "" OFF)
option(BENCHMARK_USE_BUNDLED_GTEST "" OFF)

include(FetchContent)

# Fix warnings about DOWNLOAD_EXTRACT_TIMESTAMP
if(POLICY CMP0135)
	cmake_policy(SET CMP0135 NEW)
endif()
message(STATUS "Fetching Zydis (f2ad85f92fc6645a642053882eaf0e95693977e9)...")
FetchContent_Declare(Zydis SYSTEM
	GIT_REPOSITORY
		"https://github.com/zyantific/zydis"
	GIT_TAG
		f2ad85f92fc6645a642053882eaf0e95693977e9
)
FetchContent_MakeAvailable(Zydis)

message(STATUS "Fetching GTest (v1.15.2)...")
FetchContent_Declare(GTest SYSTEM
	GIT_REPOSITORY
		"https://github.com/google/googletest"
	GIT_TAG
		v1.15.2
)
FetchContent_MakeAvailable(GTest)

message(STATUS "Fetching GBenchmark (v1.6.1)...")
FetchContent_Declare(GBenchmark SYSTEM
	GIT_REPOSITORY
		"https://github.com/google/benchmark"
	GIT_TAG
		v1.6.1
)
FetchContent_MakeAvailable(GBenchmark)

message(STATUS "Fetching sfl (1.10.1)...")
FetchContent_Declare(sfl
	GIT_REPOSITORY
		"https://github.com/slavenf/sfl-library.git"
	GIT_TAG
		1.10.1
)
FetchContent_MakeAvailable(sfl)

```

`thirdparty/cmake.toml`:

```toml
# Reference: https://build-cpp.github.io/cmkr/cmake-toml

[options]
INSTALL_GTEST = false
BUILD_GMOCK = false
BENCHMARK_ENABLE_TESTING = false
BENCHMARK_ENABLE_INSTALL = false
BENCHMARK_USE_BUNDLED_GTEST = false

[fetch-content.Zydis]
git = "https://github.com/zyantific/zydis"
tag = "f2ad85f92fc6645a642053882eaf0e95693977e9"
system = true

[fetch-content.GTest]
git = "https://github.com/google/googletest"
tag = "v1.15.2"
system = true

[fetch-content.GBenchmark]
git = "https://github.com/google/benchmark"
tag = "v1.6.1"
system = true

[fetch-content.sfl]
git = "https://github.com/slavenf/sfl-library.git"
tag = "1.10.1"
```