Project Path: arc_ZehMatt_SnakeRoyal_yg_hdj_h

Source Tree:

```txt
arc_ZehMatt_SnakeRoyal_yg_hdj_h
├── CREDITS
├── LICENSE
├── Preview.jpg
├── README.md
└── src
    ├── Resources
    │   ├── Icon.txt
    │   ├── snake.ico
    │   ├── snake.png
    │   └── snake_uZ7_icon.ico
    ├── SnakeRoyal
    │   ├── Buffer.h
    │   ├── Color.h
    │   ├── Config.h
    │   ├── Game.cpp
    │   ├── Game.h
    │   ├── Logging.cpp
    │   ├── Logging.h
    │   ├── Main.cpp
    │   ├── Network.cpp
    │   ├── Network.h
    │   ├── NetworkMessage.h
    │   ├── NetworkPlay.cpp
    │   ├── Painter.cpp
    │   ├── Painter.h
    │   ├── Player.h
    │   ├── Players.cpp
    │   ├── Players.h
    │   ├── Serialization.h
    │   ├── Snake.h
    │   ├── SnakeRoyal.aps
    │   ├── SnakeRoyal.rc
    │   ├── SnakeRoyal.vcxproj
    │   ├── SnakeRoyal.vcxproj.filters
    │   ├── Snakes.cpp
    │   ├── Snakes.h
    │   ├── Socket.cpp
    │   ├── Socket.h
    │   ├── TileMap.cpp
    │   ├── TileMap.h
    │   ├── Types.h
    │   ├── Utils.cpp
    │   ├── Utils.h
    │   ├── Vector2.h
    │   └── resource.h
    └── SnakeRoyal.sln

```

`CREDITS`:

```
* Special thanks to Ted John (IntelOrca) for allowing me to use the Socket implementation.
* The Icon was made by Iconby Lorc (CC 3.0)
```

`LICENSE`:

```
MIT License

Copyright (c) 2019 ζeh Matt

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# SnakeRoyal
Multiplayer snake game written at a single weekend
![Screenshot](Preview.jpg)

So expect bugs...

# Building
## Windows
Just open it with Visual Studio 2019 Community Edition or higher and it should compile out of the box, it has no dependencies.
## Linux
Sorry but not at this time, PR's are welcome!

# Usage
Once built you can join a server via
```
SnakeRoyal.exe join <ip>
```
The default port is 11754 you can choose to use a different one by adding port
```
SnakeRoyal.exe join <ip>:<port>
```

# Hosting
You can host a server by using following command:
```
SnakeRoyal.exe host
```
If you don't wish to have any visual output you can also choose to do it like following:
```
SnakeRoyal.exe host --headless
```
To specify a different port:
```
SnakeRoyal.exe host <host> <port>
```

# Credits
- Ted John ([IntelOrca](https://github.com/IntelOrca)) for allowing me to use the Socket implementation from [OpenRCT2](https://github.com/OpenRCT2/OpenRCT2)
- Iconby Lorc for the Icon (CC 3.0)

```

`src/Resources/Icon.txt`:

```txt
Snake iconby Lorc under CC BY 3.0
```

`src/SnakeRoyal.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.29025.244
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "SnakeRoyal", "SnakeRoyal\SnakeRoyal.vcxproj", "{15B83893-63BA-44C8-BCB6-635F1EAA75A5}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{15B83893-63BA-44C8-BCB6-635F1EAA75A5}.Debug|x64.ActiveCfg = Debug|x64
		{15B83893-63BA-44C8-BCB6-635F1EAA75A5}.Debug|x64.Build.0 = Debug|x64
		{15B83893-63BA-44C8-BCB6-635F1EAA75A5}.Debug|x86.ActiveCfg = Debug|Win32
		{15B83893-63BA-44C8-BCB6-635F1EAA75A5}.Debug|x86.Build.0 = Debug|Win32
		{15B83893-63BA-44C8-BCB6-635F1EAA75A5}.Release|x64.ActiveCfg = Release|x64
		{15B83893-63BA-44C8-BCB6-635F1EAA75A5}.Release|x64.Build.0 = Release|x64
		{15B83893-63BA-44C8-BCB6-635F1EAA75A5}.Release|x86.ActiveCfg = Release|Win32
		{15B83893-63BA-44C8-BCB6-635F1EAA75A5}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {4CB75A70-D122-494A-A5FC-85777A9A027A}
	EndGlobalSection
EndGlobal

```

`src/SnakeRoyal/Buffer.h`:

```h
#pragma once

#ifndef _BUFFER_H_
#define _BUFFER_H_
#pragma once

#include <stdint.h>
#include <memory>
#include <assert.h>

enum class BufferSeek
{
    SET,
    END,
    CUR,
};

template<typename T> class BufferBase
{
private:
    T* m_buffer;
    size_t m_capacity;
    size_t m_size;
    size_t m_offset;
    bool m_borrowed;

public:
    BufferBase();
    ~BufferBase();

    BufferBase(const BufferBase& other)
    {
        *this = other;
    }

    BufferBase& operator=(const BufferBase& other)
    {
        purge();
        write(other.base(), other.size());
        return *this;
    }

    // Move semantics
    BufferBase(BufferBase&& other)
    {
        m_buffer = other.m_buffer;
        m_size = other.m_size;
        m_offset = other.m_offset;
        m_capacity = other.m_capacity;
        m_borrowed = other.m_borrowed;

        // Release from the other object, we can't delete it.
        other.m_buffer = nullptr;
        other.m_size = 0;
    }

    BufferBase& operator=(BufferBase&& other)
    {
        if (this != &other)
        {
            purge();

            m_buffer = other.m_buffer;
            m_size = other.m_size;
            m_offset = other.m_offset;
            m_capacity = other.m_capacity;

            // Release from the other object, we can't delete it.
            other.m_buffer = nullptr;
            other.m_size = 0;
        }
        return *this;
    }

    // Write data at the current position, overwrites,
    size_t write(const void* data, size_t size);

    size_t write_str(const char* str)
    {
        return write((const void*)str, (strlen(str) + 1) * sizeof(char));
    }

    size_t write_str(const wchar_t* str)
    {
        return write((const void*)str, (wcslen(str) + 1) * sizeof(wchar_t));
    }

    template<typename D> size_t write(const D& data)
    {
        return write(&data, sizeof(D));
    }

    size_t write(const BufferBase<T>& data)
    {
        return write(data.base(), data.size());
    }

    // Just expands the buffer and returns the offset, this allows direct
    // writing.
    size_t room(size_t len);

    // Insert data at the current position, extends buffer.
    size_t insert(const void* data, size_t size);

    size_t insert_str(const char* str)
    {
        return insert(str, (strlen(str) + 1) * sizeof(char));
    }

    size_t insert_str(const wchar_t* str)
    {
        return insert(str, (wcslen(str) + 1) * sizeof(wchar_t));
    }

    // Read data from the current position.
    size_t read(void* data, size_t size);

    template<typename D> size_t read(D& data)
    {
        return read(&data, sizeof(D));
    }

    size_t seek(size_t offset, BufferSeek method = BufferSeek::SET);

    size_t erase(size_t size);

    size_t offset() const;

    bool eob() const;

    bool empty() const;

    size_t size() const;
    size_t capacity() const;

    void reserve(size_t newCapacity);

    T& operator[](size_t index);

    void clear();
    void purge();

    T* base() const;

private:
    T* reallocate(T* buf, size_t count)
    {
        size_t byteSize = sizeof(T) * count;

        void* res = nullptr;
        if (buf)
            res = ::realloc(buf, byteSize);
        else
            res = ::malloc(byteSize);

        return static_cast<T*>(res);
    }

    void dealloc(T* buf)
    {
        if (!buf || m_borrowed == true)
            return;

        ::free(buf);
    }

private:
    void grow(size_t size, bool insertType);
};

template<typename T> bool BufferBase<T>::empty() const
{
    return m_size == 0;
}

template<typename T> T& BufferBase<T>::operator[](size_t index)
{
    return m_buffer[index];
}

template<typename T> BufferBase<T>::BufferBase()
{
    m_buffer = nullptr;
    m_capacity = 0;
    m_offset = 0;
    m_size = 0;
    m_borrowed = false;
}

template<typename T> BufferBase<T>::~BufferBase()
{
    purge();
}

template<typename T> void BufferBase<T>::grow(size_t size, bool insertType)
{
    size_t spaceLeft = (m_size - m_offset);

    if (m_borrowed)
    {
        if (size > spaceLeft)
        {
            assert(false);
        }
        return;
    }

    if (m_offset + size > m_size)
    {
        if (m_offset + size < m_capacity)
        {
            // Capacity space left.
            if (spaceLeft < size)
                size -= spaceLeft;

            m_size += size;
            return;
        }
    }
    else
    {
        // Space left, however insert always expands size.
        if (insertType)
        {
            m_size += size;
            return;
        }
        return;
    }

    size_t newCapcity = (m_capacity + size + 1) << 1;

    m_buffer = reallocate(m_buffer, newCapcity);

    if (insertType)
        m_size += size;
    else
    {
        m_size += (size - spaceLeft);
    }

    m_capacity = newCapcity;
}

template<typename T> size_t BufferBase<T>::write(const void* data, size_t size)
{
    grow(size, false);

    memcpy(m_buffer + m_offset, data, size);
    m_buffer[m_size] = '\0';

    m_offset += size;

    return size;
}

template<typename T> size_t BufferBase<T>::room(size_t len)
{
    grow(len, false);

    size_t offset = m_offset;
    m_offset += len;

    return offset;
}

template<typename T> size_t BufferBase<T>::insert(const void* data, size_t size)
{
    grow(size, true);

    size_t sizeOfEnd = m_size - (m_offset + size);

    memmove(m_buffer + m_offset + size, m_buffer + m_offset, sizeOfEnd);
    memcpy(m_buffer + m_offset, data, size);
    m_buffer[m_size] = '\0';

    m_offset += size;

    return size;
}

template<typename T> size_t BufferBase<T>::erase(size_t size)
{
    if (empty())
        return 0;

    if (m_offset + size > m_size)
        size = (m_size - m_offset);

    size_t sizeOfEnd = m_size - (m_offset + size);

    memmove(m_buffer + m_offset, m_buffer + m_offset + size, sizeOfEnd);
    m_size -= size;
    m_buffer[m_size] = '\0';

    return size;
}

template<typename T> size_t BufferBase<T>::read(void* data, size_t size)
{
    if (m_offset + size > m_size)
        size = (m_size - m_offset);

    memcpy(data, m_buffer + m_offset, size);
    m_offset += size;

    return size;
}

template<typename T> bool BufferBase<T>::eob() const
{
    return m_offset >= m_size;
}

template<typename T> size_t BufferBase<T>::size() const
{
    return m_size;
}

template<typename T> size_t BufferBase<T>::capacity() const
{
    return m_capacity;
}

template<typename T>
size_t BufferBase<T>::seek(
    size_t offset, BufferSeek method /*= BufferSeek::SET*/)
{
    switch (method)
    {
        case BufferSeek::SET:
            m_offset = 0;
        case BufferSeek::CUR:
        {
            size_t maxOffset = offset;

            if (maxOffset + m_offset > m_size)
                maxOffset = m_size - m_offset;

            m_offset += maxOffset;
        }
        break;
        case BufferSeek::END:
        {
            if (m_size - offset > m_size)
                m_offset = 0;
            else
                m_offset = (m_size - offset);
        }
        break;
    }
    return m_offset;
}

template<typename T> size_t BufferBase<T>::offset() const
{
    return m_offset;
}

template<typename T> void BufferBase<T>::reserve(size_t newCapacity)
{
    if (newCapacity > m_capacity)
    {
        T* buffer = new T[newCapacity];
        if (m_buffer)
        {
            memcpy(buffer, m_buffer, m_size);
        }
        m_buffer = buffer;
        m_capacity = newCapacity;
    }
}

template<typename T> void BufferBase<T>::clear()
{
    // Capacity and buffer remain set.
    m_size = 0;
    m_offset = 0;
    if (m_buffer)
        m_buffer[0] = '\0';
}

template<typename T> void BufferBase<T>::purge()
{
    dealloc(m_buffer);
    m_size = 0;
    m_capacity = 0;
    m_buffer = nullptr;
    m_offset = 0;
}

template<typename T> T* BufferBase<T>::base() const
{
    return m_buffer;
}

typedef BufferBase<uint8_t> Buffer;

#endif // _BUFFER_H_
```

`src/SnakeRoyal/Color.h`:

```h
#pragma once

#include <stdint.h>
#include <iterator>
#include <windows.h>

#include "Config.h"

struct Color
{
    uint8_t r = 0;
    uint8_t g = 0;
    uint8_t b = 0;

    COLORREF getColorRef() const
    {
        return RGB(r, g, b);
    }

    bool operator==(const Color& other) const
    {
        return r == other.r && g == other.g && b == other.b;
    }

    bool operator!=(const Color& other) const
    {
        return !(other == *this);
    }
};

static constexpr Color COLOR_BLACK{ 0, 0, 0 };
static constexpr Color COLOR_BLUE{ 0, 0, 128 };
static constexpr Color COLOR_BRIGHT_BLUE{ 0, 0, 255 };
static constexpr Color COLOR_BRIGHT_RED{ 255, 0, 0 };
static constexpr Color COLOR_MAGENTA{ 128, 0, 128 };
static constexpr Color COLOR_MAUVE{ 128, 0, 255 };
static constexpr Color COLOR_PURPLE{ 255, 0, 128 };
static constexpr Color COLOR_BRIGHT_MAGENTA{ 255, 0, 255 };
static constexpr Color COLOR_GREEN{ 0, 128, 0 };
static constexpr Color COLOR_CYAN{ 0, 128, 128 };
static constexpr Color COLOR_SKY_BLUE{ 0, 128, 255 };
static constexpr Color COLOR_RED{ 128, 0, 0 };
static constexpr Color COLOR_YELLOW{ 128, 128, 0 };
static constexpr Color COLOR_GREY{ 128, 128, 128 };
static constexpr Color COLOR_PASTEL_BLUE{ 128, 128, 255 };
static constexpr Color COLOR_ORANGE{ 255, 128, 0 };
static constexpr Color COLOR_PINK{ 255, 128, 128 };
static constexpr Color COLOR_PASTEL_MAGENTA{ 255, 128, 255 };
static constexpr Color COLOR_BRIGHT_GREEN{ 0, 255, 0 };
static constexpr Color COLOR_SEA_GREEN{ 0, 255, 128 };
static constexpr Color COLOR_BRIGHT_CYAN{ 0, 255, 255 };
static constexpr Color COLOR_LIME{ 128, 255, 0 };
static constexpr Color COLOR_PASTEL_GREEN{ 128, 255, 128 };
static constexpr Color COLOR_PASTEL_CYAN{ 128, 255, 255 };
static constexpr Color COLOR_BRIGHT_YELLOW{ 255, 255, 0 };
static constexpr Color COLOR_PASTEL_YELLOW{ 255, 255, 128 };
static constexpr Color COLOR_WHITE{ 255, 255, 255 };

static constexpr Color COLOR_BG = COLOR_BLACK;

static constexpr Color COLOR_PLAYER_PALETTE[] = {
    COLOR_BRIGHT_BLUE,    COLOR_RED,           COLOR_MAGENTA,
    COLOR_MAUVE,          COLOR_PURPLE,        COLOR_BRIGHT_MAGENTA,
    COLOR_GREEN,          COLOR_PASTEL_GREEN,  COLOR_CYAN,
    COLOR_SKY_BLUE,       COLOR_BRIGHT_YELLOW, COLOR_YELLOW,
    COLOR_PASTEL_BLUE,    COLOR_BLUE,          COLOR_PINK,
    COLOR_PASTEL_MAGENTA, COLOR_BRIGHT_GREEN,  COLOR_BRIGHT_RED,
    COLOR_SEA_GREEN,      COLOR_BRIGHT_CYAN,   COLOR_LIME,
    COLOR_PASTEL_CYAN,    COLOR_PASTEL_YELLOW, COLOR_WHITE,
};

static_assert(MAX_PLAYERS <= std::size(COLOR_PLAYER_PALETTE));
```

`src/SnakeRoyal/Config.h`:

```h
#pragma once

static constexpr int MAX_PLAYERS = 24;

static constexpr int TILE_MAP_GRID_W = 48;
static constexpr int TILE_MAP_GRID_H = 32;

static constexpr int TILE_SIZE_W = 8;
static constexpr int TILE_SIZE_H = 8;

static constexpr int TILE_MAP_SIZE_W = TILE_MAP_GRID_W * (TILE_SIZE_W + 1);
static constexpr int TILE_MAP_SIZE_H = TILE_MAP_GRID_H * (TILE_SIZE_H + 1);

static constexpr int TILE_MAP_MARGIN_TOP = 30;
static constexpr int TILE_MAP_MARGIN_BOTTOM = 60;
static constexpr int TILE_MAP_MARGIN_RIGHT = 30;
static constexpr int TILE_MAP_MARGIN_LEFT = 20;

static constexpr int PLAYER_LIST_W = 250;
static constexpr int PLAYER_LIST_H = TILE_MAP_SIZE_H;
static constexpr int PLAYER_LIST_X = TILE_MAP_SIZE_W + TILE_MAP_MARGIN_LEFT
                                     + 10;
static constexpr int PLAYER_LIST_Y = TILE_MAP_MARGIN_TOP;

static constexpr int WINDOW_SIZE_W = TILE_MAP_MARGIN_LEFT + TILE_MAP_SIZE_W
                                     + TILE_SIZE_W + TILE_MAP_MARGIN_RIGHT
                                     + PLAYER_LIST_W + 10;
static constexpr int WINDOW_SIZE_H = TILE_MAP_MARGIN_TOP + TILE_MAP_SIZE_H
                                     + TILE_SIZE_H + TILE_MAP_MARGIN_BOTTOM;

static constexpr double GAME_TICK_RATE = 1.0 / 20.0;
// The maximum threshold time is GAME_TICK_RATE * GAME_TICK_DELTA_THRESHOLD
// 100 ms seems to be a good value, clients with 100ms latency should still have
// bearable gameplay.
static constexpr int GAME_TICK_DELTA_THRESHOLD = 4;

static constexpr int GAME_ROUND_RESTART_TICKS = 60;
```

`src/SnakeRoyal/Game.cpp`:

```cpp
#include <iostream>
#include <windows.h>
#include <thread>
#include <assert.h>

#include "Logging.h"
#include "Game.h"
#include "TileMap.h"
#include "Snakes.h"
#include "Players.h"
#include "Utils.h"
#include "Network.h"

Game gGame;

static constexpr Color COLOR_FOOD = COLOR_ORANGE;

void Game::setHeadless(bool headless)
{
    _headless = headless;
}

bool Game::getHeadless() const
{
    return _headless;
}

void Game::init(HWND hWnd)
{
    logPrint("%s\n", __FUNCTION__);

    _hWnd = hWnd;
    _randState = static_cast<uint32_t>(time(nullptr));
    _tick = 0;

    if (gNetwork.getMode() == NetworkMode::NONE)
    {
        restart(GAME_ROUND_RESTART_TICKS);
    }
}

void Game::restart(uint32_t delayInTicks)
{
    logPrint("%s\n", __FUNCTION__);

    setRoundState(RoundState::RESTARTING, delayInTicks);

    if (gNetwork.getMode() == NetworkMode::SERVER)
    {
        MessageServerRoundRestart msgRoundRestart;
        msgRoundRestart.tick = _tick;
        msgRoundRestart.delay = delayInTicks;
        gNetwork.sendMessage(msgRoundRestart);
    }
}

void Game::startRound()
{
    logPrint("%s\n", __FUNCTION__);

    gTileMap.reset();

    size_t playerCount = gPlayers.count();

    int32_t spawnY = TILE_MAP_GRID_H / 2;
    int32_t spawnSpacing = TILE_MAP_GRID_W / (playerCount + 1);
    int32_t spawnX = spawnSpacing;

    for (PlayerId playerId = 0; playerId < MAX_PLAYERS; playerId++)
    {
        if (!gPlayers.isValidPlayer(playerId))
            continue;

        const Player& player = gPlayers.getPlayer(playerId);
        if (player.snakeId != INVALID_SNAKE_ID)
        {
            gSnakes.remove(player.snakeId);
        }

        SnakeId snakeId = gSnakes.create(playerId, spawnX, spawnY);
        spawnX += spawnSpacing;

        gPlayers.setSnake(playerId, snakeId);
    }

    // Place food.
    for (int i = 0; i < 3; i++)
    {
        createFood();
    }

    setRoundState(RoundState::RUNNING, 0);

    if (gNetwork.getMode() == NetworkMode::SERVER)
    {
        MessageServerRoundStart msgRoundStart;
        msgRoundStart.tick = _tick;
        gNetwork.sendMessage(msgRoundStart);
    }
}

void Game::update()
{
    int32_t numUpdates = 1;

    gNetwork.update();

    if (gNetwork.getMode() == NetworkMode::CLIENT)
    {
        // Allow client to catch up for GAME_TICK_DELTA_THRESHOLD *
        // GAME_TICK_RATE in ms
        numUpdates = std::min<int32_t>(
            gNetwork.getServerTick() - _tick, GAME_TICK_DELTA_THRESHOLD);
    }

    for (int i = 0; i < numUpdates; i++)
    {
        gNetwork.update();

        if (gNetwork.getMode() == NetworkMode::CLIENT)
        {
            if (_tick >= gNetwork.getServerTick())
                break;
        }

        if (getRoundState() == RoundState::RUNNING)
        {
            gPlayers.update();
            gSnakes.update();
        }

        if (gNetwork.getMode() == NetworkMode::SERVER)
        {
            if (getRoundState() == RoundState::RESTARTING
                && _tick >= _roundData.timeout)
            {
                startRound();
            }
            else if (getRoundState() == RoundState::RUNNING)
            {
                size_t snakesCount = gSnakes.count();
                size_t snakesAlive = gSnakes.alive();
                if (snakesCount > 0 && snakesAlive == 0)
                {
                    gGame.restart(GAME_ROUND_RESTART_TICKS);
                }
            }
        }

        _tick++;

        if (gNetwork.getMode() == NetworkMode::CLIENT)
        {
            assert(_tick <= gNetwork.getServerTick());
        }

        gNetwork.flush();
    }
}

void Game::draw()
{
    RECT rc;
    GetClientRect(_hWnd, &rc);

    Painter painter(_hWnd, rc);
    painter.clear({ 0, 0, 0 });

    gTileMap.draw(painter);

    drawInfo(painter);
}

void Game::drawInfo(Painter& painter)
{
    gPlayers.draw(painter);

    char roundInfo[1024]{};

    if (gNetwork.getMode() == NetworkMode::CLIENT)
    {
        char pingInfo[128]{};
        sprintf_s(pingInfo, "Ping: %d ms, ", gNetwork.getCurrentPing());
        strcat_s(roundInfo, pingInfo);
    }

    switch (_roundData.state)
    {
        case RoundState::IDLE:
            strcat_s(roundInfo, "State: Idle");
            break;
        case RoundState::RUNNING:
            strcat_s(roundInfo, "State: Running");
            break;
        case RoundState::RESTARTING:
        {
            char restartInfo[128]{};

            uint32_t remainingTicks = 0;
            if (_tick < _roundData.timeout)
                remainingTicks = _roundData.timeout - _tick;

            double secsRemaining = (GAME_TICK_RATE * remainingTicks);
            sprintf_s(
                restartInfo, "State: Restarting in %.02f secs ...",
                secsRemaining);

            strcat_s(roundInfo, restartInfo);
        }
        break;
    }

    painter.text(roundInfo, TILE_MAP_MARGIN_LEFT, 10);
}

uint32_t Game::getRandState() const
{
    return _randState;
}

void Game::setRandState(uint32_t state)
{
    _randState = state;
}

uint32_t Game::getRand()
{
    // Park Miller PRNG
    return _randState = ((uint64_t)_randState * 48271u) % 0x7fffffff;
}

RoundState Game::getRoundState() const
{
    return _roundData.state;
}

RoundData_t& Game::getRoundData()
{
    return _roundData;
}

void Game::setRoundState(RoundState state, uint32_t delay /* = 0*/)
{
    _roundData.state = state;
    _roundData.timeout = _tick + delay;

    if (gNetwork.getMode() == NetworkMode::SERVER)
    {
        MessageServerRoundState msgRoundState;
        msgRoundState.tick = _tick;
        msgRoundState.state = state;
        msgRoundState.delay = delay;
        gNetwork.sendMessage(msgRoundState);
    }
}

uint32_t Game::getClientTime() const
{
    return static_cast<uint32_t>(
        (static_cast<double>(_tick) * GAME_TICK_RATE) * 1000.0);
}

uint32_t Game::getHostTime() const
{
    if (gNetwork.getMode() == NetworkMode::SERVER
        || gNetwork.getMode() == NetworkMode::NONE)
        return static_cast<uint32_t>(
            (static_cast<double>(_tick) * GAME_TICK_RATE) * 1000.0);

    return static_cast<uint32_t>(
        (static_cast<double>(gNetwork.getServerTick()) * GAME_TICK_RATE)
        * 1000.0);
}

void Game::setFocus(bool hasFocus)
{
    _hasFocus = hasFocus;
}

bool Game::hasFocus() const
{
    return _hasFocus;
}

uint32_t Game::getTick() const
{
    return _tick;
}

void Game::setTick(uint32_t tick)
{
    _tick = tick;
}

void Game::createFood()
{
    while (true)
    {
        int32_t x = gGame.getRand() % TILE_MAP_GRID_W;
        int32_t y = gGame.getRand() % TILE_MAP_GRID_H;

        const TileData_t& data = gTileMap.getTileData(x, y);
        if (data.type != TileType::NONE)
            continue;

        gTileMap.setData(x, y, TileType::FOOD, COLOR_FOOD);
        break;
    }
}

```

`src/SnakeRoyal/Game.h`:

```h
#pragma once

#include "Config.h"
#include "Painter.h"

enum class RoundState : uint8_t
{
    IDLE = 1,
    RUNNING,
    RESTARTING,
};

struct RoundData_t
{
    RoundState state = RoundState::IDLE;
    uint32_t timeout = 0;
};

class Game
{
    HWND _hWnd = nullptr;
    uint32_t _tick = 0;
    bool _headless = false;
    bool _hasFocus = true;
    uint32_t _randState = 0;
    RoundData_t _roundData;

public:
    void setHeadless(bool headless);
    bool getHeadless() const;
    void init(HWND hWnd);
    void restart(uint32_t delayInTicks);
    void startRound();
    void update();
    void draw();

    uint32_t getRandState() const;
    void setRandState(uint32_t state);
    uint32_t getRand();

    RoundState getRoundState() const;
    void setRoundState(RoundState state, uint32_t delay = 0);
    RoundData_t& getRoundData();

    uint32_t getClientTime() const;
    uint32_t getHostTime() const;

    void setFocus(bool hasFocus);
    bool hasFocus() const;

    uint32_t getTick() const;
    void setTick(uint32_t tick);

    void createFood();

private:
    void drawInfo(Painter& painter);
};

extern Game gGame;
```

`src/SnakeRoyal/Logging.cpp`:

```cpp
#include "Logging.h"

#include <conio.h>
#include <windows.h>
#include <varargs.h>

Logging gLogging;

Logging::Logging()
{
    AllocConsole();
}

Logging::~Logging()
{
    FreeConsole();
}

void Logging::print(const char* fmt, ...)
{
    va_list vl;
    va_start(vl, fmt);
    _vcprintf(fmt, vl);
    va_end(vl);
}

```

`src/SnakeRoyal/Logging.h`:

```h
#pragma once

class Logging
{
public:
    Logging();
    ~Logging();

    void print(const char* fmt, ...);
};

extern Logging gLogging;

template<typename... Args> inline void logPrint(const char* fmt, Args... args)
{
    gLogging.print(fmt, args...);
}

```

`src/SnakeRoyal/Main.cpp`:

```cpp
#include <iostream>
#include <windows.h>
#include <thread>
#include <vector>
#include "resource.h"

#include "Config.h"
#include "Game.h"
#include "Utils.h"
#include "Logging.h"
#include "Network.h"

// Data
static HWND _hWnd;

// Functions
static LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
static bool ProcessCommandLine(LPTSTR lpCmdLine);
static void Init(HINSTANCE hInstance);
static void Shutdown();
static void GameLoop();

// Main
LRESULT CALLBACK WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_QUIT:
    case WM_DESTROY:
        DestroyWindow(hWnd);
    case WM_CLOSE:
        PostQuitMessage(0);
        break;
    case WM_PAINT:
        gGame.draw();
        break;
    case WM_KILLFOCUS:
        gGame.setFocus(false);
        break;
    case WM_SETFOCUS:
        gGame.setFocus(true);
        break;
    case WM_ERASEBKGND:
        return TRUE;
    default:
        return DefWindowProc(hWnd, uMsg, wParam, lParam);
    }
    return 0;
}

int WINAPI wWinMain(HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPTSTR    lpCmdLine,
    int       nCmdShow)
{
    if (!ProcessCommandLine(lpCmdLine))
    {
        return EXIT_FAILURE;
    }

    Init(hInstance);
    GameLoop();
    Shutdown();

    return EXIT_SUCCESS;
}

static bool ProcessCommandLine(LPTSTR lpCmdLine)
{
    std::vector<std::string> args;

    // Convert.
    {
        int argc;
        LPWSTR* szArgList = CommandLineToArgvW(lpCmdLine, &argc);

        for (int i = 0; i < argc; i++)
        {
            args.push_back(Utils::toMBString(szArgList[i]));
        }

        LocalFree(szArgList);
    }

    // Process
    {
        for (size_t i = 0; i < args.size(); ++i)
        {
            if (args[i] == "host")
            {
                std::string host = NETWORK_DEFAULT_HOST;
                uint16_t port = NETWORK_DEFAULT_PORT;

                int n = 0;
                if (i + 2 < args.size())
                {
                    host = args[i + 2];
                    ++n;
                }
                if (i + 1 < args.size())
                {
                    if (args[i + 1][0] != '-' && args[i + 1][1] != '-')
                    {
                        port = static_cast<uint16_t>(atol(args[i + 1].c_str()));
                        ++n;
                    }
                }

                gNetwork.startServer(host.c_str(), port);
                i += n;
            }
            else if (args[i] == "join")
            {
                if (i + 1 >= args.size())
                {
                    logPrint("ERROR: Invalid parameters: join <address>\n");
                    return false;
                }

                std::string host = args[i + 1];
                uint16_t port = NETWORK_DEFAULT_PORT;

                size_t portPos = host.find_last_of(':');
                if (portPos != host.npos)
                {
                    port = static_cast<uint16_t>(atol(host.c_str() + portPos + 1));
                    host = host.substr(0, portPos);
                }

                gNetwork.startClient(host.c_str(), port);
                ++i;
            }
            else if (args[i] == "--headless")
            {
                gGame.setHeadless(true);
            }
        }
    }

    return true;
}

static void Init(HINSTANCE hInstance)
{
    if (gGame.getHeadless() == false)
    {
        WNDCLASSEX wc{};

        wc.style = CS_HREDRAW | CS_VREDRAW;
        wc.lpszClassName = L"DenuvoGame";
        wc.hInstance = hInstance;
        wc.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);
        wc.lpfnWndProc = WndProc;
        wc.hCursor = LoadCursor(0, IDC_ARROW);
        wc.style = 0;
        wc.cbWndExtra = 0;
        wc.cbClsExtra = 0;
        wc.cbSize = sizeof(WNDCLASSEX);
        wc.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_ICON1));

        RegisterClassEx(&wc);
        _hWnd = CreateWindowW(wc.lpszClassName,
            L"Snake Royal",
            WS_OVERLAPPEDWINDOW | WS_VISIBLE,
            CW_USEDEFAULT,
            CW_USEDEFAULT,
            WINDOW_SIZE_W,
            WINDOW_SIZE_H,
            nullptr,
            nullptr,
            hInstance,
            nullptr);

        gGame.init(_hWnd);
        return;
    }

    gGame.init(nullptr);
}

static void Shutdown()
{
}

static void GameLoop()
{
    MSG msg{};

    double accumulator = 0.0;
    double lastTime = Utils::getTime();

    bool exitLoop = false;

    while (!exitLoop)
    {
        if (gGame.getHeadless() == false)
        {
            if (PeekMessage(&msg, nullptr, 0, 0, PM_REMOVE))
            {
                if (msg.message == WM_QUIT)
                {
                    exitLoop = true;
                    continue;
                }
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }

        double currentTime = Utils::getTime();
        double elapsed = currentTime - lastTime;
        lastTime = currentTime;
        accumulator += elapsed;

        gNetwork.update();

        if (accumulator < GAME_TICK_RATE)
        {
            std::this_thread::yield();
        }
        else
        {
            while (accumulator >= GAME_TICK_RATE)
            {
                gGame.update();
                accumulator -= GAME_TICK_RATE;
            }
        }

        if (gGame.getHeadless() == false)
        {
            // Force redrawing
            RedrawWindow(_hWnd, nullptr, nullptr, RDW_INVALIDATE);
        }

        gNetwork.flush();
    }
}

```

`src/SnakeRoyal/Network.cpp`:

```cpp
#include "Network.h"
#include "NetworkMessage.h"
#include "Logging.h"
#include "Utils.h"
#include "Snakes.h"

Network gNetwork;

Network::Network()
{
    InitializeWSA();
}

Network::~Network()
{
    DisposeWSA();
}

void Network::startServer(const std::string& address, uint16_t port)
{
    logPrint("%s(%s, %u)\n", __FUNCTION__, address.c_str(), port);

    _mode = NetworkMode::SERVER;

    _listenSocket = CreateTcpSocket();
    _listenSocket->Listen(address, port);

    logPrint("Ready for clients...\n");
}

void Network::startClient(const std::string& address, uint16_t port)
{
    logPrint("%s(%s, %u)\n", __FUNCTION__, address.c_str(), port);

    _mode = NetworkMode::CLIENT;

    _serverConnection = std::make_unique<Connection>();
    _serverConnection->sock = CreateTcpSocket();
    _serverConnection->lastStatus = _serverConnection->sock->GetStatus();

    _serverConnection->sock->ConnectAsync(address, port);
}

void Network::update()
{
    if (_mode == NetworkMode::CLIENT)
        updateClient();
    else if (_mode == NetworkMode::SERVER)
        updateServer();

    processQueue();
}

void Network::flush()
{
    if (_mode == NetworkMode::SERVER)
    {
        for (auto& connection : _connections)
        {
            flushConnection(connection);
        }
    }
    else if (_mode == NetworkMode::CLIENT)
    {
        flushConnection(_serverConnection);
    }
}

void Network::processQueue()
{
    for (auto it = _connections.begin(); it != _connections.end();)
    {
        auto& connection = *it;

        if (!processConnection(connection))
        {
            onClientDisconnected(connection);
            it = _connections.erase(it);
        }
        else
        {
            it++;
        }
    }
}

void Network::updateServer()
{
    std::unique_ptr<ITcpSocket> clientSock = _listenSocket->Accept();
    if (clientSock != nullptr)
    {
        auto connection = std::make_unique<Connection>();
        connection->playerId = INVALID_PLAYER_ID;
        connection->sock = std::move(clientSock);

        onClientConnected(connection);

        _connections.push_back(std::move(connection));
    }

    MessageServerTick msgTick;
    msgTick.tick = gGame.getTick();
    sendMessage(msgTick);
}

void Network::updateClient()
{
    SocketStatus currentStatus = _serverConnection->sock->GetStatus();

    // Check current socket state against the last known to print out whats happening.
    if (_serverConnection->lastStatus != currentStatus)
    {
        switch (currentStatus)
        {
            case SocketStatus::CLOSED:
                logPrint("Connection closed\n");
                break;
            case SocketStatus::RESOLVING:
                logPrint("Resolving host...\n");
                break;
            case SocketStatus::CONNECTING:
                logPrint("Connecting...\n");
                break;
            case SocketStatus::CONNECTED:
                onConnected();
                break;
        }
        _serverConnection->lastStatus = currentStatus;
    }

    if (currentStatus != SocketStatus::CONNECTED)
    {
        return;
    }

    if (!processConnection(_serverConnection))
    {
        onDisconnected();
    }

    MessageClientPing msgPing;
    msgPing.timestamp = Utils::getTime();
    sendMessage(msgPing);

    auto itRange = _tickQueue.equal_range(gGame.getTick());
    for (auto it = itRange.first; it != itRange.second;)
    {
        it->second();
        it = _tickQueue.erase(it);
    }
}

void Network::flushConnection(std::unique_ptr<Connection>& connection)
{
    auto& buffer = connection->sendBuffer;
    if (buffer.empty())
        return;

    connection->sock->SendData(buffer.base(), buffer.size());
    buffer.clear();
}

bool Network::processConnection(std::unique_ptr<Connection>& connection)
{
    uint8_t tempBuffer[NETWORK_BUFFER_SIZE]{};
    size_t received = 0;

    auto readStatus = connection->sock->ReceiveData(
        tempBuffer, sizeof(tempBuffer), &received);
    if (readStatus == SocketReadStatus::SUCCESS)
    {
        auto& buffer = connection->recvBuffer;
        buffer.seek(0, BufferSeek::END);
        buffer.write(tempBuffer, received);
    }
    else if (readStatus == SocketReadStatus::DISCONNECTED)
    {
        return false;
    }

    if (!processPackets(connection))
    {
        return false;
    }

    return true;
}

bool Network::processPackets(std::unique_ptr<Connection>& connection)
{
    auto& buffer = connection->recvBuffer;
    buffer.seek(0);

    size_t processed = 0;
    while (!buffer.eob())
    {
        MessageHeader_t header;
        if (buffer.read(header) < sizeof(header))
        {
            break;
        }

        if (header.signature != NETWORK_MESSAGE_SIGNATURE)
        {
            logPrint("Invalid signature!\n");
            return false;
        }

        if (buffer.offset() + header.size > buffer.size())
        {
            // Need more data.
            break;
        }

        switch (header.msg)
        {
            // Server.
            //////////////////////////////////////////////////////////////////////////
            case MessageClientHello::MESSAGE_ID:
                if (!dispatchMessage<MessageClientHello>(
                        buffer, connection, &Network::onClientMessageHello))
                    return false;
                break;
            case MessageClientSnakeDirection::MESSAGE_ID:
                if (!dispatchMessage<MessageClientSnakeDirection>(
                        buffer, connection, &Network::onClientSnakeDirection))
                    return false;
                break;
            case MessageClientPing::MESSAGE_ID:
                if (!dispatchMessage<MessageClientPing>(
                        buffer, connection, &Network::onClientMessagePing))
                    return false;
                break;
            // Client
            //////////////////////////////////////////////////////////////////////////
            case MessageServerTick::MESSAGE_ID:
                if (!dispatchMessage<MessageServerTick>(
                        buffer, _serverConnection,
                        &Network::onServerMessageTick))
                    return false;
                break;
            case MessageServerState::MESSAGE_ID:
                if (!dispatchMessage<MessageServerState>(
                        buffer, _serverConnection,
                        &Network::onServerMessageState))
                    return false;
                break;
            case MessageServerLocalPlayerId::MESSAGE_ID:
                if (!dispatchMessage<MessageServerLocalPlayerId>(
                        buffer, _serverConnection,
                        &Network::onServerMessagePlayerLocalId))
                    return false;
                break;
            case MessageServerPlayerList::MESSAGE_ID:
                if (!dispatchMessage<MessageServerPlayerList>(
                        buffer, _serverConnection,
                        &Network::onServerMessagePlayerList))
                    return false;
                break;
            case MessageServerSnakeList::MESSAGE_ID:
                if (!dispatchMessage<MessageServerSnakeList>(
                        buffer, _serverConnection,
                        &Network::onServerMessageSnakeList))
                    return false;
                break;
            case MessageServerSnakeDirection::MESSAGE_ID:
                if (!dispatchMessage<MessageServerSnakeDirection>(
                        buffer, _serverConnection,
                        &Network::onServerMessageSnakeDirection))
                    return false;
                break;
            case MessageServerRoundRestart::MESSAGE_ID:
                if (!dispatchMessage<MessageServerRoundRestart>(
                        buffer, _serverConnection,
                        &Network::onServerMessageRoundRestart))
                    return false;
                break;
            case MessageServerRoundState::MESSAGE_ID:
                if (!dispatchMessage<MessageServerRoundState>(
                        buffer, _serverConnection,
                        &Network::onServerMessageRoundState))
                    return false;
                break;
            case MessageServerRoundStart::MESSAGE_ID:
                if (!dispatchMessage<MessageServerRoundStart>(
                        buffer, _serverConnection,
                        &Network::onServerMessageRoundStart))
                    return false;
                break;
            case MessageServerPlayerDisconnected::MESSAGE_ID:
                if (!dispatchMessage<MessageServerPlayerDisconnected>(
                        buffer, _serverConnection,
                        &Network::onServerMessagePlayerDisconnected))
                    return false;
                break;
            case MessageServerPong::MESSAGE_ID:
                if (!dispatchMessage<MessageServerPong>(
                        buffer, _serverConnection,
                        &Network::onServerMessagePong))
                    return false;
                break;
            default:
                logPrint("Unhandled network message: %u\n", header.msg);
                assert(false);
                break;
        }

        processed = buffer.offset();
    }

    if (processed > 0)
    {
        buffer.seek(0);
        buffer.erase(processed);
    }

    return true;
}

void Network::onClientConnected(std::unique_ptr<Connection>& connection)
{
    logPrint("Client connected: %s\n", connection->sock->GetHostName());
}

void Network::onClientDisconnected(std::unique_ptr<Connection>& connection)
{
    logPrint("Client disconnected: %s\n", connection->sock->GetHostName());

    PlayerId playerId = connection->playerId;
    if (playerId != INVALID_PLAYER_ID)
    {
        const Player& player = gPlayers.getPlayer(playerId);
        if (player.snakeId != INVALID_SNAKE_ID)
        {
            gSnakes.remove(player.snakeId);
        }
        gPlayers.removePlayer(playerId);

        MessageServerPlayerDisconnected msgDisconnected;
        msgDisconnected.tick = gGame.getTick();
        msgDisconnected.playerId = playerId;
        sendMessage(msgDisconnected);
    }

    if (gPlayers.count() == 0)
    {
        gGame.setRoundState(RoundState::IDLE, 0);
    }
}

void Network::onClientMessageHello(
    std::unique_ptr<Connection>& connection, const MessageClientHello& msg)
{
    bool isFirstPlayer = gPlayers.count() == 0;

    SnakeId newSnakeId = INVALID_SNAKE_ID;

    // Create new player.
    PlayerId newPlayerId = gPlayers.createPlayer(msg.name, newSnakeId);

    // Create new snake.
    if (isFirstPlayer == false && gGame.getRoundState() == RoundState::RUNNING)
    {
        newSnakeId = gSnakes.create(newPlayerId, 0, 0);
        gPlayers.setSnake(newPlayerId, newSnakeId);
    }

    connection->playerId = newPlayerId;

    // Send new player list.
    {
        MessageServerPlayerList msgPlayerList;
        msgPlayerList.tick = gGame.getTick();

        for (PlayerId id = 0; id < MAX_PLAYERS; id++)
        {
            msgPlayerList.players[id] = gPlayers.getPlayer(id);
        }

        sendMessage(msgPlayerList);
    }

    // Send client his local player id.
    {
        MessageServerLocalPlayerId msgPlayerId;
        msgPlayerId.playerId = newPlayerId;

        sendMessage(msgPlayerId, connection);
    }

    // Send current state to client.
    {
        MessageServerState msgServerState;
        msgServerState.randState = gGame.getRandState();
        msgServerState.tick = gGame.getTick();
        msgServerState.tiles = gTileMap.getData();
        msgServerState.roundData = gGame.getRoundData();

        sendMessage(msgServerState, connection);
    }

    // Send all snakes to client.
    {
        MessageServerSnakeList msgServerSnakeList;
        msgServerSnakeList.tick = gGame.getTick();
        msgServerSnakeList.snakes = gSnakes.getSnakes();
        sendMessage(msgServerSnakeList);
    }

    // Restart round, if its already restarting it resets the timeout.
    if (isFirstPlayer || gGame.getRoundState() == RoundState::RESTARTING)
    {
        gGame.restart(GAME_ROUND_RESTART_TICKS);
    }
}

void Network::onClientSnakeDirection(
    std::unique_ptr<Connection>& connection,
    const MessageClientSnakeDirection& msg)
{
    const Player& player = gPlayers.getPlayer(connection->playerId);

    gSnakes.setDirection(player.snakeId, msg.newDirection);

    MessageServerSnakeDirection msgSnakeDir;
    msgSnakeDir.tick = gGame.getTick();
    msgSnakeDir.snakeId = player.snakeId;
    msgSnakeDir.newDirection = msg.newDirection;

    sendMessage(msgSnakeDir);
}

void Network::onClientMessagePing(
    std::unique_ptr<Connection>& connection, const MessageClientPing& msg)
{
    MessageServerPong msgPong;
    msgPong.timestamp = msg.timestamp;
    sendMessage(msgPong, connection);
}

void Network::onConnected()
{
    logPrint("Connected.\n");

    MessageClientHello msg;
    msg.version = NETWORK_VERSION;
    Utils::getUsername(msg.name, sizeof(msg.name));

    sendMessage(msg, _serverConnection);
}

void Network::onDisconnected()
{
    logPrint("Disconnected.\n");

    _mode = NetworkMode::NONE;
    _tickQueue.clear();
    _serverTick = 0;
}

void Network::onServerMessageTick(
    std::unique_ptr<Connection>& serverConnection, const MessageServerTick& msg)
{
    _serverTick = msg.tick;
}

void Network::onServerMessagePlayerLocalId(
    std::unique_ptr<Connection>& serverConnection,
    const MessageServerLocalPlayerId& msg)
{
    gPlayers.setLocalPlayerId(msg.playerId);
}

void Network::onServerMessageSnakeList(
    std::unique_ptr<Connection>& serverConnection,
    const MessageServerSnakeList& msg)
{
    _tickQueue.emplace(msg.tick, [msg]() -> void {
        for (SnakeId id = 0; id < msg.snakes.size(); id++)
        {
            const Snake& newData = msg.snakes[id];

            Snake& curData = gSnakes.getData(id);
            curData = newData;
        }
    });
}

void Network::onServerMessagePlayerList(
    std::unique_ptr<Connection>& serverConnection,
    const MessageServerPlayerList& msg)
{
    _tickQueue.emplace(msg.tick, [msg]() -> void {
        PlayerId id = 0;
        for (auto& playerData : msg.players)
        {
            gPlayers.setPlayerById(id, playerData);
            id++;
        }
    });
}

void Network::onServerMessageState(
    std::unique_ptr<Connection>& serverConnection,
    const MessageServerState& msg)
{
    gTileMap.getData() = msg.tiles;
    gGame.setTick(msg.tick);
    gGame.setRandState(msg.randState);
    gGame.getRoundData() = msg.roundData;
}

void Network::onServerMessageSnakeDirection(
    std::unique_ptr<Connection>& serverConnection,
    const MessageServerSnakeDirection& msg)
{
    _tickQueue.emplace(msg.tick, [msg]() -> void {
        gSnakes.setDirection(msg.snakeId, msg.newDirection);
    });
}

void Network::onServerMessageRoundRestart(
    std::unique_ptr<Connection>& serverConnection,
    const MessageServerRoundRestart& msg)
{
    _tickQueue.emplace(msg.tick, [msg]() -> void { gGame.restart(msg.delay); });
}

void Network::onServerMessageRoundState(
    std::unique_ptr<Connection>& serverConnection,
    const MessageServerRoundState& msg)
{
    _tickQueue.emplace(msg.tick, [msg]() -> void {
        gGame.setRoundState(msg.state, msg.delay);
    });
}

void Network::onServerMessagePlayerDisconnected(
    std::unique_ptr<Connection>& serverConnection,
    const MessageServerPlayerDisconnected& msg)
{
    _tickQueue.emplace(msg.tick, [msg]() -> void {
        PlayerId playerId = msg.playerId;
        if (playerId != INVALID_PLAYER_ID)
        {
            const Player& player = gPlayers.getPlayer(playerId);
            if (player.snakeId != INVALID_SNAKE_ID)
            {
                gSnakes.remove(player.snakeId);
            }
            gPlayers.removePlayer(playerId);
        }
    });
}

void Network::onServerMessageRoundStart(
    std::unique_ptr<Connection>& serverConnection,
    const MessageServerRoundStart& msg)
{
    _tickQueue.emplace(msg.tick, [msg]() -> void { gGame.startRound(); });
}

void Network::onServerMessagePong(
    std::unique_ptr<Connection>& serverConnection, const MessageServerPong& msg)
{
    double currentTime = Utils::getTime();
    double delta = currentTime - msg.timestamp;

    _currentPing = static_cast<uint32_t>(delta * 1000.0);
}

```

`src/SnakeRoyal/Network.h`:

```h
#pragma once

#include "Socket.h"
#include "NetworkMessage.h"
#include "Game.h"
#include "Buffer.h"

#include <map>
#include <functional>

enum class NetworkMode
{
    NONE = 0,
    CLIENT,
    SERVER,
};

static constexpr const char* NETWORK_DEFAULT_HOST = "0.0.0.0";
static constexpr uint16_t NETWORK_DEFAULT_PORT = 11754;
static constexpr size_t NETWORK_BUFFER_SIZE = 1024 * 64;

struct Connection
{
    std::unique_ptr<ITcpSocket> sock;
    SocketStatus lastStatus = SocketStatus::CLOSED;
    PlayerId playerId = INVALID_PLAYER_ID;
    Buffer recvBuffer;
    Buffer sendBuffer;
};

class Network
{
    NetworkMode _mode = NetworkMode::NONE;

private:     // Server specific data.
    std::unique_ptr<ITcpSocket> _listenSocket;
    std::vector<std::unique_ptr<Connection>> _connections;

private:     // Client specific data.
    std::unique_ptr<ITcpSocket> _clientSocket;
    std::unique_ptr<Connection> _serverConnection;

    // Last server known server tick, as a client we can not run beyond that.
    uint32_t _serverTick = 0;

    // Last measured client ping.
    uint32_t _currentPing = 0;

    // This is used as a queue where events have to be executed at a 
    // specific tick. The order of events is same order as packets
    // arrive which is on TCP always ordered per tick.
    std::multimap<uint32_t, std::function<void()>> _tickQueue;

public:
    Network();
    ~Network();

    void startServer(
        const std::string& address, uint16_t port = NETWORK_DEFAULT_PORT);
    void startClient(
        const std::string& address, uint16_t port = NETWORK_DEFAULT_PORT);
    void update();
    void flush();

    uint32_t getCurrentPing() const
    {
        return _currentPing;
    }

    NetworkMode getMode() const
    {
        return _mode;
    }

    uint32_t getServerTick() const
    {
        return _serverTick;
    }

    // Send message to specified connection.
    template<typename T>
    void sendMessage(const T& message, std::unique_ptr<Connection>& connection)
    {
        Buffer messageBuffer;
        message.serialize(messageBuffer);

        MessageHeader_t header;
        header.signature = NETWORK_MESSAGE_SIGNATURE;
        header.size = messageBuffer.size();
        header.msg = static_cast<NetworkMessage>(T::MESSAGE_ID);

        auto& buffer = connection->sendBuffer;
        header.serialize(buffer);
        buffer.write(messageBuffer);
    }

    // Broadcast a message.
    template<typename T> void sendMessage(const T& message)
    {
        if (getMode() == NetworkMode::CLIENT)
        {
            sendMessage(message, _serverConnection);
        }
        else
        {
            for (auto& connection : _connections)
            {
                sendMessage(message, connection);
            }
        }
    }

    template<typename T, typename F>
    bool dispatchMessage(
        Buffer& buffer, std::unique_ptr<Connection>& connection, F fn)
    {
        T msg;
        if (!msg.deserialize(buffer))
        {
            assert(false);
            return false;
        }
        (this->*fn)(connection, msg);
        return true;
    }

    void processQueue();

private: // Common
    void updateServer();
    void updateClient();
    void flushConnection(std::unique_ptr<Connection>& connection);
    bool processConnection(std::unique_ptr<Connection>& connection);
    bool processPackets(std::unique_ptr<Connection>& connection);

private: // Server events
    void onClientConnected(std::unique_ptr<Connection>& clientConnection);
    void onClientDisconnected(std::unique_ptr<Connection>& clientConnection);

private: // Server message dispatchers.
    void onClientMessageHello(
        std::unique_ptr<Connection>& clientConnection,
        const MessageClientHello& msg);
    void onClientSnakeDirection(
        std::unique_ptr<Connection>& clientConnection,
        const MessageClientSnakeDirection& msg);
    void onClientMessagePing(
        std::unique_ptr<Connection>& connection, const MessageClientPing& msg);

private: // Client events.
    void onConnected();
    void onDisconnected();

private: // Client message dispatchers.
    void onServerMessageTick(
        std::unique_ptr<Connection>& serverConnection,
        const MessageServerTick& msg);
    void onServerMessagePlayerLocalId(
        std::unique_ptr<Connection>& serverConnection,
        const MessageServerLocalPlayerId& msg);
    void onServerMessageSnakeList(
        std::unique_ptr<Connection>& serverConnection,
        const MessageServerSnakeList& msg);
    void onServerMessagePlayerList(
        std::unique_ptr<Connection>& serverConnection,
        const MessageServerPlayerList& msg);
    void onServerMessageState(
        std::unique_ptr<Connection>& serverConnection,
        const MessageServerState& msg);
    void onServerMessageSnakeDirection(
        std::unique_ptr<Connection>& serverConnection,
        const MessageServerSnakeDirection& msg);
    void onServerMessageRoundRestart(
        std::unique_ptr<Connection>& serverConnection,
        const MessageServerRoundRestart& msg);
    void onServerMessageRoundState(
        std::unique_ptr<Connection>& serverConnection,
        const MessageServerRoundState& msg);
    void onServerMessagePlayerDisconnected(
        std::unique_ptr<Connection>& serverConnection,
        const MessageServerPlayerDisconnected& msg);
    void onServerMessageRoundStart(
        std::unique_ptr<Connection>& serverConnection,
        const MessageServerRoundStart& msg);
    void onServerMessagePong(
        std::unique_ptr<Connection>& serverConnection,
        const MessageServerPong& msg);
};

extern Network gNetwork;

```

`src/SnakeRoyal/NetworkMessage.h`:

```h
#pragma once

#include "Types.h"
#include "Buffer.h"
#include "Serialization.h"
#include "TileMap.h"
#include "Players.h"
#include "Game.h"
#include "Snake.h"

enum NetworkMessage : uint16_t
{
    BASE = 0,

    CLIENT_HELLO,
    CLIENT_SNAKE_DIRECTION,
    CLIENT_PING,

    SERVER_PONG,
    SERVER_PLAYER_LIST,
    SERVER_PLAYER_DISCONNECTED,
    SERVER_LOCAL_PLAYER_ID,
    SERVER_STATE,
    SERVER_TICK,
    SERVER_SNAKE_LIST,
    SERVER_SNAKE_DIRECTION,
    SERVER_ROUND_STATE,
    SERVER_ROUND_RESTART,
    SERVER_ROUND_START,
    SERVER_ASSIGN_SNAKE,
};

static constexpr uint32_t NETWORK_MESSAGE_SIGNATURE = 0xDEADBEEF;
static constexpr uint32_t NETWORK_VERSION = 1;

template<typename T, NetworkMessage MSG = NetworkMessage::BASE>
struct MessageBasePOD
{
    enum
    {
        MESSAGE_ID = MSG
    };

    bool serialize(Buffer& buffer) const
    {
        return buffer.write(reinterpret_cast<const T&>(*this)) == sizeof(T);
    }

    bool deserialize(Buffer& buffer)
    {
        return buffer.read(reinterpret_cast<T&>(*this)) == sizeof(T);
    }
};

template<typename T, NetworkMessage MSG = NetworkMessage::BASE>
struct MessageBaseComplex
{
    enum
    {
        MESSAGE_ID = MSG
    };

    template<typename T>
    bool serializeField(Buffer& buffer, const T& data) const
    {
        return Serializer<T>::serialize(buffer, data);
    }

    template<typename T> bool deserializeField(Buffer& buffer, T& data)
    {
        return Serializer<T>::deserialize(buffer, data);
    }
};

struct MessageHeader_t : MessageBasePOD<MessageHeader_t>
{
    uint32_t signature;
    uint32_t size;
    NetworkMessage msg;
};

struct MessageClientHello
    : MessageBasePOD<MessageClientHello, NetworkMessage::CLIENT_HELLO>
{
    uint32_t version;
    char name[128];
};

struct MessageServerTick
    : MessageBasePOD<MessageServerTick, NetworkMessage::SERVER_TICK>
{
    uint32_t tick;
};

struct MessageServerPlayerList : MessageBasePOD<
                                     MessageServerPlayerList,
                                     NetworkMessage::SERVER_PLAYER_LIST>
{
    uint32_t tick;
    std::array<Player, MAX_PLAYERS> players;
};

struct MessageServerLocalPlayerId : MessageBasePOD<
                                        MessageServerLocalPlayerId,
                                        NetworkMessage::SERVER_LOCAL_PLAYER_ID>
{
    PlayerId playerId;
};

struct MessageServerState
    : MessageBasePOD<MessageServerState, NetworkMessage::SERVER_STATE>
{
    uint32_t tick;
    uint32_t randState;
    RoundData_t roundData;
    uint32_t timeout;
    std::array<TileData_t, TILE_MAP_SIZE> tiles;
};

struct MessageServerSnakeList : MessageBaseComplex<
                                    MessageServerSnakeList,
                                    NetworkMessage::SERVER_SNAKE_LIST>
{
    uint32_t tick;
    std::array<Snake, MAX_PLAYERS> snakes;

    bool serialize(Buffer& buffer) const
    {
        serializeField(buffer, tick);

        uint16_t snakeCount = static_cast<uint16_t>(snakes.size());
        serializeField(buffer, snakeCount);
        for (uint16_t i = 0; i < snakeCount; i++)
        {
            const Snake& snake = snakes[i];
            const SnakeBase& baseData = reinterpret_cast<const SnakeBase&>(
                snake);

            buffer.write(baseData);

            uint16_t tailCount = static_cast<uint16_t>(snake.pieces.size());
            serializeField(buffer, tailCount);

            for (uint16_t y = 0; y < tailCount; y++)
            {
                buffer.write(snake.pieces[y]);
            }
        }
        return true;
    }

    bool deserialize(Buffer& buffer)
    {
        buffer.read(tick);

        uint16_t snakeCount = 0;
        deserializeField(buffer, snakeCount);
        for (uint16_t i = 0; i < snakeCount; i++)
        {
            Snake& snake = snakes[i];
            SnakeBase& baseData = reinterpret_cast<SnakeBase&>(snake);

            buffer.read(baseData);

            uint16_t tailCount = 0;
            deserializeField(buffer, tailCount);

            snake.pieces.resize(tailCount);
            for (uint16_t y = 0; y < tailCount; y++)
            {
                buffer.read(snake.pieces[y]);
            }
        }
        return true;
    }
};

struct MessageClientSnakeDirection : MessageBasePOD<
                                         MessageClientSnakeDirection,
                                         NetworkMessage::CLIENT_SNAKE_DIRECTION>
{
    Vector2i newDirection;
};

struct MessageServerSnakeDirection : MessageBasePOD<
                                         MessageServerSnakeDirection,
                                         NetworkMessage::SERVER_SNAKE_DIRECTION>
{
    uint32_t tick;
    SnakeId snakeId;
    Vector2i newDirection;
};

struct MessageServerRoundState : MessageBasePOD<
                                     MessageServerRoundState,
                                     NetworkMessage::SERVER_ROUND_STATE>
{
    uint32_t tick;
    RoundState state;
    uint32_t delay;
};

struct MessageServerRoundRestart : MessageBasePOD<
                                       MessageServerRoundRestart,
                                       NetworkMessage::SERVER_ROUND_RESTART>
{
    uint32_t tick;
    uint32_t delay;
};

struct MessageServerRoundStart : MessageBasePOD<
                                     MessageServerRoundStart,
                                     NetworkMessage::SERVER_ROUND_START>
{
    uint32_t tick;
};

struct MessageServerPlayerDisconnected
    : MessageBasePOD<
          MessageServerPlayerDisconnected,
          NetworkMessage::SERVER_PLAYER_DISCONNECTED>
{
    uint32_t tick;
    PlayerId playerId;
};

struct MessageClientPing
    : MessageBasePOD<MessageClientPing, NetworkMessage::CLIENT_PING>
{
    double timestamp;
};

struct MessageServerPong
    : MessageBasePOD<MessageServerPong, NetworkMessage::SERVER_PONG>
{
    double timestamp;
};
```

`src/SnakeRoyal/NetworkPlay.cpp`:

```cpp
#include "NetworkPlay.h"

```

`src/SnakeRoyal/Painter.cpp`:

```cpp
#include "Painter.h"
#include <windows.h>

Painter::Painter(HWND hwnd, RECT rect)
    : _hWnd(hwnd)
    , _rect(rect)
    , _brush(nullptr)
    , _brushColor{ 0, 0, 0 }
    , _pen(nullptr)
    , _penColor{ 255, 255, 255 }
    , _hFont(nullptr)
{
    _hdc = BeginPaint(_hWnd, &_ps);
    _hdcMem = CreateCompatibleDC(_ps.hdc);
    _hbmMem = CreateCompatibleBitmap(
        _ps.hdc, _rect.right - rect.left, _rect.bottom - _rect.top);

    _hbmOld = (HBITMAP)SelectObject(_hdcMem, _hbmMem);
}

Painter::~Painter()
{
    BitBlt(
        _ps.hdc, _rect.left, _rect.top, _rect.right - _rect.left,
        _rect.bottom - _rect.top, _hdcMem, 0, 0, SRCCOPY);

    SelectObject(_hdcMem, _hbmOld);

    if (_brush != nullptr)
        DeleteObject(_brush);

    if (_pen != nullptr)
        DeleteObject(_pen);

    if (_hbmMem)
        DeleteObject(_hbmMem);

    if (_hdcMem)
        DeleteDC(_hdcMem);

    if (_hFont)
        DeleteObject(_hFont);

    EndPaint(_hWnd, &_ps);
}

void Painter::setFont(const char* fontName, int weight)
{
    if (_hFont != nullptr)
        DeleteObject(_hFont);

    _hFont = CreateFontA(
        weight, 0, 0, 0, FW_DONTCARE, FALSE, FALSE, FALSE, DEFAULT_CHARSET,
        OUT_OUTLINE_PRECIS, CLIP_DEFAULT_PRECIS, CLEARTYPE_QUALITY,
        VARIABLE_PITCH, fontName);
}

void Painter::setBgColor(Color color)
{
    if (_brush != nullptr && color == _brushColor)
        return;

    if (_brush != nullptr)
    {
        DeleteObject(_brush);
    }

    _brush = CreateSolidBrush(color.getColorRef());
    _brushColor = color;
}

void Painter::setColor(Color color)
{
    if (_pen != nullptr && color == _penColor)
        return;

    if (_brush != nullptr)
    {
        DeleteObject(_brush);
    }

    _pen = CreatePen(PS_SOLID, 0, color.getColorRef());
    _penColor = color;
}

void Painter::clear(Color color)
{
    setBgColor(color);
    FillRect(_hdcMem, &_rect, _brush);
}

void Painter::rect(int32_t x, int32_t y, int32_t w, int32_t h, Color color)
{
    setBgColor(color);
    RECT rc{ x, y, x + w, y + h };
    FrameRect(_hdcMem, &rc, _brush);
}

void Painter::filledRect(
    int32_t x, int32_t y, int32_t w, int32_t h, Color color)
{
    setBgColor(color);

    RECT rc;
    rc.left = x;
    rc.top = y;
    rc.right = x + w;
    rc.bottom = y + h;

    FillRect(_hdcMem, &rc, _brush);
}

void Painter::filledEllipse(
    int32_t x, int32_t y, int32_t w, int32_t h, Color color)
{
    setBgColor(color);
    SelectObject(_hdcMem, _brush);
    Ellipse(_hdcMem, x, y, x + w, y + h);
}

void Painter::text(const std::string& txt, int32_t x, int32_t y, Color color)
{
    setFont("Terminal", 12);
    SelectObject(_hdcMem, _hFont);
    SetBkColor(_hdcMem, RGB(0, 0, 0));
    SetTextColor(_hdcMem, color.getColorRef());

    RECT rc;
    rc.left = x;
    rc.top = y;
    rc.right = x;
    rc.bottom = y;

    DrawTextA(_hdcMem, txt.c_str(), -1, &rc, DT_LEFT | DT_NOPREFIX | DT_NOCLIP);
}

void Painter::textCentered(
    const std::string& txt,
    int32_t x,
    int32_t y,
    int32_t w,
    int32_t h,
    Color color)
{
    setFont("Terminal", 12);
    SelectObject(_hdcMem, _hFont);
    SetBkColor(_hdcMem, COLOR_BG.getColorRef());
    SetTextColor(_hdcMem, color.getColorRef());

    RECT rc;
    rc.left = x;
    rc.top = y;
    rc.right = x + w;
    rc.bottom = y + h;

    DrawTextA(_hdcMem, txt.c_str(), -1, &rc, DT_CENTER | DT_NOPREFIX);
}

void Painter::textRight(
    const std::string& txt,
    int32_t x,
    int32_t y,
    int32_t w,
    int32_t h,
    Color color)
{
    setFont("Terminal", 12);
    SelectObject(_hdcMem, _hFont);
    SetBkColor(_hdcMem, COLOR_BG.getColorRef());
    SetTextColor(_hdcMem, color.getColorRef());

    RECT rc;
    rc.left = x;
    rc.top = y;
    rc.right = x + w;
    rc.bottom = y + h;

    DrawTextA(_hdcMem, txt.c_str(), -1, &rc, DT_RIGHT | DT_NOPREFIX);
}
```

`src/SnakeRoyal/Painter.h`:

```h
#pragma once

#include <stdint.h>
#include <windows.h>

#include "Color.h"

class Painter
{
    HWND _hWnd;
    PAINTSTRUCT _ps;
    HDC _hdc;
    HDC _hdcMem;
    HBITMAP _hbmMem;
    HBITMAP _hbmOld;
    HFONT _hFont;
    RECT _rect;
    HBRUSH _brush;
    Color _brushColor;
    HPEN _pen;
    Color _penColor;

public:
    Painter(HWND hWnd, RECT rect);
    ~Painter();

    void setFont(const char* fontName, int weight);
    void setBgColor(Color color);
    void setColor(Color color);

    void clear(Color color);
    void rect(int32_t x, int32_t y, int32_t w, int32_t h, Color color);
    void filledRect(int32_t x, int32_t y, int32_t w, int32_t h, Color color);
    void filledEllipse(int32_t x, int32_t y, int32_t w, int32_t h, Color color);
    void text(
        const std::string& txt,
        int32_t x,
        int32_t y,
        Color color = COLOR_WHITE);
    void textCentered(
        const std::string& txt,
        int32_t x,
        int32_t y,
        int32_t w,
        int32_t h,
        Color color = COLOR_WHITE);
    void textRight(
        const std::string& txt,
        int32_t x,
        int32_t y,
        int32_t w,
        int32_t h,
        Color color);
};
```

`src/SnakeRoyal/Player.h`:

```h
#pragma once

#include <stdint.h>
#include <array>
#include <limits>

#include "Config.h"
#include "Types.h"

enum class Buttons : uint32_t
{
    NONE = 0,
    UP = (1 << 0),
    DOWN = (1 << 1),
    LEFT = (1 << 2),
    RIGHT = (1 << 3),
};

struct PlayerData
{
    PlayerId id = INVALID_PLAYER_ID;
    SnakeId snakeId = INVALID_SNAKE_ID;
    Color color = COLOR_BLACK;
};

struct Player : PlayerData
{
    uint32_t pressed = 0;
    char name[128] = {};

    bool isButtonPressed(Buttons button) const
    {
        return (pressed & static_cast<uint32_t>(button)) != 0;
    }
};
```

`src/SnakeRoyal/Players.cpp`:

```cpp
#include <windows.h>
#include <assert.h>

#include "Players.h"
#include "Snakes.h"
#include "Network.h"

Players gPlayers;

PlayerId Players::createLocalPlayer(const char* name, SnakeId snakeId)
{
    PlayerId id = createPlayer(name, snakeId);
    _localId = id;
    return id;
}

PlayerId Players::createPlayer(const char* name, SnakeId snakeId)
{
    PlayerId res = INVALID_PLAYER_ID;

    for (PlayerId id = 0; id < _players.size(); id++)
    {
        Player& player = _players[id];
        if (player.id == INVALID_PLAYER_ID)
        {
            player.id = id;
            player.snakeId = snakeId;
            player.color = COLOR_PLAYER_PALETTE[id];
            strcpy_s(player.name, name);

            res = id;
            break;
        }
    }

    return res;
}

bool Players::removePlayer(PlayerId playerId)
{
    assert(playerId != INVALID_PLAYER_ID);
    if (playerId == INVALID_PLAYER_ID)
        return false;

    Player& player = _players[playerId];
    if (player.id == INVALID_PLAYER_ID)
        return false;

    player.id = INVALID_PLAYER_ID;
    player.snakeId = INVALID_SNAKE_ID;
    player.name[0] = '\0';

    if (_localId == playerId)
        _localId = INVALID_PLAYER_ID;

    return true;
}

void Players::setPlayerById(PlayerId playerId, const Player& data)
{
    _players[playerId] = data;
}

void Players::setLocalPlayerId(PlayerId playerId)
{
    _localId = playerId;
}

void Players::setSnake(PlayerId playerId, SnakeId snakeId)
{
    assert(isValidPlayer(playerId) == true);
    _players[playerId].snakeId = snakeId;
}

uint32_t Players::getScore(PlayerId playerId) const
{
    if (!isValidPlayer(playerId))
        return 0;

    const Player& player = getPlayer(playerId);
    if (player.snakeId == INVALID_SNAKE_ID)
        return 0;

    const Snake& snake = gSnakes.getData(player.snakeId);
    if (snake.pieces.empty())
        return 0;

    uint32_t score = static_cast<uint32_t>(snake.pieces.size());

    // Magical score!
    return (score * score);
}

Color Players::getColor(PlayerId playerId) const
{
    assert(isValidPlayer(playerId) == true);
    return _players[playerId].color;
}

void Players::update()
{
    if (_localId == INVALID_PLAYER_ID)
        return;

    Player& player = _players[_localId];
    if (player.snakeId == INVALID_SNAKE_ID)
        return;

    player.pressed = 0;

    // TODO: Refactor this part, it should be picked up by the window messages.
    if (gGame.hasFocus())
    {
        if ((GetAsyncKeyState('W') & 0x8000) != 0)
            player.pressed |= static_cast<uint32_t>(Buttons::UP);
        if ((GetAsyncKeyState('A') & 0x8000) != 0)
            player.pressed |= static_cast<uint32_t>(Buttons::LEFT);
        if ((GetAsyncKeyState('S') & 0x8000) != 0)
            player.pressed |= static_cast<uint32_t>(Buttons::DOWN);
        if ((GetAsyncKeyState('D') & 0x8000) != 0)
            player.pressed |= static_cast<uint32_t>(Buttons::RIGHT);
    }

    Vector2i curDirection = gSnakes.getDirection(player.snakeId);
    Vector2i newDirection = curDirection;

    if (curDirection == DIR_UP || curDirection == DIR_DOWN)
    {
        if (player.isButtonPressed(Buttons::LEFT))
            newDirection = DIR_LEFT;
        else if (player.isButtonPressed(Buttons::RIGHT))
            newDirection = DIR_RIGHT;
    }
    else if (curDirection == DIR_RIGHT || curDirection == DIR_LEFT)
    {
        if (player.isButtonPressed(Buttons::UP))
            newDirection = DIR_UP;
        else if (player.isButtonPressed(Buttons::DOWN))
            newDirection = DIR_DOWN;
    }
    else if (curDirection == DIR_NONE)
    {
        if (player.isButtonPressed(Buttons::UP))
            newDirection = DIR_UP;
        else if (player.isButtonPressed(Buttons::DOWN))
            newDirection = DIR_DOWN;
        else if (player.isButtonPressed(Buttons::LEFT))
            newDirection = DIR_LEFT;
        else if (player.isButtonPressed(Buttons::RIGHT))
            newDirection = DIR_RIGHT;
    }

    if (newDirection != curDirection)
    {
        if (gNetwork.getMode() == NetworkMode::CLIENT)
        {
            MessageClientSnakeDirection msgSnakeDir;
            msgSnakeDir.newDirection = newDirection;

            gNetwork.sendMessage(msgSnakeDir);
        }
        else
        {
            gSnakes.setDirection(player.snakeId, newDirection);
        }
    }
}

void Players::draw(Painter& painter) const
{
    painter.rect(
        PLAYER_LIST_X, PLAYER_LIST_Y, PLAYER_LIST_W, PLAYER_LIST_H,
        { 0, 255, 0 });
    painter.textCentered(
        "  Players  ", PLAYER_LIST_X, PLAYER_LIST_Y - 8, PLAYER_LIST_W, 20);

    std::vector<Player> players(_players.begin(), _players.end());

    auto getSortValue = [this](const Player& player) -> int32_t {
        if (player.id == INVALID_PLAYER_ID)
            return -2;
        if (player.snakeId == INVALID_SNAKE_ID)
            return -1;
        if (gSnakes.getData(player.snakeId).state == SnakeState::DEAD)
            return -1;
        return getScore(player.id);
    };

    std::sort(
        players.begin(), players.end(),
        [&getSortValue](const Player& a, const Player& b) -> bool {
            return getSortValue(a) > getSortValue(b);
        });

    int32_t offsetY = PLAYER_LIST_Y + 20;
    for (auto& player : players)
    {
        if (player.id == INVALID_PLAYER_ID)
            break;

        painter.filledRect(
            PLAYER_LIST_X + 10, offsetY, TILE_SIZE_W, TILE_SIZE_H,
            player.color);

        Color textColor = COLOR_GREEN;
        if (player.snakeId == INVALID_SNAKE_ID
            || gSnakes.getData(player.snakeId).state == SnakeState::DEAD)
        {
            textColor = COLOR_RED;
        }

        std::string score = std::to_string(getScore(player.id));
        painter.textRight(
            score, PLAYER_LIST_X + 10, offsetY, PLAYER_LIST_W - 20, 20,
            textColor);

        painter.text(
            player.name, PLAYER_LIST_X + 10 + TILE_SIZE_W + 10, offsetY,
            textColor);

        offsetY = offsetY + 20;
    }
}

bool Players::isValidPlayer(PlayerId playerId) const
{
    if (playerId >= MAX_PLAYERS || _players[playerId].id == INVALID_PLAYER_ID)
        return false;

    return true;
}

const Player& Players::getLocalPlayer() const
{
    assert(_localId != INVALID_PLAYER_ID);
    return _players[_localId];
}

const Player& Players::getPlayer(PlayerId playerId) const
{
    return _players[playerId];
}

const size_t Players::count() const
{
    size_t res = 0;
    for (auto& player : _players)
    {
        if (player.id != INVALID_PLAYER_ID)
            res++;
    }
    return res;
}

```

`src/SnakeRoyal/Players.h`:

```h
#pragma once

#include "Types.h"

#include "Config.h"
#include "Player.h"

class Painter;

class Players
{
    std::array<Player, MAX_PLAYERS> _players;
    PlayerId _localId = INVALID_PLAYER_ID;

public:
    PlayerId createLocalPlayer(const char* name, SnakeId snakeId);
    PlayerId createPlayer(const char* name, SnakeId snakeId);
    bool removePlayer(PlayerId playerId);
    void setPlayerById(PlayerId playerId, const Player& data);
    void setLocalPlayerId(PlayerId playerId);
    void setSnake(PlayerId playerId, SnakeId snakeId);
    uint32_t getScore(PlayerId playerId) const;
    Color getColor(PlayerId playerId) const;

    void update();
    void draw(Painter& painter) const;

    bool isValidPlayer(PlayerId) const;
    const Player& getLocalPlayer() const;
    const Player& getPlayer(PlayerId playerId) const;

    const size_t count() const;
};

extern Players gPlayers;
```

`src/SnakeRoyal/Serialization.h`:

```h
#pragma once

#include "Buffer.h"

#include <array>
#include <vector>

template<typename T> struct Serializer;

template<typename T> struct SerializerInteger
{
    static bool serialize(Buffer& buffer, const T& data)
    {
        return buffer.write(data);
    }
    static bool deserialize(Buffer& buffer, T& data)
    {
        return buffer.read(data);
    }
};

template<> struct Serializer<uint8_t> : SerializerInteger<uint8_t>
{
};

template<> struct Serializer<uint16_t> : SerializerInteger<uint16_t>
{
};

template<> struct Serializer<uint32_t> : SerializerInteger<uint32_t>
{
};

template<> struct Serializer<uint64_t> : SerializerInteger<uint64_t>
{
};

template<typename T> struct Serializer<std::vector<T>>
{
    static bool serialize(Buffer& buffer, const std::vector<T>& data)
    {
        uint32_t len = static_cast<uint32_t>(data.size());
        if (!Serializer<uint32_t>::serialize(buffer, len))
            return false;
        if (!data.empty())
        {
            const size_t dataSize = len * sizeof(T);
            if (buffer.write(data.data(), dataSize) != dataSize)
                return false;
        }
        return true;
    }
    static bool deserialize(Buffer& buffer, std::vector<T>& data)
    {
        uint32_t len = 0;
        if (!Serializer<uint32_t>::deserialize(buffer, len))
            return false;
        data.resize(len);
        if (len > 0)
        {
            const size_t dataSize = len * sizeof(T);
            if (buffer.read(data.data(), dataSize) != dataSize)
                return false;
        }
        return true;
    }
};

template<typename T, size_t N> struct Serializer<std::array<T, N>>
{
    static bool serialize(Buffer& buffer, const std::array<T, N>& data)
    {
        uint32_t len = static_cast<uint32_t>(data.size());
        if (!Serializer<uint32_t>::serialize(buffer, len))
            return false;
        const size_t dataSize = len * sizeof(T);
        if (buffer.write(data.data(), dataSize) != dataSize)
            return false;
        return true;
    }
    static bool deserialize(Buffer& buffer, std::array<T, N>& data)
    {
        uint32_t len = 0;
        if (!Serializer<uint32_t>::deserialize(buffer, len))
            return false;
        if (len != data.size())
            return false;
        const size_t dataSize = len * sizeof(T);
        if (buffer.read(data.data(), dataSize) != dataSize)
            return false;
        return true;
    }
};
```

`src/SnakeRoyal/Snake.h`:

```h
#pragma once

#include "Types.h"

enum class SnakeState : uint8_t
{
    IDLE = 0,
    ALIVE,
    DEAD,
};

struct SnakeBase
{
    SnakeState state = SnakeState::IDLE;
    SnakeId id = INVALID_SNAKE_ID;
    Vector2i direction;
    PlayerId playerId;
};

struct Snake : SnakeBase
{
    std::vector<Vector2i> pieces;
};
```

`src/SnakeRoyal/SnakeRoyal.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// Neutral resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_NEU)
LANGUAGE LANG_NEUTRAL, SUBLANG_NEUTRAL

/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_ICON1               ICON                    "..\\Resources\\snake.ico"

#endif    // Neutral resources
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`src/SnakeRoyal/SnakeRoyal.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{15B83893-63BA-44C8-BCB6-635F1EAA75A5}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>SnakeRoyal</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>SnakeRoyal</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;NOMINMAX;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;NOMINMAX;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;NOMINMAX;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <AssemblerOutput>AssemblyAndMachineCode</AssemblerOutput>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;NOMINMAX;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Game.cpp" />
    <ClCompile Include="Logging.cpp" />
    <ClCompile Include="Main.cpp" />
    <ClCompile Include="Network.cpp" />
    <ClCompile Include="Painter.cpp" />
    <ClCompile Include="Players.cpp" />
    <ClCompile Include="Snakes.cpp" />
    <ClCompile Include="Socket.cpp" />
    <ClCompile Include="TileMap.cpp" />
    <ClCompile Include="Utils.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Buffer.h" />
    <ClInclude Include="Color.h" />
    <ClInclude Include="Config.h" />
    <ClInclude Include="Game.h" />
    <ClInclude Include="Logging.h" />
    <ClInclude Include="Network.h" />
    <ClInclude Include="NetworkMessage.h" />
    <ClInclude Include="Painter.h" />
    <ClInclude Include="Player.h" />
    <ClInclude Include="Players.h" />
    <ClInclude Include="resource.h" />
    <ClInclude Include="Serialization.h" />
    <ClInclude Include="Snake.h" />
    <ClInclude Include="Snakes.h" />
    <ClInclude Include="Socket.h" />
    <ClInclude Include="TileMap.h" />
    <ClInclude Include="Types.h" />
    <ClInclude Include="Utils.h" />
    <ClInclude Include="Vector2.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="SnakeRoyal.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`src/SnakeRoyal/SnakeRoyal.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="Main.cpp" />
    <ClCompile Include="Game.cpp">
      <Filter>Game</Filter>
    </ClCompile>
    <ClCompile Include="Painter.cpp">
      <Filter>Game</Filter>
    </ClCompile>
    <ClCompile Include="Players.cpp">
      <Filter>Game</Filter>
    </ClCompile>
    <ClCompile Include="Snakes.cpp">
      <Filter>Game</Filter>
    </ClCompile>
    <ClCompile Include="TileMap.cpp">
      <Filter>Game</Filter>
    </ClCompile>
    <ClCompile Include="Network.cpp">
      <Filter>Game</Filter>
    </ClCompile>
    <ClCompile Include="Socket.cpp">
      <Filter>Game</Filter>
    </ClCompile>
    <ClCompile Include="Logging.cpp">
      <Filter>Game</Filter>
    </ClCompile>
    <ClCompile Include="Utils.cpp">
      <Filter>Game</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Vector2.h">
      <Filter>Game</Filter>
    </ClInclude>
    <ClInclude Include="Color.h">
      <Filter>Game</Filter>
    </ClInclude>
    <ClInclude Include="Config.h">
      <Filter>Game</Filter>
    </ClInclude>
    <ClInclude Include="Painter.h">
      <Filter>Game</Filter>
    </ClInclude>
    <ClInclude Include="Players.h">
      <Filter>Game</Filter>
    </ClInclude>
    <ClInclude Include="Snakes.h">
      <Filter>Game</Filter>
    </ClInclude>
    <ClInclude Include="TileMap.h">
      <Filter>Game</Filter>
    </ClInclude>
    <ClInclude Include="Utils.h">
      <Filter>Game</Filter>
    </ClInclude>
    <ClInclude Include="Game.h">
      <Filter>Game</Filter>
    </ClInclude>
    <ClInclude Include="Network.h">
      <Filter>Game</Filter>
    </ClInclude>
    <ClInclude Include="Socket.h">
      <Filter>Game</Filter>
    </ClInclude>
    <ClInclude Include="NetworkMessage.h">
      <Filter>Game</Filter>
    </ClInclude>
    <ClInclude Include="Logging.h">
      <Filter>Game</Filter>
    </ClInclude>
    <ClInclude Include="Buffer.h">
      <Filter>Game</Filter>
    </ClInclude>
    <ClInclude Include="Serialization.h">
      <Filter>Game</Filter>
    </ClInclude>
    <ClInclude Include="resource.h">
      <Filter>Resource</Filter>
    </ClInclude>
    <ClInclude Include="Player.h">
      <Filter>Game</Filter>
    </ClInclude>
    <ClInclude Include="Snake.h">
      <Filter>Game</Filter>
    </ClInclude>
    <ClInclude Include="Types.h">
      <Filter>Game</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <Filter Include="Game">
      <UniqueIdentifier>{8c159749-4873-4fbe-a763-65ed7b2a2e3a}</UniqueIdentifier>
    </Filter>
    <Filter Include="Resource">
      <UniqueIdentifier>{b3332e8d-1a94-40ac-8fe8-97988b5cfa52}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="SnakeRoyal.rc">
      <Filter>Resource</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>
```

`src/SnakeRoyal/Snakes.cpp`:

```cpp
#include <array>
#include "Snakes.h"
#include "TileMap.h"
#include "Utils.h"
#include "Network.h"
#include "Players.h"

Snakes gSnakes;

static constexpr Color COLOR_DEAD = COLOR_GREY;

static void moveSnakePiece(
    Snake& snake, size_t i, Vector2i newPos, TileType type, Color color)
{
    const Vector2i& oldPos = snake.pieces[i];
    gTileMap.setData(oldPos.x, oldPos.y, TileType::NONE, COLOR_BG);
    snake.pieces[i] = newPos;
    gTileMap.setData(newPos.x, newPos.y, type, color);
}

static void snakeDeath(Snake& snake)
{
    snake.state = SnakeState::DEAD;
    for (auto& pieces : snake.pieces)
    {
        gTileMap.setData(pieces.x, pieces.y, TileType::SNAKE_DEAD, COLOR_DEAD);
    }
}

static void updateSnake(Snake& snake)
{
    if (snake.direction == DIR_NONE)
        return;

    const Vector2i head = snake.pieces[0];

    Vector2i newPos = head + snake.direction;
    newPos.x = Utils::mod(newPos.x, TILE_MAP_GRID_W);
    newPos.y = Utils::mod(newPos.y, TILE_MAP_GRID_H);

    Color color = gPlayers.getColor(snake.playerId);

    bool replaceFood = false;

    TileData_t& tileData = gTileMap.getTileData(newPos.x, newPos.y);
    if (tileData.type == TileType::FOOD)
    {
        // Collision with food, grow one tail.
        snake.pieces.insert(snake.pieces.begin(), newPos);
        replaceFood = true;
    }
    else if (
        tileData.type == TileType::SNAKE_TAIL
        || tileData.type == TileType::SNAKE_HEAD)
    {
        // Snake collision.
        snakeDeath(snake);
        return;
    }
    else if (tileData.type == TileType::SNAKE_DEAD)
    {
        // Remove our tail.
        auto& tailPos = snake.pieces.back();
        gTileMap.setData(tailPos.x, tailPos.y, TileType::SNAKE_DEAD, color);

        snake.pieces.pop_back();
        if (snake.pieces.empty())
        {
            snakeDeath(snake);
            return;
        }

        moveSnakePiece(snake, 0, newPos, TileType::SNAKE_HEAD, color);
    }
    else
    {
        if (snake.pieces.size() > 1)
        {
            // Move tail to front.
            snake.pieces.insert(snake.pieces.begin(), snake.pieces.back());
            snake.pieces.pop_back();
        }
    }

    // Update the tile map based on our pieces.
    moveSnakePiece(snake, 0, newPos, TileType::SNAKE_HEAD, color);
    for (size_t i = 1; i < snake.pieces.size(); i++)
    {
        moveSnakePiece(snake, i, snake.pieces[i], TileType::SNAKE_TAIL, color);
    }

    // Picking up food replaces it with one.
    if (replaceFood)
    {
        gGame.createFood();
    }
}

SnakeId Snakes::create(PlayerId playerId, int32_t x, int32_t y)
{
    SnakeId res = INVALID_SNAKE_ID;

    for (SnakeId id = 0; id < _snakes.size(); id++)
    {
        Snake& snake = _snakes[id];
        if (snake.id == INVALID_SNAKE_ID)
        {
            snake.state = SnakeState::ALIVE;
            snake.pieces.push_back({ x, y });
            snake.id = id;
            snake.playerId = playerId;
            snake.direction = DIR_NONE;
            res = id;

            Color color = gPlayers.getColor(playerId);
            gTileMap.setData(x, y, TileType::SNAKE_HEAD, color);
            break;
        }
    }

    return res;
}

Snake& Snakes::getData(SnakeId id)
{
    return _snakes[id];
}

void Snakes::remove(SnakeId id)
{
    Snake& snake = _snakes[id];
    snake.id = INVALID_SNAKE_ID;
    snake.direction = DIR_NONE;
    for (auto& piece : snake.pieces)
    {
        gTileMap.setData(piece.x, piece.y, TileType::NONE, COLOR_BG);
    }
    snake.pieces.clear();
}

void Snakes::update()
{
    size_t alive = 0;
    size_t count = 0;

    for (auto& snake : _snakes)
    {
        if (snake.id == INVALID_SNAKE_ID)
            continue;

        count++;

        if (snake.state != SnakeState::ALIVE)
            continue;

        updateSnake(snake);

        if (snake.state == SnakeState::ALIVE)
            alive++;
    }
}

void Snakes::setDirection(SnakeId id, const Vector2i& dir)
{
    Snake& snake = _snakes[id];
    snake.direction = dir;
}

Vector2i Snakes::getDirection(SnakeId id) const
{
    const Snake& snake = _snakes[id];
    return snake.direction;
}

size_t Snakes::count() const
{
    size_t res = 0;
    for (auto& snake : _snakes)
    {
        if (snake.id != INVALID_SNAKE_ID)
            res++;
    }
    return res;
}

size_t Snakes::alive() const
{
    size_t res = 0;
    for (auto& snake : _snakes)
    {
        if (snake.id == INVALID_SNAKE_ID)
            continue;
        if (snake.state == SnakeState::ALIVE)
            res++;
    }
    return res;
}

const std::array<Snake, MAX_PLAYERS>& Snakes::getSnakes() const
{
    return _snakes;
}

```

`src/SnakeRoyal/Snakes.h`:

```h
#pragma once

#include "Types.h"
#include "Config.h"
#include "Snake.h"

class Snakes
{
    std::array<Snake, MAX_PLAYERS> _snakes;

public:
    Snakes() = default;

    SnakeId create(PlayerId playerId, int32_t x, int32_t y);
    Snake& getData(SnakeId id);
    void remove(SnakeId id);
    void update();
    void setDirection(SnakeId id, const Vector2i& dir);
    Vector2i getDirection(SnakeId id) const;

    size_t count() const;
    size_t alive() const;

    const std::array<Snake, MAX_PLAYERS>& getSnakes() const;
};

extern Snakes gSnakes;
```

`src/SnakeRoyal/Socket.cpp`:

```cpp
#include <chrono>
#include <cmath>
#include <cstring>
#include <future>
#include <string>
#include <thread>
#include <winsock2.h>
#include <ws2tcpip.h>

#pragma comment(lib, "Ws2_32.lib")

#define LAST_SOCKET_ERROR() WSAGetLastError()
#undef EWOULDBLOCK
#define EWOULDBLOCK WSAEWOULDBLOCK
#ifndef SHUT_RD
#define SHUT_RD SD_RECEIVE
#endif
#ifndef SHUT_RDWR
#define SHUT_RDWR SD_BOTH
#endif
#define FLAG_NO_PIPE 0

#include "Socket.h"

static constexpr auto CONNECT_TIMEOUT = std::chrono::milliseconds(3000);
static bool _wsaInitialised = false;

class SocketException : public std::runtime_error
{
public:
    explicit SocketException(const std::string& message)
        : std::runtime_error(message)
    {
    }
};

class Socket
{
protected:
    static bool ResolveAddress(
        const std::string& address,
        uint16_t port,
        sockaddr_storage* ss,
        socklen_t* ss_len)
    {
        return ResolveAddress(AF_UNSPEC, address, port, ss, ss_len);
    }

    static bool ResolveAddressIPv4(
        const std::string& address,
        uint16_t port,
        sockaddr_storage* ss,
        socklen_t* ss_len)
    {
        return ResolveAddress(AF_INET, address, port, ss, ss_len);
    }

    static bool SetNonBlocking(SOCKET socket, bool on)
    {
#ifdef _WIN32
        u_long nonBlocking = on;
        return ioctlsocket(socket, FIONBIO, &nonBlocking) == 0;
#else
        int32_t flags = fcntl(socket, F_GETFL, 0);
        return fcntl(
                   socket, F_SETFL,
                   on ? (flags | O_NONBLOCK) : (flags & ~O_NONBLOCK))
               == 0;
#endif
    }

    static bool SetOption(SOCKET socket, int32_t a, int32_t b, bool value)
    {
        int32_t ivalue = value ? 1 : 0;
        return setsockopt(socket, a, b, (const char*)&ivalue, sizeof(ivalue))
               == 0;
    }

private:
    static bool ResolveAddress(
        int32_t family,
        const std::string& address,
        uint16_t port,
        sockaddr_storage* ss,
        socklen_t* ss_len)
    {
        std::string serviceName = std::to_string(port);

        addrinfo hints = {};
        hints.ai_family = family;
        if (address.empty())
        {
            hints.ai_flags = AI_PASSIVE;
        }

        addrinfo* result = nullptr;
        int errorcode = getaddrinfo(
            address.empty() ? nullptr : address.c_str(), serviceName.c_str(),
            &hints, &result);
        if (errorcode != 0)
        {
            return false;
        }
        if (result == nullptr)
        {
            return false;
        }
        else
        {
            std::memcpy(ss, result->ai_addr, result->ai_addrlen);
            *ss_len = (socklen_t)result->ai_addrlen;
            freeaddrinfo(result);
            return true;
        }
    }
};

class TcpSocket final : public ITcpSocket, protected Socket
{
private:
    SocketStatus _status = SocketStatus::CLOSED;
    uint16_t _listeningPort = 0;
    SOCKET _socket = INVALID_SOCKET;

    std::string _hostName;
    std::future<void> _connectFuture;
    std::string _error;

public:
    TcpSocket() = default;

    ~TcpSocket() override
    {
        if (_connectFuture.valid())
        {
            _connectFuture.wait();
        }
        CloseSocket();
    }

    SocketStatus GetStatus() const override
    {
        return _status;
    }

    const char* GetError() const override
    {
        return _error.empty() ? nullptr : _error.c_str();
    }

    void Listen(uint16_t port) override
    {
        Listen("", port);
    }

    void Listen(const std::string& address, uint16_t port) override
    {
        if (_status != SocketStatus::CLOSED)
        {
            throw std::runtime_error("Socket not closed.");
        }

        sockaddr_storage ss{};
        socklen_t ss_len;
        if (!ResolveAddress(address, port, &ss, &ss_len))
        {
            throw SocketException("Unable to resolve address.");
        }

        // Create the listening socket
        _socket = socket(ss.ss_family, SOCK_STREAM, IPPROTO_TCP);
        if (_socket == INVALID_SOCKET)
        {
            throw SocketException("Unable to create socket.");
        }

        // Turn off IPV6_V6ONLY so we can accept both v4 and v6 connections
        int32_t value = 0;
        if (setsockopt(
                _socket, IPPROTO_IPV6, IPV6_V6ONLY, (const char*)&value,
                sizeof(value))
            != 0)
        {
            printf("IPV6_V6ONLY failed. %d\n", LAST_SOCKET_ERROR());
        }

        value = 1;
        if (setsockopt(
                _socket, SOL_SOCKET, SO_REUSEADDR, (const char*)&value,
                sizeof(value))
            != 0)
        {
            printf("SO_REUSEADDR failed. %d\n", LAST_SOCKET_ERROR());
        }

        try
        {
            // Bind to address:port and listen
            if (bind(_socket, (sockaddr*)&ss, ss_len) != 0)
            {
                throw SocketException("Unable to bind to socket.");
            }
            if (listen(_socket, SOMAXCONN) != 0)
            {
                throw SocketException("Unable to listen on socket.");
            }

            if (!SetNonBlocking(_socket, true))
            {
                throw SocketException("Failed to set non-blocking mode.");
            }
        }
        catch (const std::exception&)
        {
            CloseSocket();
            throw;
        }

        _listeningPort = port;
        _status = SocketStatus::LISTENING;
    }

    std::unique_ptr<ITcpSocket> Accept() override
    {
        if (_status != SocketStatus::LISTENING)
        {
            throw std::runtime_error("Socket not listening.");
        }
        struct sockaddr_storage client_addr
        {
        };
        socklen_t client_len = sizeof(struct sockaddr_storage);

        std::unique_ptr<ITcpSocket> tcpSocket;
        SOCKET socket = accept(
            _socket, (struct sockaddr*)&client_addr, &client_len);
        if (socket == INVALID_SOCKET)
        {
            if (LAST_SOCKET_ERROR() != EWOULDBLOCK)
            {
                printf("Failed to accept client.\n");
            }
        }
        else
        {
            if (!SetNonBlocking(socket, true))
            {
                closesocket(socket);
                printf("Failed to set non-blocking mode.\n");
            }
            else
            {
                char hostName[NI_MAXHOST];
                int32_t rc = getnameinfo(
                    (struct sockaddr*)&client_addr, client_len, hostName,
                    sizeof(hostName), nullptr, 0,
                    NI_NUMERICHOST | NI_NUMERICSERV);
                SetOption(socket, IPPROTO_TCP, TCP_NODELAY, true);
                if (rc == 0)
                {
                    tcpSocket = std::unique_ptr<ITcpSocket>(
                        new TcpSocket(socket, hostName));
                }
                else
                {
                    tcpSocket = std::unique_ptr<ITcpSocket>(
                        new TcpSocket(socket, ""));
                }
            }
        }
        return tcpSocket;
    }

    void Connect(const std::string& address, uint16_t port) override
    {
        if (_status != SocketStatus::CLOSED)
        {
            throw std::runtime_error("Socket not closed.");
        }

        try
        {
            // Resolve address
            _status = SocketStatus::RESOLVING;

            sockaddr_storage ss{};
            socklen_t ss_len;
            if (!ResolveAddress(address, port, &ss, &ss_len))
            {
                throw SocketException("Unable to resolve address.");
            }

            _status = SocketStatus::CONNECTING;
            _socket = socket(ss.ss_family, SOCK_STREAM, IPPROTO_TCP);
            if (_socket == INVALID_SOCKET)
            {
                throw SocketException("Unable to create socket.");
            }

            SetOption(_socket, IPPROTO_TCP, TCP_NODELAY, true);
            if (!SetNonBlocking(_socket, true))
            {
                throw SocketException("Failed to set non-blocking mode.");
            }

            // Connect
            int32_t connectResult = connect(_socket, (sockaddr*)&ss, ss_len);
            if (connectResult != SOCKET_ERROR
                || (LAST_SOCKET_ERROR() != EINPROGRESS
                    && LAST_SOCKET_ERROR() != EWOULDBLOCK))
            {
                throw SocketException("Failed to connect.");
            }

            auto connectStartTime = std::chrono::system_clock::now();

            int32_t error = 0;
            socklen_t len = sizeof(error);
            if (getsockopt(_socket, SOL_SOCKET, SO_ERROR, (char*)&error, &len)
                != 0)
            {
                throw SocketException(
                    "getsockopt failed with error: "
                    + std::to_string(LAST_SOCKET_ERROR()));
            }
            if (error != 0)
            {
                throw SocketException(
                    "Connection failed: " + std::to_string(error));
            }

            do
            {
                // Sleep for a bit
                std::this_thread::sleep_for(std::chrono::milliseconds(100));

                fd_set writeFD;
                FD_ZERO(&writeFD);
                FD_SET(_socket, &writeFD);
                timeval timeout{};
                timeout.tv_sec = 0;
                timeout.tv_usec = 0;
                if (select(
                        (int32_t)(_socket + 1), nullptr, &writeFD, nullptr,
                        &timeout)
                    > 0)
                {
                    error = 0;
                    len = sizeof(error);
                    if (getsockopt(
                            _socket, SOL_SOCKET, SO_ERROR, (char*)&error, &len)
                        != 0)
                    {
                        throw SocketException(
                            "getsockopt failed with error: "
                            + std::to_string(LAST_SOCKET_ERROR()));
                    }
                    if (error == 0)
                    {
                        _status = SocketStatus::CONNECTED;
                        return;
                    }
                }
            } while ((std::chrono::system_clock::now() - connectStartTime)
                     < CONNECT_TIMEOUT);

            // Connection request timed out
            throw SocketException("Connection timed out.");
        }
        catch (const std::exception&)
        {
            CloseSocket();
            throw;
        }
    }

    void ConnectAsync(const std::string& address, uint16_t port) override
    {
        if (_status != SocketStatus::CLOSED)
        {
            throw std::runtime_error("Socket not closed.");
        }

        auto saddress = std::string(address);
        std::promise<void> barrier;
        _connectFuture = barrier.get_future();
        auto thread = std::thread(
            [this, saddress, port](std::promise<void> barrier2) -> void {
                try
                {
                    Connect(saddress.c_str(), port);
                }
                catch (const std::exception& ex)
                {
                    _error = std::string(ex.what());
                }
                barrier2.set_value();
            },
            std::move(barrier));
        thread.detach();
    }

    void Disconnect() override
    {
        if (_status == SocketStatus::CONNECTED)
        {
            shutdown(_socket, SHUT_RDWR);
        }
    }

    size_t SendData(const void* buffer, size_t size) override
    {
        if (_status != SocketStatus::CONNECTED)
        {
            throw std::runtime_error("Socket not connected.");
        }

        size_t totalSent = 0;
        do
        {
            const char* bufferStart = (const char*)buffer + totalSent;
            size_t remainingSize = size - totalSent;
            int32_t sentBytes = send(
                _socket, bufferStart, (int32_t)remainingSize, FLAG_NO_PIPE);
            if (sentBytes == SOCKET_ERROR)
            {
                return totalSent;
            }
            totalSent += sentBytes;
        } while (totalSent < size);
        return totalSent;
    }

    SocketReadStatus ReceiveData(
        void* buffer, size_t size, size_t* sizeReceived) override
    {
        if (_status != SocketStatus::CONNECTED)
        {
            throw std::runtime_error("Socket not connected.");
        }

        int32_t readBytes = recv(_socket, (char*)buffer, (int32_t)size, 0);
        if (readBytes == 0)
        {
            *sizeReceived = 0;
            return SocketReadStatus::DISCONNECTED;
        }
        else if (readBytes == SOCKET_ERROR)
        {
            *sizeReceived = 0;
            if (LAST_SOCKET_ERROR() != EWOULDBLOCK)
            {
                return SocketReadStatus::DISCONNECTED;
            }
            else
            {
                return SocketReadStatus::FAIL;
            }
        }
        else
        {
            *sizeReceived = readBytes;
            return SocketReadStatus::SUCCESS;
        }
    }

    void Close() override
    {
        if (_connectFuture.valid())
        {
            _connectFuture.wait();
        }
        CloseSocket();
    }

    const char* GetHostName() const override
    {
        return _hostName.empty() ? nullptr : _hostName.c_str();
    }

private:
    explicit TcpSocket(SOCKET socket, const std::string& hostName)
    {
        _socket = socket;
        _hostName = hostName;
        _status = SocketStatus::CONNECTED;
    }

    void CloseSocket()
    {
        if (_socket != INVALID_SOCKET)
        {
            closesocket(_socket);
            _socket = INVALID_SOCKET;
        }
        _status = SocketStatus::CLOSED;
    }
};

bool InitializeWSA()
{
    if (!_wsaInitialised)
    {
        WSADATA wsa_data{};
        if (WSAStartup(MAKEWORD(2, 2), &wsa_data) != 0)
        {
            printf("Unable to initialise winsock.\n");
            return false;
        }
        _wsaInitialised = true;
    }
    return _wsaInitialised;
}

void DisposeWSA()
{
    if (_wsaInitialised)
    {
        WSACleanup();
        _wsaInitialised = false;
    }
}

std::unique_ptr<ITcpSocket> CreateTcpSocket()
{
    return std::make_unique<TcpSocket>();
}

```

`src/SnakeRoyal/Socket.h`:

```h
#pragma once

#include <memory>
#include <string>
#include <vector>

enum class SocketStatus
{
    CLOSED,
    RESOLVING,
    CONNECTING,
    CONNECTED,
    LISTENING,
};

enum class SocketReadStatus
{
    SUCCESS,
    FAIL,
    DISCONNECTED,
};

class ITcpSocket
{
public:
    virtual ~ITcpSocket() = default;

    virtual SocketStatus GetStatus() const abstract;
    virtual const char* GetError() const abstract;
    virtual const char* GetHostName() const abstract;

    virtual void Listen(uint16_t port) abstract;
    virtual void Listen(const std::string& address, uint16_t port) abstract;
    virtual std::unique_ptr<ITcpSocket> Accept() abstract;

    virtual void Connect(const std::string& address, uint16_t port) abstract;
    virtual void ConnectAsync(
        const std::string& address, uint16_t port) abstract;

    virtual size_t SendData(const void* buffer, size_t size) abstract;
    virtual SocketReadStatus ReceiveData(
        void* buffer, size_t size, size_t* sizeReceived) abstract;

    virtual void Disconnect() abstract;
    virtual void Close() abstract;
};

bool InitializeWSA();
void DisposeWSA();

std::unique_ptr<ITcpSocket> CreateTcpSocket();

```

`src/SnakeRoyal/TileMap.cpp`:

```cpp
#include "TileMap.h"
#include "Game.h"
#include <assert.h>

TileMap gTileMap;

void TileMap::draw(Painter& painter)
{
    painter.rect(
        TILE_MAP_MARGIN_LEFT - 1, TILE_MAP_MARGIN_TOP - 1, TILE_MAP_SIZE_W + 2,
        TILE_MAP_SIZE_H + 2, { 0, 255, 0 });

    for (int32_t x = 0; x < TILE_MAP_GRID_W; x++)
    {
        int32_t xx = x * (TILE_SIZE_W + 1);
        for (int32_t y = 0; y < TILE_MAP_GRID_H; y++)
        {
            int32_t yy = y * (TILE_SIZE_H + 1);

            const TileData_t& data = getTileData(x, y);
            switch (data.type)
            {
                case TileType::NONE:
                    painter.filledRect(
                        xx + TILE_MAP_MARGIN_LEFT, yy + TILE_MAP_MARGIN_TOP,
                        TILE_SIZE_W, TILE_SIZE_H, { 0, 0, 0 });
                    break;
                case TileType::SNAKE_HEAD:
                    painter.filledRect(
                        xx + TILE_MAP_MARGIN_LEFT, yy + TILE_MAP_MARGIN_TOP,
                        TILE_SIZE_W, TILE_SIZE_H, data.color);
                    break;
                case TileType::SNAKE_TAIL:
                {
                    Color color = data.color;
                    color.r /= 2;
                    color.g /= 2;
                    color.b /= 2;
                    painter.filledRect(
                        xx + TILE_MAP_MARGIN_LEFT, yy + TILE_MAP_MARGIN_TOP,
                        TILE_SIZE_W, TILE_SIZE_H, color);
                }
                break;
                case TileType::SNAKE_DEAD:
                    painter.filledRect(
                        xx + TILE_MAP_MARGIN_LEFT, yy + TILE_MAP_MARGIN_TOP,
                        TILE_SIZE_W, TILE_SIZE_H, data.color);
                    break;
                case TileType::FOOD:
                    painter.filledEllipse(
                        xx + TILE_MAP_MARGIN_LEFT, yy + TILE_MAP_MARGIN_TOP,
                        TILE_SIZE_W, TILE_SIZE_H, data.color);
                    break;
                default:
                    assert(false);
            }
        }
    }
}

void TileMap::setData(int32_t x, int32_t y, TileType type, Color color)
{
    TileData_t& data = getTileData(x, y);
    data.type = type;
    data.color = color;
}

void TileMap::reset()
{
    for (auto& tileData : _tiles)
    {
        tileData.type = TileType::NONE;
    }
}

std::array<TileData_t, TILE_MAP_SIZE>& TileMap::getData()
{
    return _tiles;
}

```

`src/SnakeRoyal/TileMap.h`:

```h
#pragma once

#include <stdint.h>
#include <vector>
#include <array>

#include "Painter.h"
#include "Color.h"
#include "Config.h"

enum class TileType
{
    NONE = 0,
    SNAKE_HEAD,
    SNAKE_TAIL,
    SNAKE_DEAD,
    FOOD,
};

struct TileData_t
{
    TileType type = TileType::NONE;
    Color color = COLOR_BLACK;
};

static constexpr size_t TILE_MAP_SIZE = TILE_MAP_GRID_H * TILE_MAP_GRID_W;

class TileMap
{
private:
    std::array<TileData_t, TILE_MAP_SIZE> _tiles;

public:
    void draw(Painter& painter);

    TileData_t& getTileData(int32_t x, int32_t y)
    {
        const size_t index = x + (TILE_MAP_GRID_W * y);
        return _tiles[index];
    }

    const TileData_t& getTileData(int32_t x, int32_t y) const
    {
        const size_t index = x + (TILE_MAP_GRID_W * y);
        return _tiles[index];
    }

    void setData(int32_t x, int32_t y, TileType type, Color color);

    void reset();

    std::array<TileData_t, TILE_MAP_SIZE>& getData();
};

extern TileMap gTileMap;
```

`src/SnakeRoyal/Types.h`:

```h
#pragma once

#include <stdint.h>
#include <limits>
#include <vector>
#include <array>

#include "Vector2.h"
#include "Color.h"

using PlayerId = uint8_t;

static constexpr PlayerId INVALID_PLAYER_ID = std::numeric_limits<
    PlayerId>::max();

using SnakeId = uint8_t;

static constexpr SnakeId INVALID_SNAKE_ID = std::numeric_limits<SnakeId>::max();
```

`src/SnakeRoyal/Utils.cpp`:

```cpp
#include <windows.h>
#include <chrono>
#include "Utils.h"

namespace Utils
{
static std::chrono::high_resolution_clock _clock;
static const auto _timeStart = _clock.now();

double getTime()
{
    auto deltaTime = _clock.now() - _timeStart;
    return std::chrono::duration_cast<std::chrono::nanoseconds>(deltaTime)
               .count()
           / 1000000000.0;
}

std::wstring toWString(const std::string& str)
{
    int num_chars = MultiByteToWideChar(
        CP_UTF8, 0, str.c_str(), str.length(), NULL, 0);
    std::wstring wstrTo;
    if (num_chars)
    {
        wstrTo.resize(num_chars);
        MultiByteToWideChar(
            CP_UTF8, 0, str.c_str(), str.length(), &wstrTo[0], num_chars);
    }
    return wstrTo;
}

std::string toMBString(const std::wstring& wstr)
{
    int num_chars = WideCharToMultiByte(
        CP_UTF8, 0, wstr.c_str(), wstr.length(), NULL, 0, NULL, NULL);
    std::string strTo;
    if (num_chars > 0)
    {
        strTo.resize(num_chars);
        WideCharToMultiByte(
            CP_UTF8, 0, wstr.c_str(), wstr.length(), &strTo[0], num_chars, NULL,
            NULL);
    }
    return strTo;
}

void getUsername(char* buffer, size_t maxBuffer)
{
    memset(buffer, 0, maxBuffer);

    DWORD bufferSize = maxBuffer;
    GetUserNameA(buffer, &bufferSize);
}

} // namespace Utils
```

`src/SnakeRoyal/Utils.h`:

```h
#pragma once

#include <string>

namespace Utils
{
double getTime();
std::wstring toWString(const std::string& str);
std::string toMBString(const std::wstring& wstr);

template<typename T> int mod(T x, T divisor)
{
    T m = x % divisor;
    return m + ((m >> ((sizeof(T) * 8) - 1)) & divisor);
}

void getUsername(char* buffer, size_t maxBuffer);

} // namespace Utils

```

`src/SnakeRoyal/Vector2.h`:

```h
#pragma once

#include <stdint.h>

struct Vector2i
{
    int32_t x;
    int32_t y;

    Vector2i operator+(const Vector2i& other) const
    {
        return Vector2i{ x + other.x, y + other.y };
    }

    Vector2i operator-(const Vector2i& other) const
    {
        return Vector2i{ x + other.x, y + other.y };
    }

    bool operator==(const Vector2i& other) const
    {
        return x == other.x && y == other.y;
    }

    bool operator!=(const Vector2i& other) const
    {
        return !(other == *this);
    }
};

static constexpr Vector2i DIR_NONE{ 0, 0 };
static constexpr Vector2i DIR_UP{ 0, -1 };
static constexpr Vector2i DIR_DOWN{ 0, 1 };
static constexpr Vector2i DIR_LEFT{ -1, 0 };
static constexpr Vector2i DIR_RIGHT{ 1, 0 };
```

`src/SnakeRoyal/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by SnakeRoyal.rc
//
#define IDI_ICON1                       104

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```