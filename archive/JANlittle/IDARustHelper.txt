Project Path: arc_JANlittle_IDARustHelper_s06377uy

Source Tree:

```txt
arc_JANlittle_IDARustHelper_s06377uy
├── IDARustHelper
│   ├── Demangler.py
│   ├── RustType.py
│   ├── StringRecover
│   │   ├── __init__.py
│   │   ├── arm_rust.py
│   │   ├── pc_rust.py
│   │   ├── riscv_rust.py
│   │   └── rust.py
│   ├── __init__.py
│   └── resource
│       └── rust-logo.png
├── IDARustHelperPlugin.py
├── LICENSE
└── README.md

```

`IDARustHelper/Demangler.py`:

```py
from idaapi import *
import idautils
from rust_demangler import demangle
import string

class IDARustDemangler():
    """
    IDARustDemangler is a tool that demangles and normalizes symbols for use with the IDA disassembler.
    It replaces or modifies special characters to make them compatible with IDA's syntax, 
    making binary analysis faster and more efficient.
    """

    def __init__(self, debug=False):
        self.debug = debug
        self.num_resolved = 0
        self.hash_prefix = "17h"
        self.delimiters = "><"
        self.badchars = "*,'`" + self.delimiters
        self.queue = {}
        self.resolved = {}

    def add(self, address: int, symbol: str) -> None:
        # Must add support for non legacy symbols

        if symbol in self.queue.values():
            return

        # If the hash is present
        if symbol.lstrip("_").startswith("Z") and self.hash_prefix in symbol:
            hash = symbol.split(self.hash_prefix)[-1].rstrip("E")

            # If the hash length is not 16 skip as it is not a valid rust legacy symbol
            if len(hash) < 16 or any([c not in string.hexdigits for c in hash[:16]]):
                hash = ""

            self.queue[address, hash] = symbol
        else:
            # If the hash is not present
            if symbol.lstrip("_").startswith("R") or '::' in symbol:
                self.queue[address, ""] = symbol

    def resolve(self):
        resolved_symbols = []
        for symbol in self.queue.values():
            try:
                if symbol != demangle(symbol):
                    resolved_symbols.append(demangle(symbol))
            except:
                resolved_symbols.append(symbol)
        self.resolved = zip(self.queue.keys(), resolved_symbols)

    def apply(self):
        # for each symbol resolved normalize it and apply it to the IDA db
        for (address, hash), symbol in self.resolved:
            set_func_cmt(get_func(address), symbol, 1)
            normalized = self.ida_normalize(symbol)

            # If normalization succeded and all the character in the normalized
            # symbol are valid set the name in IDA
            if any([badchar in normalized for badchar in self.badchars]) and self.debug:
                print(
                    f"[ERROR] {address:#016x} -> sym:'{symbol}', hash: '{hash}', normalized: '{normalized}'")
                continue

            if self.debug:
                print(
                    f"[*] {address:#016x} -> sym:'{symbol}', hash: '{hash}', normalized: '{normalized}'")

            # set the name and add the hash at the end
            # print(f"[*] {address:#x} -> {normalized + str(len(hash)) + hash}")
            if hash == "":
                is_set = set_name(address, normalized)
            else:
                is_set = set_name(address, normalized + str(len(hash)) + hash)
            if not is_set and self.debug:
                print(
                    f"[ERROR] {address:#016x} -> sym:'{symbol}', hash: '{hash}', normalized: '{normalized}'")
            self.num_resolved += 1

    def ida_normalize(self, name: str) -> str:
        """
        This function tries to normalize sybmols to be accepted by IDA
        """

        # Replace bad characters with accepted ones
        # unfortunately there is no way known to me
        # to insert these chars into IDA symbol names

        name = name.replace(" ", "_")
        name = name.replace(",", "_")
        name = name.replace("{", "<")
        name = name.replace("}", ">")
        name = name.replace("'","_")
        name = name.replace("`","_")
        name = name.replace("-","_")
        name = name.replace("=","_")
        name = name.replace("\\","_")
        name = name.replace(";","_")
        name = name.replace("+","_")
        name = name.replace("!","_")

        i = 0
        output = "_ZN"

        while i < len(name):
            if name[i] == "<":
                # 'I' corresponds to '<'
                output += "I"
                i += 1
            elif name[i] == ">":
                # 'E' corresponds to '>'
                output += "E"
                i += 1
            elif name[i] == "*":
                # 'P' corresponds to pointer-type word
                output += "P"
                i += 1
            else:

                # if it the `word` starts with "::" skip it
                # as IDA automatically adds it
                if name[i:i+2] == "::":
                    i += 2

                # this should find the closest delimiter to
                # recognize the entire word

                idxs = []

                for special_char in self.delimiters:
                    tmp_idx = name[i+1:].find(special_char)

                    if tmp_idx != -1:
                        idxs.append(tmp_idx)

                if len(idxs) >= 1:
                    idx = min(idxs)
                    word = name[i:i+idx + 1]
                else:
                    word = name[i:]

                if len(word) > 0:
                    if "*" in word:
                        # if '*' is present it means it is a pointer just have
                        # to a number of 'P' at the start of the word
                        # corresponding to the number of '*'
                        output += "P" * word.count("*")
                        i += word.count("*")
                        word = word.replace("*", "")

                    output += str(len(word)) + word

                i += len(word)

        output += "E"
        return output
    
    def run(self):
        print("Demangler started!")
        for address in idautils.Functions():
            self.add(address, get_func_name(address))

        self.resolve()
        self.apply()
        print(f"Demangled {self.num_resolved} symbols")
```

`IDARustHelper/RustType.py`:

```py
from idaapi import *


# can add more rust types here
STR = '''
struct str {
    char* ptr;
    size_t len;
}
'''

type_list = [(STR, 'str')]

def set_rust_type():
    print("[*] Adding Rust types to IDA...")
    til = get_idati()
    for t, n in type_list:
        idc_parse_types(t, 0)
        import_type(til, -1, n)

    print(f"[*] {len(type_list)} Rust types added to IDA!")
```

`IDARustHelper/StringRecover/arm_rust.py`:

```py
from .rust import proc_rust_t
from idaapi import *

# Rust ABI need to be investigated,
# assume callregs: X0, X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X11, X12, X13, X14, X15, -1
rv_arm = [129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, -1]

class arm_rust_t(proc_rust_t):
    def __init__(self) -> None:
        super().__init__()
        self.look_forward = 8
        if self.is64:
            self.regs.set(ARGREGS_GP_ONLY, rv_arm, None)    # How to pass const int * parm...?

    def insn_get_rptr(self, insn: insn_t) -> int:
        if self.is64:
            # ADRL X1, aSel
            # ADRP X9, #unk_34C56@PAGE
            if (insn.itype == ARM_adrl or insn.itype == ARM_adrp) and insn.Op1.type == o_reg:
                return insn.Op1.reg
            else:
                return -1
        else:
            # LDR R0, =(unk_28E30 - 0x32D0)
            if insn.itype == ARM_ldr and insn.Op1.type == o_reg:
                return insn.Op1.reg
            else:
                return -1

    def insn_check_for_rlen(self, insn: insn_t, rlen: int) -> int:
        # MOV W2, #0x20
        # MOVS R1, #0xC
        if insn.itype == ARM_mov and insn.Op1.is_reg(rlen) and insn.Op2.type == o_imm:
            return insn.Op2.value
        else:
            return -1
    
```

`IDARustHelper/StringRecover/pc_rust.py`:

```py
from .rust import proc_rust_t
from idaapi import *

class pc_rust_t(proc_rust_t):
    def __init__(self) -> None:
        super().__init__()

    # lea rax, aImagine
    def insn_get_rptr(self, insn: insn_t) -> int:
        if insn.itype == NN_lea and insn.Op1.type == o_reg:
            return insn.Op1.reg
        else:
            return -1
        
    # mov esi, 1Ch         ; .len (_str.length)
    def insn_check_for_rlen(self, insn: insn_t, rlen: int) -> int:
        if insn.itype == NN_mov and insn.Op1.is_reg(rlen) and insn.Op2.type == o_imm:
            return insn.Op2.value
        else:
            return -1
        
    # mov [rsp+238h+var_60.length], 7
    def is_rlen_stk_insn(self, insn: insn_t, rbase:int, stkoff: int) -> bool:
        return insn.itype == NN_mov and insn.Op1.type == o_displ and insn.Op1.reg == rbase and insn.Op1.addr == stkoff + self.bitness // 8 and insn.Op2.type == o_imm
    
    def get_strlen(self, insn_ea: int, strlit_ea: int) -> int:
        strlen = super().get_strlen(insn_ea, strlit_ea)
        if strlen != -1:
            return strlen
        
        if self.is64:
            insn = insn_t()
            if decode_insn(insn, insn_ea) == 0:
                return -1
            rptr = self.insn_get_rptr(insn)
            if rptr != -1:
                for _ in range(self.look_forward):
                    next_ea = insn.ea + insn.size
                    if decode_insn(insn, next_ea) == 0:
                        return -1
                    if insn.itype == NN_jmp and insn.Op1.type == o_near:
                        if decode_insn(insn, insn.Op1.addr) == 0:
                            return -1
                    # lea rax, aImagine
                    # mov [rsp+238h+var_60.data_ptr], rax
                    # ......
                    # mov [rsp+238h+var_60.length], 7
                    # or another situation like:
                    # lea rax, unk_9E64D
                    # mov [rbx+580h], rax
                    # ......
                    # mov qword ptr [rbx+588h], 6Dh ; 'm'
                    if insn.itype == NN_mov and insn.Op1.type == o_displ and insn.Op2.is_reg(rptr):
                        stkoff = insn.Op1.addr
                        rbase = insn.Op1.reg
                        for _ in range(self.look_forward):
                            next_ea += insn.size
                            if decode_insn(insn, next_ea) > 0:
                                if self.is_rlen_stk_insn(insn, rbase, stkoff):
                                    return insn.Op2.value
                            else:
                                return -1
                        return -1
                    elif insn.itype == NN_push and insn.Op1.type == o_imm:
                        return insn.Op1.value
                    
                    
            # .text:000000014009E009                 lea     rdx, unk_1401D0BF5
            # .text:000000014009E010                 jmp     loc_14009E199
            # .text:000000014009E015 ; ---------------------------------------------------------------------------
            # .text:000000014009E015 loc_14009E015:
            # .text:000000014009E015                 mov     rcx, [rsi+20h]  ; jumptable 000000014009DEBA case 14
            # .text:000000014009E019                 mov     rax, [rsi+28h]
            # .text:000000014009E01D                 mov     rax, [rax+18h]
            # .text:000000014009E021                 lea     rdx, unk_1401D0BEC
            # .text:000000014009E028                 mov     r8d, 9
            # .text:000000014009E02E                 jmp     loc_14009E229

            # .text:000000000001DF0E                 lea     rax, unk_40AE0  ; jumptable 000000000001DCEB case 33
            # .text:000000000001DF15                 mov     ecx, 10h
            # .text:000000000001DF1A                 jmp     short loc_1DF7C
        else:   # 32-bit, namely x86
            insn = insn_t()
            if decode_insn(insn, insn_ea) == 0:
                return -1
            # push    0Bh
            # push    offset unk_A297E8
            if insn.itype == NN_push:
                if decode_prev_insn(insn, insn_ea) == 0:
                    return -1
                if insn.itype == NN_push and insn.Op1.type == o_imm:
                    return insn.Op1.value
        return -1
    
```

`IDARustHelper/StringRecover/riscv_rust.py`:

```py
from .rust import proc_rust_t
from idaapi import *

# The RISC-V calling convention passes arguments in registers when possible. Up to eight integer 
# registers, a0-a7, and up to eight floating-point registers, fa0-fa7, are used for this purpose
#           a0  a1  a2  a3  a4  a5  a6  a7
rv_riscv = [10, 11, 12, 13, 14, 15, 16, 17, -1]

class riscv_rust_t(proc_rust_t):
    def __init__(self) -> None:
        super().__init__()
        self.look_forward = 5
        # hope to someone will implement ev_get_cc_regs
        self.regs.set(ARGREGS_GP_ONLY, rv_riscv, None)    # How to pass const int * parm...?

    def insn_get_rptr(self, insn: insn_t) -> int:
        # la a0, unk_2672B
        if insn.itype == RISCV_la and insn.Op1.type == o_reg:
            return insn.Op1.reg
        else:
            return -1
        
    def insn_check_for_rlen(self, insn: insn_t, rlen: int) -> int:
        # li a1, 21h
        if insn.itype == RISCV_li and insn.Op1.is_reg(rlen) and insn.Op2.type == o_imm:
            return insn.Op2.value
        else:
            return -1
```

`IDARustHelper/StringRecover/rust.py`:

```py
from idaapi import *
import idc

class proc_rust_t:
    '''encapsulate the basic methods and data used during processing the xref which in code segment'''
    def __init__(self) -> None:
        self.look_forward = 5
        self.look_backward = 5
        self.is64 = inf_get_app_bitness() == 64
        self.bitness = inf_get_app_bitness()
        # is 32bit rust binary still use fastcall?
        self.regs = callregs_t(CM_CC_FASTCALL)

    def get_strlen(self, insn_ea: int, strlit_ea: int) -> int:
        '''
        check the neighbor instructions of INSN_EA to find the strlit length
        @param: insn_ea    insn EA which loads of strlit address
        @param: strlit_ea  strlit EA with dr_O to INSN_EA
        @return: -1 if not successful
        
        The default implementation uses the commont patterns for register-based ABI:
        1: load _str.ptr to RPTR register      <- INSN_EA
            may be several alien insns\n
            load _str.length to RLEN register\n
        2: load _str.length to RLEN register\n
            may be several alien insns\n
            load _str.ptr to RPTR register      <- INSN_EA
        '''
        insn = insn_t()
        if not decode_insn(insn, insn_ea):
            return -1
        rptr = self.insn_get_rptr(insn)
        if rptr == -1:
            return -1
        rlen = self.get_rlen_by_rptr(rptr)
        if rlen != -1:
            # pattern 1
            ea = insn.ea + insn.size
            for _ in range(self.look_forward):
                if self.break_scan(ea):
                    break
                if not decode_insn(insn, ea):
                    break
                
                strlen = self.insn_check_for_rlen(insn, rlen)
                if strlen != -1:
                    return strlen
                ea += insn.size

            # pattern 2
            ea = insn.ea
            for _ in range(self.look_backward):
                if decode_prev_insn(insn, ea) != BADADDR:
                    strlen = self.insn_check_for_rlen(insn, rlen)
                    if strlen != -1:
                        return strlen
                ea = insn.ea
                if self.break_scan(ea):
                    break

        return -1


    def insn_get_rptr(self, insn: insn_t) -> int:
        '''callbacks for default get_strlen implementation'''
        return -1
    
    def insn_check_for_rlen(self, insn: insn_t, rlen: int) -> int:
        return -1

    # helper
    def findreg(self, regs, r) -> int:
        for i in range(len(regs.gpregs)):
            if regs.gpregs[i] == r:
                return i
        return -1

    def get_rlen_by_rptr(self, rptr: int) -> int:
        '''
        _str { data_ptr; length } is placed to two sequential callregs
        @return: register for _str.length or -1
        '''
        rlen = -1
        rptr_ind = self.findreg(self.regs, rptr)
        if rptr_ind != -1 and rptr_ind < len(self.regs.gpregs) - 1:
            rlen = self.regs.gpregs[rptr_ind + 1]
        return rlen
    
    def break_scan(self, ea: int) -> bool:
        # is jump or call insn?
        if get_first_fcref_from(ea) != BADADDR:
            return True
        
        # is return insn?
        insn = insn_t()
        return decode_insn(insn, ea) > 0 and is_ret_insn(insn, False)

rust_strlit_names = ["__const", ".rodata", ".rdata"]

class rust_ctx_t:
    '''handle the whole process of rust string recovery'''
    def __init__(self, debug=False) -> None:
        self.bitness = inf_get_app_bitness()
        ph_id = ph_get_id()
        if ph_id == PLFM_386:
            from .pc_rust import pc_rust_t
            self.mod = pc_rust_t()
        elif ph_id == PLFM_ARM:
            from .arm_rust import arm_rust_t
            self.mod = arm_rust_t()
        elif ph_id == PLFM_RISCV:
            from .riscv_rust import riscv_rust_t
            self.mod = riscv_rust_t()
        else:
            raise Exception("Unsupported platform")
        self.debug = debug
        
    def get_strlen(self, ea_ptr: int) -> int:
        if self.bitness == 32:
            return get_dword(ea_ptr + 4)
        else:
            return get_qword(ea_ptr + 8)

    def get_mod_strlen(self, insn_ea: int, strlit_ea: int) -> int:
        return self.mod.get_strlen(insn_ea, strlit_ea)

    def make_str(self, ea_ptr: int) -> bool:
        name = get_name(get_first_dref_from(ea_ptr))
        if name == None:
            return False
        if self.bitness == 32:
            flag = idc.create_struct(ea_ptr, 8, "str")
        else:
            flag = idc.create_struct(ea_ptr, 16, "str")
        if flag:
            return set_name(ea_ptr, 'str_' + name, SN_FORCE)
        else:
            return False

        # appbytes = self.bitness // 8
        # ea_len = ea_ptr + appbytes
        # sz_len = appbytes
        # # TODO: create str struct in more lenient conditions
        # if is_head(get_flags(ea_len)) and get_item_size(ea_len) != sz_len:
        #     if self.bitness == 32:
        #         # return create_dword(ea_len, sz_len, True)
        #         return idc.create_struct(ea_ptr, 8, "str")
        #     else:
        #         # return create_qword(ea_len, sz_len, True)
        #         return idc.create_struct(ea_ptr, 16, "str")
        # else:
        #     return False

    def perform_final_strlit_analysis(self):
        '''
        Try to find the strlits and create the missed strings.
        RUST does not use string pool, string literal is an ordinary constant 
        and can be alternated with the other constants 
        '''
        print("Creating Rust-specific string literals")
        qty = get_segm_qty()
        for i in range(qty):
            seg = getnseg(i)
            sname:str = get_segm_name(seg)
            if sname != -1:
                for pn in rust_strlit_names:
                    if sname.endswith(pn):
                        if not self.process_strlit_range(seg):
                            break
        print("Rust-specific string literals created")

    def process_strlit_range(self, r: range_t) -> bool:
        '''
        create strlits in range identified by xref:
        * get EA with xref
        * check for strlit
        * adjust length using next xref
        * create strlit
        '''
        if self.debug:
            print("RUST: process_strlit_range %#x..%#x\n" % (r.start_ea, r.end_ea))
        minbytes = self.bitness // 8
        ea = r.start_ea

        while ea < r.end_ea:
            length = get_max_strlit_length(ea, STRTYPE_C, ALOPT_IGNHEADS | ALOPT_IGNPRINT | ALOPT_IGNCLT)
            if length < minbytes:   # FIXME
                # let skip small strlit
                ea = next_that(ea, r.end_ea, has_xref)
                continue
            # Initially dividing strings by xrefs
            end = next_that(ea, ea + length, has_xref)
            if end != BADADDR:
                length = end - ea
            length = self.check_for_strlit(ea, length)
            ea += length
        
        return True

    def check_for_strlit(self, ea: int, length: int) -> int:
        '''
        Create strlit if it has meaning.
        We should be completely sure to create a strlit
        otherwise we produce a mess:
        * try to check the xref'ed places and may be to adjust the length
        * do not forget about the classic C-like 0-terminated strings
        '''
        if self.debug:
            print("RUST: check_for_strlit %#x..%#x\n" % (ea, ea+length))

        # Usually the difference between adjusted length and input length should less then 3.
        # Turned out that find the false descriptor for C-like string is easy.
        max_len_delta = 3
        adjlen = 0      # adjusted length
        trust_counter = 0

        # at first check data refs as the more reliable way (.data.rel.ro)
        drefs = []
        xb = xrefblk_t()        # use xrefblk_t to get more info about xref
        ok = xb.first_to(ea, XREF_DATA)
        while ok:
            if xb.type != dr_O:
                ok = xb.next_to()
                continue
            frm = xb.frm
            F = get_flags(frm)
            if is_data(F):
                detected_len = self.get_strlen(frm)
                if detected_len > length:   # false alarm, must be string length at least
                    ok = xb.next_to()
                    continue
                if adjlen == 0:
                    adjlen = detected_len
                elif adjlen != detected_len:
                    return length   # every ref must describe the same strlit
                trust_counter += 1
                drefs.append(frm)
            ok = xb.next_to()

        if adjlen == 0:
            # check code refs
            ok = xb.first_to(ea, XREF_DATA)
            while ok:
                if xb.type != dr_O:
                    ok = xb.next_to()
                    continue
                frm = xb.frm
                F = get_flags(frm)
                if is_code(F):
                    detected_len = self.get_mod_strlen(frm, ea)
                    if detected_len != -1:
                        if adjlen == 0:
                            adjlen = detected_len
                        elif adjlen != detected_len:
                            return length
                        trust_counter += 1
                ok = xb.next_to()
                
        if adjlen != 0 and adjlen <= length and (trust_counter > 1 or (length - adjlen) < max_len_delta):
            if self.debug:
                print("RUST: strlit %#x..%#x\n" % (ea, ea+adjlen))
            length = adjlen
            F = get_flags(ea)
            if is_tail(F):  # preserve the strlit item head to decrease the mess
                head = get_item_head(ea)
                if is_strlit(get_flags(head)):
                    del_items(head, DELIT_SIMPLE, ea-head)
                    create_strlit(head, ea-head, STRTYPE_C)
            itemsz = get_item_size(ea)
            del_items(ea, DELIT_SIMPLE, length)
            create_strlit(ea, length, STRTYPE_C)
            if is_strlit(F):
                if length < itemsz - 1:
                    create_strlit(ea + length, itemsz - length, STRTYPE_C)
                elif length == itemsz - 1:
                    create_byte(ea + length, 1, True)
            
            for dea in drefs:
                self.make_str(dea)

        return length
                    
    
```

`IDARustHelperPlugin.py`:

```py
from idaapi import *
import IDARustHelper.Demangler as Demangler
import IDARustHelper.RustType as RustType
import IDARustHelper.StringRecover.rust as StringRecover

# Register the actual plugin
class IDARustHelperHandler(plugin_t):
    PLUGIN_NAME = "IDA Rust Helper"
    PLUGIN_DIRECTORY = "IDARustHelper"
    PLUGIN_DESCRIPTION = "Rust RE Helper"

    flags = PLUGIN_UNL
    comment = PLUGIN_DESCRIPTION
    help = PLUGIN_DESCRIPTION
    wanted_name = PLUGIN_NAME
    wanted_hotkey = ""

    def init(self):
        self.demangler = Demangler.IDARustDemangler(debug=False)
        self.ctx = StringRecover.rust_ctx_t(debug=False)
        return PLUGIN_OK

    def run(self, arg):
        print(f"[*] {self.PLUGIN_NAME} started!")

        self.demangler.run()
        RustType.set_rust_type()
        self.ctx.perform_final_strlit_analysis()

        print(f"[*] {self.PLUGIN_NAME} finished!")
        return 1

    def term(self):
        pass


class IDARustDemanglerHook(ida_kernwin.UI_Hooks):
    """
    this class is only used to install the icon to the corresponding IDA action
    """

    def __init__(self, cb):
        super().__init__()
        self.cb = cb

    def updated_actions(self):
        if self.cb():
            self.unhook()


def install_icon():
    plugin_name = IDARustHelperHandler.PLUGIN_NAME
    action_name = "Edit/Plugins/" + plugin_name
    LOGO_PATH = None

    # if the action is not present wait for our hook action
    if action_name not in ida_kernwin.get_registered_actions():
        return False

    # check if in any of the IDA plugins directory if there is
    # our plugin directory and take the logo from there
    for plugin_path in get_ida_subdirs("plugins"):
        LOGO_PATH = os.path.join(
            plugin_path, f"{IDARustHelperHandler.PLUGIN_DIRECTORY}\\resource\\rust-logo.png")

        # if the file exists use the first one found
        if os.path.isfile(LOGO_PATH):
            break

    if LOGO_PATH is None:
        print("[?] IDA Rust Helper logo not found")
        return True

    # load the logo and apply it to the action
    icon = load_custom_icon(
        LOGO_PATH, format="png")

    ida_kernwin.update_action_icon(action_name, icon)

    return True


def PLUGIN_ENTRY():
    return IDARustHelperHandler()


h = IDARustDemanglerHook(install_icon)
h.hook()
```

`LICENSE`:

```
MIT License

Copyright (c) 2024 JANlittle

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# IDARustHelper

**Just a simple combination of some existing projects :)**

It can help you:

- **Demangle the Rust function name**
- **Add some Rust type**(like str, you can join more types by youself!)
- **Identify Rust strlit and rename str struct**

## Install

First, Install rust_demangler: `pip install rust_demangler`

And then, just copy the file `IDARustHelperPlugin.py` and the folder `IDARustHelper` to `${IDA_DIR}/plugins`.

## Usage

`Edit` -> `Plugins` -> `IDA Rust Helper`, and then wait a few seconds.

## Support

**Just tested on IDA Pro 7.7, python3.8 and 64bit ELF.** But it should work on Windows PE, Mach-O. 

Also should work with IDA Pro 8.x. 

Arm, RISC-V should be work well also, both 32bit and 64bit.

## Known Issue
- `callregs_t.set` need a `int const *` parm, but I really don't know how to pass it...

## How it work?

**Before I start, I would like to sincerely thank [teambi0s](https://github.com/teambi0s/rust_demangler), [timetravelthree](https://github.com/timetravelthree/IDARustDemangler), [hex-rays](https://hex-rays.com/blog/rust-analysis-plugin-tech-preview/) for their work!**

### Demangle

For the part of demangling, I combine the work of [teambi0s](https://github.com/teambi0s/rust_demangler) and [timetravelthree](https://github.com/timetravelthree/IDARustDemangler). Teambi0s's work can demangle most symbols, and timetravelthree's work was able to re-mangle the symbols to make them more friendly to display in IDA.

Re-mangle can't quite get the symbols to display perfectly in IDA, because IDA has a character limit for symbols, but I think it's enough. If you want full display, you can modify the character whitelist in `ida.cfg`(like `NameChars` variant) to bypass the restriction.

### Add Rust type

Just definde them in C declation and parse them! You can see `RustType.py` to get implementation details.

### Identify Rust strlit

For this part, I just simply ported the [hex-rays plugin](https://hex-rays.com/blog/rust-analysis-plugin-tech-preview/) to idapython. It follows the following basic idea:

1. Scan the entire read-only data segment to find long strings and initially split them based on xrefs.
2. Depending on the location of the xrefs, they are categorised into data references and code references, and different methods are used to detect their legitimacy.
3. For data references, some string literals are referenced in a form similar to golang's str structure, and we can find them in places like .data.rel.ro segments. Sometimes a literal is referenced by many str structures, and the length of the string literal is finally determined by traversing them and comparing them to the length of the initial division.
4. For code references, some string literals and their lengths are reflected directly in the assignment of instructions, the actual form of which will vary depending on the machine. The final length of the string is found by pattern matching.
5. Finally, all found str structures will be typed and renamed to make it easier to analyse in the code.




```