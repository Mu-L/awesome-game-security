Project Path: arc_mizt0_mixed-boolean-transform_vu5cxo8v

Source Tree:

```txt
arc_mizt0_mixed-boolean-transform_vu5cxo8v
├── README.md
├── testing
│   ├── main.cpp
│   ├── main_o.cpp
│   └── main_o.py
├── transform
│   ├── engine.cpp
│   ├── engine.h
│   ├── evaluate.cpp
│   ├── evaluate.h
│   ├── table.cpp
│   ├── table.h
│   ├── transform.cpp
│   ├── transform.filters
│   ├── transform.vcxproj
│   └── util.h
└── transform.sln

```

`README.md`:

```md

# mixed-boolean-transform
A proof-of-concept program that generates mixed boolean arithmetic expressions capable of hiding information, such as constants within source code.


## Dependencies 
This project requires `z3` , `gmp` , and `eigen3` libraries to be installed on your system. Use `vcpkg` to install these dependencies as it simplifies the process. 

## Installation  

1. Install vcpkg If you don't have `vcpkg` installed on your system, follow the instructions in the official vcpkg repository: [vcpkg](https://github.com/microsoft/vcpkg)
2.  Open a terminal or command prompt and run the following commands using `vcpkg`: 
  
```bash 
# Install z3 
vcpkg install z3 
# Install gmp 
vcpkg install gmp
# Install eigen3
vcpkg install eigen3
```
## Example Use
```cpp
#include <iostream>

// insert zero mba in between x + mba + y
int fun_a(int x, int y){
	return x + y;  
}

int fun_b(int x, int y){
	int z = fun_a(x, y);
	int q = 1020; // constant mba 
	return z + q; 
}

int fun_c(int x, int y){
	int n = x + y; // insert zero mba in between x + mba + y
	return fun_b(x, y); 
	
}

int main() {
	std::cout << "Value is: " << fun_c(40,20) << std::endl;  
	return 0; // Will print 1080
}
```
In this C++ file, we can easily trace that the value will be printed is 1080.

```cpp
#include <iostream>

int fun_a(int x, int y){
    return x + ((346944530715156030497453)*((-2*(~(x | y))+-1*(x & ~y)+1*(~y)+1*(~(x | y)))+(308924813101144738138186))+(285590800713089855787518))%2**79 + y;
}

int fun_b(int x, int y){
    int z = fun_a(x, y);
    return z + ((312646088269814805846141)*((-2*(x & y)+-2*(x ^ y)+1*(x | y)+1*(x | y))+(223327974010260293607636064))+(539947916355369829107996))%2**79; 
}

int fun_c(int x, int y){
    int n = x + ((3174376919201385605733)*((-1*(x | ~y)+1*(y)+-1*(~(x & y))+2*(~y))+(151660436265643080081342))+(589456583812029285273098))%2**79 + y;
    return fun_b(x, y);
    
}

int main() {
    std::cout << "Value is: " << fun_c(40,20) << std::endl;  
    return 0;
```
After, it is now difficult to see what will be printed after passing `40, 20`

## Limitations
It is possible to apply this source-to-source constant transformation on C++ files; however, parsing and handling large integer types would need to be taken into consideration.





```

`testing/main.cpp`:

```cpp
#include <iostream>

// insert zero mba in between x + mba + y
int fun_a(int x, int y){
	return x + y;  
}

int fun_b(int x, int y){
	int z = fun_a(x, y);
	int q = 1020; // constant mba 
	return z + q; 
}

int fun_c(int x, int y){
	int n = x + y; // insert zero mba in between x + mba + y
	return fun_b(x, y);
	
}

int main() {
	std::cout << "Value is: " << fun_c(40,20) << std::endl;  
	return 0;
}

```

`testing/main_o.cpp`:

```cpp
#include <iostream>

int fun_a(int x, int y){
    return x + ((346944530715156030497453)*((-2*(~(x | y))+-1*(x & ~y)+1*(~y)+1*(~(x | y)))+(308924813101144738138186))+(285590800713089855787518))%2**79 + y;
}

int fun_b(int x, int y){
    int z = fun_a(x, y);
    return z + ((312646088269814805846141)*((-2*(x & y)+-2*(x ^ y)+1*(x | y)+1*(x | y))+(223327974010260293607636064))+(539947916355369829107996))%2**79; 
}

int fun_c(int x, int y){
    int n = x + ((3174376919201385605733)*((-1*(x | ~y)+1*(y)+-1*(~(x & y))+2*(~y))+(151660436265643080081342))+(589456583812029285273098))%2**79 + y;
    return fun_b(x, y);
    
}

int main() {
    std::cout << "Value is: " << fun_c(40,20) << std::endl;  
    return 0;
}


// Must be rewritten because C++ doesn't have built-in big integer types by default
// 

```

`testing/main_o.py`:

```py
def fun_a(x, y):
    return x + ((346944530715156030497453)*((-2*(~(x | y))+-1*(x & ~y)+1*(~y)+1*(~(x | y)))+(308924813101144738138186))+(285590800713089855787518)) % (2**79) + y

def fun_b(x, y):
    z = fun_a(x, y)
    return z + ((312646088269814805846141)*((-2*(x & y)+-2*(x ^ y)+1*(x | y)+1*(x | y))+(223327974010260293607636064))+(539947916355369829107996)) % (2**79)

def fun_c(x, y):
    n = x + ((3174376919201385605733)*((-1*(x | ~y)+1*(y)+-1*(~(x & y))+2*(~y))+(151660436265643080081342))+(589456583812029285273098))%2**79 + y
    return fun_b(x, y)

if __name__ == "__main__":
    print("Value is:", fun_c(40, 20))

# This is just to test if it will  evaluate to 1080

```

`transform.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.33529.622
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "transform", "transform\transform.vcxproj", "{7661CFEC-899F-4253-AA2F-6DDFD24FFFAE}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{7661CFEC-899F-4253-AA2F-6DDFD24FFFAE}.Debug|x64.ActiveCfg = Debug|x64
		{7661CFEC-899F-4253-AA2F-6DDFD24FFFAE}.Debug|x64.Build.0 = Debug|x64
		{7661CFEC-899F-4253-AA2F-6DDFD24FFFAE}.Debug|x86.ActiveCfg = Debug|Win32
		{7661CFEC-899F-4253-AA2F-6DDFD24FFFAE}.Debug|x86.Build.0 = Debug|Win32
		{7661CFEC-899F-4253-AA2F-6DDFD24FFFAE}.Release|x64.ActiveCfg = Release|x64
		{7661CFEC-899F-4253-AA2F-6DDFD24FFFAE}.Release|x64.Build.0 = Release|x64
		{7661CFEC-899F-4253-AA2F-6DDFD24FFFAE}.Release|x86.ActiveCfg = Release|Win32
		{7661CFEC-899F-4253-AA2F-6DDFD24FFFAE}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {EE93378D-1B4D-4A00-839B-0E1656CFAD64}
	EndGlobalSection
EndGlobal

```

`transform/engine.cpp`:

```cpp
#include "engine.h"
#include <iostream>

Engine::Engine(int t) : V(ctx), solver(ctx)
{
    this->t = t;
    b << 0, 0, 0, 0;

    for (int i = 0; i < t; ++i) {
        std::string var_name = "x" + std::to_string(i);
        V.push_back(ctx.int_const(var_name.c_str()));
    }

    for (unsigned i = 0; i < V.size(); ++i) {
        std::cout << "Solve for: " << V[i] << std::endl;
    }

    // constraint: var != 0 
    for (unsigned i = 0; i < V.size(); ++i) {
        solver.add(V[i] != 0); //  can't be zero vector 
    }



    // Check if the constraints are satisfiable
    //if (solver.check() == z3::sat) {
}

void Engine::add_matrix(Eigen::MatrixXi F)
{
    for (int i = 0; i < r; ++i) {
        z3::expr_vector row_expr(ctx);
        for (int j = 0; j < t; ++j) {
            row_expr.push_back(F(i, j) * V[j]);
        }
        std::cout << "b(i) " << b(i) << std::endl;
        solver.add(z3::sum(row_expr) == b(i));
    }
    matrix_present = true;
}

bool Engine::execute(Eigen::VectorXd &sorted_sol)
{
    if (!matrix_present) {
        std::cout << "Add matrix first!\n";
        return false;
    }
	
    if (solver.check() == z3::sat) {
        std::cout << "Constraint satisfied\n";


        z3::model model = solver.get_model();
        //Eigen::VectorXd sorted_sol(t);
        for (int i = 0; i < t; ++i) {
            std::string var_name = "v" + std::to_string(i);
            int value = model.eval(V[i]).get_numeral_int();
            std::cout << value << ", ";
            sorted_sol(i) = value;
        }
        std::cout << "<- Engine Solved\n";
        return true;
    }
    else {
        std::cout << "Constraint not satisfied\n";
    }
    return false;
}

```

`transform/engine.h`:

```h
#pragma once
#include <z3++.h>
#include <Eigen/Dense>

class Engine {
public:
	Engine(int t);
	void add_matrix(Eigen::MatrixXi matrix);
	bool execute(Eigen::VectorXd& sorted_sol);
private:
	int t;  // desired number of variables that must evaluate to 0
	z3::context ctx;
	z3::expr_vector V; // xpr_vector to store the integer variables
	z3::solver solver;
	Eigen::Vector4i b;
	bool matrix_present = false;
	const int r = 4;
};

```

`transform/evaluate.cpp`:

```cpp
#pragma warning(disable:4146)
#include "evaluate.h"
#include <iostream>
#include "util.h"

#include <gmp.h>
#include <regex>


Evaluate::Evaluate(int t) : solution(t)
{

}

std::string Evaluate::get_expression(Table &table)
{
    std::cout << "Solution from Z3: \n" << solution << std::endl;
    std::vector<std::vector<int>> initial_table = table.initial_truth_table;
    auto current_matrix = table.get_matrix();

    std::cout << "current matrix size should be 4: " << current_matrix.innerSize() << std::endl;
    std::string result = "";
    for (int i = 0; i < current_matrix.innerSize(); i++) {

        auto truth_vec = initial_table[i]; // error here
        std::cout << "test:\n";
        print_vec(truth_vec);

        //std::vector<int> cur_temp = column_matrix[i];

        std::string to_expr = get_expr_from_vec(truth_vec);

        std::ostringstream ss;
        ss.precision(0);
        ss << std::fixed << solution(i);
        std::cout << ss.str() << std::endl;

        result.append(ss.str());
        result.append("*");
        result.append(to_expr);

        if (i != current_matrix.innerSize()- 1)
        result.append("+");
    }

    //std::cout << result << std::endl;
    return result;
}


std::pair<std::pair<std::string, std::string>, std::pair<std::string, std::string>> get_invertible_affine(int n) {
    mpz_t one, a_value, b_value;  // https://stackoverflow.com/questions/30942413/c-gmp-generating-random-number   
    mpz_init(one);
    mpz_init(a_value);
    mpz_init(b_value);
    // setup random 
    gmp_randstate_t rstate;
    gmp_randinit_mt(rstate);
    gmp_randseed_ui(rstate, std::time(0));
    // a start
    mpz_set_ui(one, 1); // for calculating the random number floor
    mpz_urandomb(a_value, rstate, n);  // generate a random integer in the range [0, (2^n)-1]
    mpz_add(a_value, a_value, one); // low floor (case b)
    const char* a_value_str = mpz_get_str(NULL, 10, a_value);
    std::cout << "(a) random number generated 0-2^n-1: " << a_value_str << std::endl;
    // b start 
    mpz_urandomb(b_value, rstate, n);
    mpz_sub(b_value, b_value, one);
    const char* b_value_str = mpz_get_str(NULL, 10, b_value);
    std::cout << "(b) random number generated 0-2^n-1: " << b_value_str << std::endl;
    //    code 3 (0x3).
    mpz_t modulus;
    mpz_init(modulus);
    mpz_ui_pow_ui(modulus, 2, n);

    mpz_t a_inv, negative_one;
    mpz_init(a_inv);

    mpz_init(negative_one);
    mpz_set_si(negative_one, -1); // https://stackoverflow.com/questions/11181172/using-the-mpz-powm-functions-from-the-gmp-mpir-libraries-with-negative-exponents

    mpz_powm(a_inv, a_value, negative_one, modulus);

    const char* a_inv_str = mpz_get_str(NULL, 10, a_inv);
    std::cout << "(a)inverse: " << a_inv_str << std::endl;

    mpz_t b_inv;
    mpz_init(b_inv);

    mpz_t a_inv_neg;
    mpz_init(a_inv_neg);

    mpz_neg(a_inv_neg, a_inv);
    mpz_mul(b_inv, a_inv_neg, b_value);

    std::cout << " test -a_inv * b : " << mpz_get_str(NULL, 10, b_inv) << std::endl;

    mpz_mod(b_inv, b_inv, modulus);
    const char* b_inv_str = mpz_get_str(NULL, 10, b_inv);
    std::cout << "(b)inverse: " << b_inv_str << std::endl;

    return std::make_pair(std::make_pair(a_value_str, b_value_str), std::make_pair(a_inv_str, b_inv_str));
}

std::string solv(const std::string& input) {
    const std::regex pattern(R"(\((\d+)\)\s*\*\s*\((\d+)\)\s*\+\s*\((\d+)\))");
    std::string first_match, second_match, third_match;
    mpz_t x_value, y_value, z_value, result;
    std::smatch matches;
    mpz_init(x_value);
    mpz_init(y_value);
    mpz_init(z_value);
    mpz_init(result);
    std::string out = "";

    if (std::regex_match(input, matches, pattern)) {
        first_match = matches[1].str();
        second_match = matches[2].str();
        third_match = matches[3].str();
        std::cout << "found: " << first_match;
        std::cout << "\nfound: " << second_match;
        std::cout << "\nfound: " << third_match;
        mpz_set_str(x_value, first_match.c_str(), 10);
        mpz_set_str(y_value, second_match.c_str(), 10);
        mpz_set_str(z_value, third_match.c_str(), 10);

        mpz_mul(result, x_value, y_value);
        mpz_add(result, result, z_value);
        out = mpz_get_str(NULL, 10, result);
    }

    std::cout << "solved  p (eval) = " << out << std::endl;
    return out;
}

void Evaluate::constant(std::string& z) {
    int k = 1020;  // put the constant here, for example : 1020
    int k_shift = 1020;
    int k_bit_len = 0;

    while (k_shift > 0) {
        k_shift >>= 1;
        k_bit_len++;
    }

    std::random_device rd;
    std::mt19937 generator(rd());

    int minVal = k_bit_len + 1;
    std::cout << "k bit len + 1 : " << minVal << std::endl;
    int maxVal = 100;

    std::uniform_int_distribution<int> distribution(minVal, maxVal);
    int n = distribution(generator);
    std::cout << "N value argument: " << n << std::endl;

    auto coeffs = get_invertible_affine(n);

    std::cout << "coeffs: " << coeffs.first.first << " " << coeffs.first.second << " " << coeffs.second.first << " " << coeffs.second.second << std::endl;
    std::string to_replace = "replace";
    std::string p = "(" + coeffs.first.first + ")" + +"*(" + std::to_string(k) + ")+(" + coeffs.first.second + ")";
    std::string q = "(" + coeffs.second.first + ")" + "*(" + to_replace + ")+(" + coeffs.second.second + ")";

    std::cout << "P: " << p << std::endl;
    std::cout << "Q: " << q << std::endl;


    // p val
    std::cout << "p_val not eval " << p << std::endl;

    std::string p_val = solv(p);
    std::cout << "p_val evaluated: " << p_val << std::endl;

    // 114503850325760475253189*(129)+(313523368772846873043148)

    size_t pos = q.find(to_replace);
    if (pos != std::string::npos)
        q.replace(pos, to_replace.length(), "(" + z + ")+(" + p_val + ")");
    // q val

    std::string out = "(" + q + ")" + "%2**" + std::to_string(n);

    std::cout << " go: " << out << std::endl;
}

```

`transform/evaluate.h`:

```h
#pragma once
#include <Eigen/Dense>
#include "table.h"
class Evaluate {
public:
	Evaluate(int t);
	Eigen::VectorXd solution;
	std::string get_expression(Table& table);
	void constant(std::string& z);
private:

};
```

`transform/table.cpp`:

```cpp
#include "table.h"
#include <iostream>


Table::Table(int t= 4) : rng(std::time(0)), dist(0, ExpressionTruthTableVec.size() - 1), column_matrix(4, 4) { //5 
    this->t = t;
    
     // k =t
    for (int i = 0; i < t; ++i) {
        std::size_t idx = dist(rng);
        std::cout << "random index: " << idx << std::endl;
        initial_truth_table.push_back(ExpressionTruthTableVec[idx].truth_table);
    }

    //    std::vector<int> l1 = { 1, 0, 1, 1 };
    //    std::vector<int> l2 = { 0, 1, 1, 0 };
    //    std::vector<int> l3 = { 0, 1, 0, 0 };
    //    std::vector<int> l4 = { 1, 0, 0, 1 };
    //initial_truth_table.push_back(l1);
    //initial_truth_table.push_back(l2);
    //initial_truth_table.push_back(l3);
    //initial_truth_table.push_back(l4); 

    // fix to add variables
    for (const auto& vec : initial_truth_table) {
        Eigen::VectorXd _vec(4); // truth vec 
        std::cout << "Push row as VectorXd:";
        for (int i = 0; i < 4; ++i) {
            std::cout << " " << vec[i];
            _vec[i] = vec[i];
        }
        std::cout << " <" << std::endl;

        initial_truth_table_eig.push_back(_vec);
    }


    // Stack the column vectors horizontally to create a matrix
    //for (const auto& vecxd : initial_truth_table_eig) {
    //    column_matrix << vecxd;
    //} doesn't work for some reason

    for (size_t i = 0; i < initial_truth_table_eig.size(); ++i) {
        column_matrix.col(i) = initial_truth_table_eig[i];
    }


    //column_matrix << initial_truth_table_eig[0], initial_truth_table_eig[1], initial_truth_table_eig[2], initial_truth_table_eig[3];
    
   
    
    std::cout << "Column Matrix: (stacked by column) \n" << column_matrix << std::endl;
 
}

Eigen::Matrix<int, Eigen::Dynamic, Eigen::Dynamic> Table::get_matrix()
{
    std::cout << "Get Matrix\n";
    Eigen::Matrix<int, Eigen::Dynamic, Eigen::Dynamic> F(r, c);
    for (int i = 0; i < r; ++i) {
        for (int j = 0; j < c; ++j) {
            F(i, j) = column_matrix(i, j);
        }
    }

    //for (int i = 0; i < r; ++i) {
    //    for (int j = 0; j < c; ++j) {
    //        std::cout << F(i, j) << " ";
    //    }
    //    std::cout << std::endl;
    //}
        return F;
}


```

`transform/table.h`:

```h
#pragma once

#include <string>
#include <vector>
#include <random>
#include <ctime>
#include <Eigen/Dense>
#include <Eigen/Core>
struct ExpressionTruthTable {
    std::string expression;
    std::vector<int> truth_table;
};

inline std::vector<ExpressionTruthTable> ExpressionTruthTableVec = {
   {"(x & y)",    {0, 0, 0, 1}},
   {"(x & ~y)",   {0, 0, 1, 0}},
   {"(x)",        {0, 0, 1, 1}},
   {"(~x & y)",   {0, 1, 0, 0}},
   {"(y)",        {0, 1, 0, 1}},
   {"(x ^ y)",    {0, 1, 1, 0}},
   {"(x | y)",    {0, 1, 1, 1}},
   {"(~(x | y))", {1, 0, 0, 0}},
   {"(~(x ^ y))", {1, 0, 0, 1}},
   {"(~y)",       {1, 0, 1, 0}},
   {"(x | ~y)",   {1, 0, 1, 1}},
   {"(~x)",       {1, 1, 0, 0}},
   {"(~x | y)",   {1, 1, 0, 1}},
   {"(~(x & y))", {1, 1, 1, 0}},
   {"(-1)",       {1, 1, 1, 1}}
};

class Table {
public:
    int t; // number of expressions (truth table)
    Eigen::Matrix<int, Eigen::Dynamic, Eigen::Dynamic> get_matrix();
    std::vector<std::vector<int>> initial_truth_table{}; // first 4 random ->  use for eval
    Table(int t);
private:
    std::mt19937 rng;
    std::uniform_int_distribution<std::size_t> dist;
    std::vector< Eigen::VectorXd> initial_truth_table_eig{};
    Eigen::MatrixXd column_matrix;
    const int r = 4;
    const int c = 4;
};
```

`transform/transform.cpp`:

```cpp
#include <iostream>
#include <vector>
#include <random>
#include <Eigen/Dense>
#include <z3++.h>
#include "table.h"
#include "engine.h"
#include "evaluate.h"
#include "util.h"

int main() {
    std::string z;
    // to obfuscate constants and expressions
    int var_count = 4; 
    bool satsfied = false;
    while (!satsfied) {
        Table table = Table(var_count);
        Engine engine = Engine(var_count);
        Evaluate eval = Evaluate(var_count);

        auto F = table.get_matrix(); // by column already
        std::cout << "F: \n" << F << std::endl;
        engine.add_matrix(F);

        //std::cout << "debug this: \n";
        std::cout << "Use to eval:\n" << eval.solution << std::endl;
        satsfied = engine.execute(eval.solution);
        if (satsfied) {
            std::cout << " eval is :\n" << eval.solution << std::endl;
            std::cout << "final: " << eval.get_expression(table) << std::endl;
            z = eval.get_expression(table);

            eval.constant(z);
        }
    }



    std::cout << "complete\n";
    return 0;
}



```

`transform/transform.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="transform.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="table.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="engine.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="evaluate.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="table.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="engine.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="evaluate.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="util.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`transform/transform.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{7661cfec-899f-4253-aa2f-6ddfd24fffae}</ProjectGuid>
    <RootNamespace>mbamath</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>mba-transform</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp17</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="engine.cpp" />
    <ClCompile Include="evaluate.cpp" />
    <ClCompile Include="transform.cpp" />
    <ClCompile Include="table.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="engine.h" />
    <ClInclude Include="evaluate.h" />
    <ClInclude Include="table.h" />
    <ClInclude Include="util.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`transform/util.h`:

```h

#pragma once
#include <vector>
#include <iostream>
#include "table.h"

inline void print_vec(std::vector<int>& tt) {
    for (int val : tt) {
        std::cout << val << ", ";
    }
    std::cout << "\n";

}

inline std::string get_expr_from_vec(const std::vector<int>& inputVector) {

    std::cout << "[=]Truth table to converted to expression: " << std::endl;
    for (int value : inputVector) {
        std::cout << value << " ";
    }
    std::cout << std::endl;

    for (const auto& match : ExpressionTruthTableVec) {

        if (match.truth_table == inputVector) {
            std::cout << "[=] Converted to: " << match.expression << std::endl;
            return match.expression;
        }
    }


    return "";
}


```