Project Path: arc_mastercodeon314_KsDumper-11_abyml4ty

Source Tree:

```txt
arc_mastercodeon314_KsDumper-11_abyml4ty
├── DarkControls
│   ├── BlankForm.Designer.cs
│   ├── BlankForm.cs
│   ├── BlankForm.resx
│   ├── Controls
│   │   ├── AppIcon.cs
│   │   ├── CloseButton.cs
│   │   ├── CustomCheckedListBox.cs
│   │   ├── CustomScrollBar.cs
│   │   ├── CustomStatusStrip.cs
│   │   ├── DarkButton.cs
│   │   ├── DarkCheckBox.cs
│   │   ├── DarkListView.cs
│   │   ├── DarkSelectFileButton.cs
│   │   ├── DarkTextBox.cs
│   │   ├── FlatComboBox.cs
│   │   ├── FlatScrollBar.cs
│   │   ├── FlatScrollBar1.cs
│   │   ├── MaximizeButton.cs
│   │   ├── MinimizeButton.cs
│   │   ├── NoFocusCueBotton.cs
│   │   ├── ProgressBarEx.cs
│   │   ├── SimpleColorTransforms.cs
│   │   ├── TransparentLabel.cs
│   │   ├── VisualStudioTabControl.cs
│   │   └── WindowsDefaultTitleBarButton.cs
│   ├── DarkControls.csproj
│   ├── Properties
│   │   ├── AssemblyInfo.cs
│   │   ├── Resources.Designer.cs
│   │   └── Resources.resx
│   ├── Utils.cs
│   ├── icons8-crossed-axes-100.png
│   └── selectFileBtn.Image.png
├── DriverInterface
│   ├── BSOD.cs
│   ├── CancelableTask.cs
│   ├── CrashMon.cs
│   ├── Driver
│   │   ├── KsDumperDriver.sys
│   │   ├── ManualLoader.bat
│   │   ├── Taigei64.dll
│   │   ├── drv64.dll
│   │   └── kdu.exe
│   ├── DriverInterface.csproj
│   ├── KduProvider.cs
│   ├── KduProviderSettings.cs
│   ├── KduSelfExtract.cs
│   ├── KduWrapper.cs
│   ├── KsDumperDriverInterface.cs
│   ├── Operations.cs
│   ├── PE
│   │   ├── 32
│   │   │   ├── PE32File.cs
│   │   │   └── PE32Header.cs
│   │   ├── 64
│   │   │   ├── PE64File.cs
│   │   │   └── PE64Header.cs
│   │   ├── DOSHeader.cs
│   │   ├── NativePEStructs.cs
│   │   ├── PEFile.cs
│   │   └── PESection.cs
│   ├── ProcessDumper.cs
│   ├── ProcessSummary.cs
│   ├── Properties
│   │   ├── AssemblyInfo.cs
│   │   ├── Resources.Designer.cs
│   │   └── Resources.resx
│   ├── Utility
│   │   ├── Logger.cs
│   │   ├── MarshalUtility.cs
│   │   ├── ProcessListView.cs
│   │   └── WinApi.cs
│   └── packages.config
├── KsDumper11
│   ├── Default.ico
│   ├── Driver
│   │   ├── KsDumperDriver.sys
│   │   ├── ManualLoader.bat
│   │   ├── Taigei64.dll
│   │   ├── drv64.dll
│   │   └── kdu.exe
│   ├── DumperForm.Designer.cs
│   ├── DumperForm.cs
│   ├── DumperForm.resx
│   ├── JsonSettings.cs
│   ├── JsonSettingsManager.cs
│   ├── KsDumper11.csproj
│   ├── LabelDrawer.cs
│   ├── ProcessDumper.cs
│   ├── ProcessSummary.cs
│   ├── Program.cs
│   ├── Properties
│   │   ├── AssemblyInfo.cs
│   │   ├── Resources.Designer.cs
│   │   ├── Resources.cs
│   │   ├── Resources.resources
│   │   ├── Resources.resx
│   │   ├── Settings.Designer.cs
│   │   └── Settings.settings
│   ├── ProviderSelector.Designer.cs
│   ├── ProviderSelector.cs
│   ├── ProviderSelector.resx
│   ├── SnifferBypass.cs
│   ├── StartDriver.cs
│   ├── Trigger.Designer.cs
│   ├── Trigger.cs
│   ├── Trigger.resx
│   ├── TriggerForm.Designer.cs
│   ├── TriggerForm.cs
│   ├── TriggerForm.resx
│   ├── Turn_OFF_Microsoft_Vulnerable_Driver_Blocklist.reg
│   ├── Turn_ON_Microsoft_Vulnerable_Driver_Blocklist.reg
│   ├── app.manifest
│   ├── icons8-crossed-axes-100.png
│   └── packages.config
├── KsDumper11.sln
├── KsDumperDriver
│   ├── Driver.c
│   ├── KsDumperDriver.vcxproj
│   ├── KsDumperDriver.vcxproj.filters
│   ├── NTUndocumented.h
│   ├── ProcessLister.c
│   ├── ProcessLister.h
│   ├── UserModeBridge.h
│   ├── Utility.c
│   └── Utility.h
├── README.md
└── Version.json

```

`DarkControls/BlankForm.Designer.cs`:

```cs
namespace DarkControls
{
    partial class BlankForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(BlankForm));
            this.transparentLabel1 = new DarkControls.Controls.TransparentLabel();
            this.closeBtn = new DarkControls.Controls.WindowsDefaultTitleBarButton();
            this.appIcon1 = new DarkControls.Controls.AppIcon();
            ((System.ComponentModel.ISupportInitialize)(this.appIcon1)).BeginInit();
            this.SuspendLayout();
            // 
            // transparentLabel1
            // 
            this.transparentLabel1.Font = new System.Drawing.Font("Microsoft Sans Serif", 12F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.transparentLabel1.Location = new System.Drawing.Point(32, 4);
            this.transparentLabel1.Name = "transparentLabel1";
            this.transparentLabel1.Size = new System.Drawing.Size(108, 20);
            this.transparentLabel1.TabIndex = 8;
            this.transparentLabel1.Text = "Form1";
            // 
            // closeBtn
            // 
            this.closeBtn.ButtonType = DarkControls.Controls.WindowsDefaultTitleBarButton.Type.Close;
            this.closeBtn.ClickColor = System.Drawing.Color.Red;
            this.closeBtn.ClickIconColor = System.Drawing.Color.Black;
            this.closeBtn.HoverColor = System.Drawing.Color.OrangeRed;
            this.closeBtn.HoverIconColor = System.Drawing.Color.Black;
            this.closeBtn.IconColor = System.Drawing.Color.Black;
            this.closeBtn.IconLineThickness = 2;
            this.closeBtn.Location = new System.Drawing.Point(776, 0);
            this.closeBtn.Name = "closeBtn";
            this.closeBtn.Size = new System.Drawing.Size(40, 40);
            this.closeBtn.TabIndex = 7;
            this.closeBtn.Text = "windowsDefaultTitleBarButton1";
            this.closeBtn.UseVisualStyleBackColor = true;
            // 
            // appIcon1
            // 
            this.appIcon1.AppIconImage = ((System.Drawing.Image)(resources.GetObject("appIcon1.AppIconImage")));
            this.appIcon1.Image = ((System.Drawing.Image)(resources.GetObject("appIcon1.Image")));
            this.appIcon1.Location = new System.Drawing.Point(0, 1);
            this.appIcon1.Name = "appIcon1";
            this.appIcon1.Scale = 3.5F;
            this.appIcon1.Size = new System.Drawing.Size(28, 28);
            this.appIcon1.TabIndex = 9;
            this.appIcon1.TabStop = false;
            // 
            // Form1
            // 
            this.AllowDrop = true;
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(33)))), ((int)(((byte)(33)))), ((int)(((byte)(33)))));
            this.ClientSize = new System.Drawing.Size(816, 489);
            this.Controls.Add(this.appIcon1);
            this.Controls.Add(this.transparentLabel1);
            this.Controls.Add(this.closeBtn);
            this.DoubleBuffered = true;
            this.ForeColor = System.Drawing.Color.Silver;
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.None;
            this.Name = "Form1";
            this.Text = "Basic File Box";
            ((System.ComponentModel.ISupportInitialize)(this.appIcon1)).EndInit();
            this.ResumeLayout(false);

        }

        #endregion
        private DarkControls.Controls.WindowsDefaultTitleBarButton closeBtn;
        private DarkControls.Controls.TransparentLabel transparentLabel1;
        private DarkControls.Controls.AppIcon appIcon1;
    }
}


```

`DarkControls/BlankForm.cs`:

```cs
using System;
using System.IO;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.Runtime.InteropServices;
using System.Diagnostics;
using DarkControls;

namespace DarkControls
{
    public partial class BlankForm : Form
    {
        protected override CreateParams CreateParams
        {
            get
            {
                // Activate double buffering at the form level.  All child controls will be double buffered as well.
                CreateParams cp = base.CreateParams;
                cp.ExStyle |= 0x02000000;  // Turn on WS_EX_COMPOSITED
                return cp;
            }
        }

        public BlankForm()
        {

            InitializeComponent();

            this.FormBorderStyle = FormBorderStyle.None;
            this.Region = Region.FromHrgn(Utils.CreateRoundRectRgn(0, 0, Width, Height, 10, 10));
            this.closeBtn.Region = Region.FromHrgn(Utils.CreateRoundRectRgn(0, 0, closeBtn.Width, closeBtn.Height, 10, 10));
        }

        protected override void WndProc(ref Message m)
        {
            base.WndProc(ref m);
            if (m.Msg == Utils.WM_NCHITTEST)
                m.Result = (IntPtr)(Utils.HT_CAPTION);
        }
    }
}

```

`DarkControls/BlankForm.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <assembly alias="System.Drawing" name="System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
  <data name="appIcon1.AppIconImage" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        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
</value>
  </data>
  <data name="appIcon1.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAYAAAByDd+UAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8
        YQUAAAAJcEhZcwAACxEAAAsRAX9kX5EAAASJSURBVEhL7ZVrUJRVGMdfK7WaJhomMvvApQkhLnKHhQV2
        WWFZYDF2YRWWkOW2EkoiQQVoENhFRYRABBHiXojg1BgOiMOUM6iTOCjkNFLhTE3f+NQ0xVD/p3N2jlAw
        CNjUJ39f9jn///95zp5333df6SH/OzYF9LwoV2Qt2SW8+DocHfbgiH0hJuxy0CYRrRPWUpjHMzzrkIOj
        vFc4K2OXSo87Z6PTNZ/IMRvDTrvJ3nE3upyy0e9ioA0iNo9LKW3gniXDs6yH9/IZfJaILY97JrICi4g8
        zBjQ5GKjkCW3DFz0yMBesZyHa26ZuCiWkkaDjbyXz3BPR5aQl2KjoKeC0xAQaMLNQDbAbKb1wpKC0vGC
        PB3T/iYyCGkernGPZ4QkmX1ofSD7gnyWPBUyaw2eFpYkhRnxXowZQyoTfpQbcUeZhhKDy8KlU6SSvTIZ
        42EZ6Gefp/7xW5bSI1xTZaKPZ3hWOBKfoUxFiTwJU9tM+FmbhSG+lxSqR8Oet4hqOkGxabjr7g4n0SOF
        G8g2KhHfRRjJEKmn8OgkzAhrHq5FJSCCZ1h2SptCtsKSnJ2xJS4Td1vbifLeJApme1kMdTSqS0uImjrn
        EJ+CmRAZvLkel4A72h1IM8SRD6vH9IkY1Ceg2dLEiE/Aaa7FGXCDZ2INZNIlYIp7QX7kudOEme5PiA4V
        E0VoUW1puodGhZr32Uk72v9AchKm9RE4YNRhNkWHc0Y9kVGPMJ5L1GMwKQ5VyTo07tRjiGs7mMczlmw8
        fterUfJqMn76tIfoQzZTzWbz3BJ0ClRXFRCd/Xhudt8uol2RKE7VISb9FXyQEYurZgNZ8VzadsyZtmOY
        1xlqWGdocdXEMjzLeoryMon4ySrZLF3IopMtJkmOmgYWrNpHlOALhZClbC0O5ERjMDeaWl+LRi/XzOFk
        lROF0ewYHLSEGEYvhB5h/bXsZClBy5xsMXuVOFmgZj90JDYLyUK+Gt/na/Alr3PZrV4YiR+Y9q3FFBTF
        YhPvzVWIG2S1FKoQVspue7GUDqrQVrwNn/G6VEHPFKtwuURNbzOti3nzNxKxx4b3iuWDURGKk+VKDPCa
        b3ZIgdsVCvx6RqJHuVamxFC5AnW8/tdUylHVEEZUFwi7YzI8URmEycMhKDwcjP3Mu1XD/sqOB5A9zxwL
        wlHR9mDUy9BSK8MvJ0IQ85EcHnUBuFEjwzvCllhdUSej63VyuNYHQ3uCZwPQJOy10eqH9tN++KbRFwU9
        Mlg3++LrJv+Fze7BtIoWX1xr9CGrU74oZD232/zQIuzV0e2B+l5XjHV4UNmIgh7r8sJEuzdKhb2EDm9U
        dHniJkm0rsOLys64YLx7K2qFfX/6XLC/1x/XOqbnlH2BeK7fDRO9Wxees+U464Hyc24Y/9yHnu2Z/E3F
        Zoz1OSNH2MvzhTN6Lvj9+e5g+2zigCsmzzsvvYzLcf5llA+44NZI82zSBR8cZ70rX9pBR/IcccToFVuM
        Dm9BnpBXzbAT3uC9lxxx+ZLTwpvnvlzfTE9eccAmsVwzX70Em8m/vVMf8h8iSX8BwCCUC3RVqvIAAAAA
        SUVORK5CYII=
</value>
  </data>
</root>
```

`DarkControls/Controls/AppIcon.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Drawing;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.Drawing.Drawing2D;
using System.Drawing.Imaging;
using System.ComponentModel;

namespace DarkControls.Controls
{
    public class AppIcon : PictureBox
    {
        private float _Scale = 3.5f;

        [
Description("The value used to scale down the icon"),
    DefaultValue("3.5"),
            RefreshProperties(RefreshProperties.All)
]
        public float Scale
        {
            get
            {
                return _Scale;
            }
            set
            {
                _Scale = value;
                SizeF sz = calcImgSize();
                this.Image = ResizeImage(appIconImg, (int)sz.Width, (int)sz.Height);
                base.Size = new Size((int)sz.Width, (int)sz.Height);
            }
        }

        [
    DefaultValue("50, 50"),
            RefreshProperties(RefreshProperties.All)
]
        public new Size Size
        {
            get
            {
                return base.Size;
            }
            set
            {
                //SizeF sz = calcImgSize();
                //this.Image = ResizeImage(appIconImg, (int)sz.Width, (int)sz.Height);
                //base.Size = new Size((int)sz.Width, (int)sz.Height);
                base.Size = value;
            }
        }
        private bool drag = false; // determine if we should be moving the form
        private Point startPoint = new Point(0, 0); // also for the moving
        public Form DragForm { get; set; } = null;

        private Image appIconImg = Properties.Resources.icons8_crossed_axes_100;

        [
Description("The image that will be used for the icon"),
    RefreshProperties(RefreshProperties.All)
]
        public Image AppIconImage
        {
            get
            {
                return appIconImg;
            }
            set
            {
                appIconImg = value;
            }
        }

        public AppIcon()
        {
            SetStyle(ControlStyles.SupportsTransparentBackColor, true);
            BackColor = Color.FromArgb(33, 33, 33);

            this.MouseDown += AppLogo_MouseDown;
            this.MouseUp += AppLogo_MouseUp;
            this.MouseMove += AppLogo_MouseMove;
            SizeF sz = calcImgSize();
            //this.Image = ResizeImage(appIconImg, (int)sz.Width, (int)sz.Height);
            //this.Size = new Size((int)sz.Width, (int)sz.Height);

            if (this.DesignMode == false)
            {
                if (DragForm != null) DragForm.Load += DragForm_Load;
            }
        }

        private SizeF calcImgSize()
        {
            float scale = 3.5f;
            SizeF sz = new SizeF(appIconImg.Width, appIconImg.Height);
            float x = sz.Width / (float)scale;
            float y = sz.Height / (float)scale;
            return new SizeF(x, y);
        }

        private void DragForm_Load(object sender, EventArgs e)
        {
            SizeF sz = calcImgSize();
            //this.Image = ResizeImage(appIconImg, (int)sz.Width, (int)sz.Height);
            //this.Size = new Size((int)sz.Width, (int)sz.Height);
            this.Invalidate();
        }

        private void AppLogo_MouseMove(object sender, MouseEventArgs e)
        {
            if (this.drag)
            { // if we should be dragging it, we need to figure out some movement
                Point p1 = new Point(e.X, e.Y);
                Point p2 = DragForm.PointToScreen(p1);
                Point p3 = new Point(p2.X - this.startPoint.X,
                                     p2.Y - this.startPoint.Y);
                DragForm.Location = p3;
            }
        }

        private void AppLogo_MouseUp(object sender, MouseEventArgs e)
        {
            if (e.Button == MouseButtons.Left)
            {
                this.drag = false;
            }
        }

        private void AppLogo_MouseDown(object sender, MouseEventArgs e)
        {
            if (e.Button == MouseButtons.Left)
            {
                this.startPoint = e.Location;
                this.drag = true;
            }
        }

        /// <summary>
        /// Resize the image to the specified width and height.
        /// </summary>
        /// <param name="image">The image to resize.</param>
        /// <param name="width">The width to resize to.</param>
        /// <param name="height">The height to resize to.</param>
        /// <returns>The resized image.</returns>
        public static Bitmap ResizeImage(Image image, int width, int height)
        {
            var destRect = new Rectangle(0, 0, width, height);
            var destImage = new Bitmap(width, height);

            destImage.MakeTransparent();

            destImage.SetResolution(image.HorizontalResolution, image.VerticalResolution);

            using (var graphics = Graphics.FromImage(destImage))
            {
                graphics.CompositingMode = CompositingMode.SourceCopy;
                graphics.CompositingQuality = CompositingQuality.HighQuality;
                graphics.InterpolationMode = InterpolationMode.HighQualityBicubic;
                graphics.SmoothingMode = SmoothingMode.HighQuality;
                graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;

                using (var wrapMode = new ImageAttributes())
                {
                    //Color cl = Color.White;
                    wrapMode.SetColorKey(Color.FromArgb(230, 230, 230), Color.White, ColorAdjustType.Bitmap);
                    wrapMode.SetWrapMode(WrapMode.TileFlipXY);
                    graphics.DrawImage(image, destRect, 0, 0, image.Width, image.Height, GraphicsUnit.Pixel, wrapMode);
                }
            }

            return destImage;
        }
    }
}

```

`DarkControls/Controls/CloseButton.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DarkControls.Controls
{
    public class CloseButton : WindowsDefaultTitleBarButton
    {
        public CloseButton()
        {
            this.ButtonType = DarkControls.Controls.WindowsDefaultTitleBarButton.Type.Close;
            this.ClickColor = System.Drawing.Color.Red;
            this.ClickIconColor = System.Drawing.Color.Black;
            this.HoverColor = System.Drawing.Color.OrangeRed;
            this.HoverIconColor = System.Drawing.Color.Black;
            this.IconColor = System.Drawing.Color.Black;
            this.IconLineThickness = 2;
            this.Size = new System.Drawing.Size(40, 40);
            this.UseVisualStyleBackColor = true;
        }
    }
}

```

`DarkControls/Controls/CustomCheckedListBox.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.Drawing;
using System.Drawing.Text;
using System.Drawing.Drawing2D;

namespace DarkControls.Controls
{
    public class CustomCheckedListBox : CheckedListBox
    {
        public CustomCheckedListBox()
        {
            //this.SetStyle(
            //    ControlStyles.OptimizedDoubleBuffer |
            //    ControlStyles.ResizeRedraw,
            //    //ControlStyles.UserPaint,
            //    true);
            //this.DrawMode = DrawMode.OwnerDrawFixed;

            this.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(33)))), ((int)(((byte)(33)))), ((int)(((byte)(33)))));
            this.ForeColor = Color.Silver;
            this.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
            this.CheckedItemColor = System.Drawing.Color.Silver;
            this.CheckOnClick = true;
        }



        protected override void OnPaint(PaintEventArgs e)
        {
            Region iRegion = new Region(e.ClipRectangle);
            e.Graphics.FillRegion(new SolidBrush(this.BackColor), iRegion);
            if (this.Items.Count > 0)
            {
                for (int i = 0; i < this.Items.Count; ++i)
                {
                    System.Drawing.Rectangle irect = this.GetItemRectangle(i);
                    if (e.ClipRectangle.IntersectsWith(irect))
                    {
                        if ((this.SelectionMode == SelectionMode.One && this.SelectedIndex == i)
                        || (this.SelectionMode == SelectionMode.MultiSimple && this.SelectedIndices.Contains(i))
                        || (this.SelectionMode == SelectionMode.MultiExtended && this.SelectedIndices.Contains(i)))
                        {
                            OnDrawItem(new DrawItemEventArgs(e.Graphics, this.Font,
                                irect, i,
                                DrawItemState.Selected, this.ForeColor,
                                this.BackColor));
                        }
                        else
                        {
                            OnDrawItem(new DrawItemEventArgs(e.Graphics, this.Font,
                                irect, i,
                                DrawItemState.Default, this.ForeColor,
                                this.BackColor));
                        }
                        iRegion.Complement(irect);
                    }
                }
            }
            base.OnPaint(e);
        }

        protected override void OnDrawItem(DrawItemEventArgs e)
        {
            Size checkSize = CheckBoxRenderer.GetGlyphSize(e.Graphics, System.Windows.Forms.VisualStyles.CheckBoxState.CheckedNormal);
            int dx = (e.Bounds.Height - checkSize.Width) / 2;
            e.DrawBackground();
            //e.DrawFocusRectangle();
            if (this.Items.Count > 0)
            {
                //var isChecked = GetItemChecked(e.Index) ? CheckState.Checked : CheckState.Unchecked;
                bool isChecked = GetItemChecked(e.Index);//For some reason e.State doesn't work so we have to do this instead.
                //CheckBoxRenderer.DrawCheckBox(e.Graphics, new Point(dx, e.Bounds.Top + dx), isChecked ? System.Windows.Forms.VisualStyles.CheckBoxState.CheckedNormal : System.Windows.Forms.VisualStyles.CheckBoxState.UncheckedNormal);
                DarkCheckBox.DrawCheckBox(e.Graphics, new Point(dx, e.Bounds.Top + dx), this.GetItemCheckState(e.Index));
                using (StringFormat sf = new StringFormat { LineAlignment = StringAlignment.Center })
                {
                    using (Brush brush = new SolidBrush(isChecked ? CheckedItemColor : ForeColor))
                    {
                        e.Graphics.DrawString(Items[e.Index].ToString(), Font, brush, new Rectangle(e.Bounds.Height, e.Bounds.Top, e.Bounds.Width - e.Bounds.Height, e.Bounds.Height), sf);
                    }
                }
            }

            //base.OnDrawItem(e);
        }
        Color checkedItemColor = Color.Green;
        public Color CheckedItemColor
        {
            get { return checkedItemColor; }
            set
            {
                checkedItemColor = value;
                //Invalidate();
            }
        }
    }
}

```

`DarkControls/Controls/CustomScrollBar.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms.VisualStyles;
using System.Windows.Forms;

namespace DarkControls.Controls
{
    public class CustomScrollBar : Control
    {
        private Rectangle clickedBarRectangle;
        private Rectangle thumbRectangle;
        private Rectangle leftArrowRectangle;
        private Rectangle rightArrowRectangle;
        private bool leftArrowClicked = false;
        private bool rightArrowClicked = false;
        private bool leftBarClicked = false;
        private bool rightBarClicked = false;
        private bool thumbClicked = false;
        private ScrollBarState thumbState = ScrollBarState.Normal;
        private ScrollBarArrowButtonState leftButtonState =
            ScrollBarArrowButtonState.LeftNormal;
        private ScrollBarArrowButtonState rightButtonState =
            ScrollBarArrowButtonState.RightNormal;

        // This control does not allow these widths to be altered.
        private int thumbWidth = 15;
        private int arrowWidth = 17;

        // Set the right limit of the thumb's right border.
        private int thumbRightLimitRight = 0;

        // Set the right limit of the thumb's left border.
        private int thumbRightLimitLeft = 0;

        // Set the left limit of thumb's left border.
        private int thumbLeftLimit = 0;

        // Set the distance from the left edge of the thumb to the
        // cursor tip.
        private int thumbPosition = 0;

        // Set the distance from the left edge of the scroll bar track
        // to the cursor tip.
        private int trackPosition = 0;

        // This timer draws the moving thumb while the scroll arrows or
        // track are pressed.
        private Timer progressTimer = new Timer();

        public CustomScrollBar()
            : base()
        {
            this.Location = new Point(10, 10);
            this.Width = 200;
            this.Height = 20;
            this.DoubleBuffered = true;
            this.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(33)))), ((int)(((byte)(33)))), ((int)(((byte)(33)))));

            SetUpScrollBar();
            progressTimer.Interval = 20;
            progressTimer.Tick += new EventHandler(progressTimer_Tick);
        }

        // Calculate the sizes of the scroll bar elements.
        private void SetUpScrollBar()
        {
            clickedBarRectangle = ClientRectangle;
            thumbRectangle = new Rectangle(
                ClientRectangle.X + ClientRectangle.Width / 2,
                ClientRectangle.Y, thumbWidth,
                ClientRectangle.Height);
            leftArrowRectangle = new Rectangle(
                ClientRectangle.X, ClientRectangle.Y,
                arrowWidth, ClientRectangle.Height);
            rightArrowRectangle = new Rectangle(
                ClientRectangle.Right - arrowWidth,
                ClientRectangle.Y, arrowWidth,
                ClientRectangle.Height);

            // Set the default starting thumb position.
            thumbPosition = thumbWidth / 2;

            // Set the right limit of the thumb's right border.
            thumbRightLimitRight = ClientRectangle.Right - arrowWidth;

            // Set the right limit of the thumb's left border.
            thumbRightLimitLeft = thumbRightLimitRight - thumbWidth;

            // Set the left limit of the thumb's left border.
            thumbLeftLimit = ClientRectangle.X + arrowWidth;
        }

        // Draw the scroll bar in its normal state.
        protected override void OnPaint(PaintEventArgs e)
        {
            e.Graphics.Clear(BackColor);
            base.OnPaint(e);

            // Visual styles are not enabled.
            if (!ScrollBarRenderer.IsSupported)
            {
                this.Parent.Text = "CustomScrollBar Disabled";
                return;
            }

            this.Parent.Text = "CustomScrollBar Enabled";

            // Draw the scroll bar track.
            ScrollBarRenderer.DrawRightHorizontalTrack(e.Graphics,
                ClientRectangle, ScrollBarState.Normal);

            // Draw the thumb and thumb grip in the current state.
            ScrollBarRenderer.DrawHorizontalThumb(e.Graphics,
                thumbRectangle, thumbState);
            ScrollBarRenderer.DrawHorizontalThumbGrip(e.Graphics,
                thumbRectangle, thumbState);

            // Draw the scroll arrows in the current state.
            ScrollBarRenderer.DrawArrowButton(e.Graphics,
                    leftArrowRectangle, leftButtonState);
            ScrollBarRenderer.DrawArrowButton(e.Graphics,
                    rightArrowRectangle, rightButtonState);

            // Draw a highlighted rectangle in the left side of the scroll
            // bar track if the user has clicked between the left arrow
            // and thumb.
            if (leftBarClicked)
            {
                clickedBarRectangle.X = thumbLeftLimit;
                clickedBarRectangle.Width = thumbRectangle.X - thumbLeftLimit;
                ScrollBarRenderer.DrawLowerVerticalTrack(e.Graphics,
                    clickedBarRectangle, ScrollBarState.Pressed);
            }

            // Draw a highlighted rectangle in the right side of the scroll
            // bar track if the user has clicked between the right arrow
            // and thumb.
            else if (rightBarClicked)
            {
                clickedBarRectangle.X =
                    thumbRectangle.X + thumbRectangle.Width;
                clickedBarRectangle.Width =
                    thumbRightLimitRight - clickedBarRectangle.X;
                ScrollBarRenderer.DrawRightHorizontalTrack(e.Graphics,
                    clickedBarRectangle, ScrollBarState.Pressed);
            }
        }

        // Handle a mouse click in the scroll bar.
        protected override void OnMouseDown(MouseEventArgs e)
        {
            base.OnMouseDown(e);

            if (!ScrollBarRenderer.IsSupported)
                return;

            // When the thumb is clicked, update the distance from the left
            // edge of the thumb to the cursor tip.
            if (thumbRectangle.Contains(e.Location))
            {
                thumbClicked = true;
                thumbPosition = e.Location.X - thumbRectangle.X;
                thumbState = ScrollBarState.Pressed;
            }

            // When the left arrow is clicked, start the timer to scroll
            // while the arrow is held down.
            else if (leftArrowRectangle.Contains(e.Location))
            {
                leftArrowClicked = true;
                leftButtonState = ScrollBarArrowButtonState.LeftPressed;
                progressTimer.Start();
            }

            // When the right arrow is clicked, start the timer to scroll
            // while the arrow is held down.
            else if (rightArrowRectangle.Contains(e.Location))
            {
                rightArrowClicked = true;
                rightButtonState = ScrollBarArrowButtonState.RightPressed;
                progressTimer.Start();
            }

            // When the scroll bar is clicked, start the timer to move the
            // thumb while the mouse is held down.
            else
            {
                trackPosition = e.Location.X;

                if (e.Location.X < this.thumbRectangle.X)
                {
                    leftBarClicked = true;
                }
                else
                {
                    rightBarClicked = true;
                }
                progressTimer.Start();
            }

            Invalidate();
        }

        // Draw the track.
        protected override void OnMouseUp(MouseEventArgs e)
        {
            base.OnMouseUp(e);

            if (!ScrollBarRenderer.IsSupported)
                return;

            // Update the thumb position, if the new location is within
            // the bounds.
            if (thumbClicked)
            {
                thumbClicked = false;
                thumbState = ScrollBarState.Normal;

                if (e.Location.X > (thumbLeftLimit + thumbPosition) &&
                    e.Location.X < (thumbRightLimitLeft + thumbPosition))
                {
                    thumbRectangle.X = e.Location.X - thumbPosition;
                    thumbClicked = false;
                }
            }

            // If one of the four thumb movement areas was clicked,
            // stop the timer.
            else if (leftArrowClicked)
            {
                leftArrowClicked = false;
                leftButtonState = ScrollBarArrowButtonState.LeftNormal;
                progressTimer.Stop();
            }

            else if (rightArrowClicked)
            {
                rightArrowClicked = false;
                rightButtonState = ScrollBarArrowButtonState.RightNormal;
                progressTimer.Stop();
            }

            else if (leftBarClicked)
            {
                leftBarClicked = false;
                progressTimer.Stop();
            }

            else if (rightBarClicked)
            {
                rightBarClicked = false;
                progressTimer.Stop();
            }

            Invalidate();
        }

        // Track mouse movements if the user clicks on the scroll bar thumb.
        protected override void OnMouseMove(MouseEventArgs e)
        {
            base.OnMouseMove(e);

            if (!ScrollBarRenderer.IsSupported)
                return;

            // Update the thumb position, if the new location is
            // within the bounds.
            if (thumbClicked)
            {
                // The thumb is all the way to the left.
                if (e.Location.X <= (thumbLeftLimit + thumbPosition))
                {
                    thumbRectangle.X = thumbLeftLimit;
                }

                // The thumb is all the way to the right.
                else if (e.Location.X >= (thumbRightLimitLeft + thumbPosition))
                {
                    thumbRectangle.X = thumbRightLimitLeft;
                }

                // The thumb is between the ends of the track.
                else
                {
                    thumbRectangle.X = e.Location.X - thumbPosition;
                }

                Invalidate();
            }
        }

        // Recalculate the sizes of the scroll bar elements.
        protected override void OnSizeChanged(EventArgs e)
        {
            base.OnSizeChanged(e);
            SetUpScrollBar();
        }

        // Handle the timer tick by updating the thumb position.
        private void progressTimer_Tick(object sender, EventArgs myEventArgs)
        {
            if (!ScrollBarRenderer.IsSupported)
                return;

            // If an arrow is clicked, move the thumb in small increments.
            if (rightArrowClicked && thumbRectangle.X < thumbRightLimitLeft)
            {
                thumbRectangle.X++;
            }
            else if (leftArrowClicked && thumbRectangle.X > thumbLeftLimit)
            {
                thumbRectangle.X--;
            }

            // If the track bar to right of the thumb is clicked, move the
            // thumb to the right in larger increments until the right edge
            // of the thumb hits the cursor.
            else if (rightBarClicked &&
                thumbRectangle.X < thumbRightLimitLeft &&
                thumbRectangle.X + thumbRectangle.Width < trackPosition)
            {
                thumbRectangle.X += 3;
            }

            // If the track bar to left of the thumb is clicked, move the
            // thumb to the left in larger increments until the left edge
            // of the thumb hits the cursor.
            else if (leftBarClicked &&
                thumbRectangle.X > thumbLeftLimit &&
                thumbRectangle.X > trackPosition)
            {
                thumbRectangle.X -= 3;
            }

            Invalidate();
        }
    }
}

```

`DarkControls/Controls/CustomStatusStrip.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace DarkControls.Controls
{
    public class CustomStatusStrip : StatusStrip
    {
        protected override void OnPaint(PaintEventArgs e)
        {
            // Set the background color to RGB value 33, 33, 33
            this.BackColor = Color.FromArgb(33, 33, 33);

            // Set the foreground color to Silver
            this.ForeColor = Color.Silver;

            e.Graphics.Clear(this.BackColor);

            // Call the base OnPaint method to handle the actual rendering
            base.OnPaint(e);
        }

        //protected override void OnRender (ToolStripRenderEventArgs e)
        //{
        //    // Set the background color to RGB value 33, 33, 33
        //    e.Graphics.Clear(Color.FromArgb(33, 33, 33));
        //    base.OnRenderToolStripBackground(e);
        //}

        //protected override void OnRenderToolStripContentPanelBackground(ToolStripContentPanelRenderEventArgs e)
        //{
        //    e.Graphics.Clear(Color.FromArgb(33, 33, 33));
        //    base.OnRenderToolStripContentPanelBackground(e);
        //}

        //protected override void OnRenderItem(ToolStripItemRenderEventArgs e)
        //{
        //    // Set the background color to RGB value 33, 33, 33
        //    e.Item.BackColor = Color.FromArgb(33, 33, 33);

        //    // Set the foreground color to Silver
        //    e.Item.ForeColor = Color.Silver;

        //    // Call the base OnRenderItem method to handle the actual rendering
        //    base.OnRenderItem(e);
        //}
    }
}

```

`DarkControls/Controls/DarkButton.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.Drawing;

namespace DarkControls.Controls
{
    public class DarkButton : Button
    {
        public DarkButton()
        {
            this.BackColor = Color.FromArgb(33, 33, 33);
            this.ForeColor = Color.Silver;

            this.Size = new Size(75, 23);
            this.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
            this.UseVisualStyleBackColor = true;

            //this.Region = Region.FromHrgn(Utils.CreateRoundRectRgn(0, 0, Width, Height, 25, 25));
        }

        protected override void OnEnabledChanged(EventArgs e)
        {
            if (this.Enabled)
            {
                this.ForeColor = Color.Silver;
                this.Update();
                this.Invalidate();
            }
            else
            {
                this.ForeColor = Color.FromArgb(Color.Silver.R - 32, Color.Silver.G - 32, Color.Silver.B - 32);
                this.Update();
                this.Invalidate();
            }

            base.OnEnabledChanged(e);
        }
    }
}

```

`DarkControls/Controls/DarkCheckBox.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Runtime.InteropServices;
using SystemMath = System.Math;

namespace DarkControls.Controls
{
    public class DarkCheckBox : CheckBox
    {
        [DllImport("Gdi32.dll", EntryPoint = "CreateRoundRectRgn")]
        private static extern IntPtr CreateRoundRectRgn
(
int nLeftRect,     // x-coordinate of upper-left corner
int nTopRect,      // y-coordinate of upper-left corner
int nRightRect,    // x-coordinate of lower-right corner
int nBottomRect,   // y-coordinate of lower-right corner
int nWidthEllipse, // width of ellipse
int nHeightEllipse // height of ellipse
);

        public Color CheckColor { get; set; } = Color.CornflowerBlue;
        public Color BoxFillColor { get; set; } = Color.FromArgb(33, 33, 33);
        public Color BoxBorderColor { get; set; } = Color.DarkSlateBlue;
        public DarkCheckBox()
        {
            Appearance = System.Windows.Forms.Appearance.Button;
            FlatStyle = System.Windows.Forms.FlatStyle.Flat;
            TextAlign = ContentAlignment.MiddleRight;
            FlatAppearance.BorderSize = 0;
            AutoSize = false;
            Height = 16;
        }

        public static GraphicsPath RoundedRect(Rectangle bounds, int radius)
        {
            int diameter = radius * 2;
            Size size = new Size(diameter, diameter);
            Rectangle arc = new Rectangle(bounds.Location, size);
            GraphicsPath path = new GraphicsPath();

            if (radius == 0)
            {
                path.AddRectangle(bounds);
                return path;
            }

            // top left arc
            path.AddArc(arc, 180, 90);

            // top right arc
            arc.X = bounds.Right - diameter;
            path.AddArc(arc, 270, 90);

            // bottom right arc
            arc.Y = bounds.Bottom - diameter;
            path.AddArc(arc, 0, 90);

            // bottom left arc
            arc.X = bounds.Left;
            path.AddArc(arc, 90, 90);

            path.CloseFigure();
            return path;
        }

        bool mouseEntered = false;
        bool mouseDown = false;

        protected override void OnMouseEnter(EventArgs eventargs)
        {
            mouseEntered = true;
            base.OnMouseEnter(eventargs);
        }

        protected override void OnMouseLeave(EventArgs eventargs)
        {
            mouseEntered = false;
            base.OnMouseLeave(eventargs);
        }

        protected override void OnMouseDown(MouseEventArgs mevent)
        {
            if (mevent.Button == MouseButtons.Left)
            {
                mouseDown = true;
                this.Invalidate();
            }
            base.OnMouseDown(mevent);
        }

        //protected override void OnMouseMove(MouseEventArgs mevent)
        //{
        //    if (mevent.Button == MouseButtons.Left)
        //    {
        //        mouseDown = true;
        //        this.Invalidate();
        //    }
        //    base.OnMouseMove(mevent);
        //}

        protected override void OnMouseUp(MouseEventArgs mevent)
        {
            if (mevent.Button == MouseButtons.Left)
            {
                mouseDown = false;
                this.Invalidate();
            }
            base.OnMouseUp(mevent);
        }

        public static void DrawCheckBox(Graphics g, Point p, CheckState Checked)
        {
            Color BoxFillColor = Color.FromArgb(33, 33, 33);
            //using (SolidBrush brush = new SolidBrush(BoxFillColor))
            //    g.DrawString(Text, Font, brush, 26, 6);

            Point pt = new Point(4, 4);
            Rectangle rect = new Rectangle(p, new Size(12, 12));

            //if (mouseEntered)
            //{
            //    if (mouseDown)
            //    {
            //        Color col = Color.FromArgb(BoxFillColor.R - 4, BoxFillColor.G - 4, BoxFillColor.B - 4);
            //        using (GraphicsPath path = RoundedRect(rect, 4))
            //        {
            //            g.FillPath(new SolidBrush(col), path);
            //        }
            //    }
            //    else
            //    {
            //        Color col = Color.FromArgb(BoxFillColor.R + 22, BoxFillColor.G + 22, BoxFillColor.B + 22);
            //        using (GraphicsPath path = RoundedRect(rect, 4))
            //        {
            //            g.FillPath(new SolidBrush(col), path);
            //        }
            //    }
            //}
            //else
            {
                using (GraphicsPath path = RoundedRect(rect, 4))
                {
                    g.FillPath(new SolidBrush(BoxFillColor), path);
                }
            }

            if (Checked == CheckState.Checked)
            {
                using (SolidBrush brush = new SolidBrush(Color.CornflowerBlue))
                using (Font wing = new Font("Wingdings", 12f))
                    g.DrawString("ü", wing, brush, p.X - 2f, p.Y - 2f);
            }
            else if (Checked == CheckState.Indeterminate)
            {
                using (GraphicsPath path = RoundedRect(rect, 4))
                {
                    g.FillPath(new SolidBrush(Color.CornflowerBlue), path);
                }
            }

            using (GraphicsPath path = RoundedRect(rect, 4))
            {
                g.DrawPath(new Pen(Color.Silver), path);
            }
        }

        protected override void OnPaint(PaintEventArgs pevent)
        {
            //base.OnPaint(pevent);

            pevent.Graphics.Clear(BackColor);

            if (this.Enabled)
            {
                using (SolidBrush brush = new SolidBrush(ForeColor))
                    pevent.Graphics.DrawString(Text, Font, brush, 26, 6);

                Point pt = new Point(4, 4);
                Rectangle rect = new Rectangle(pt, new Size(16, 16));

                if (mouseEntered)
                {
                    if (mouseDown)
                    {
                        Color col = Color.FromArgb(BoxFillColor.R - 4, BoxFillColor.G - 4, BoxFillColor.B - 4);
                        using (GraphicsPath path = RoundedRect(rect, 4))
                        {
                            pevent.Graphics.FillPath(new SolidBrush(col), path);
                        }
                    }
                    else
                    {
                        Color col = Color.FromArgb(BoxFillColor.R + 22, BoxFillColor.G + 22, BoxFillColor.B + 22);
                        using (GraphicsPath path = RoundedRect(rect, 4))
                        {
                            pevent.Graphics.FillPath(new SolidBrush(col), path);
                        }
                    }
                }
                else
                {
                    using (GraphicsPath path = RoundedRect(rect, 4))
                    {
                        pevent.Graphics.FillPath(new SolidBrush(BoxFillColor), path);
                    }
                }

                if (Checked)
                {
                    using (SolidBrush brush = new SolidBrush(CheckColor))
                    using (Font wing = new Font("Wingdings", 12f))
                        pevent.Graphics.DrawString("ü", wing, brush, 3, 5);
                }

                using (GraphicsPath path = RoundedRect(rect, 4))
                {
                    pevent.Graphics.DrawPath(new Pen(BoxBorderColor), path);
                }
            }
            else
            {
                double brightnessDim = 0.4;
                double[] hsbForeColor = SimpleColorTransforms.RgBtoHsb(ForeColor);
                double[] hsBoxFillColor = SimpleColorTransforms.RgBtoHsb(BoxFillColor);
                double[] hsBoxBorderColor = SimpleColorTransforms.RgBtoHsb(BoxBorderColor);
                double[] hsCheckColor = SimpleColorTransforms.RgBtoHsb(CheckColor);

                hsbForeColor[1] = 0.0;
                hsbForeColor[2] -= brightnessDim;

                hsBoxFillColor[1] = 0.0;
                //hsBoxFillColor[2] -= brightnessDim;

                hsBoxBorderColor[1] = 0.0;
                hsBoxBorderColor[2] -= brightnessDim;

                hsCheckColor[1] = 0.0;
                hsCheckColor[2] -= brightnessDim;

                Color foreColor = SimpleColorTransforms.HsBtoRgb(hsbForeColor[0], hsbForeColor[1], hsbForeColor[2]);
                Color boxFillColor = SimpleColorTransforms.HsBtoRgb(hsBoxFillColor[0], hsBoxFillColor[1], hsBoxFillColor[2]);
                Color boxBorderColor = SimpleColorTransforms.HsBtoRgb(hsBoxBorderColor[0], hsBoxBorderColor[1], hsBoxBorderColor[2]);
                Color checkColor = SimpleColorTransforms.HsBtoRgb(hsCheckColor[0], hsCheckColor[1], hsCheckColor[2]);


                using (SolidBrush brush = new SolidBrush(foreColor))
                    pevent.Graphics.DrawString(Text, Font, brush, 26, 6);

                Point pt = new Point(4, 4);
                Rectangle rect = new Rectangle(pt, new Size(16, 16));

                pevent.Graphics.FillRectangle(new SolidBrush(boxFillColor), rect);

                if (Checked)
                {
                    using (SolidBrush brush = new SolidBrush(checkColor))
                    using (Font wing = new Font("Wingdings", 12f))
                        pevent.Graphics.DrawString("ü", wing, brush, 3, 5);
                }

                using (GraphicsPath path = RoundedRect(rect, 4))
                {
                    pevent.Graphics.DrawPath(new Pen(boxBorderColor), path);
                }
            }
        }
    }
}

```

`DarkControls/Controls/DarkListView.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace DarkControls.Controls
{
    public class DarkListView : ListView
    {
        public DarkListView()
        {
            this.BackColor = Color.FromArgb(33, 33, 33);
            this.ForeColor = Color.Silver;
            this.DoubleBuffered = true;
            //this.SetStyle(ControlStyles.UserPaint, true);
            this.SetStyle(ControlStyles.DoubleBuffer, true);
            //this.SetStyle(ControlStyles.AllPaintingInWmPaint, true);

            System.Windows.Forms.ListView view = this;

            colorListViewHeader(ref view, this.BackColor, this.ForeColor);
        }

        public static void colorListViewHeader(ref System.Windows.Forms.ListView list, Color backColor, Color foreColor)
        {
            list.OwnerDraw = true;
            list.DrawColumnHeader +=
                new DrawListViewColumnHeaderEventHandler
                (
                    (sender, e) => headerDraw(sender, e, backColor, foreColor)
                );
            list.DrawItem += new DrawListViewItemEventHandler(bodyDraw);
        }

        private static void headerDraw(object sender, DrawListViewColumnHeaderEventArgs e, Color backColor, Color foreColor)
        {
            using (SolidBrush backBrush = new SolidBrush(backColor))
            {
                e.Graphics.FillRectangle(backBrush, e.Bounds);
            }

            using (SolidBrush foreBrush = new SolidBrush(foreColor))
            {
                e.Graphics.DrawString(e.Header.Text, e.Font, foreBrush, e.Bounds);
            }
        }

        private static void bodyDraw(object sender, DrawListViewItemEventArgs e)
        {
            e.DrawDefault = true;
        }

        protected override void OnPaint(PaintEventArgs e)
        {
            base.OnPaint(e);
        }
    }
}

```

`DarkControls/Controls/DarkSelectFileButton.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.Drawing;

namespace DarkControls.Controls
{
    public class DarkSelectFileButton : Button
    {
        public DarkSelectFileButton()
        {
            this.BackColor = Color.FromArgb(33, 33, 33);
            this.ForeColor = Color.Silver;
            this.FlatAppearance.BorderColor = System.Drawing.Color.Silver;
            this.FlatAppearance.BorderSize = 0;
            this.FlatAppearance.MouseOverBackColor = System.Drawing.Color.Silver;
            this.Image = Properties.Resources.selectFileBtn_Image;
            this.Size = new Size(75, 23);
            this.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
            this.UseVisualStyleBackColor = true;
        }
    }
}

```

`DarkControls/Controls/DarkTextBox.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.Drawing;
using System.Windows.Forms.VisualStyles;
using System.Diagnostics;

namespace DarkControls.Controls
{
    public class DarkTextBox : System.Windows.Forms.TextBox
    {
        public DarkTextBox()
        {
            // Initialize the renderer

            this.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(33)))), ((int)(((byte)(33)))), ((int)(((byte)(33)))));
            this.ForeColor = Color.Silver;

            this.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
            this.SetStyle(
  ControlStyles.AllPaintingInWmPaint |
  ControlStyles.DoubleBuffer, true);
        }

        protected override void OnPaint(PaintEventArgs e)
        {
            //Debugger.Break();
            if (ScrollBarRenderer.IsSupported)
            {
                //Debugger.Break();
                // Draw the custom scrollbar
                ScrollBarRenderer.DrawUpperVerticalTrack(e.Graphics, new Rectangle(this.Right - 18, this.Top, 18, this.Height), ScrollBarState.Normal);
                ScrollBarRenderer.DrawLowerVerticalTrack(e.Graphics, new Rectangle(this.Right - 18, this.Top, 18, this.Height), ScrollBarState.Normal);
                ScrollBarRenderer.DrawVerticalThumb(e.Graphics, new Rectangle(this.Right - 18, this.Top, 18, this.Height), ScrollBarState.Normal);
                ScrollBarRenderer.DrawVerticalThumbGrip(e.Graphics, new Rectangle(this.Right - 18, this.Top, 18, this.Height), ScrollBarState.Normal);
            }

            base.OnPaint(e);
        }

        //protected override void WndProc(ref Message m)
        //{
        //    base.WndProc(ref m);
        //    if (m.Msg == 0x00F7)
        //    {
        //        m.Result = (IntPtr)1;
        //    }
        //}
    }
}

```

`DarkControls/Controls/FlatComboBox.cs`:

```cs
using System;
using System.ComponentModel;
using System.Drawing;
using System.Runtime.InteropServices;
using System.Windows.Forms;

namespace DarkControls.Controls
{
    public class FlatComboBox : ComboBox
    {
        private Color borderColor = Color.Gray;
        [DefaultValue(typeof(Color), "Gray")]
        public Color BorderColor
        {
            get { return borderColor; }
            set
            {
                if (borderColor != value)
                {
                    borderColor = value;
                    Invalidate();
                }
            }
        }
        private Color buttonColor = Color.LightGray;
        [DefaultValue(typeof(Color), "LightGray")]
        public Color ButtonColor
        {
            get { return buttonColor; }
            set
            {
                if (buttonColor != value)
                {
                    buttonColor = value;
                    Invalidate();
                }
            }
        }
        protected override void WndProc(ref Message m)
        {
            if (m.Msg == WM_PAINT && DropDownStyle != ComboBoxStyle.Simple)
            {
                var clientRect = ClientRectangle;
                var dropDownButtonWidth = SystemInformation.HorizontalScrollBarArrowWidth;
                var outerBorder = new Rectangle(clientRect.Location,
                    new Size(clientRect.Width - 1, clientRect.Height - 1));
                var innerBorder = new Rectangle(outerBorder.X + 1, outerBorder.Y + 1,
                    outerBorder.Width - dropDownButtonWidth - 2, outerBorder.Height - 2);
                var innerInnerBorder = new Rectangle(innerBorder.X + 1, innerBorder.Y + 1,
                    innerBorder.Width - 2, innerBorder.Height - 2);
                var dropDownRect = new Rectangle(innerBorder.Right + 1, innerBorder.Y,
                    dropDownButtonWidth, innerBorder.Height + 1);
                if (RightToLeft == RightToLeft.Yes)
                {
                    innerBorder.X = clientRect.Width - innerBorder.Right;
                    innerInnerBorder.X = clientRect.Width - innerInnerBorder.Right;
                    dropDownRect.X = clientRect.Width - dropDownRect.Right;
                    dropDownRect.Width += 1;
                }
                var innerBorderColor = Enabled ? BackColor : SystemColors.Control;
                var outerBorderColor = Enabled ? BorderColor : SystemColors.ControlDark;
                var buttonColor = Enabled ? ButtonColor : SystemColors.Control;
                var middle = new Point(dropDownRect.Left + dropDownRect.Width / 2,
                    dropDownRect.Top + dropDownRect.Height / 2);
                var arrow = new Point[]
                {
                new Point(middle.X - 3, middle.Y - 2),
                new Point(middle.X + 4, middle.Y - 2),
                new Point(middle.X, middle.Y + 2)
                };
                var ps = new PAINTSTRUCT();
                bool shoulEndPaint = false;
                IntPtr dc;
                if (m.WParam == IntPtr.Zero)
                {
                    dc = BeginPaint(Handle, ref ps);
                    m.WParam = dc;
                    shoulEndPaint = true;
                }
                else
                {
                    dc = m.WParam;
                }
                var rgn = CreateRectRgn(innerInnerBorder.Left, innerInnerBorder.Top,
                    innerInnerBorder.Right, innerInnerBorder.Bottom);
                SelectClipRgn(dc, rgn);
                DefWndProc(ref m);
                DeleteObject(rgn);
                rgn = CreateRectRgn(clientRect.Left, clientRect.Top,
                    clientRect.Right, clientRect.Bottom);
                SelectClipRgn(dc, rgn);
                using (var g = Graphics.FromHdc(dc))
                {
                    using (var b = new SolidBrush(buttonColor))
                    {
                        g.FillRectangle(b, dropDownRect);
                    }
                    using (var b = new SolidBrush(outerBorderColor))
                    {
                        g.FillPolygon(b, arrow);
                    }
                    using (var p = new Pen(innerBorderColor))
                    {
                        g.DrawRectangle(p, innerBorder);
                        g.DrawRectangle(p, innerInnerBorder);
                    }
                    using (var p = new Pen(outerBorderColor))
                    {
                        g.DrawRectangle(p, outerBorder);
                    }
                }
                if (shoulEndPaint)
                    EndPaint(Handle, ref ps);
                DeleteObject(rgn);
            }
            else
                base.WndProc(ref m);
        }

        private const int WM_PAINT = 0xF;
        [StructLayout(LayoutKind.Sequential)]
        public struct RECT
        {
            public int L, T, R, B;
        }
        [StructLayout(LayoutKind.Sequential)]
        public struct PAINTSTRUCT
        {
            public IntPtr hdc;
            public bool fErase;
            public int rcPaint_left;
            public int rcPaint_top;
            public int rcPaint_right;
            public int rcPaint_bottom;
            public bool fRestore;
            public bool fIncUpdate;
            public int reserved1;
            public int reserved2;
            public int reserved3;
            public int reserved4;
            public int reserved5;
            public int reserved6;
            public int reserved7;
            public int reserved8;
        }
        [DllImport("user32.dll")]
        private static extern IntPtr BeginPaint(IntPtr hWnd,
            [In, Out] ref PAINTSTRUCT lpPaint);

        [DllImport("user32.dll")]
        private static extern bool EndPaint(IntPtr hWnd, ref PAINTSTRUCT lpPaint);

        [DllImport("gdi32.dll")]
        public static extern int SelectClipRgn(IntPtr hDC, IntPtr hRgn);

        [DllImport("user32.dll")]
        public static extern int GetUpdateRgn(IntPtr hwnd, IntPtr hrgn, bool fErase);
        public enum RegionFlags
        {
            ERROR = 0,
            NULLREGION = 1,
            SIMPLEREGION = 2,
            COMPLEXREGION = 3,
        }
        [DllImport("gdi32.dll")]
        internal static extern bool DeleteObject(IntPtr hObject);

        [DllImport("gdi32.dll")]
        private static extern IntPtr CreateRectRgn(int x1, int y1, int x2, int y2);
    }
}

```

`DarkControls/Controls/FlatScrollBar.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DarkControls.Controls
{
    internal class FlatScrollBar
    {
    }
}

```

`DarkControls/Controls/FlatScrollBar1.cs`:

```cs
//using System;
//// Copyright (c) Smart PC Utilities, Ltd.
//// All rights reserved.

//#region References
//using System.Windows.Forms;

//using System.ComponentModel;
//using System.Linq;

//#endregion

//namespace DarkControls.Controls
//{

//    [Designer(typeof(FlatScrollBarDesigner))]
//    [ToolboxBitmap(typeof(ScrollBar))]
//    [DefaultEvent("Scroll")]
//    [DefaultProperty("Value")]
//    public partial class FlatScrollBar : Control, ITheme
//    {

//        #region Private Members

//        private const int SETREDRAW = 11; // Redraw constant

//        private bool _isUpdating; // Indicates many changes to the scrollbar are happening, so stop painting till finished.

//        private ScrollBarOrientation _orientation = ScrollBarOrientation.Vertical; // The scrollbar orientation - horizontal / vertical.
//        private ScrollOrientation _scrollOrientation = ScrollOrientation.VerticalScroll; // The scroll orientation in scroll events.

//        private Rectangle _rectClickedBar; // The clicked channel rectangle.
//        private Rectangle _rectThumb;
//        private Rectangle _rectTopArrow;
//        private Rectangle _rectBottomArrow;
//        private Rectangle _rectChannel;

//        private bool _topArrowClicked; // Indicates if top arrow was clicked.
//        private bool _bottomArrowClicked; // Indicates if down arrow was clicked.
//        private bool _topBarClicked; // Indicates if channel rectangle above the thumb was clicked.
//        private bool _bottomBarClicked; // Indicates if channel rectangle under the thumb was clicked.
//        private bool _thumbClicked; // Indicates if the thumb was clicked.

//        private ScrollBarState _thumbState = ScrollBarState.Normal; // The state of the thumb.

//        private ScrollBarArrowButtonState _topButtonState = ScrollBarArrowButtonState.UpNormal; // The state of the top arrow.
//        private ScrollBarArrowButtonState _bottomButtonState = ScrollBarArrowButtonState.DownNormal; // The state of the bottom arrow.

//        private int _minimum;
//        private int _maximum = 100;
//        private int _smallChange = 1;
//        private int _largeChange = 10;
//        private int _value;

//        private int _thumbWidth = 15;
//        private int _thumbHeight;

//        private int _arrowWidth = 15;
//        private int _arrowHeight = 17;

//        private int _thumbBottomLimitBottom; // The bottom limit for the thumb bottom.
//        private int _thumbBottomLimitTop; // The bottom limit for the thumb top.
//        private int _thumbTopLimit; // The top limit for the thumb top.
//        private int _thumbPosition; // The current position of the thumb.

//        private int _trackPosition; // The track position.

//        private readonly Timer progressTimer = new DateAndTime.Timer(); // The progress timer for moving the thumb.

//        private UITheme _theme = UITheme.VS2019LightBlue;

//        private Color _backColor = Color.FromArgb(245, 245, 245);

//        private Color _borderColor = Color.FromArgb(245, 245, 245);
//        private Color _borderColorDisabled = Color.FromArgb(245, 245, 245);

//        private readonly Color[] _thumbColors = new Color[4];
//        private readonly Color[] _arrowColors = new Color[4];

//        #endregion

//        #region Constructor

//        public FlatScrollBar()
//        {

//            SetStyle(ControlStyles.OptimizedDoubleBuffer | ControlStyles.ResizeRedraw | ControlStyles.Selectable | ControlStyles.AllPaintingInWmPaint | ControlStyles.UserPaint, true);

//            SetUpScrollBar(); // Setup the ScrollBar

//            progressTimer.Interval = 20;
//            this.progressTimer.Tick += ProgressTimerTick;

//            _thumbColors[0] = Color.FromArgb(194, 195, 201); // Normal state
//            _thumbColors[1] = Color.FromArgb(104, 104, 104); // Hover state
//            _thumbColors[2] = Color.FromArgb(91, 91, 91); // Pressed state

//            _arrowColors[0] = Color.FromArgb(134, 137, 153); // Normal state
//            _arrowColors[1] = Color.FromArgb(28, 151, 234); // Hover state
//            _arrowColors[2] = Color.FromArgb(0, 122, 204); // Pressed state

//        }

//        #endregion

//        #region Events

//        /// <summary>
//        /// Raised when the ScrollBar control is scrolled.
//        /// </summary>
//        [Category("Behavior")]
//        [Description("Raised when the ScrollBar control is scrolled.")]
//        public event ScrollEventHandler Scroll;

//        #endregion

//        #region Public Properties

//        [Category("Layout")]
//        [Description("Gets or sets the ScrollBar orientation.")]
//        [DefaultValue(ScrollBarOrientation.Vertical)]
//        public ScrollBarOrientation Orientation
//        {
//            get
//            {
//                return _orientation;
//            }
//            set
//            {

//                if (value != _orientation)
//                {

//                    _orientation = value;
//                    _scrollOrientation = value == ScrollBarOrientation.Vertical ? ScrollOrientation.VerticalScroll : ScrollOrientation.HorizontalScroll;

//                    if (DesignMode) // only in DesignMode switch width and height
//                    {
//                        Size = new Size(Height, Width);
//                    }

//                    SetUpScrollBar();

//                }

//            }
//        }

//        [Category("Behavior")]
//        [Description("Gets or sets the ScrollBar minimum value.")]
//        [DefaultValue(0)]
//        public int Minimum
//        {
//            get
//            {
//                return _minimum;
//            }
//            set
//            {

//                if (_minimum == value || value < 0 || value >= _maximum)
//                {
//                    return;
//                }

//                _minimum = value;

//                // Current value less than new minimum value - adjust
//                if (_value < value)
//                {
//                    _value = value;
//                }

//                // Current large change value invalid - adjust
//                if (_largeChange > _maximum - _minimum)
//                {
//                    _largeChange = _maximum - _minimum;
//                }

//                SetUpScrollBar();

//                if (_value < value) // Current value less than new minimum value - adjust
//                {
//                    Value = value;
//                }
//                else
//                {
//                    ChangeThumbPosition(GetThumbPosition()); // Current value is valid - adjust thumb position
//                    Refresh();
//                }

//            }
//        }

//        [Category("Behavior")]
//        [Description("Gets or sets the ScrollBar maximum value.")]
//        [DefaultValue(100)]
//        public int Maximum
//        {
//            get
//            {
//                return _maximum;
//            }
//            set
//            {

//                if (value == _maximum || value < 1 || value <= _minimum)
//                {
//                    return;
//                }

//                _maximum = value;

//                if (_largeChange > _maximum - _minimum)
//                {
//                    _largeChange = _maximum - _minimum;
//                }

//                SetUpScrollBar();

//                if (_value > _maximum)
//                {
//                    Value = _maximum;
//                }
//                else
//                {
//                    ChangeThumbPosition(GetThumbPosition());
//                    Refresh();
//                }

//            }
//        }

//        [Category("Behavior")]
//        [Description("Gets or sets the ScrollBar small change value.")]
//        [DefaultValue(1)]
//        public int SmallChange
//        {
//            get
//            {
//                return _smallChange;
//            }
//            set
//            {

//                if (value == _smallChange || value < 1 || value >= _largeChange)
//                {
//                    return;
//                }

//                _smallChange = value;
//                SetUpScrollBar();

//            }
//        }

//        [Category("Behavior")]
//        [Description("Gets or sets the ScrollBar large change value.")]
//        [DefaultValue(10)]
//        public int LargeChange
//        {
//            get
//            {
//                return _largeChange;
//            }
//            set
//            {

//                if (value == _largeChange || value < _smallChange || value < 2)
//                {
//                    return;
//                }

//                if (value > _maximum - _minimum)
//                {
//                    _largeChange = _maximum - _minimum;
//                }
//                else
//                {
//                    _largeChange = value;
//                }

//                SetUpScrollBar();

//            }
//        }

//        [Category("Behavior")]
//        [Description("Gets or sets the ScrollBar current value.")]
//        [DefaultValue(0)]
//        public int Value
//        {
//            get
//            {
//                return _value;
//            }
//            set
//            {

//                if (_value == value || value < _minimum || value > _maximum)
//                {
//                    return;
//                }

//                _value = value;
//                ChangeThumbPosition(GetThumbPosition());
//                OnScroll(new ScrollEventArgs(ScrollEventType.ThumbPosition, -1, _value, _scrollOrientation));
//                Refresh();

//            }
//        }

//        [Category("Appearance")]
//        [Description("The theme to apply to the Flat ScrollBar control.")]
//        [DefaultValue(typeof(UITheme), "1")]
//        public UITheme Theme
//        {
//            get
//            {
//                return _theme;
//            }
//            set
//            {
//                _theme = value;

//                if (_theme == UITheme.VS2019DarkBlue)
//                {

//                    _backColor = Color.FromArgb(62, 62, 66);

//                    _borderColor = Color.FromArgb(62, 62, 66);
//                    _borderColorDisabled = Color.FromArgb(62, 62, 66);

//                    _thumbColors[0] = Color.FromArgb(104, 104, 104);
//                    _thumbColors[1] = Color.FromArgb(158, 158, 158);
//                    _thumbColors[2] = Color.FromArgb(239, 235, 239);

//                    _arrowColors[0] = Color.FromArgb(153, 153, 153);
//                    _arrowColors[1] = Color.FromArgb(28, 151, 234);
//                    _arrowColors[2] = Color.FromArgb(0, 122, 204);
//                }

//                else if (_theme == UITheme.VS2019LightBlue)
//                {

//                    _backColor = Color.FromArgb(245, 245, 245);

//                    _borderColor = Color.FromArgb(245, 245, 245);
//                    _borderColorDisabled = Color.FromArgb(245, 245, 245);

//                    _thumbColors[0] = Color.FromArgb(194, 195, 201); // Normal state
//                    _thumbColors[1] = Color.FromArgb(104, 104, 104); // Hover state
//                    _thumbColors[2] = Color.FromArgb(91, 91, 91); // Pressed state

//                    _arrowColors[0] = Color.FromArgb(134, 137, 153); // Normal state
//                    _arrowColors[1] = Color.FromArgb(28, 151, 234); // Hover state
//                    _arrowColors[2] = Color.FromArgb(0, 122, 204); // Pressed state
//                }

//                else if (_theme == UITheme.Custom)
//                {
//                    ParentTheme = false;

//                }

//                Invalidate();
//            }
//        }

//        [Category("Appearance")]
//        [Description("True to allow the control to inherit the parent control style.")]
//        [DefaultValue(true)]
//        public bool ParentTheme { get; set; } = true;

//        #endregion

//        #region Public Methods

//        public void BeginUpdate()
//        {
//            NativeMethods.SendMessage(Handle, SETREDRAW, false, 0);
//            _isUpdating = true;
//        }

//        public void EndUpdate()
//        {
//            NativeMethods.SendMessage(Handle, SETREDRAW, true, 0);
//            _isUpdating = false;
//            SetUpScrollBar();
//            Refresh();
//        }

//        #endregion

//        #region Overridden Methods

//        protected virtual void OnScroll(ScrollEventArgs e)
//        {
//            ;
//#error Cannot convert RaiseEventStatementSyntax - see comment for details
//            /* Cannot convert ArgumentListSyntax, System.NullReferenceException: Object reference not set to an instance of an object.
//                           at ICSharpCode.CodeConverter.Util.SymbolExtensions.GetParameters(ISymbol symbol) in D:\GitWorkspace\CodeConverter\CodeConverter\Util\SymbolExtensions.cs:line 18
//                           at ICSharpCode.CodeConverter.CSharp.ExpressionNodeVisitor.<>c__DisplayClass127_0.<<ConvertArgumentsAsync>g__ConvertArg|0>d.MoveNext() in D:\GitWorkspace\CodeConverter\CodeConverter\CSharp\ExpressionNodeVisitor.cs:line 1585
//                        --- End of stack trace from previous location ---
//                           at ICSharpCode.CodeConverter.Common.AsyncEnumerableTaskExtensions.SelectAsync[TArg,TResult](IEnumerable`1 source, Func`2 selector) in D:\GitWorkspace\CodeConverter\CodeConverter\Common\AsyncEnumerableTaskExtensions.cs:line 0
//                           at ICSharpCode.CodeConverter.Common.AsyncEnumerableTaskExtensions.SelectAsync[TArg,TResult](IEnumerable`1 nodes, Func`3 selector) in D:\GitWorkspace\CodeConverter\CodeConverter\Common\AsyncEnumerableTaskExtensions.cs:line 0
//                           at ICSharpCode.CodeConverter.CSharp.ExpressionNodeVisitor.ConvertArgumentsAsync(ArgumentListSyntax node) in D:\GitWorkspace\CodeConverter\CodeConverter\CSharp\ExpressionNodeVisitor.cs:line 1579
//                           at ICSharpCode.CodeConverter.CSharp.ExpressionNodeVisitor.VisitArgumentList(ArgumentListSyntax node) in D:\GitWorkspace\CodeConverter\CodeConverter\CSharp\ExpressionNodeVisitor.cs:line 489
//                           at ICSharpCode.CodeConverter.CSharp.CommentConvertingVisitorWrapper.ConvertHandledAsync[T](VisualBasicSyntaxNode vbNode, SourceTriviaMapKind sourceTriviaMap) in D:\GitWorkspace\CodeConverter\CodeConverter\CSharp\CommentConvertingVisitorWrapper.cs:line 36

//                        Input: (Me, e)

//                        Context:
//                                    RaiseEvent Scroll(Me, e)

//                         */
//        }

//        protected override void OnPaint(PaintEventArgs e)
//        {

//            var g = e.Graphics;
//            g.SmoothingMode = SmoothingMode.None;

//            DrawBackground(g, ClientRectangle);
//            DrawThumb(g, _rectThumb, _thumbState);
//            DrawArrowButton(g, _rectTopArrow, _topButtonState, true, _orientation);
//            DrawArrowButton(g, _rectBottomArrow, _bottomButtonState, false, _orientation);

//            if (_topBarClicked)
//            {

//                if (_orientation == ScrollBarOrientation.Vertical)
//                {
//                    _rectClickedBar.Y = _thumbTopLimit;
//                    _rectClickedBar.Height = _rectThumb.Y - _thumbTopLimit;
//                }
//                else
//                {
//                    _rectClickedBar.X = _thumbTopLimit;
//                    _rectClickedBar.Width = _rectThumb.X - _thumbTopLimit;
//                }
//            }

//            else if (_bottomBarClicked)
//            {

//                if (_orientation == ScrollBarOrientation.Vertical)
//                {
//                    _rectClickedBar.Y = _rectThumb.Bottom + 1;
//                    _rectClickedBar.Height = _thumbBottomLimitBottom - _rectClickedBar.Y + 1;
//                }
//                else
//                {
//                    _rectClickedBar.X = _rectThumb.Right + 1;
//                    _rectClickedBar.Width = _thumbBottomLimitBottom - _rectClickedBar.X + 1;
//                }

//            }

//            using (var p = new Pen(Enabled ? _borderColor : _borderColorDisabled))
//            {
//                e.Graphics.DrawRectangle(p, 0, 0, Width - 1, Height - 1);
//            }

//        }

//        protected override void OnMouseDown(MouseEventArgs e)
//        {
//            base.OnMouseDown(e);
//            Focus();

//            if (e.Button == MouseButtons.Left)
//            {

//                Point mouseLocation = e.Location;

//                if (_rectThumb.Contains(mouseLocation))
//                {

//                    _thumbClicked = true;
//                    _thumbPosition = Conversions.ToInteger(_orientation == ScrollBarOrientation.Vertical ? mouseLocation.Y - _rectThumb.Y : mouseLocation.X - _rectThumb.X);
//                    _thumbState = ScrollBarState.Pressed;
//                    Invalidate(_rectThumb);
//                }

//                else if (_rectTopArrow.Contains(mouseLocation))
//                {

//                    _topArrowClicked = true;
//                    _topButtonState = ScrollBarArrowButtonState.UpPressed;
//                    Invalidate(_rectTopArrow);
//                    ProgressThumb(true);
//                }

//                else if (_rectBottomArrow.Contains(mouseLocation))
//                {

//                    _bottomArrowClicked = true;
//                    _bottomButtonState = ScrollBarArrowButtonState.DownPressed;
//                    Invalidate(_rectBottomArrow);
//                    ProgressThumb(true);
//                }

//                else
//                {
//                    _trackPosition = Conversions.ToInteger(_orientation == ScrollBarOrientation.Vertical ? mouseLocation.Y : mouseLocation.X);

//                    if (Conversions.ToBoolean(Operators.ConditionalCompareObjectLess(_trackPosition, _orientation == ScrollBarOrientation.Vertical ? _rectThumb.Y : _rectThumb.X, false)))
//                    {
//                        _topBarClicked = true;
//                    }
//                    else
//                    {
//                        _bottomBarClicked = true;
//                    }

//                    ProgressThumb(true);

//                }
//            }

//            else if (e.Button == MouseButtons.Right)
//            {
//                _trackPosition = Conversions.ToInteger(_orientation == ScrollBarOrientation.Vertical ? e.Y : e.X);
//            }

//        }

//        protected override void OnMouseUp(MouseEventArgs e)
//        {
//            base.OnMouseUp(e);

//            if (e.Button == MouseButtons.Left)
//            {

//                if (_thumbClicked)
//                {
//                    _thumbClicked = false;
//                    _thumbState = ScrollBarState.Normal;
//                    OnScroll(new ScrollEventArgs(ScrollEventType.EndScroll, -1, _value, _scrollOrientation));
//                }

//                else if (_topArrowClicked)
//                {
//                    _topArrowClicked = false;
//                    _topButtonState = ScrollBarArrowButtonState.UpNormal;
//                    StopTimer();
//                }

//                else if (_bottomArrowClicked)
//                {
//                    _bottomArrowClicked = false;
//                    _bottomButtonState = ScrollBarArrowButtonState.DownNormal;
//                    StopTimer();
//                }

//                else if (_topBarClicked)
//                {
//                    _topBarClicked = false;
//                    StopTimer();
//                }

//                else if (_bottomBarClicked)
//                {
//                    _bottomBarClicked = false;
//                    StopTimer();

//                }

//                Invalidate();

//            }

//        }

//        protected override void OnMouseLeave(EventArgs e)
//        {
//            base.OnMouseLeave(e);
//            ResetScrollStatus();
//        }

//        protected override void OnMouseMove(MouseEventArgs e)
//        {
//            base.OnMouseMove(e);

//            if (e.Button == MouseButtons.Left) // Moving and holding the left mouse button
//            {

//                if (_thumbClicked)
//                {

//                    int oldScrollValue = _value;

//                    int pos = Conversions.ToInteger(_orientation == ScrollBarOrientation.Vertical ? e.Location.Y : e.Location.X);

//                    if (pos <= _thumbTopLimit + _thumbPosition) // The thumb is all the way to the top
//                    {
//                        ChangeThumbPosition(_thumbTopLimit);
//                        _value = _minimum;
//                    }

//                    else if (pos >= _thumbBottomLimitTop + _thumbPosition) // The thumb is all the way to the bottom
//                    {
//                        ChangeThumbPosition(_thumbBottomLimitTop);
//                        _value = _maximum;
//                    }

//                    else // The thumb is between the ends of the track.
//                    {

//                        ChangeThumbPosition(pos - _thumbPosition);

//                        int pixelRange, thumbPos, arrowSize;

//                        // Calculate the value - first some helper variables dependent on the current orientation

//                        if (_orientation == ScrollBarOrientation.Vertical)
//                        {
//                            pixelRange = Height - 2 * _arrowHeight - _thumbHeight;
//                            thumbPos = _rectThumb.Y;
//                            arrowSize = _arrowHeight;
//                        }
//                        else
//                        {
//                            pixelRange = Width - 2 * _arrowWidth - _thumbWidth;
//                            thumbPos = _rectThumb.X;
//                            arrowSize = _arrowWidth;
//                        }

//                        float perc = 0f;

//                        if (pixelRange != 0)
//                        {
//                            perc = (thumbPos - arrowSize) / (float)pixelRange;
//                        }

//                        _value = Convert.ToInt32(perc * (_maximum - _minimum) + _minimum);

//                    }

//                    if (oldScrollValue != _value)
//                    {
//                        OnScroll(new ScrollEventArgs(ScrollEventType.ThumbTrack, oldScrollValue, _value, _scrollOrientation));
//                        Refresh();
//                    }

//                }
//            }

//            else if (!ClientRectangle.Contains(e.Location))
//            {
//                ResetScrollStatus();
//            }

//            else if (e.Button == MouseButtons.None) // Only moving the mouse
//            {

//                if (_rectTopArrow.Contains(e.Location))
//                {
//                    _topButtonState = ScrollBarArrowButtonState.UpHot;
//                    Invalidate(_rectTopArrow);
//                }

//                else if (_rectBottomArrow.Contains(e.Location))
//                {
//                    _bottomButtonState = ScrollBarArrowButtonState.DownHot;
//                    Invalidate(_rectBottomArrow);
//                }

//                else if (_rectThumb.Contains(e.Location))
//                {
//                    _thumbState = ScrollBarState.Hot;
//                    Invalidate(_rectThumb);

//                }

//            }

//        }

//        protected override void SetBoundsCore(int x, int y, int width, int height, BoundsSpecified specified)
//        {

//            if (DesignMode)
//            {

//                if (_orientation == ScrollBarOrientation.Vertical)
//                {

//                    if (height < 2 * _arrowHeight + 10)
//                        height = 2 * _arrowHeight + 10;
//                    width = SystemInformation.VerticalScrollBarWidth;
//                }

//                else
//                {

//                    if (width < 2 * _arrowWidth + 10)
//                        width = 2 * _arrowWidth + 10;
//                    height = SystemInformation.VerticalScrollBarWidth;

//                }

//            }

//            base.SetBoundsCore(x, y, width, height, specified);

//            if (DesignMode)
//                SetUpScrollBar();

//        }

//        protected override void OnSizeChanged(EventArgs e)
//        {
//            base.OnSizeChanged(e);
//            SetUpScrollBar();
//        }

//        protected override bool ProcessDialogKey(Keys keyData)
//        {

//            Keys keyUp = Keys.Up;
//            Keys keyDown = Keys.Down;

//            if (_orientation == ScrollBarOrientation.Horizontal)
//            {
//                keyUp = Keys.Left;
//                keyDown = Keys.Right;
//            }

//            if (keyData == keyUp)
//            {
//                Value -= _smallChange;
//                return true;
//            }

//            if (keyData == keyDown)
//            {
//                Value += _smallChange;
//                return true;
//            }

//            if (keyData == Keys.PageUp)
//            {
//                Value = GetValue(false, true);
//                return true;
//            }

//            if (keyData == Keys.PageDown)
//            {

//                if (Value + _largeChange > _maximum)
//                {
//                    Value = _maximum;
//                }
//                else
//                {
//                    Value += _largeChange;
//                }

//                return true;

//            }

//            if (keyData == Keys.Home)
//            {
//                Value = _minimum;
//                return true;
//            }

//            if (keyData == Keys.End)
//            {
//                Value = _maximum;
//                return true;
//            }

//            return base.ProcessDialogKey(keyData);

//        }

//        protected override void OnEnabledChanged(EventArgs e)
//        {
//            base.OnEnabledChanged(e);

//            if (Enabled)
//            {
//                _thumbState = ScrollBarState.Normal;
//                _topButtonState = ScrollBarArrowButtonState.UpNormal;
//                _bottomButtonState = ScrollBarArrowButtonState.DownNormal;
//            }
//            else
//            {
//                _thumbState = ScrollBarState.Disabled;
//                _topButtonState = ScrollBarArrowButtonState.UpDisabled;
//                _bottomButtonState = ScrollBarArrowButtonState.DownDisabled;
//            }

//            Refresh();

//        }

//        #endregion

//        #region Overriden Properties

//        protected override Size DefaultSize
//        {
//            get
//            {
//                return new Size(SystemInformation.VerticalScrollBarWidth, 200);
//            }
//        }

//        #endregion

//        #region Private Methods

//        private void SetUpScrollBar()
//        {

//            if (_isUpdating)
//                return;

//            if (_orientation == ScrollBarOrientation.Vertical)
//            {
//                _arrowHeight = 17;
//                _arrowWidth = 15;
//                _thumbWidth = 13;
//                _thumbHeight = GetThumbSize();
//                _rectClickedBar = ClientRectangle;
//                _rectClickedBar.Inflate(-1, -1);
//                _rectClickedBar.Y += _arrowHeight;
//                _rectClickedBar.Height -= _arrowHeight * 2;
//                _rectChannel = _rectClickedBar;
//                _rectThumb = new Rectangle(ClientRectangle.Right / 2 - (int)Math.Round(_thumbWidth / 2d), ClientRectangle.Y + _arrowHeight + 1, _thumbWidth, _thumbHeight);
//                _rectTopArrow = new Rectangle(ClientRectangle.Right / 2 - (int)Math.Round(_arrowWidth / 2d) + 1, ClientRectangle.Y + 1, _arrowWidth, _arrowHeight);
//                _rectBottomArrow = new Rectangle(ClientRectangle.Right / 2 - (int)Math.Round(_arrowWidth / 2d), ClientRectangle.Bottom - _arrowHeight - 1, _arrowWidth, _arrowHeight);
//                _thumbPosition = _rectThumb.Height / 2;
//                _thumbBottomLimitBottom = ClientRectangle.Bottom - _arrowHeight - 2;
//                _thumbBottomLimitTop = _thumbBottomLimitBottom - _rectThumb.Height;
//                _thumbTopLimit = ClientRectangle.Y + _arrowHeight + 2;
//            }
//            else
//            {
//                _arrowHeight = 15;
//                _arrowWidth = 17;
//                _thumbHeight = 13;
//                _thumbWidth = GetThumbSize();
//                _rectClickedBar = ClientRectangle;
//                _rectClickedBar.Inflate(-1, -1);
//                _rectClickedBar.X += _arrowWidth;
//                _rectClickedBar.Width -= _arrowWidth * 2;
//                _rectChannel = _rectClickedBar;
//                _rectThumb = new Rectangle(ClientRectangle.X + _arrowWidth + 1, ClientRectangle.Bottom / 2 - (int)Math.Round(_thumbHeight / 2d), _thumbWidth, _thumbHeight);
//                _rectTopArrow = new Rectangle(ClientRectangle.X + 2, ClientRectangle.Bottom / 2 - (int)Math.Round(_arrowHeight / 2d) + 1, _arrowWidth, _arrowHeight);
//                _rectBottomArrow = new Rectangle(ClientRectangle.Right - _arrowWidth - 2, ClientRectangle.Bottom / 2 - (int)Math.Round(_arrowHeight / 2d), _arrowWidth, _arrowHeight);
//                _thumbPosition = _rectThumb.Width / 2;
//                _thumbBottomLimitBottom = ClientRectangle.Right - _arrowWidth - 3;
//                _thumbBottomLimitTop = _thumbBottomLimitBottom - _rectThumb.Width;
//                _thumbTopLimit = ClientRectangle.X + _arrowWidth + 3;
//            }

//            ChangeThumbPosition(GetThumbPosition());
//            Refresh();

//        }

//        private void ResetScrollStatus()
//        {

//            Point pos = PointToClient(Cursor.Position);

//            if (ClientRectangle.Contains(pos))
//            {

//                if (_rectThumb.Contains(pos))
//                {

//                    _thumbState = ScrollBarState.Hot;
//                    _topButtonState = ScrollBarArrowButtonState.UpNormal;
//                    _bottomButtonState = ScrollBarArrowButtonState.DownNormal;
//                }

//                else if (_rectTopArrow.Contains(pos))
//                {

//                    _thumbState = ScrollBarState.Normal;
//                    _topButtonState = ScrollBarArrowButtonState.UpActive;
//                    _bottomButtonState = ScrollBarArrowButtonState.DownNormal;
//                }

//                else if (_rectBottomArrow.Contains(pos))
//                {

//                    _thumbState = ScrollBarState.Normal;
//                    _topButtonState = ScrollBarArrowButtonState.UpNormal;
//                    _bottomButtonState = ScrollBarArrowButtonState.DownActive;
//                }

//                else
//                {
//                    _thumbState = ScrollBarState.Normal;
//                    _topButtonState = ScrollBarArrowButtonState.UpNormal;
//                    _bottomButtonState = ScrollBarArrowButtonState.DownNormal;
//                }
//            }

//            else
//            {
//                _thumbState = ScrollBarState.Normal;
//                _topButtonState = ScrollBarArrowButtonState.UpNormal;
//                _bottomButtonState = ScrollBarArrowButtonState.DownNormal;
//            }

//            _topArrowClicked = false;
//            _bottomArrowClicked = false;
//            _topBarClicked = false;
//            _bottomBarClicked = false;

//            StopTimer();
//            Refresh();

//        }

//        private int GetValue(bool smallIncrement, bool up)
//        {

//            int newValue;

//            if (up)
//            {

//                newValue = _value - (smallIncrement ? _smallChange : _largeChange);
//                if (newValue < _minimum)
//                    newValue = _minimum;
//            }

//            else
//            {

//                newValue = _value + (smallIncrement ? _smallChange : _largeChange);
//                if (newValue > _maximum)
//                    newValue = _maximum;

//            }

//            return newValue;

//        }

//        private int GetThumbPosition()
//        {

//            int pixelRange, arrowSize;

//            if (_orientation == ScrollBarOrientation.Vertical)
//            {
//                pixelRange = Height;
//                arrowSize = _arrowHeight;
//            }
//            else
//            {
//                pixelRange = Width;
//                arrowSize = _arrowWidth;
//            }

//            int realRange = _maximum - _minimum;
//            float perc = 0f;

//            if (realRange != 0)
//            {
//                perc = (_value - (float)_minimum) / realRange;
//            }

//            return Math.Max(_thumbTopLimit, Math.Min(_thumbBottomLimitTop, Convert.ToInt32(perc * pixelRange + arrowSize)));

//        }

//        private int GetThumbSize()
//        {

//            int trackSize = Conversions.ToInteger(_orientation == ScrollBarOrientation.Vertical ? Height - 2 * _arrowHeight : Width - 2 * _arrowWidth);

//            if (_maximum == 0 || _largeChange == 0)
//            {
//                return trackSize;
//            }

//            float newThumbSize = _largeChange * (float)trackSize / _maximum;

//            return Convert.ToInt32(Math.Min(trackSize, Math.Max(newThumbSize, 10.0f)));

//        }

//        private void ChangeThumbPosition(int position)
//        {

//            if (_orientation == ScrollBarOrientation.Vertical)
//            {
//                _rectThumb.Y = position;
//            }
//            else
//            {
//                _rectThumb.X = position;
//            }

//        }

//        private void ProgressThumb(bool enableTimer)
//        {

//            int scrollOldValue = _value;
//            ScrollEventType type = ScrollEventType.First;
//            int thumbSize, thumbPos;

//            if (_orientation == ScrollBarOrientation.Vertical)
//            {
//                thumbPos = _rectThumb.Y;
//                thumbSize = _rectThumb.Height;
//            }
//            else
//            {
//                thumbPos = _rectThumb.X;
//                thumbSize = _rectThumb.Width;
//            }

//            if (_bottomArrowClicked || _bottomBarClicked && thumbPos + thumbSize < _trackPosition)
//            {

//                type = _bottomArrowClicked ? ScrollEventType.SmallIncrement : ScrollEventType.LargeIncrement;
//                _value = GetValue(_bottomArrowClicked, false);

//                if (_value == _maximum)
//                {
//                    ChangeThumbPosition(_thumbBottomLimitTop);
//                    type = ScrollEventType.Last;
//                }
//                else
//                {
//                    ChangeThumbPosition(Math.Min(_thumbBottomLimitTop, GetThumbPosition()));
//                }
//            }

//            else if (_topArrowClicked || _topBarClicked && thumbPos > _trackPosition)
//            {

//                type = _topArrowClicked ? ScrollEventType.SmallDecrement : ScrollEventType.LargeDecrement;
//                _value = GetValue(_topArrowClicked, true);

//                if (_value == _minimum)
//                {
//                    ChangeThumbPosition(_thumbTopLimit);
//                    type = ScrollEventType.First;
//                }
//                else
//                {
//                    ChangeThumbPosition(Math.Max(_thumbTopLimit, GetThumbPosition()));
//                }
//            }

//            else if (!(_topArrowClicked && thumbPos == _thumbTopLimit || _bottomArrowClicked && thumbPos == _thumbBottomLimitTop))
//            {

//                ResetScrollStatus();
//                return;

//            }

//            if (scrollOldValue != _value)
//            {

//                OnScroll(new ScrollEventArgs(type, scrollOldValue, _value, _scrollOrientation));
//                Invalidate(_rectChannel);

//                if (enableTimer)
//                    StartTimer();
//            }

//            else
//            {

//                if (_topArrowClicked)
//                {
//                    type = ScrollEventType.SmallDecrement;
//                }
//                else if (_bottomArrowClicked)
//                {
//                    type = ScrollEventType.SmallIncrement;
//                }

//                OnScroll(new ScrollEventArgs(type, _value));

//            }

//        }

//        #endregion

//        #region Timer Methods

//        private void ProgressTimerTick(object sender, EventArgs e)
//        {
//            ProgressThumb(true);
//        }

//        private void StartTimer()
//        {

//            if (!progressTimer.Enabled)
//            {
//                progressTimer.Interval = 600;
//                progressTimer.Start();
//            }
//            else
//            {
//                progressTimer.Interval = 10;
//            }

//        }

//        private void StopTimer()
//        {
//            progressTimer.Stop();
//        }

//        #endregion

//        #region Drawing Methods

//        private void DrawBackground(Graphics g, Rectangle rect)
//        {

//            if (g is null || rect.IsEmpty || g.IsVisibleClipEmpty || !g.VisibleClipBounds.IntersectsWith(rect))
//                return;

//            using (var sb = new SolidBrush(_backColor))
//            {
//                g.FillRectangle(sb, rect);
//            }

//        }

//        private void DrawThumb(Graphics g, Rectangle rect, ScrollBarState state)
//        {

//            if (g is null || rect.IsEmpty || g.IsVisibleClipEmpty || !g.VisibleClipBounds.IntersectsWith(rect) || state == ScrollBarState.Disabled)
//            {
//                return;
//            }

//            int index = 0;

//            switch (state)
//            {

//                case ScrollBarState.Hot:
//                {
//                    index = 1;
//                    break;
//                }

//                case ScrollBarState.Pressed:
//                {
//                    index = 2;
//                    break;
//                }

//            }

//            using (var sb = new SolidBrush(_thumbColors[index]))
//            {
//                g.FillRectangle(sb, rect);
//            }

//        }

//        private void DrawArrowButton(Graphics g, Rectangle rect, ScrollBarArrowButtonState state, bool arrowUp, ScrollBarOrientation orientation)
//        {

//            if (g is null || rect.IsEmpty || g.IsVisibleClipEmpty || !g.VisibleClipBounds.IntersectsWith(rect))
//            {
//                return;
//            }

//            if (orientation == ScrollBarOrientation.Vertical)
//            {
//                DrawArrowButtonVertical(g, rect, state, arrowUp);
//            }
//            else
//            {
//                DrawArrowButtonHorizontal(g, rect, state, arrowUp);
//            }

//        }

//        private void DrawArrowButtonVertical(Graphics g, Rectangle rect, ScrollBarArrowButtonState state, bool arrowUp)
//        {

//            using (var img = GetArrowDownButtonImage(state))
//            {

//                if (arrowUp)
//                    img.RotateFlip(RotateFlipType.Rotate180FlipNone);
//                g.DrawImage(img, rect);

//            }

//        }

//        private void DrawArrowButtonHorizontal(Graphics g, Rectangle rect, ScrollBarArrowButtonState state, bool arrowUp)
//        {

//            using (var img = GetArrowDownButtonImage(state))
//            {

//                if (arrowUp)
//                {
//                    img.RotateFlip(RotateFlipType.Rotate90FlipNone);
//                }
//                else
//                {
//                    img.RotateFlip(RotateFlipType.Rotate270FlipNone);
//                }

//                g.DrawImage(img, rect);

//            }

//        }

//        private Image GetArrowDownButtonImage(ScrollBarArrowButtonState state)
//        {

//            var rect = new Rectangle(0, 0, _arrowWidth, _arrowHeight);
//            var bitmap = new Bitmap(_arrowWidth, _arrowHeight, PixelFormat.Format32bppArgb);

//            using (Graphics g = Graphics.FromImage(bitmap))
//            {

//                g.SmoothingMode = SmoothingMode.None;
//                g.InterpolationMode = InterpolationMode.HighQualityBicubic;

//                int index = 0;

//                switch (state)
//                {

//                    case ScrollBarArrowButtonState.UpHot:
//                    case ScrollBarArrowButtonState.DownHot:
//                    {
//                        index = 1;
//                        break;
//                    }

//                    case ScrollBarArrowButtonState.UpActive:
//                    case ScrollBarArrowButtonState.DownActive:
//                    {
//                        index = 1;
//                        break;
//                    }

//                    case ScrollBarArrowButtonState.UpPressed:
//                    case ScrollBarArrowButtonState.DownPressed:
//                    {
//                        index = 2;
//                        break;
//                    }

//                }

//                using (var sb = new SolidBrush(_arrowColors[index]))
//                {
//                    g.FillPolygon(sb, GetDownArrow(rect));
//                }

//            }

//            return bitmap;

//        }

//        private static Point[] GetDownArrow(Rectangle r)
//        {

//            var middle = new Point(r.Left + r.Width / 2 - 1, r.Top + r.Height / 2 + 1);
//            return new[] { new Point(middle.X - 3, middle.Y - 2), new Point(middle.X + 4, middle.Y - 2), new Point(middle.X, middle.Y + 2) };

//        }

//        #endregion

//        #region Enumerations

//        private enum ScrollBarArrowButtonState
//        {

//            /// <summary>
//            /// Indicates the up arrow is in normal state.
//            /// </summary>
//            UpNormal,

//            /// <summary>
//            /// Indicates the up arrow is in hot state.
//            /// </summary>
//            UpHot,

//            /// <summary>
//            /// Indicates the up arrow is in active state.
//            /// </summary>
//            UpActive,

//            /// <summary>
//            /// Indicates the up arrow is in pressed state.
//            /// </summary>
//            UpPressed,

//            /// <summary>
//            /// Indicates the up arrow is in disabled state.
//            /// </summary>
//            UpDisabled,

//            /// <summary>
//            /// Indicates the down arrow is in normal state.
//            /// </summary>
//            DownNormal,

//            /// <summary>
//            /// Indicates the down arrow is in hot state.
//            /// </summary>
//            DownHot,

//            /// <summary>
//            /// Indicates the down arrow is in active state.
//            /// </summary>
//            DownActive,

//            /// <summary>
//            /// Indicates the down arrow is in pressed state.
//            /// </summary>
//            DownPressed,

//            /// <summary>
//            /// Indicates the down arrow is in disabled state.
//            /// </summary>
//            DownDisabled

//        }

//        private enum ScrollBarState
//        {

//            /// <summary>
//            /// Indicates a normal scrollbar state.
//            /// </summary>
//            Normal,

//            /// <summary>
//            /// Indicates a hot scrollbar state.
//            /// </summary>
//            Hot,

//            /// <summary>
//            /// Indicates an active scrollbar state.
//            /// </summary>
//            Active,

//            /// <summary>
//            /// Indicates a pressed scrollbar state.
//            /// </summary>
//            Pressed,

//            /// <summary>
//            /// Indicates a disabled scrollbar state.
//            /// </summary>
//            Disabled

//        }

//        #endregion

//    }

//}
```

`DarkControls/Controls/MaximizeButton.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DarkControls.Controls
{
    public class MaximizeButton : WindowsDefaultTitleBarButton
    {
        public MaximizeButton()
        {
            this.ButtonType = DarkControls.Controls.WindowsDefaultTitleBarButton.Type.Maximize;
            this.ClickColor = System.Drawing.Color.DodgerBlue;
            this.ClickIconColor = System.Drawing.Color.Black;
            this.HoverColor = System.Drawing.Color.SkyBlue;
            this.HoverIconColor = System.Drawing.Color.Black;
            this.IconColor = System.Drawing.Color.Black;
            this.IconLineThickness = 2;
            this.Size = new System.Drawing.Size(40, 40);
            this.UseVisualStyleBackColor = true;
        }
    }
}

```

`DarkControls/Controls/MinimizeButton.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DarkControls.Controls
{
    public class MinimizeButton : WindowsDefaultTitleBarButton
    {
        public MinimizeButton()
        {
            this.ButtonType = DarkControls.Controls.WindowsDefaultTitleBarButton.Type.Minimize;
            this.ClickColor = System.Drawing.Color.DodgerBlue;
            this.ClickIconColor = System.Drawing.Color.Black;
            this.HoverColor = System.Drawing.Color.SkyBlue;
            this.HoverIconColor = System.Drawing.Color.Black;
            this.IconColor = System.Drawing.Color.Black;
            this.IconLineThickness = 2;
            this.Size = new System.Drawing.Size(40, 40);
            this.UseVisualStyleBackColor = true;
        }
    }
}

```

`DarkControls/Controls/NoFocusCueBotton.cs`:

```cs
using System.ComponentModel;
using System.Windows.Forms;

namespace DarkControls.Controls
{
    /// <summary>
    /// Modified button which has no focus rectangles when the form which contains this button loses fucus while the button was focused.
    /// </summary>
    [ToolboxItem(typeof(NoFocusCueBotton))]
    public class NoFocusCueBotton : Button
    {
        protected override bool ShowFocusCues => false;

        /// <summary>
        /// Creates a new instance of a <see cref="NoFocusCueBotton"/>
        /// </summary>
        public NoFocusCueBotton() { }

        public override void NotifyDefault(bool value)
        {
            base.NotifyDefault(false);
        }
    }
}
```

`DarkControls/Controls/ProgressBarEx.cs`:

```cs
using System;
using System.Windows.Forms;
using System.Drawing;
using System.Drawing.Drawing2D;

namespace DarkControls.Controls
{
    public class ProgressBarEx : ProgressBar
    {
        public ProgressBarEx()
        {
            this.SetStyle(ControlStyles.UserPaint, true);
        }

        protected override void OnPaintBackground(PaintEventArgs pevent)
        {
            // None... Helps control the flicker.
        }

        protected override void OnPaint(PaintEventArgs e)
        {
            const int inset = 2; // A single inset value to control teh sizing of the inner rect.

            using (Image offscreenImage = new Bitmap(this.Width, this.Height))
            {
                using (Graphics offscreen = Graphics.FromImage(offscreenImage))
                {
                    offscreen.Clear(this.BackColor);
                    Rectangle rect = new Rectangle(0, 0, this.Width, this.Height);
                    offscreen.DrawRectangle(new Pen(Color.Silver, 2), rect);

                    //if (ProgressBarRenderer.IsSupported)
                    //    ProgressBarRenderer.DrawHorizontalBar(offscreen, rect);

                    rect.Inflate(new Size(-inset, -inset)); // Deflate inner rect.
                    rect.Width = (int)(rect.Width * ((double)this.Value / this.Maximum));
                    if (rect.Width == 0) rect.Width = 1; // Can't draw rec with width of 0.

                    //LinearGradientBrush brush = new LinearGradientBrush(rect, this.BackColor, this.ForeColor, LinearGradientMode.Horizontal);
                    SolidBrush brush = new SolidBrush(this.ForeColor);

                    offscreen.FillRectangle(brush, inset, inset, rect.Width, rect.Height);

                    e.Graphics.DrawImage(offscreenImage, 0, 0);
                }
            }
        }
    }
}

```

`DarkControls/Controls/SimpleColorTransforms.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Runtime.InteropServices;
using SystemMath = System.Math;

namespace DarkControls.Controls
{
    /// <summary>
    /// Static methods for transforming argb spaces and argb values.
    /// </summary>
    public static class SimpleColorTransforms
    {
        private static double tolerance
            => 0.000000000000001;


        /// <summary>
        /// Defines brightness levels.
        /// </summary>
        public enum Brightness
                : byte
        {
            Bright = 255,
            MediumBright = 210,
            Medium = 142,
            Dim = 98,
            XDim = 50
        }


        /// <summary>
        /// Defines alpha levels.
        /// </summary>
        public enum Alpha
                : byte
        {
            Opaque = 255,
            MediumHigh = 230,
            Medium = 175,
            MediumLow = 142,
            Low = 109,
            XLow = 45
        }


        /// <summary>
        /// Defines hint alpha levels.
        /// </summary>
        public enum HintAlpha
                : byte
        {
            Low = 64,
            XLow = 48,
            XxLow = 32,
            XxxLow = 16
        }


        /// <summary>
        /// Specifies a mode for argb transformations.
        /// </summary>
        public enum ColorTransformMode
                : byte
        {
            Hsl,
            Hsb
        }


        /// <summary>
        /// Converts RGB to HSL. Alpha is ignored.
        /// Output is: { H: [0, 360], S: [0, 1], L: [0, 1] }.
        /// </summary>
        /// <param name="color">The color to convert.</param>
        public static double[] RgBtoHsl(Color color)
        {
            double h = 0D;
            double s = 0D;
            double l;

            // normalize red, green, blue values
            double r = color.R / 255D;
            double g = color.G / 255D;
            double b = color.B / 255D;

            double max = SystemMath.Max(r, SystemMath.Max(g, b));
            double min = SystemMath.Min(r, SystemMath.Min(g, b));

            // hue
            if (SystemMath.Abs(max - min) < SimpleColorTransforms.tolerance)
                h = 0D; // undefined
            else if ((SystemMath.Abs(max - r) < SimpleColorTransforms.tolerance)
                    && (g >= b))
                h = (60D * (g - b)) / (max - min);
            else if ((SystemMath.Abs(max - r) < SimpleColorTransforms.tolerance)
                    && (g < b))
                h = ((60D * (g - b)) / (max - min)) + 360D;
            else if (SystemMath.Abs(max - g) < SimpleColorTransforms.tolerance)
                h = ((60D * (b - r)) / (max - min)) + 120D;
            else if (SystemMath.Abs(max - b) < SimpleColorTransforms.tolerance)
                h = ((60D * (r - g)) / (max - min)) + 240D;

            // luminance
            l = (max + min) / 2D;

            // saturation
            if ((SystemMath.Abs(l) < SimpleColorTransforms.tolerance)
                    || (SystemMath.Abs(max - min) < SimpleColorTransforms.tolerance))
                s = 0D;
            else if ((0D < l)
                    && (l <= .5D))
                s = (max - min) / (max + min);
            else if (l > .5D)
                s = (max - min) / (2D - (max + min)); //(max-min > 0)?

            return new[]
            {
                SystemMath.Max(0D, SystemMath.Min(360D, double.Parse($"{h:0.##}"))),
                SystemMath.Max(0D, SystemMath.Min(1D, double.Parse($"{s:0.##}"))),
                SystemMath.Max(0D, SystemMath.Min(1D, double.Parse($"{l:0.##}")))
            };
        }


        /// <summary>
        /// Converts HSL to RGB, with a specified output Alpha.
        /// Arguments are limited to the defined range:
        /// does not raise exceptions.
        /// </summary>
        /// <param name="h">Hue, must be in [0, 360].</param>
        /// <param name="s">Saturation, must be in [0, 1].</param>
        /// <param name="l">Luminance, must be in [0, 1].</param>
        /// <param name="a">Output Alpha, must be in [0, 255].</param>
        public static Color HsLtoRgb(double h, double s, double l, int a = 255)
        {
            h = SystemMath.Max(0D, SystemMath.Min(360D, h));
            s = SystemMath.Max(0D, SystemMath.Min(1D, s));
            l = SystemMath.Max(0D, SystemMath.Min(1D, l));
            a = SystemMath.Max(0, SystemMath.Min(255, a));

            // achromatic argb (gray scale)
            if (SystemMath.Abs(s) < SimpleColorTransforms.tolerance)
            {
                return Color.FromArgb(
                        a,
                        SystemMath.Max(0, SystemMath.Min(255, Convert.ToInt32(double.Parse($"{l * 255D:0.00}")))),
                        SystemMath.Max(0, SystemMath.Min(255, Convert.ToInt32(double.Parse($"{l * 255D:0.00}")))),
                        SystemMath.Max(0, SystemMath.Min(255, Convert.ToInt32(double.Parse($"{l * 255D:0.00}")))));
            }

            double q = l < .5D
                    ? l * (1D + s)
                    : (l + s) - (l * s);
            double p = (2D * l) - q;

            double hk = h / 360D;
            double[] T = new double[3];
            T[0] = hk + (1D / 3D); // Tr
            T[1] = hk; // Tb
            T[2] = hk - (1D / 3D); // Tg

            for (int i = 0; i < 3; i++)
            {
                if (T[i] < 0D)
                    T[i] += 1D;
                if (T[i] > 1D)
                    T[i] -= 1D;

                if ((T[i] * 6D) < 1D)
                    T[i] = p + ((q - p) * 6D * T[i]);
                else if ((T[i] * 2D) < 1)
                    T[i] = q;
                else if ((T[i] * 3D) < 2)
                    T[i] = p + ((q - p) * ((2D / 3D) - T[i]) * 6D);
                else
                    T[i] = p;
            }

            return Color.FromArgb(
                    a,
                    SystemMath.Max(0, SystemMath.Min(255, Convert.ToInt32(double.Parse($"{T[0] * 255D:0.00}")))),
                    SystemMath.Max(0, SystemMath.Min(255, Convert.ToInt32(double.Parse($"{T[1] * 255D:0.00}")))),
                    SystemMath.Max(0, SystemMath.Min(255, Convert.ToInt32(double.Parse($"{T[2] * 255D:0.00}")))));
        }


        /// <summary>
        /// Converts RGB to HSB. Alpha is ignored.
        /// Output is: { H: [0, 360], S: [0, 1], B: [0, 1] }.
        /// </summary>
        /// <param name="color">The color to convert.</param>
        public static double[] RgBtoHsb(Color color)
        {
            // normalize red, green and blue values
            double r = color.R / 255D;
            double g = color.G / 255D;
            double b = color.B / 255D;

            // conversion start
            double max = SystemMath.Max(r, SystemMath.Max(g, b));
            double min = SystemMath.Min(r, SystemMath.Min(g, b));

            double h = 0D;
            if ((SystemMath.Abs(max - r) < SimpleColorTransforms.tolerance)
                    && (g >= b))
                h = (60D * (g - b)) / (max - min);
            else if ((SystemMath.Abs(max - r) < SimpleColorTransforms.tolerance)
                    && (g < b))
                h = ((60D * (g - b)) / (max - min)) + 360D;
            else if (SystemMath.Abs(max - g) < SimpleColorTransforms.tolerance)
                h = ((60D * (b - r)) / (max - min)) + 120D;
            else if (SystemMath.Abs(max - b) < SimpleColorTransforms.tolerance)
                h = ((60D * (r - g)) / (max - min)) + 240D;

            double s = SystemMath.Abs(max) < SimpleColorTransforms.tolerance
                    ? 0D
                    : 1D - (min / max);

            return new[]
            {
                SystemMath.Max(0D, SystemMath.Min(360D, h)),
                SystemMath.Max(0D, SystemMath.Min(1D, s)),
                SystemMath.Max(0D, SystemMath.Min(1D, max))
            };
        }


        /// <summary>
        /// Converts HSB to RGB, with a specified output Alpha.
        /// Arguments are limited to the defined range:
        /// does not raise exceptions.
        /// </summary>
        /// <param name="h">Hue, must be in [0, 360].</param>
        /// <param name="s">Saturation, must be in [0, 1].</param>
        /// <param name="b">Brightness, must be in [0, 1].</param>
        /// <param name="a">Output Alpha, must be in [0, 255].</param>
        public static Color HsBtoRgb(double h, double s, double b, int a = 255)
        {
            h = SystemMath.Max(0D, SystemMath.Min(360D, h));
            s = SystemMath.Max(0D, SystemMath.Min(1D, s));
            b = SystemMath.Max(0D, SystemMath.Min(1D, b));
            a = SystemMath.Max(0, SystemMath.Min(255, a));

            double r = 0D;
            double g = 0D;
            double bl = 0D;

            if (SystemMath.Abs(s) < SimpleColorTransforms.tolerance)
                r = g = bl = b;
            else
            {
                // the argb wheel consists of 6 sectors. Figure out which sector
                // you're in.
                double sectorPos = h / 60D;
                int sectorNumber = (int)SystemMath.Floor(sectorPos);
                // get the fractional part of the sector
                double fractionalSector = sectorPos - sectorNumber;

                // calculate values for the three axes of the argb.
                double p = b * (1D - s);
                double q = b * (1D - (s * fractionalSector));
                double t = b * (1D - (s * (1D - fractionalSector)));

                // assign the fractional colors to r, g, and b based on the sector
                // the angle is in.
                switch (sectorNumber)
                {
                    case 0:
                        r = b;
                        g = t;
                        bl = p;
                        break;
                    case 1:
                        r = q;
                        g = b;
                        bl = p;
                        break;
                    case 2:
                        r = p;
                        g = b;
                        bl = t;
                        break;
                    case 3:
                        r = p;
                        g = q;
                        bl = b;
                        break;
                    case 4:
                        r = t;
                        g = p;
                        bl = b;
                        break;
                    case 5:
                        r = b;
                        g = p;
                        bl = q;
                        break;
                }
            }

            return Color.FromArgb(
                    a,
                    SystemMath.Max(0, SystemMath.Min(255, Convert.ToInt32(double.Parse($"{r * 255D:0.00}")))),
                    SystemMath.Max(0, SystemMath.Min(255, Convert.ToInt32(double.Parse($"{g * 255D:0.00}")))),
                    SystemMath.Max(0, SystemMath.Min(255, Convert.ToInt32(double.Parse($"{bl * 250D:0.00}")))));
        }


        /// <summary>
        /// Multiplies the Color's Luminance or Brightness by the argument;
        /// and optionally specifies the output Alpha.
        /// </summary>
        /// <param name="color">The color to transform.</param>
        /// <param name="colorTransformMode">Transform mode.</param>
        /// <param name="brightnessTransform">The transformation multiplier.</param>
        /// <param name="outputAlpha">Can optionally specify the Alpha to directly
        /// set on the output. If null, then the input <paramref name="color"/>
        /// Alpha is used.</param>
        public static Color TransformBrightness(
                Color color,
                ColorTransformMode colorTransformMode,
                double brightnessTransform,
                byte? outputAlpha = null)
        {
            double[] hsl = colorTransformMode == ColorTransformMode.Hsl
                    ? SimpleColorTransforms.RgBtoHsl(color)
                    : SimpleColorTransforms.RgBtoHsb(color);
            if ((SystemMath.Abs(hsl[2]) < SimpleColorTransforms.tolerance)
                    && (brightnessTransform > 1D))
                hsl[2] = brightnessTransform - 1D;
            else
                hsl[2] *= brightnessTransform;
            return colorTransformMode == ColorTransformMode.Hsl
                    ? SimpleColorTransforms.HsLtoRgb(hsl[0], hsl[1], hsl[2], outputAlpha ?? color.A)
                    : SimpleColorTransforms.HsBtoRgb(hsl[0], hsl[1], hsl[2], outputAlpha ?? color.A);
        }


        /// <summary>
        /// Multiplies the Color's Saturation, and Luminance or Brightness by the argument;
        /// and optionally specifies the output Alpha.
        /// </summary>
        /// <param name="color">The color to transform.</param>
        /// <param name="colorTransformMode">Transform mode.</param>
        /// <param name="saturationTransform">The transformation multiplier.</param>
        /// <param name="brightnessTransform">The transformation multiplier.</param>
        /// <param name="outputAlpha">Can optionally specify the Alpha to directly
        /// set on the output. If null, then the input <paramref name="color"/>
        /// Alpha is used.</param>
        public static Color TransformSaturationAndBrightness(
                Color color,
                ColorTransformMode colorTransformMode,
                double saturationTransform,
                double brightnessTransform,
                byte? outputAlpha = null)
        {
            double[] hsl = colorTransformMode == ColorTransformMode.Hsl
                    ? SimpleColorTransforms.RgBtoHsl(color)
                    : SimpleColorTransforms.RgBtoHsb(color);
            if ((SystemMath.Abs(hsl[1]) < SimpleColorTransforms.tolerance)
                    && (saturationTransform > 1D))
                hsl[1] = saturationTransform - 1D;
            else
                hsl[1] *= saturationTransform;
            if ((SystemMath.Abs(hsl[2]) < SimpleColorTransforms.tolerance)
                    && (brightnessTransform > 1D))
                hsl[2] = brightnessTransform - 1D;
            else
                hsl[2] *= brightnessTransform;
            return colorTransformMode == ColorTransformMode.Hsl
                    ? SimpleColorTransforms.HsLtoRgb(hsl[0], hsl[1], hsl[2], outputAlpha ?? color.A)
                    : SimpleColorTransforms.HsBtoRgb(hsl[0], hsl[1], hsl[2], outputAlpha ?? color.A);
        }


        /// <summary>
        /// Creates a new Color by combining R, G, and B from each Color, scaled by the Color's Alpha.
        /// The R, G, B of each Color is scaled by the Color's Alpha. The R, G, B of both results is
        /// then added together and divided by 2. The valuea are limited to [0, 255].
        /// The Alpha of the output Color is specified; and is also limited to [0, 255]
        /// (does not raise exceptions).
        /// </summary>
        /// <param name="color1">Combined by scaling RGB by the A.</param>
        /// <param name="color2">Combined by scaling RGB by the A.</param>
        /// <param name="outputAlpha">The Alpha of the output Color.</param>
        public static Color AlphaCombine(Color color1, Color color2, byte outputAlpha)
        {
            double a1 = color1.A / 255D;
            double a2 = color2.A / 255D;
            return Color.FromArgb(
                    outputAlpha,
                    (byte)SystemMath.Max(0D, SystemMath.Min(255D, ((color1.R * a1) + (color2.R * a2)) * .5D)),
                    (byte)SystemMath.Max(0D, SystemMath.Min(255D, ((color1.G * a1) + (color2.G * a2)) * .5D)),
                    (byte)SystemMath.Max(0D, SystemMath.Min(255D, ((color1.B * a1) + (color2.B * a2)) * .5D)));
        }
    }
}

```

`DarkControls/Controls/TransparentLabel.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace DarkControls.Controls
{
    public class TransparentLabel : Label
    {
        protected override void WndProc(ref Message m)
        {
            const int WM_NCHITTEST = 0x0084;
            const int HTTRANSPARENT = (-1);

            if (m.Msg == WM_NCHITTEST)
            {
                m.Result = (IntPtr)HTTRANSPARENT;
            }
            else
            {
                base.WndProc(ref m);
            }
        }
    }
}

```

`DarkControls/Controls/VisualStudioTabControl.cs`:

```cs
using System;
using System.ComponentModel;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Drawing.Text;
using System.Windows.Forms;

namespace VisualStudioTabControl
{

    public class VisualStudioTabControl : TabControl
    {
        //protected override CreateParams CreateParams
        //{
        //    get
        //    {
        //        // Activate double buffering at the form level.  All child controls will be double buffered as well.
        //        CreateParams cp = base.CreateParams;
        //        cp.ExStyle |= 0x02000000;  // Turn on WS_EX_COMPOSITED
        //        return cp;
        //    }
        //}

        /// <summary>
        ///     Format of the title of the TabPage
        /// </summary>
        private readonly StringFormat CenterSringFormat = new StringFormat
        {
            Alignment = StringAlignment.Near,
            LineAlignment = StringAlignment.Center
        };

        /// <summary>
        ///     The color of the active tab header
        /// </summary>
        private Color activeColor = Color.FromArgb(0, 122, 204);

        /// <summary>
        ///     The color of the background of the Tab
        /// </summary>
        private Color backTabColor = Color.FromArgb(33, 33, 33);

        /// <summary>
        ///     The color of the border of the control
        /// </summary>
        private Color borderColor = Color.FromArgb(35, 35, 35);

        /// <summary>
        ///     Color of the closing button
        /// </summary>
        private Color closingButtonColor = Color.WhiteSmoke;

        /// <summary>
        ///     Message for the user before losing
        /// </summary>
        private string closingMessage;

        /// <summary>
        ///     The color of the tab header
        /// </summary>
        private Color headerColor = Color.FromArgb(45, 45, 48);

        /// <summary>
        ///     The color of the horizontal line which is under the headers of the tab pages
        /// </summary>
        private Color horizLineColor = Color.FromArgb(0, 122, 204);

        /// <summary>
        ///     A random page will be used to store a tab that will be deplaced in the run-time
        /// </summary>
        private TabPage predraggedTab;

        /// <summary>
        ///     The color of the text
        /// </summary>
        private Color textColor = Color.FromArgb(255, 255, 255);
        
        ///<summary>
        /// Shows closing buttons
        /// </summary> 
        public bool ShowClosingButton { get; set; }

        /// <summary>
        /// Selected tab text color
        /// </summary>
        public Color selectedTextColor = Color.FromArgb(255, 255, 255);
        /// <summary>
        ///     Init
        /// </summary>
        public VisualStudioTabControl()
        {
            SetStyle(
                ControlStyles.AllPaintingInWmPaint | ControlStyles.UserPaint | ControlStyles.ResizeRedraw
                | ControlStyles.DoubleBuffer,
                true);
            DoubleBuffered = true;
            SizeMode = TabSizeMode.Normal;
            ItemSize = new Size(240, 16);
            AllowDrop = true;
        }

        [Category("Colors"), Browsable(true), Description("The color of the selected page")]
        public Color ActiveColor
        {
            get
            {
                return this.activeColor;
            }

            set
            {
                this.activeColor = value;
            }
        }

        [Category("Colors"), Browsable(true), Description("The color of the background of the tab")]
        public Color BackTabColor
        {
            get
            {
                return this.backTabColor;
            }

            set
            {
                this.backTabColor = value;
            }
        }

        [Category("Colors"), Browsable(true), Description("The color of the border of the control")]
        public Color BorderColor
        {
            get
            {
                return this.borderColor;
            }

            set
            {
                this.borderColor = value;
            }
        }

        /// <summary>
        ///     The color of the closing button
        /// </summary>
        [Category("Colors"), Browsable(true), Description("The color of the closing button")]
        public Color ClosingButtonColor
        {
            get
            {
                return this.closingButtonColor;
            }

            set
            {
                this.closingButtonColor = value;
            }
        }

        /// <summary>
        ///     The message that will be shown before closing.
        /// </summary>
        [Category("Options"), Browsable(true), Description("The message that will be shown before closing.")]
        public string ClosingMessage
        {
            get
            {
                return this.closingMessage;
            }

            set
            {
                this.closingMessage = value;
            }
        }

        [Category("Colors"), Browsable(true), Description("The color of the header.")]
        public Color HeaderColor
        {
            get
            {
                return this.headerColor;
            }

            set
            {
                this.headerColor = value;
            }
        }

        [Category("Colors"), Browsable(true),
         Description("The color of the horizontal line which is located under the headers of the pages.")]
        public Color HorizontalLineColor
        {
            get
            {
                return this.horizLineColor;
            }

            set
            {
                this.horizLineColor = value;
            }
        }

        /// <summary>
        ///     Show a Yes/No message before closing?
        /// </summary>
        [Category("Options"), Browsable(true), Description("Show a Yes/No message before closing?")]
        public bool ShowClosingMessage { get; set; }

        [Category("Colors"), Browsable(true), Description("The color of the title of the page")]
        public Color SelectedTextColor
        {
            get
            {
                return this.selectedTextColor;
            }

            set
            {
                this.selectedTextColor = value;
            }
        }

        [Category("Colors"), Browsable(true), Description("The color of the title of the page")]
        public Color TextColor
        {
            get
            {
                return this.textColor;
            }

            set
            {
                this.textColor = value;
            }
        }

        /// <summary>
        ///     Sets the Tabs on the top
        /// </summary>
        protected override void CreateHandle()
        {
            base.CreateHandle();
            Alignment = TabAlignment.Top;
        }

        /// <summary>
        ///     Drags the selected tab
        /// </summary>
        /// <param name="drgevent"></param>
        protected override void OnDragOver(DragEventArgs drgevent)
        {
            var draggedTab = (TabPage)drgevent.Data.GetData(typeof(TabPage));
            var pointedTab = getPointedTab();

            if (ReferenceEquals(draggedTab, predraggedTab) && pointedTab != null)
            {
                drgevent.Effect = DragDropEffects.Move;

                if (!ReferenceEquals(pointedTab, draggedTab))
                {
                    this.ReplaceTabPages(draggedTab, pointedTab);
                }
            }

            base.OnDragOver(drgevent);
        }

        /// <summary>
        ///     Handles the selected tab|closes the selected page if wanted.
        /// </summary>
        /// <param name="e"></param>
        protected override void OnMouseDown(MouseEventArgs e)
        {
            predraggedTab = getPointedTab();
            var p = e.Location;
            if (!this.ShowClosingButton)
            {
            }
            else
            {
                for (var i = 0; i < this.TabCount; i++)
                {
                    var r = this.GetTabRect(i);
                    r.Offset(r.Width - 15, 2);
                    r.Width = 10;
                    r.Height = 10;
                    if (!r.Contains(p))
                    {
                        continue;
                    }

                    if (this.ShowClosingMessage)
                    {
                        if (DialogResult.Yes == MessageBox.Show(this.ClosingMessage, "Close", MessageBoxButtons.YesNo))
                        {
                            this.TabPages.RemoveAt(i);
                        }
                    }
                    else
                    {
                        this.TabPages.RemoveAt(i);
                    }
                }
            }

            base.OnMouseDown(e);
        }

        /// <summary>
        ///     Holds the selected page until it sets down
        /// </summary>
        /// <param name="e"></param>
        protected override void OnMouseMove(MouseEventArgs e)
        {
            if (e.Button == MouseButtons.Left && predraggedTab != null)
            {
                this.DoDragDrop(predraggedTab, DragDropEffects.Move);
            }

            base.OnMouseMove(e);
        }

        /// <summary>
        ///     Abandons the selected tab
        /// </summary>
        /// <param name="e"></param>
        protected override void OnMouseUp(MouseEventArgs e)
        {
            predraggedTab = null;
            base.OnMouseUp(e);
        }

        /// <summary>
        ///     Draws the control
        /// </summary>
        /// <param name="e"></param>
        protected override void OnPaint(PaintEventArgs e)
        {
            
            var g = e.Graphics;
            var Drawer = g;

            Drawer.SmoothingMode = SmoothingMode.HighQuality;
            Drawer.PixelOffsetMode = PixelOffsetMode.HighQuality;
            Drawer.TextRenderingHint = TextRenderingHint.ClearTypeGridFit;
            Drawer.Clear(this.headerColor);
            try
            {
                if (SelectedTab != null)
                {
                    SelectedTab.BackColor = this.backTabColor;
                }
            }
            catch (Exception ex)
            {
                // ignored
            }

            try
            {
                SelectedTab.BorderStyle = BorderStyle.None;
            }
            catch (Exception ex)
            {
                // ignored
            }

            for (var i = 0; i <= TabCount - 1; i++)
            {
                var Header = new Rectangle(
                    new Point(GetTabRect(i).Location.X + 2, GetTabRect(i).Location.Y),
                    new Size(GetTabRect(i).Width, GetTabRect(i).Height));
                var HeaderSize = new Rectangle(Header.Location, new Size(Header.Width, Header.Height));
                Brush ClosingColorBrush = new SolidBrush(this.closingButtonColor);

                if (i == SelectedIndex)
                {
                    // Draws the back of the header 
                    Drawer.FillRectangle(new SolidBrush(this.headerColor), HeaderSize);

                    // Draws the back of the color when it is selected
                    Drawer.FillRectangle(
                        new SolidBrush(this.activeColor),
                        new Rectangle(Header.X - 5, Header.Y - 3, Header.Width, Header.Height + 5));

                    // Draws the title of the page
                    Drawer.DrawString(
                        TabPages[i].Text,
                        Font,
                        new SolidBrush(this.selectedTextColor),
                        HeaderSize,
                        this.CenterSringFormat);

                    // Draws the closing button
                    if (this.ShowClosingButton)
                    {
                        e.Graphics.DrawString("X", Font, ClosingColorBrush, HeaderSize.Right - 17, 3);
                    }
                }
                else
                {
                    // Simply draws the header when it is not selected
                    Drawer.DrawString(
                        TabPages[i].Text,
                        Font,
                        new SolidBrush(this.textColor),
                        HeaderSize,
                        this.CenterSringFormat);
                }
            }

            // Draws the horizontal line
            Drawer.DrawLine(new Pen(this.horizLineColor, 5), new Point(0, 19), new Point(Width, 19));

            // Draws the background of the tab control
            Drawer.FillRectangle(new SolidBrush(this.backTabColor), new Rectangle(0, 20, Width, Height - 20));

            // Draws the border of the TabControl
            Drawer.DrawRectangle(new Pen(this.borderColor, 2), new Rectangle(0, 0, Width, Height));
            Drawer.InterpolationMode = InterpolationMode.HighQualityBicubic;
        }

        /// <summary>
        ///     Gets the pointed tab
        /// </summary>
        /// <returns></returns>
        private TabPage getPointedTab()
        {
            for (var i = 0; i <= this.TabPages.Count - 1; i++)
            {
                if (this.GetTabRect(i).Contains(this.PointToClient(Cursor.Position)))
                {
                    return this.TabPages[i];
                }
            }

            return null;
        }

        /// <summary>
        ///     Swaps the two tabs
        /// </summary>
        /// <param name="Source"></param>
        /// <param name="Destination"></param>
        private void ReplaceTabPages(TabPage Source, TabPage Destination)
        {
            var SourceIndex = this.TabPages.IndexOf(Source);
            var DestinationIndex = this.TabPages.IndexOf(Destination);

            this.TabPages[DestinationIndex] = Source;
            this.TabPages[SourceIndex] = Destination;

            if (this.SelectedIndex == SourceIndex)
            {
                this.SelectedIndex = DestinationIndex;
            }
            else if (this.SelectedIndex == DestinationIndex)
            {
                this.SelectedIndex = SourceIndex;
            }

            this.Refresh();
        }
    }
}

```

`DarkControls/Controls/WindowsDefaultTitleBarButton.cs`:

```cs
using System;
using System.ComponentModel;
using System.Drawing;
using System.Windows.Forms;

namespace DarkControls.Controls
{
    /// <summary>
    /// Button which represents the default close, minimize or maximize buttons of the windows 10 aero theme.
    /// </summary>
    [ToolboxItem(true)]
    public class WindowsDefaultTitleBarButton : NoFocusCueBotton
    {
        /// <summary>
        /// Represents the 3 possible types of the windows border buttons.
        /// </summary>
        public enum Type
        {
            Close,
            Maximize,
            Minimize
        }

        private Pen activeIconColorPen;
        private Brush activeIconColorBrush;
        private Brush activeColorBrush;
        private Type btnType;

        /// <summary>
        /// The type which defines the buttons behaviour.
        /// </summary>

        [RefreshProperties(System.ComponentModel.RefreshProperties.All)]
        [EditorBrowsable(EditorBrowsableState.Always)]
        [Browsable(true)]
        [Category("Appearance")]
        [Description("The type which defines the buttons behaviour.")]
        public Type ButtonType {
            get
            {
                return btnType;
            }
            set
            {
                btnType = value;
            }
        }

        /// <summary>
        /// The background color of the button when the mouse is inside the buttons bounds.
        /// </summary>

        [RefreshProperties(System.ComponentModel.RefreshProperties.All)]
        [EditorBrowsable(EditorBrowsableState.Always)]
        [Browsable(true)]
        [Category("Appearance")]
        [Description("The background color of the button when the mouse is inside the buttons bounds.")]
        public Color HoverColor { get; set; }

        /// <summary>
        /// The background color of the button when the button is clicked.
        /// </summary>
        
        [RefreshProperties(System.ComponentModel.RefreshProperties.All)]
        [EditorBrowsable(EditorBrowsableState.Always)]
        [Browsable(true)]
        [Category("Appearance")]
        [Description("The background color of the button when the button is clicked.")]
        public Color ClickColor { get; set; }

        /// <summary>
        /// The default color of the icon.
        /// </summary>
        
        [RefreshProperties(System.ComponentModel.RefreshProperties.All)]
        [EditorBrowsable(EditorBrowsableState.Always)]
        [Browsable(true)]
        [Category("Appearance")]
        [Description("The default color of the icon.")]
        public Color IconColor { get; set; }

        /// <summary>
        /// The color of the icon when the mouse is inside the buttons bounds.
        /// </summary>
        
        [RefreshProperties(System.ComponentModel.RefreshProperties.All)]
        [EditorBrowsable(EditorBrowsableState.Always)]
        [Browsable(true)]
        [Category("Appearance")]
        [Description("The color of the icon when the mouse is inside the buttons bounds.")]
        public Color HoverIconColor { get; set; }

        /// <summary>
        /// The color of the icon when the mouse is inside the buttons bounds.
        /// </summary>
        
        [RefreshProperties(System.ComponentModel.RefreshProperties.All)]
        [EditorBrowsable(EditorBrowsableState.Always)]
        [Browsable(true)]
        [Category("Appearance")]
        [DefaultValue("2")]
        [Description("The thickness of the lines making up the icon")]
        public int IconLineThickness { get; set; }

        /// <summary>
        /// The color of the icon when the button is clicked.
        /// </summary>
        
        [RefreshProperties(System.ComponentModel.RefreshProperties.All)]
        [EditorBrowsable(EditorBrowsableState.Always)]
        [Browsable(true)]
        [Category("Appearance")]
        [Description("The color of the icon when the button is clicked.")]
        public Color ClickIconColor { get; set; }

        /// <summary>
        /// Property which returns the active background color of the button depending on if the button is clicked or hovered.
        /// </summary>
        /// 
        
        [RefreshProperties(System.ComponentModel.RefreshProperties.All)]
        [EditorBrowsable(EditorBrowsableState.Always)]
        [Browsable(true)]
        public virtual Color ActiveColor
        {
            get
            {
                if (this.DesignMode == false)
                {
                    if (this.Clicked)
                        return this.ClickColor;

                    if (this.Hovered)
                        return this.HoverColor;

                    return BackColor;
                }
                else
                {
                    return this.HoverColor;
/*                    switch (this.ButtonType)
                    {
                        case Type.Close:
                        {
                            return Color.Red;
                        }
                        case Type.Maximize:
                        {
                            return Color.SkyBlue;
                        }
                        case Type.Minimize:
                        {
                            return Color.SkyBlue;
                        }
                    }*/
                }
                return Color.Empty;
            }
        }

        /// <summary>
        /// Property which returns the active color of the buttons icon depending on if the button is clicked or hovered.
        /// </summary>
        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        [RefreshProperties(System.ComponentModel.RefreshProperties.All)]
        [EditorBrowsable(EditorBrowsableState.Never)]
        [Browsable(false)]
        public virtual Color ActiveIconColor
        {
            get
            {
                if (this.DesignMode == false)
                {
                    if (this.Clicked)
                        return this.ClickIconColor;

                    if (this.Hovered)
                        return this.HoverIconColor;

                    return IconColor;
                }
                else
                {
                    return Color.Black;
                }
            }
        }

        /// <summary>
        /// Property which indicates if the mouse is currently inside the bounds of the button.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        [Browsable(false)]
        [DefaultValue(false)]
        public bool Hovered { get; set; }

        /// <summary>
        /// Property which indicates if the left mouse button was pressed down inside the buttons bounds. Can be true before the click event is triggered.
        /// </summary>
        [EditorBrowsable(EditorBrowsableState.Never)]
        [Browsable(false)]
        [DefaultValue(false)]
        public bool Clicked { get; set; }

        public WindowsDefaultTitleBarButton() { }

        protected override void OnMouseEnter(EventArgs e)
        {
            base.OnMouseEnter(e);
            Hovered = true;
        }

        protected override void OnMouseLeave(EventArgs e)
        {
            base.OnMouseLeave(e);
            Hovered = false;
        }

        protected override void OnMouseDown(MouseEventArgs mevent)
        {
            base.OnMouseDown(mevent);
            Clicked = true;
        }

        protected override void OnMouseUp(MouseEventArgs mevent)
        {
            base.OnMouseUp(mevent);
            Clicked = false;
        }

        protected override void OnClick(EventArgs e)
        {
            if (ButtonType == Type.Close)
                this.FindForm()?.Close();
            else if (ButtonType == Type.Maximize)
                this.FindForm().WindowState = this.FindForm().WindowState == FormWindowState.Maximized ? FormWindowState.Normal : FormWindowState.Maximized;
            else
                this.FindForm().WindowState = FormWindowState.Minimized;

            base.OnClick(e);
        }

        protected override void OnPaint(PaintEventArgs pevent)
        {
            System.Diagnostics.Trace.WriteLine(pevent.ClipRectangle.ToString());

            activeColorBrush?.Dispose();
            activeColorBrush = new SolidBrush(ActiveColor);

            pevent.Graphics.FillRectangle(new SolidBrush(ActiveColor), pevent.ClipRectangle);
            pevent.Graphics.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.HighQuality;

            activeIconColorBrush?.Dispose();
            activeIconColorPen?.Dispose();

            activeIconColorBrush = new SolidBrush(ActiveIconColor);
            activeIconColorPen = new Pen(activeIconColorBrush, IconLineThickness);

            if (ButtonType == Type.Close)
            {
                drawCloseIcon(pevent, new Rectangle(0, 0, this.Width, this.Height));
            }
            else if (ButtonType == Type.Maximize)
            {
                drawMaximizeIcon(pevent, new Rectangle(0, 0, this.Width, this.Height));
            }
            else
            {
                drawMinimizeIcon(pevent, new Rectangle(0, 0, this.Width, this.Height));
            }
        }

        protected virtual void drawCloseIcon(PaintEventArgs e, Rectangle drawRect)
        {
            int size = 12;
            e.Graphics.DrawLine(
                activeIconColorPen,
                drawRect.X + drawRect.Width / 2 - (size / 2),
                drawRect.Y + drawRect.Height / 2 - (size / 2),
                drawRect.X + drawRect.Width / 2 + (size / 2),
                drawRect.Y + drawRect.Height / 2 + (size / 2));

            e.Graphics.DrawLine(
                activeIconColorPen,
                drawRect.X + drawRect.Width / 2 - (size / 2),
                drawRect.Y + drawRect.Height / 2 + (size / 2),
                drawRect.X + drawRect.Width / 2 + (size / 2),
                drawRect.Y + drawRect.Height / 2 - (size / 2));
        }

        protected virtual void drawMaximizeIcon(PaintEventArgs e, Rectangle drawRect)
        {
            if (this.FindForm().WindowState == FormWindowState.Normal)
            {
                int size = 10;
                Rectangle rect = new Rectangle(
                        drawRect.X + drawRect.Width / 2 - (size / 2),
                        drawRect.Y + drawRect.Height / 2 - (size / 2),
                        size, size);
                Rectangle r2 = new Rectangle(rect.X, rect.Y, rect.Width, 2);
                e.Graphics.DrawRectangle(activeIconColorPen, rect);

                e.Graphics.FillRectangle(new SolidBrush(activeIconColorPen.Color), r2);
            }
            else if (this.FindForm().WindowState == FormWindowState.Maximized)
            {
                e.Graphics.DrawRectangle(
                    activeIconColorPen,
                    new Rectangle(
                        drawRect.X + drawRect.Width / 2 - 3,
                        drawRect.Y + drawRect.Height / 2 - 5,
                        8, 8));

                Rectangle rect = new Rectangle(
                    drawRect.X + drawRect.Width / 2 - 5,
                    drawRect.Y + drawRect.Height / 2 - 3,
                    8, 8);

                e.Graphics.FillRectangle(activeIconColorBrush, rect);
                e.Graphics.DrawRectangle(activeIconColorPen, rect);
            }
        }

        protected virtual void drawMinimizeIcon(PaintEventArgs e, Rectangle drawRect)
        {
            int lower = 3;
            e.Graphics.DrawLine(
                activeIconColorPen,
                drawRect.X + drawRect.Width / 2 - 5,
                drawRect.Y + drawRect.Height / 2 + lower,
                drawRect.X + drawRect.Width / 2 + 5,
                drawRect.Y + drawRect.Height / 2 + lower);
        }
    }
}
```

`DarkControls/DarkControls.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{66C94ACB-63C7-42A3-9D83-A3801CED4F1C}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>DarkControls</RootNamespace>
    <AssemblyName>DarkControls</AssemblyName>
    <TargetFrameworkVersion>v4.8</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <Deterministic>true</Deterministic>
    <TargetFrameworkProfile />
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\x86\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x64'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\x64\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <LangVersion>7.3</LangVersion>
    <ErrorReport>prompt</ErrorReport>
    <Optimize>true</Optimize>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x64'">
    <OutputPath>bin\Release\x64\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>AnyCPU</PlatformTarget>
    <LangVersion>7.3</LangVersion>
    <ErrorReport>prompt</ErrorReport>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x86'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\x86\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>x86</PlatformTarget>
    <LangVersion>7.3</LangVersion>
    <ErrorReport>prompt</ErrorReport>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x86'">
    <OutputPath>bin\x86\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>x86</PlatformTarget>
    <LangVersion>7.3</LangVersion>
    <ErrorReport>prompt</ErrorReport>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Configuration" />
    <Reference Include="System.Core" />
    <Reference Include="System.Drawing" />
    <Reference Include="System.Drawing.Design" />
    <Reference Include="System.Windows.Forms" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Net.Http" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Controls\AppIcon.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Include="Controls\CloseButton.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Include="Controls\CustomCheckedListBox.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Include="Controls\CustomScrollBar.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Include="Controls\DarkButton.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Include="Controls\DarkCheckBox.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Include="Controls\DarkListView.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Include="Controls\DarkSelectFileButton.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Include="Controls\DarkTextBox.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Include="Controls\FlatComboBox.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Include="Controls\FlatScrollBar.cs" />
    <Compile Include="Controls\FlatScrollBar1.cs" />
    <Compile Include="Controls\MaximizeButton.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Include="Controls\MinimizeButton.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Include="Controls\NoFocusCueBotton.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Include="Controls\ProgressBarEx.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Include="Controls\SimpleColorTransforms.cs" />
    <Compile Include="Controls\TransparentLabel.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Include="Controls\VisualStudioTabControl.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Include="Controls\WindowsDefaultTitleBarButton.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Include="BlankForm.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Include="BlankForm.Designer.cs" />
    <Compile Include="Controls\CustomStatusStrip.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="Properties\Resources.Designer.cs">
      <AutoGen>True</AutoGen>
      <DesignTime>True</DesignTime>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
    <Compile Include="Utils.cs" />
  </ItemGroup>
  <ItemGroup>
    <None Include="icons8-crossed-axes-100.png" />
  </ItemGroup>
  <ItemGroup>
    <EmbeddedResource Include="BlankForm.resx">
      <SubType>Designer</SubType>
    </EmbeddedResource>
    <EmbeddedResource Include="Properties\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
    </EmbeddedResource>
  </ItemGroup>
  <ItemGroup>
    <Content Include="selectFileBtn.Image.png" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
</Project>
```

`DarkControls/Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Lib")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("Lib")]
[assembly: AssemblyCopyright("Copyright ©  2023")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible
// to COM components.  If you need to access a type in this assembly from
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("66c94acb-63c7-42a3-9d83-a3801ced4f1c")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]

```

`DarkControls/Properties/Resources.Designer.cs`:

```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace DarkControls.Properties {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("DarkControls.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap appIcon1_AppIconImage {
            get {
                object obj = ResourceManager.GetObject("appIcon1.AppIconImage", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap appIcon1_Image {
            get {
                object obj = ResourceManager.GetObject("appIcon1.Image", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap icons8_crossed_axes_100 {
            get {
                object obj = ResourceManager.GetObject("icons8_crossed_axes_100", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap selectFileBtn_Image {
            get {
                object obj = ResourceManager.GetObject("selectFileBtn_Image", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
    }
}

```

`DarkControls/Properties/Resources.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <assembly alias="System.Drawing" name="System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
  <data name="appIcon1.AppIconImage" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        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
</value>
  </data>
  <data name="appIcon1.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAYAAAByDd+UAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAL
        EAAACxABrSO9dQAABIlJREFUSEvtlWtQlFUYx18rtZomGiYy+8ClCSEucoeFBXZZYVlgMXZhFZaQ5bYS
        SiJBBWgQ2EVFhEAEEeJeiODUGA6Iw5QzqJM4KOQ0UuFMTd/41DTFUP+nc3aOUDAI2NQnf1/2Of///3nO
        nnffd1/pIf87NgX0vChXZC3ZJbz4Ohwd9uCIfSEm7HLQJhGtE9ZSmMczPOuQg6O8VzgrY5dKjztno9M1
        n8gxG8NOu8necTe6nLLR72KgDSI2j0spbeCeJcOzrIf38hl8logtj3smsgKLiDzMGNDkYqOQJbcMXPTI
        wF6xnIdrbpm4KJaSRoONvJfPcE9HlpCXYqOgp4LTEBBows1ANsBspvXCkoLS8YI8HdP+JjIIaR6ucY9n
        hCSZfWh9IPuCfJY8FTJrDZ4WliSFGfFejBlDKhN+lBtxR5mGEoPLwqVTpJK9MhnjYRnoZ5+n/vFbltIj
        XFNloo9neFY4Ep+hTEWJPAlT20z4WZuFIb6XFKpHw563iGo6QbFpuOvuDifRI4UbyDYqEd9FGMkQqafw
        6CTMCGserkUlIIJnWHZKm0K2wpKcnbElLhN3W9uJ8t4kCmZ7WQx1NKpLS4iaOucQn4KZEBm8uR6XgDva
        HUgzxJEPq8f0iRjUJ6DZ0sSIT8BprsUZcINnYg1k0iVgintBfuS504SZ7k+IDhUTRWhRbWm6h0aFmvfZ
        STva/0ByEqb1EThg1GE2RYdzRj2RUY8wnkvUYzApDlXJOjTu1GOIazuYxzOWbDx+16tR8moyfvq0h+hD
        NlPNZvPcEnQKVFcVEJ39eG523y6iXZEoTtUhJv0VfJARi6tmA1nxXNp2zJm2Y5jXGWpYZ2hx1cQyPMt6
        ivIyifjJKtksXciiky0mSY6aBhas2keU4AuFkKVsLQ7kRGMwN5paX4tGL9fM4WSVE4XR7BgctIQYRi+E
        HmH9texkKUHLnGwxe5U4WaBmP3QkNgvJQr4a3+dr8CWvc9mtXhiJH5j2rcUUFMViE+/NVYgbZLUUqhBW
        ym57sZQOqtBWvA2f8bpUQc8Uq3C5RE1vM62LefM3ErHHhveK5YNREYqT5UoM8JpvdkiB2xUK/HpGoke5
        VqbEULkCdbz+11TKUdUQRlQXCLtjMjxRGYTJwyEoPByM/cy7VcP+yo4HkD3PHAvCUdH2YNTL0FIrwy8n
        QhDzkRwedQG4USPDO8KWWF1RJ6PrdXK41gdDe4JnA9Ak7LXR6of20374ptEXBT0yWDf74usm/4XN7sG0
        ihZfXGv0IatTvihkPbfb/NAi7NXR7YH6XleMdXhQ2YiCHuvywkS7N0qFvYQOb1R0eeImSbSuw4vKzrhg
        vHsraoV9f/pcsL/XH9c6pueUfYF4rt8NE71bF56z5TjrgfJzbhj/3Iee7Zn8TcVmjPU5I0fYy/OFM3ou
        +P357mD7bOKAKybPOy+9jMtx/mWUD7jg1kjzbNIFHxxnvStf2kFH8hxxxOgVW4wOb0GekFfNsBPe4L2X
        HHH5ktPCm+e+XN9MT15xwCaxXDNfvQSbyb+9Ux/yHyJJfwHAIJQLdFWq8gAAAABJRU5ErkJggg==
</value>
  </data>
  <assembly alias="System.Windows.Forms" name="System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />
  <data name="icons8_crossed_axes_100" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\icons8-crossed-axes-100.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="selectFileBtn_Image" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\selectFileBtn.Image.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
</root>
```

`DarkControls/Utils.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;

namespace DarkControls
{
    public class Utils
    {
        [DllImport("Gdi32.dll", EntryPoint = "CreateRoundRectRgn")]
        public static extern IntPtr CreateRoundRectRgn
        (
            int nLeftRect,     // x-coordinate of upper-left corner
            int nTopRect,      // y-coordinate of upper-left corner
            int nRightRect,    // x-coordinate of lower-right corner
            int nBottomRect,   // y-coordinate of lower-right corner
            int nWidthEllipse, // width of ellipse
            int nHeightEllipse // height of ellipse
        );

        public static int WM_NCHITTEST = 0x84;
        public static int HT_CAPTION = 0x2;
    }
}

```

`DriverInterface/BSOD.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace KsDumper11
{
    public class BSOD
    {
        public static bool JustHappened()
        {
            List<DateTime> detectedCrashTimes = new List<DateTime>();

            string eventLogName = "System";

            EventLog eventLog = new EventLog();
            eventLog.Log = eventLogName;

            foreach (EventLogEntry log in eventLog.Entries)
            {
                if (log.EventID == 1001)
                {
                    detectedCrashTimes.Add(log.TimeGenerated);
                }
            }

            detectedCrashTimes = detectedCrashTimes.OrderByDescending(x => x).ToList();

            foreach (DateTime crashTime in detectedCrashTimes)
            {
                if (CheckIfWithinFiveMinutes(crashTime, 5))
                {
                    return true;
                }
            }

            return false;
        }

        static bool CheckIfWithinFiveMinutes(DateTime dateTimeToCheck, int minutesAgo)
        {
            // Get the current time
            DateTime currentTime = DateTime.Now;

            // Calculate the time difference
            TimeSpan timeDifference = currentTime - dateTimeToCheck;

            // Check if the time difference is within 5 minutes
            if (timeDifference.TotalMinutes <= minutesAgo)
            {
                return true;
            }
            else
            {
                return false;
            }
        }
    }
}

```

`DriverInterface/CancelableTask.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

public class CancelableTask<T>
{
    private CancellationTokenSource cancellationTokenSource;

    public CancelableTask(CancellationToken cancellationToken)
    {
        cancellationTokenSource = new CancellationTokenSource();
        cancellationToken.Register(() => cancellationTokenSource.Cancel());
    }

    public Task<T> CreateTask(Func<CancellationToken, T> taskFunction)
    {
        var taskCompletionSource = new TaskCompletionSource<T>();

        Task.Run(() =>
        {
            try
            {
                T result = taskFunction(cancellationTokenSource.Token);
                taskCompletionSource.TrySetResult(result);
            }
            catch (OperationCanceledException)
            {
                taskCompletionSource.TrySetCanceled();
            }
            catch (Exception ex)
            {
                taskCompletionSource.TrySetException(ex);
            }
        });

        return taskCompletionSource.Task;
    }

    public void Cancel()
    {
        cancellationTokenSource.Cancel();
    }
}


```

`DriverInterface/CrashMon.cs`:

```cs
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;
using static System.Net.Mime.MediaTypeNames;

namespace KsDumper11
{
    public class CrashMon
    {
        [DllImport("kernel32.dll", SetLastError = true)]
        private static extern bool FlushFileBuffers(IntPtr handle);

        private int _checkingProvider = -1;
        public int CheckingProvider
        {
            get
            {
                return _checkingProvider;
            }
            set
            {
                _checkingProvider = value;
                Save();
            }
        }

        string savePath = KduSelfExtract.AssemblyDirectory + @"\\Setings.json";

        public CrashMon()
        {
            if (File.Exists(savePath))
            {
                _checkingProvider = JsonConvert.DeserializeObject<int>(File.ReadAllText(savePath));
            }
            else
            {
                _checkingProvider = -1;
            }
        }

        private void Save()
        {
            string json = JsonConvert.SerializeObject(_checkingProvider);

            if (!File.Exists(savePath))
            {
                FileStream fs = File.Create(savePath);
                StreamWriter sw = new StreamWriter(fs);
                sw.Write(json);
                sw.Flush();
                FlushFileBuffers(fs.Handle);
                sw.Close();
                sw.Dispose();
            }
            else
            {
                File.Delete(savePath);
                FileStream fs = File.Create(savePath);
                StreamWriter sw = new StreamWriter(fs);
                sw.Write(json);
                sw.Flush();
                FlushFileBuffers(fs.Handle);
                sw.Close();
                sw.Dispose();
            }
        }
    }
}

```

`DriverInterface/Driver/ManualLoader.bat`:

```bat
kdu.exe -prv 1 -map KsDumperDriver.sys
pause
```

`DriverInterface/DriverInterface.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{6F8B2A35-060D-4EB1-A6BA-A3057179304B}</ProjectGuid>
    <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>DriverInterface</RootNamespace>
    <AssemblyName>DriverInterface</AssemblyName>
    <TargetFrameworkVersion>v4.8</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <Deterministic>true</Deterministic>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\x86\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="Newtonsoft.Json, Version=13.0.0.0, Culture=neutral, PublicKeyToken=30ad4fe6b2a6aeed, processorArchitecture=MSIL">
      <HintPath>..\packages\Newtonsoft.Json.13.0.3\lib\net45\Newtonsoft.Json.dll</HintPath>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Drawing" />
    <Reference Include="System.Windows.Forms" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Net.Http" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="BSOD.cs" />
    <Compile Include="CancelableTask.cs" />
    <Compile Include="CrashMon.cs" />
    <Compile Include="KduProviderSettings.cs" />
    <Compile Include="KsDumperDriverInterface.cs" />
    <Compile Include="KduProvider.cs" />
    <Compile Include="KduSelfExtract.cs" />
    <Compile Include="KduWrapper.cs" />
    <Compile Include="Operations.cs" />
    <Compile Include="PE\32\PE32File.cs" />
    <Compile Include="PE\32\PE32Header.cs" />
    <Compile Include="PE\64\PE64File.cs" />
    <Compile Include="PE\64\PE64Header.cs" />
    <Compile Include="PE\DOSHeader.cs" />
    <Compile Include="PE\NativePEStructs.cs" />
    <Compile Include="PE\PEFile.cs" />
    <Compile Include="PE\PESection.cs" />
    <Compile Include="ProcessDumper.cs" />
    <Compile Include="ProcessSummary.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="Properties\Resources.Designer.cs">
      <AutoGen>True</AutoGen>
      <DesignTime>True</DesignTime>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
    <Compile Include="Utility\Logger.cs" />
    <Compile Include="Utility\MarshalUtility.cs" />
    <Compile Include="Utility\ProcessListView.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Include="Utility\WinApi.cs" />
  </ItemGroup>
  <ItemGroup>
    <None Include="Driver\KsDumperDriver.sys" />
    <None Include="packages.config" />
  </ItemGroup>
  <ItemGroup>
    <Content Include="Driver\drv64.dll" />
    <Content Include="Driver\kdu.exe" />
    <Content Include="Driver\Taigei64.dll" />
  </ItemGroup>
  <ItemGroup>
    <EmbeddedResource Include="Properties\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
    </EmbeddedResource>
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
</Project>
```

`DriverInterface/KduProvider.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace KsDumper11
{
    public class KduProvider
    {
        public int ProviderIndex { get; set; }

        public string ProviderName { get; set; }
        public string DriverName { get; set; }
        public string DeviceName { get; set; }
        public string SignerName { get; set; }
        public bool IsWHQL_Signed { get; set; }
        public string ShellcodeSupportMask { get; set; }

        public string MaxWindowsBuild { get; set; }
        public string MinWindowsBuild { get; set; }

        public string[] ExtraInfo { get; set; }

        public bool IsNonWorking
        {
            get
            {
                return this.ProviderName.Contains("NOT WORKING");
            }
        }

        public bool IsWorking
        {
            get
            {
                return this.ProviderName.Contains("WORKING");
            }
        }


        public KduProvider()
        {
        }

        public KduProvider(string provider)
        {
            processProvider(provider);
        }

        private void processProvider(string prov)
        {
            string[] lines = prov.Split('\n');

            string id = lines[0].Split(',')[0];

            ProviderIndex = int.Parse(id);

            string[] provInfo = lines[1].Split(',');

            ProviderName = provInfo[0];

            string drvName = provInfo[1].Trim().Replace("DriverName ", "").Replace('"'.ToString(), "");
            string devName = provInfo[2].Trim().Replace("DeviceName ", "").Replace('"'.ToString(), "");
            DriverName = drvName;
            DeviceName = devName;

            string signer = lines[2].Trim().Replace("Signed by: ", "").Replace('"'.ToString(), "");
            SignerName = signer;

            string shellCodeMask = lines[3].Trim().Replace("Shellcode support mask: ", "").Replace('"'.ToString(), "");
            ShellcodeSupportMask = shellCodeMask;

            foreach (string ln in lines)
            {
                if (ln.Contains("Driver is WHQL signed"))
                {
                    IsWHQL_Signed = true;
                }

                if (ln.StartsWith("Maximum Windows build undefined"))
                {
                    MaxWindowsBuild = "No Restrictions";
                }

                if (ln.StartsWith("Maximum supported Windows build: "))
                {
                    MaxWindowsBuild = ln.Replace("Maximum supported Windows build: ", "");
                }

                if (ln.StartsWith("Minimum supported Windows build: "))
                {
                    MinWindowsBuild = ln.Replace("Minimum supported Windows build: ", "");
                }
            }

            List<string> extraInfoLines = new List<string>();

            for (int i = 4; i < lines.Length; i++)
            {
                if (lines[i].StartsWith("Minimum"))
                {
                    break;
                }
                else if (!lines[i].Contains("Driver is WHQL signed"))
                {
                    extraInfoLines.Add(lines[i]);
                }
            }

            ExtraInfo = extraInfoLines.ToArray();
        }
    }
}

```

`DriverInterface/KduProviderSettings.cs`:

```cs
using KsDumper11;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace KsDumper11
{
    public class KduProviderSettings
    {
        public List<KduProvider> Providers { get; set; }

        public int DefaultProvider { get; set; } = -1;
    }
}

```

`DriverInterface/KduSelfExtract.cs`:

```cs
using Microsoft.Win32;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading.Tasks;

namespace KsDumper11
{
    public class KduSelfExtract
    {
        public static void DisableDriverBlockList()
        {
            RegistryKey configKey = Registry.LocalMachine.OpenSubKey(@"SYSTEM\CurrentControlSet\Control\CI\Config", true);

            if (configKey == null)
            {
                configKey = Registry.LocalMachine.CreateSubKey(@"SYSTEM\CurrentControlSet\Control\CI\Config");
            }

            if (configKey != null)
            {
                if (configKey.GetValue("VulnerableDriverBlocklistEnable") == null)
                {
                    configKey.SetValue("VulnerableDriverBlocklistEnable", 0);
                }
            }
        }

        static string asmDir = "";
        static string driverDir = "";
        static KduSelfExtract()
        {
            DisableDriverBlockList();

            asmDir = AssemblyDirectory;
            driverDir = asmDir + @"\Driver";
        }
        public static string AssemblyDirectory
        {
            get
            {
                string codeBase = Assembly.GetExecutingAssembly().CodeBase;
                UriBuilder uri = new UriBuilder(codeBase);
                string path = Uri.UnescapeDataString(uri.Path);
                return Path.GetDirectoryName(path);
            }
        }

        public static string KduPath
        {
            get
            {
                return driverDir + @"\kdu.exe";
            }
        }

        private static bool Extracted()
        {
            bool result = false;

            string driverPath = driverDir + @"\KsDumperDriver.sys";
            string kduPath = driverDir + @"\kdu.exe";
            string drv64Path = driverDir + @"\drv64.dll";
            string taigei64Path = driverDir + @"\Taigei64.dll";

            if (!Directory.Exists(driverDir))
            {
                return false;
            }
            else
            {
                if (!File.Exists(driverPath))
                {
                    return false;
                }
                else
                {
                    result = true;
                }

                if (!File.Exists(kduPath))
                {
                    return false;
                }
                else
                {
                    result = true;
                }

                if (!File.Exists(drv64Path))
                {
                    return false;
                }
                else
                {
                    result = true;
                }

                if (!File.Exists(taigei64Path))
                {
                    return false;
                }
                else
                {
                    result = true;
                }
            }
            return result;
        }

        public static void Extract()
        {
            if (!Extracted())
            {
                string asmDir = AssemblyDirectory;
                string driverDir = asmDir + @"\Driver";
                if (!Directory.Exists(driverDir))
                {
                    Directory.CreateDirectory(driverDir);
                }

                string driverPath = driverDir + @"\KsDumperDriver.sys";
                string kduPath = driverDir + @"\kdu.exe";
                string drv64Path = driverDir + @"\drv64.dll";
                string taigei64Path = driverDir + @"\Taigei64.dll";

                if (!File.Exists(driverPath))
                {
                    File.WriteAllBytes(driverPath, DriverInterface.Properties.Resources.KsDumperDriver);
                }

                if (!File.Exists(kduPath))
                {
                    File.WriteAllBytes(kduPath, DriverInterface.Properties.Resources.kdu);
                }

                if (!File.Exists(drv64Path))
                {
                    File.WriteAllBytes(drv64Path, DriverInterface.Properties.Resources.drv64);
                }

                if (!File.Exists(taigei64Path))
                {
                    File.WriteAllBytes(taigei64Path, DriverInterface.Properties.Resources.Taigei64);
                }
            }
        }
    }
}

```

`DriverInterface/KduWrapper.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Drawing;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;
using KsDumper11.Driver;
using Newtonsoft.Json;

namespace KsDumper11
{
    public class KduWrapper
    {
        [DllImport("kernel32.dll", SetLastError = true)]
        private static extern bool FlushFileBuffers(IntPtr handle);

        string logFolder = Environment.CurrentDirectory + "\\Logs";

        public string KduPath { get; set; }

        private CancellationToken checkerTaskCancelToken;
        private CancelableTask<int> checkerTask;

        public event EventHandler<object[]> DriverLoaded;
        public event EventHandler ProvidersLoaded;

        private KduProviderSettings kduSettingsJson;

        public List<KduProvider> providers = new List<KduProvider>();

        private bool _IsDirty = false;

        //public event EventHandler IsDirtyChanged;

        public bool IsDirty
        {
            get
            {
                return _IsDirty;
            }
            set
            {
                _IsDirty = value;
                //if (IsDirtyChanged != null)
                //{
                //    IsDirtyChanged(_IsDirty, EventArgs.Empty);
                //}
            }
        }

        //CrashMon crashMon;

        public int DefaultProvider
        {
            get
            {
                return kduSettingsJson.DefaultProvider;
            }
        }

        public KduWrapper(string kduPath)
        {
            KduPath = kduPath;
            //crashMon = new CrashMon();

            kduSettingsJson = new KduProviderSettings();
        }

        public void SetDefaultProvider(int providerID)
        {
            kduSettingsJson.DefaultProvider = providerID;

            SaveProviders();
        }

        public void ResetProviders()
        {

            for (int i = 0; i < providers.Count; i++)
            {
                string non_W = "[NOT WORKING] ";
                string W_ = "[WORKING] ";
                providers[i].ProviderName = providers[i].ProviderName.Replace(non_W, "").Replace(W_, "");
            }

            kduSettingsJson.DefaultProvider = -1;

            IsDirty = false;

            SaveProviders();
        }

        public void LoadProviders()
        {
            if (!File.Exists(KduSelfExtract.AssemblyDirectory + @"\\Providers.json"))
            {
                populateProviders();

                IsDirty = false;
            }
            else
            {
                kduSettingsJson = JsonConvert.DeserializeObject<KduProviderSettings>(File.ReadAllText(KduSelfExtract.AssemblyDirectory + @"\\Providers.json"));
                providers = kduSettingsJson.Providers;

                bool foundADirty = false;
                foreach (KduProvider provider in providers)
                {
                    if (provider.IsNonWorking == true || provider.IsWorking == true)
                    {
                        foundADirty = true;
                        break;
                    }
                }

                IsDirty = foundADirty;

                //if (crashMon.CheckingProvider != -1)
                //{
                //    //if (KsDumper11.BSOD.JustHappened())
                //    {
                //        providers[crashMon.CheckingProvider].ProviderName = "[NOT WORKING] " + providers[crashMon.CheckingProvider].ProviderName;
                //        SaveProviders();

                //        crashMon.CheckingProvider = -1;
                //    }
                //}

                FireProvidersLoaded();
            }
        }

        private void populateProviders()
        {

            ProcessStartInfo inf = new ProcessStartInfo();
            inf.FileName = KduPath;
            inf.Arguments = "-list";
            inf.CreateNoWindow = true;
            inf.WindowStyle = ProcessWindowStyle.Hidden;
            inf.RedirectStandardOutput = true;
            inf.UseShellExecute = false;

            Process proc = Process.Start(inf);
            string str = proc.StandardOutput.ReadToEnd();

            List<string> parts = new List<string>(str.Split(new string[] { "Provider #" }, StringSplitOptions.RemoveEmptyEntries));
            parts.RemoveAt(0);

            for (int i = 0; i < parts.Count; i++)
            {
                parts[i] = parts[i].Trim().Replace('\r'.ToString(), "").Replace('\t'.ToString(), "");
            }

            foreach (string prov in parts)
            {
                KduProvider p = new KduProvider(prov);
                providers.Add(p);
            }

            SaveProviders();

            FireProvidersLoaded();
        }

        private void FireProvidersLoaded()
        {
            if (ProvidersLoaded != null)
            {
                ProvidersLoaded(this, EventArgs.Empty);
            }
        }

        private void SaveProviders()
        {
            kduSettingsJson.Providers = providers;

            string json = JsonConvert.SerializeObject(kduSettingsJson);
            string savePath = KduSelfExtract.AssemblyDirectory + @"\\Providers.json";
            if (!File.Exists(savePath))
            {
                FileStream fs = File.Create(savePath);
                StreamWriter sw = new StreamWriter(fs);
                sw.Write(json);
                sw.Flush();
                FlushFileBuffers(fs.Handle);
                sw.Close();
                sw.Dispose();
            }
            else
            {
                File.Delete(savePath);
                FileStream fs = File.Create(savePath);
                StreamWriter sw = new StreamWriter(fs);
                sw.Write(json);
                sw.Flush();
                FlushFileBuffers(fs.Handle);
                sw.Close();
                sw.Dispose();
            }
        }

        private void runChecker(int providerID)
        {
            checkerTaskCancelToken = new CancellationToken();

            checkerTask = new CancelableTask<int>(checkerTaskCancelToken);

            // Create a cancelable task
            var task = checkerTask.CreateTask(token =>
            {
                while (!KsDumperDriverInterface.IsDriverOpen("\\\\.\\KsDumper"))
                {
                    try
                    {
                        // Checks to see if we need to cancel the checker
                        token.ThrowIfCancellationRequested();
                    }
                    catch (Exception)
                    {
                        break;
                    }
                }

                if (KsDumperDriverInterface.IsDriverOpen("\\\\.\\KsDumper"))
                {
                    if (DriverLoaded != null)
                    {
                        updateProvider(true, providerID);
                        DriverLoaded(this, new object[] { true, providerID });
                    }
                    return 1;
                }
                else
                {
                    if (DriverLoaded != null)
                    {
                        updateProvider(false, providerID);
                        DriverLoaded(this, new object[] { false, providerID });
                    }
                    return 0;
                }
            });
        }

        private void updateProvider(bool res, int idx)
        {
            //crashMon.CheckingProvider = -1;

            KduProvider p = providers[idx];

            if (res)
            {
                KsDumperDriverInterface ksDriver = new KsDumperDriverInterface("\\\\.\\KsDumper");
                ksDriver.UnloadDriver();

                ksDriver.Dispose();

                providers[idx].ProviderName = "[WORKING] " + providers[idx].ProviderName;

                IsDirty = true;
            }
            else
            {
                providers[idx].ProviderName = "[NOT WORKING] " + providers[idx].ProviderName;

                IsDirty = true;
            }

            SaveProviders();
        }

        static string AppendDateTimeToFileName(string originalFileName)
        {
            // Get the current date and time
            DateTime currentTime = DateTime.Now;

            // Format the date and time as a string
            string formattedDateTime = currentTime.ToString("yyyyMMddHHmmss");

            // Get the file extension from the original filename (if any)
            string fileExtension = System.IO.Path.GetExtension(originalFileName);

            // Remove the file extension from the original filename
            string fileNameWithoutExtension = System.IO.Path.GetFileNameWithoutExtension(originalFileName);

            // Append the formatted date and time to the filename
            string newFileName = $"{formattedDateTime}_{fileNameWithoutExtension}{fileExtension}";

            return newFileName;
        }

        public void Start()
        {
            int providerID = kduSettingsJson.DefaultProvider;

            if (providerID != -1)
            {
                if (providers[providerID].ProviderName.Contains("[NON WORKING]"))
                {
                    return;
                }

                string fileName = $"KsDumper11Driver_ProviderID_{providerID}.log";

                fileName = AppendDateTimeToFileName(fileName);

                string logPath = logFolder + "\\" + fileName;

                if (!Directory.Exists(logFolder))
                {
                    Directory.CreateDirectory(logFolder);
                }

                ProcessStartInfo inf = new ProcessStartInfo(KduPath)
                {
                    Arguments = $"-prv {providerID} -map .\\Driver\\KsDumperDriver.sys",
                    CreateNoWindow = true,
                    UseShellExecute = false,
                    WorkingDirectory = Environment.CurrentDirectory,
                    RedirectStandardOutput = true
                };
                Process proc = Process.Start(inf);
                proc.Exited += Proc_Exited;
                proc.EnableRaisingEvents = true;
                proc.WaitForExit(12500);

                string output = proc.StandardOutput.ReadToEnd();

                File.WriteAllText(logPath, output);
            }
            else
            {
                // alert the user to the fact they probably need to clear the settings jsons
            }
        }

        public void tryLoad(int providerID)
        {
            if (providers[providerID].ProviderName.Contains("[WORKING]") || providers[providerID].ProviderName.Contains("[NON WORKING]"))
            {
                return;
            }

            //crashMon.CheckingProvider = providerID;

            Task.Run(() =>
            {
                runChecker(providerID);

                string fileName = $"KsDumper11Driver_ProviderID_{providerID}.log";

                fileName = AppendDateTimeToFileName(fileName);

                string logPath = logFolder + "\\" + fileName;

                if (!Directory.Exists(logFolder))
                {
                    Directory.CreateDirectory(logFolder);
                }

                ProcessStartInfo inf = new ProcessStartInfo(KduPath)
                {
                    Arguments = $"-prv {providerID} -map .\\Driver\\KsDumperDriver.sys",
                    CreateNoWindow = true,
                    UseShellExecute = false,
                    WorkingDirectory = Environment.CurrentDirectory,
                    RedirectStandardOutput = true
                };
                Process proc = Process.Start(inf);
                proc.Exited += Proc_Exited;
                proc.EnableRaisingEvents = true;
                proc.WaitForExit(12500);


                string output = proc.StandardOutput.ReadToEnd();

                File.WriteAllText(logPath, output);

            });
        }

        private void Proc_Exited(object sender, EventArgs e)
        {
            if (checkerTask != null)
            {
                try
                {
                    checkerTask.Cancel();
                }
                catch { }
            }


            ProcessStartInfo inf = new ProcessStartInfo("cmd.exe")
            {
                Arguments = "/c taskkill /IM \"kdu.exe\"",
                CreateNoWindow = true,
                UseShellExecute = false,
            };

            Process proc = Process.Start(inf);
            proc.WaitForExit(12500);

            inf = new ProcessStartInfo("cmd")
            {
                Arguments = " /c \"taskkill /im kdu.exe\"",
                CreateNoWindow = true,
                UseShellExecute = false,
            };
            proc = Process.Start(inf);
            if (!proc.WaitForExit(12500))
            {
                proc.Kill();
            }
        }
    }
}

```

`DriverInterface/KsDumperDriverInterface.cs`:

```cs
using System;
using System.IO;
using System.Runtime.InteropServices;
using KsDumper11.Utility;

namespace KsDumper11.Driver
{
	public class KsDumperDriverInterface
	{
		public static KsDumperDriverInterface OpenKsDumperDriver()
		{
			return new KsDumperDriverInterface("\\\\.\\KsDumper");
		}
        public static bool IsDriverOpen(string driverPath)
        {
            IntPtr handle = WinApi.CreateFileA(driverPath, FileAccess.ReadWrite, FileShare.ReadWrite, IntPtr.Zero, FileMode.Open, (FileAttributes)0, IntPtr.Zero);
            bool result = handle != WinApi.INVALID_HANDLE_VALUE;
            WinApi.CloseHandle(handle);
            return result;
        }

        public KsDumperDriverInterface(string registryPath)
		{
			this.driverHandle = WinApi.CreateFileA(registryPath, FileAccess.ReadWrite, FileShare.ReadWrite, IntPtr.Zero, FileMode.Open, (FileAttributes)0, IntPtr.Zero);
		}

		public bool HasValidHandle()
		{
			return this.driverHandle != WinApi.INVALID_HANDLE_VALUE;
		}

		public bool GetProcessSummaryList(out ProcessSummary[] result)
		{
			result = new ProcessSummary[0];
			bool flag = this.driverHandle != WinApi.INVALID_HANDLE_VALUE;
			if (flag)
			{
				int requiredBufferSize = this.GetProcessListRequiredBufferSize();
				bool flag2 = requiredBufferSize > 0;
				if (flag2)
				{
					IntPtr bufferPointer = MarshalUtility.AllocZeroFilled(requiredBufferSize);
					Operations.KERNEL_PROCESS_LIST_OPERATION operation = new Operations.KERNEL_PROCESS_LIST_OPERATION
					{
						bufferAddress = (ulong)bufferPointer.ToInt64(),
						bufferSize = requiredBufferSize
					};
					IntPtr operationPointer = MarshalUtility.CopyStructToMemory<Operations.KERNEL_PROCESS_LIST_OPERATION>(operation);
					int operationSize = Marshal.SizeOf<Operations.KERNEL_PROCESS_LIST_OPERATION>();
					bool flag3 = WinApi.DeviceIoControl(this.driverHandle, Operations.IO_GET_PROCESS_LIST, operationPointer, operationSize, operationPointer, operationSize, IntPtr.Zero, IntPtr.Zero);
					if (flag3)
					{
						operation = MarshalUtility.GetStructFromMemory<Operations.KERNEL_PROCESS_LIST_OPERATION>(operationPointer, true);
						bool flag4 = operation.processCount > 0;
						if (flag4)
						{
							byte[] managedBuffer = new byte[requiredBufferSize];
							Marshal.Copy(bufferPointer, managedBuffer, 0, requiredBufferSize);
							Marshal.FreeHGlobal(bufferPointer);
							result = new ProcessSummary[operation.processCount];
							using (BinaryReader reader = new BinaryReader(new MemoryStream(managedBuffer)))
							{
								for (int i = 0; i < result.Length; i++)
								{
									result[i] = ProcessSummary.FromStream(reader);
								}
							}
							return true;
						}
					}
				}
			}
			return false;
		}

		private int GetProcessListRequiredBufferSize()
		{
			IntPtr operationPointer = MarshalUtility.AllocEmptyStruct<Operations.KERNEL_PROCESS_LIST_OPERATION>();
			int operationSize = Marshal.SizeOf<Operations.KERNEL_PROCESS_LIST_OPERATION>();
			bool flag = WinApi.DeviceIoControl(this.driverHandle, Operations.IO_GET_PROCESS_LIST, operationPointer, operationSize, operationPointer, operationSize, IntPtr.Zero, IntPtr.Zero);
			if (flag)
			{
				Operations.KERNEL_PROCESS_LIST_OPERATION operation = MarshalUtility.GetStructFromMemory<Operations.KERNEL_PROCESS_LIST_OPERATION>(operationPointer, true);
				bool flag2 = operation.processCount == 0 && operation.bufferSize > 0;
				if (flag2)
				{
					return operation.bufferSize;
				}
			}
			return 0;
		}

		public bool CopyVirtualMemory(int targetProcessId, IntPtr targetAddress, IntPtr bufferAddress, int bufferSize)
		{
			bool flag = this.driverHandle != WinApi.INVALID_HANDLE_VALUE;
			bool flag2;
			if (flag)
			{
				Operations.KERNEL_COPY_MEMORY_OPERATION operation = new Operations.KERNEL_COPY_MEMORY_OPERATION
				{
					targetProcessId = targetProcessId,
					targetAddress = (ulong)targetAddress.ToInt64(),
					bufferAddress = (ulong)bufferAddress.ToInt64(),
					bufferSize = bufferSize
				};
				IntPtr operationPointer = MarshalUtility.CopyStructToMemory<Operations.KERNEL_COPY_MEMORY_OPERATION>(operation);
				bool result = WinApi.DeviceIoControl(this.driverHandle, Operations.IO_COPY_MEMORY, operationPointer, Marshal.SizeOf<Operations.KERNEL_COPY_MEMORY_OPERATION>(), IntPtr.Zero, 0, IntPtr.Zero, IntPtr.Zero);
				Marshal.FreeHGlobal(operationPointer);
				flag2 = result;
			}
			else
			{
				flag2 = false;
			}
			return flag2;
		}

        public bool UnloadDriver()
        {
            if (driverHandle != WinApi.INVALID_HANDLE_VALUE)
            {
				bool result = WinApi.DeviceIoControl(driverHandle, Operations.IO_UNLOAD_DRIVER, IntPtr.Zero, 0, IntPtr.Zero, 0, IntPtr.Zero, IntPtr.Zero);
				this.Dispose();
				return result;
            }
            return false;
        }

        private readonly IntPtr driverHandle;

        public void Dispose()
        {
            try
            {
                WinApi.CloseHandle(driverHandle);
            }
            catch (Exception ex)
            {
                return;
            }
        }

        ~KsDumperDriverInterface()
        {
			try
			{
				WinApi.CloseHandle(driverHandle);
			}
			catch (Exception ex)
			{
				return;
			}
        }
    }
}

```

`DriverInterface/Operations.cs`:

```cs
using System;
using KsDumper11.Utility;
using static KsDumper11.Utility.WinApi;

namespace KsDumper11.Driver
{
	public static class Operations
	{
		private static uint CTL_CODE(int deviceType, int function, int method, int access)
		{
			return (uint)((deviceType << 16) | (access << 14) | (function << 2) | method);
		}

		public static readonly uint IO_GET_PROCESS_LIST = Operations.CTL_CODE(WinApi.FILE_DEVICE_UNKNOWN, 5924, WinApi.METHOD_BUFFERED, WinApi.FILE_ANY_ACCESS);

		public static readonly uint IO_COPY_MEMORY = Operations.CTL_CODE(WinApi.FILE_DEVICE_UNKNOWN, 5925, WinApi.METHOD_BUFFERED, WinApi.FILE_ANY_ACCESS);

        public static readonly uint IO_UNLOAD_DRIVER = CTL_CODE(FILE_DEVICE_UNKNOWN, 0x1726, METHOD_BUFFERED, FILE_ANY_ACCESS);

        public struct KERNEL_PROCESS_LIST_OPERATION
		{
			public ulong bufferAddress;

			public int bufferSize;

			public int processCount;
		}

		public struct KERNEL_COPY_MEMORY_OPERATION
		{
			public int targetProcessId;

			public ulong targetAddress;

			public ulong bufferAddress;

			public int bufferSize;
		}
	}
}

```

`DriverInterface/PE/32/PE32File.cs`:

```cs
using System.IO;
using System.Runtime.InteropServices;

using static KsDumper11.PE.NativePEStructs;

namespace KsDumper11.PE
{
    public class PE32File : PEFile
    {
        public DOSHeader DOSHeader { get; private set; }

        public byte[] DOS_Stub { get; private set; }

        public PE32Header PEHeader { get; private set; }

        public PE32File(IMAGE_DOS_HEADER dosHeader, IMAGE_NT_HEADERS32 peHeader, byte[] dosStub)
        {
            Type = PEType.PE32;
            DOSHeader = DOSHeader.FromNativeStruct(dosHeader);
            PEHeader = PE32Header.FromNativeStruct(peHeader);
            Sections = new PESection[peHeader.FileHeader.NumberOfSections];
            DOS_Stub = dosStub;
        }

        public override void SaveToDisk(string fileName)
        {
            try
            {
                using (BinaryWriter writer = new BinaryWriter(new FileStream(fileName, FileMode.Create, FileAccess.Write)))
                {
                    DOSHeader.AppendToStream(writer);
                    writer.Write(DOS_Stub);
                    PEHeader.AppendToStream(writer);
                    AppendSections(writer);
                }
            }
            catch { }
        }

        public override int GetFirstSectionHeaderOffset()
        {
            return Marshal.OffsetOf<IMAGE_NT_HEADERS32>("OptionalHeader").ToInt32() +
                PEHeader.FileHeader.SizeOfOptionalHeader;
        }

        public override void AlignSectionHeaders()
        {
            int newFileSize = DOSHeader.e_lfanew + 0x4 +
                Marshal.SizeOf<IMAGE_FILE_HEADER>() +
                PEHeader.FileHeader.SizeOfOptionalHeader +
                    (PEHeader.FileHeader.NumberOfSections * Marshal.SizeOf<IMAGE_SECTION_HEADER>());

            OrderSectionsBy(s => s.Header.PointerToRawData);

            for (int i = 0; i < Sections.Length; i++)
            {
                Sections[i].Header.VirtualAddress = AlignValue(Sections[i].Header.VirtualAddress, PEHeader.OptionalHeader.SectionAlignment);
                Sections[i].Header.VirtualSize = AlignValue(Sections[i].Header.VirtualSize, PEHeader.OptionalHeader.SectionAlignment);
                Sections[i].Header.PointerToRawData = AlignValue((uint)newFileSize, PEHeader.OptionalHeader.FileAlignment);
                Sections[i].Header.SizeOfRawData = AlignValue((uint)Sections[i].DataSize, PEHeader.OptionalHeader.FileAlignment);

                newFileSize = (int)(Sections[i].Header.PointerToRawData + Sections[i].Header.SizeOfRawData);
            }

            OrderSectionsBy(s => s.Header.VirtualAddress);
        }

        public override void FixPEHeader()
        {
            PEHeader.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress = 0;
            PEHeader.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].Size = 0;

            for (uint i = PEHeader.OptionalHeader.NumberOfRvaAndSizes; i < IMAGE_NUMBEROF_DIRECTORY_ENTRIES; i++)
            {
                PEHeader.OptionalHeader.DataDirectory[i].VirtualAddress = 0;
                PEHeader.OptionalHeader.DataDirectory[i].Size = 0;
            }

            PEHeader.OptionalHeader.NumberOfRvaAndSizes = IMAGE_NUMBEROF_DIRECTORY_ENTRIES;
            PEHeader.FileHeader.SizeOfOptionalHeader = (ushort)Marshal.SizeOf<IMAGE_OPTIONAL_HEADER32>();
            FixSizeOfImage();

            int size = DOSHeader.e_lfanew + 0x4 + Marshal.SizeOf<IMAGE_FILE_HEADER>();
            PEHeader.OptionalHeader.SizeOfHeaders = AlignValue((uint)(size + PEHeader.FileHeader.SizeOfOptionalHeader + (PEHeader.FileHeader.NumberOfSections * Marshal.SizeOf<IMAGE_SECTION_HEADER>())), PEHeader.OptionalHeader.FileAlignment);

            RemoveIatDirectory();
        }

        private uint AlignValue(uint value, uint alignment)
        {
            return ((value + alignment - 1) / alignment) * alignment;
        }

        private void FixSizeOfImage()
        {
            uint lastSize = 0;

            for (int i = 0; i < PEHeader.FileHeader.NumberOfSections; i++)
            {
                if (Sections[i].Header.VirtualAddress + Sections[i].Header.VirtualSize > lastSize)
                {
                    lastSize = Sections[i].Header.VirtualAddress + Sections[i].Header.VirtualSize;
                }
            }
            PEHeader.OptionalHeader.SizeOfImage = lastSize;
        }

        private void RemoveIatDirectory()
        {
            uint iatDataAddress = PEHeader.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress;

            PEHeader.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress = 0;
            PEHeader.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].Size = 0;

            if (iatDataAddress != 0)
            {
                for (int i = 0; i < PEHeader.FileHeader.NumberOfSections; i++)
                {
                    if (Sections[i].Header.VirtualAddress <= iatDataAddress &&
                        Sections[i].Header.VirtualAddress + Sections[i].Header.VirtualSize > iatDataAddress)
                    {
                        Sections[i].Header.Characteristics |= DataSectionFlags.MemoryRead | DataSectionFlags.MemoryWrite;
                    }
                }
            }
        }
    }
}

```

`DriverInterface/PE/32/PE32Header.cs`:

```cs
using System.IO;
using System.Linq;

using static KsDumper11.PE.NativePEStructs;

namespace KsDumper11.PE
{
    public class PE32Header
    {
        public string Signature { get; private set; }

        public PE32FileHeader FileHeader { get; private set; }

        public PE32OptionalHeader OptionalHeader { get; private set; }


        public void AppendToStream(BinaryWriter writer)
        {
            writer.Write(Signature.ToCharArray());
            FileHeader.AppendToStream(writer);
            OptionalHeader.AppendToStream(writer);
        }

        public static PE32Header FromNativeStruct(IMAGE_NT_HEADERS32 nativeStruct)
        {
            return new PE32Header
            {
                Signature = new string(nativeStruct.Signature),
                FileHeader = PE32FileHeader.FromNativeStruct(nativeStruct.FileHeader),
                OptionalHeader = PE32OptionalHeader.FromNativeStruct(nativeStruct.OptionalHeader)
            };            
        }


        public class PE32FileHeader
        {
            public ushort Machine { get; set; }
            public ushort NumberOfSections { get; set; }
            public uint TimeDateStamp { get; set; }
            public uint PointerToSymbolTable { get; set; }
            public uint NumberOfSymbols { get; set; }
            public ushort SizeOfOptionalHeader { get; set; }
            public ushort Characteristics { get; set; }

            public void AppendToStream(BinaryWriter writer)
            {
                writer.Write(Machine);
                writer.Write(NumberOfSections);
                writer.Write(TimeDateStamp);
                writer.Write(PointerToSymbolTable);
                writer.Write(NumberOfSymbols);
                writer.Write(SizeOfOptionalHeader);
                writer.Write(Characteristics);
            }

            public static PE32FileHeader FromNativeStruct(IMAGE_FILE_HEADER nativeStruct)
            {
                return new PE32FileHeader
                {
                    Machine = nativeStruct.Machine,
                    NumberOfSections = nativeStruct.NumberOfSections,
                    TimeDateStamp = nativeStruct.TimeDateStamp,
                    PointerToSymbolTable = nativeStruct.PointerToSymbolTable,
                    NumberOfSymbols = nativeStruct.NumberOfSymbols,
                    SizeOfOptionalHeader = nativeStruct.SizeOfOptionalHeader,
                    Characteristics = nativeStruct.Characteristics
                };
            }
        }
        
        public class PE32OptionalHeader
        {
            public ushort Magic { get; set; }
            public byte MajorLinkerVersion { get; set; }
            public byte MinorLinkerVersion { get; set; }
            public uint SizeOfCode { get; set; }
            public uint SizeOfInitializedData { get; set; }
            public uint SizeOfUninitializedData { get; set; }
            public uint AddressOfEntryPoint { get; set; }
            public uint BaseOfCode { get; set; }
            public uint BaseOfData { get; set; }
            public uint ImageBase { get; set; }
            public uint SectionAlignment { get; set; }
            public uint FileAlignment { get; set; }
            public ushort MajorOperatingSystemVersion { get; set; }
            public ushort MinorOperatingSystemVersion { get; set; }
            public ushort MajorImageVersion { get; set; }
            public ushort MinorImageVersion { get; set; }
            public ushort MajorSubsystemVersion { get; set; }
            public ushort MinorSubsystemVersion { get; set; }
            public uint Win32VersionValue { get; set; }
            public uint SizeOfImage { get; set; }
            public uint SizeOfHeaders { get; set; }
            public uint CheckSum { get; set; }
            public ushort Subsystem { get; set; }
            public ushort DllCharacteristics { get; set; }
            public uint SizeOfStackReserve { get; set; }
            public uint SizeOfStackCommit { get; set; }
            public uint SizeOfHeapReserve { get; set; }
            public uint SizeOfHeapCommit { get; set; }
            public uint LoaderFlags { get; set; }
            public uint NumberOfRvaAndSizes { get; set; }
            public PE32DataDirectory[] DataDirectory { get; private set; }


            public void AppendToStream(BinaryWriter writer)
            {
                writer.Write(Magic);
                writer.Write(MajorLinkerVersion);
                writer.Write(MinorLinkerVersion);
                writer.Write(SizeOfCode);
                writer.Write(SizeOfInitializedData);
                writer.Write(SizeOfUninitializedData);
                writer.Write(AddressOfEntryPoint);
                writer.Write(BaseOfCode);
                writer.Write(BaseOfData);
                writer.Write(ImageBase);
                writer.Write(SectionAlignment);
                writer.Write(FileAlignment);
                writer.Write(MajorOperatingSystemVersion);
                writer.Write(MinorOperatingSystemVersion);
                writer.Write(MajorImageVersion);
                writer.Write(MinorImageVersion);
                writer.Write(MajorSubsystemVersion);
                writer.Write(MinorSubsystemVersion);
                writer.Write(Win32VersionValue);
                writer.Write(SizeOfImage);
                writer.Write(SizeOfHeaders);
                writer.Write(CheckSum);
                writer.Write(Subsystem);
                writer.Write(DllCharacteristics);
                writer.Write(SizeOfStackReserve);
                writer.Write(SizeOfStackCommit);
                writer.Write(SizeOfHeapReserve);
                writer.Write(SizeOfHeapCommit);
                writer.Write(LoaderFlags);
                writer.Write(NumberOfRvaAndSizes);

                foreach (PE32DataDirectory dataDirectory in DataDirectory)
                {
                    dataDirectory.AppendToStream(writer);
                }
            }

            public static PE32OptionalHeader FromNativeStruct(IMAGE_OPTIONAL_HEADER32 nativeStruct)
            {
                PE32DataDirectory[] directories = nativeStruct.DataDirectory.Select(d => PE32DataDirectory.FromNativeStruct(d)).ToArray();

                return new PE32OptionalHeader
                {
                    Magic = nativeStruct.Magic,
                    MajorLinkerVersion = nativeStruct.MajorLinkerVersion,
                    MinorLinkerVersion = nativeStruct.MinorLinkerVersion,
                    SizeOfCode = nativeStruct.SizeOfCode,
                    SizeOfInitializedData = nativeStruct.SizeOfInitializedData,
                    SizeOfUninitializedData = nativeStruct.SizeOfUninitializedData,
                    AddressOfEntryPoint = nativeStruct.AddressOfEntryPoint,
                    BaseOfCode = nativeStruct.BaseOfCode,
                    BaseOfData = nativeStruct.BaseOfData,
                    ImageBase = nativeStruct.ImageBase,
                    SectionAlignment = nativeStruct.SectionAlignment,
                    FileAlignment = nativeStruct.FileAlignment,
                    MajorOperatingSystemVersion = nativeStruct.MajorOperatingSystemVersion,
                    MinorOperatingSystemVersion = nativeStruct.MinorOperatingSystemVersion,
                    MajorImageVersion = nativeStruct.MajorImageVersion,
                    MinorImageVersion = nativeStruct.MinorImageVersion,
                    MajorSubsystemVersion = nativeStruct.MajorSubsystemVersion,
                    MinorSubsystemVersion = nativeStruct.MinorSubsystemVersion,
                    Win32VersionValue = nativeStruct.Win32VersionValue,
                    SizeOfImage = nativeStruct.SizeOfImage,
                    SizeOfHeaders = nativeStruct.SizeOfHeaders,
                    CheckSum = nativeStruct.CheckSum,
                    Subsystem = nativeStruct.Subsystem,
                    DllCharacteristics = nativeStruct.DllCharacteristics,
                    SizeOfStackReserve = nativeStruct.SizeOfStackReserve,
                    SizeOfStackCommit = nativeStruct.SizeOfStackCommit,
                    SizeOfHeapReserve = nativeStruct.SizeOfHeapReserve,
                    SizeOfHeapCommit = nativeStruct.SizeOfHeapCommit,
                    LoaderFlags = nativeStruct.LoaderFlags,
                    NumberOfRvaAndSizes = nativeStruct.NumberOfRvaAndSizes,
                    DataDirectory = directories
                };
            }

            public class PE32DataDirectory
            {
                public uint VirtualAddress { get; set; }
                public uint Size { get; set; }


                public void AppendToStream(BinaryWriter writer)
                {
                    writer.Write(VirtualAddress);
                    writer.Write(Size);
                }

                public static PE32DataDirectory FromNativeStruct(IMAGE_DATA_DIRECTORY nativeStruct)
                {
                    return new PE32DataDirectory
                    {
                        VirtualAddress = nativeStruct.VirtualAddress,
                        Size = nativeStruct.Size
                    };
                }
            }
        }           
    }
}

```

`DriverInterface/PE/64/PE64File.cs`:

```cs
using System.IO;
using System.Runtime.InteropServices;

using static KsDumper11.PE.NativePEStructs;

namespace KsDumper11.PE
{
    public class PE64File : PEFile
    {
        public DOSHeader DOSHeader { get; private set; }

        public byte[] DOS_Stub { get; private set; }

        public PE64Header PEHeader { get; private set; }

        public PE64File(IMAGE_DOS_HEADER dosHeader, IMAGE_NT_HEADERS64 peHeader, byte[] dosStub)
        {
            Type = PEType.PE64;
            DOSHeader = DOSHeader.FromNativeStruct(dosHeader);
            PEHeader = PE64Header.FromNativeStruct(peHeader);
            Sections = new PESection[peHeader.FileHeader.NumberOfSections];
            DOS_Stub = dosStub;
        }

        public override void SaveToDisk(string fileName)
        {
            try
            {
                using (BinaryWriter writer = new BinaryWriter(new FileStream(fileName, FileMode.Create, FileAccess.Write)))
                {
                    DOSHeader.AppendToStream(writer);
                    writer.Write(DOS_Stub);
                    PEHeader.AppendToStream(writer);
                    AppendSections(writer);                    
                }
            }
            catch { }
        }

        public override int GetFirstSectionHeaderOffset()
        {
            return Marshal.OffsetOf<IMAGE_NT_HEADERS64>("OptionalHeader").ToInt32() +
                PEHeader.FileHeader.SizeOfOptionalHeader;
        }

        public override void AlignSectionHeaders()
        {
            int newFileSize = DOSHeader.e_lfanew + 0x4 +
                Marshal.SizeOf<IMAGE_FILE_HEADER>() +
                PEHeader.FileHeader.SizeOfOptionalHeader +
                    (PEHeader.FileHeader.NumberOfSections * Marshal.SizeOf<IMAGE_SECTION_HEADER>());

            OrderSectionsBy(s => s.Header.PointerToRawData);

            for (int i = 0; i < Sections.Length; i++)
            {
                Sections[i].Header.VirtualAddress = AlignValue(Sections[i].Header.VirtualAddress, PEHeader.OptionalHeader.SectionAlignment);
                Sections[i].Header.VirtualSize = AlignValue(Sections[i].Header.VirtualSize, PEHeader.OptionalHeader.SectionAlignment);
                Sections[i].Header.PointerToRawData = AlignValue((uint)newFileSize, PEHeader.OptionalHeader.FileAlignment);
                Sections[i].Header.SizeOfRawData = AlignValue((uint)Sections[i].DataSize, PEHeader.OptionalHeader.FileAlignment);

                newFileSize = (int)(Sections[i].Header.PointerToRawData + Sections[i].Header.SizeOfRawData);
            }

            OrderSectionsBy(s => s.Header.VirtualAddress);
        }

        public override void FixPEHeader()
        {
            PEHeader.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].VirtualAddress = 0;
            PEHeader.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT].Size = 0;

            for (uint i = PEHeader.OptionalHeader.NumberOfRvaAndSizes; i < IMAGE_NUMBEROF_DIRECTORY_ENTRIES; i++)
            {
                PEHeader.OptionalHeader.DataDirectory[i].VirtualAddress = 0;
                PEHeader.OptionalHeader.DataDirectory[i].Size = 0;
            }

            PEHeader.OptionalHeader.NumberOfRvaAndSizes = IMAGE_NUMBEROF_DIRECTORY_ENTRIES;
            PEHeader.FileHeader.SizeOfOptionalHeader = (ushort)Marshal.SizeOf<IMAGE_OPTIONAL_HEADER64>();
            FixSizeOfImage();

            int size = DOSHeader.e_lfanew + 0x4 + Marshal.SizeOf<IMAGE_FILE_HEADER>();
            PEHeader.OptionalHeader.SizeOfHeaders = AlignValue((uint)(size + PEHeader.FileHeader.SizeOfOptionalHeader + (PEHeader.FileHeader.NumberOfSections * Marshal.SizeOf<IMAGE_SECTION_HEADER>())), PEHeader.OptionalHeader.FileAlignment);

            RemoveIatDirectory();
        }

        private uint AlignValue(uint value, uint alignment)
        {
            return ((value + alignment - 1) / alignment) * alignment;
        }

        private void FixSizeOfImage()
        {
            uint lastSize = 0;

            for (int i = 0; i < PEHeader.FileHeader.NumberOfSections; i++)
            {
                if (Sections[i].Header.VirtualAddress + Sections[i].Header.VirtualSize > lastSize)
                {
                    lastSize = Sections[i].Header.VirtualAddress + Sections[i].Header.VirtualSize;
                }
            }
            PEHeader.OptionalHeader.SizeOfImage = lastSize;
        }

        private void RemoveIatDirectory()
        {
            uint iatDataAddress = PEHeader.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress;

            PEHeader.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress = 0;
            PEHeader.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IAT].Size = 0;

            if (iatDataAddress != 0)
            {
                for (int i = 0; i < PEHeader.FileHeader.NumberOfSections; i++)
                {
                    if (Sections[i].Header.VirtualAddress <= iatDataAddress &&
                        Sections[i].Header.VirtualAddress + Sections[i].Header.VirtualSize > iatDataAddress)
                    {
                        Sections[i].Header.Characteristics |= DataSectionFlags.MemoryRead | DataSectionFlags.MemoryWrite;
                    }
                }
            }
        }
    }
}

```

`DriverInterface/PE/64/PE64Header.cs`:

```cs
using System.IO;
using System.Linq;

using static KsDumper11.PE.NativePEStructs;

namespace KsDumper11.PE
{
    public class PE64Header
    {
        public string Signature { get; private set; }

        public PE64FileHeader FileHeader { get; private set; }

        public PE64OptionalHeader OptionalHeader { get; private set; }


        public void AppendToStream(BinaryWriter writer)
        {
            writer.Write(Signature.ToCharArray());
            FileHeader.AppendToStream(writer);
            OptionalHeader.AppendToStream(writer);
        }

        public static PE64Header FromNativeStruct(IMAGE_NT_HEADERS64 nativeStruct)
        {
            return new PE64Header
            {
                Signature = new string(nativeStruct.Signature),
                FileHeader = PE64FileHeader.FromNativeStruct(nativeStruct.FileHeader),
                OptionalHeader = PE64OptionalHeader.FromNativeStruct(nativeStruct.OptionalHeader)
            };            
        }


        public class PE64FileHeader
        {
            public ushort Machine { get; set; }
            public ushort NumberOfSections { get; set; }
            public uint TimeDateStamp { get; set; }
            public uint PointerToSymbolTable { get; set; }
            public uint NumberOfSymbols { get; set; }
            public ushort SizeOfOptionalHeader { get; set; }
            public ushort Characteristics { get; set; }

            public void AppendToStream(BinaryWriter writer)
            {
                writer.Write(Machine);
                writer.Write(NumberOfSections);
                writer.Write(TimeDateStamp);
                writer.Write(PointerToSymbolTable);
                writer.Write(NumberOfSymbols);
                writer.Write(SizeOfOptionalHeader);
                writer.Write(Characteristics);
            }

            public static PE64FileHeader FromNativeStruct(IMAGE_FILE_HEADER nativeStruct)
            {
                return new PE64FileHeader
                {
                    Machine = nativeStruct.Machine,
                    NumberOfSections = nativeStruct.NumberOfSections,
                    TimeDateStamp = nativeStruct.TimeDateStamp,
                    PointerToSymbolTable = nativeStruct.PointerToSymbolTable,
                    NumberOfSymbols = nativeStruct.NumberOfSymbols,
                    SizeOfOptionalHeader = nativeStruct.SizeOfOptionalHeader,
                    Characteristics = nativeStruct.Characteristics
                };
            }
        }
        
        public class PE64OptionalHeader
        {
            public ushort Magic { get; set; }
            public byte MajorLinkerVersion { get; set; }
            public byte MinorLinkerVersion { get; set; }
            public uint SizeOfCode { get; set; }
            public uint SizeOfInitializedData { get; set; }
            public uint SizeOfUninitializedData { get; set; }
            public uint AddressOfEntryPoint { get; set; }
            public uint BaseOfCode { get; set; }
#if WIN32
            public uint BaseOfData { get; set; }
            public uint ImageBase { get; set; }
#else
            public ulong ImageBase { get; set; }
#endif
            public uint SectionAlignment { get; set; }
            public uint FileAlignment { get; set; }
            public ushort MajorOperatingSystemVersion { get; set; }
            public ushort MinorOperatingSystemVersion { get; set; }
            public ushort MajorImageVersion { get; set; }
            public ushort MinorImageVersion { get; set; }
            public ushort MajorSubsystemVersion { get; set; }
            public ushort MinorSubsystemVersion { get; set; }
            public uint Win32VersionValue { get; set; }
            public uint SizeOfImage { get; set; }
            public uint SizeOfHeaders { get; set; }
            public uint CheckSum { get; set; }
            public ushort Subsystem { get; set; }
            public ushort DllCharacteristics { get; set; }
#if WIN32
            public uint SizeOfStackReserve { get; set; }
            public uint SizeOfStackCommit { get; set; }
            public uint SizeOfHeapReserve { get; set; }
            public uint SizeOfHeapCommit { get; set; }
#else
            public ulong SizeOfStackReserve { get; set; }
            public ulong SizeOfStackCommit { get; set; }
            public ulong SizeOfHeapReserve { get; set; }
            public ulong SizeOfHeapCommit { get; set; }
#endif
            public uint LoaderFlags { get; set; }
            public uint NumberOfRvaAndSizes { get; set; }
            public PE64DataDirectory[] DataDirectory { get; private set; }


            public void AppendToStream(BinaryWriter writer)
            {
                writer.Write(Magic);
                writer.Write(MajorLinkerVersion);
                writer.Write(MinorLinkerVersion);
                writer.Write(SizeOfCode);
                writer.Write(SizeOfInitializedData);
                writer.Write(SizeOfUninitializedData);
                writer.Write(AddressOfEntryPoint);
                writer.Write(BaseOfCode);
#if WIN32
                writer.Write(BaseOfData);
#endif
                writer.Write(ImageBase);
                writer.Write(SectionAlignment);
                writer.Write(FileAlignment);
                writer.Write(MajorOperatingSystemVersion);
                writer.Write(MinorOperatingSystemVersion);
                writer.Write(MajorImageVersion);
                writer.Write(MinorImageVersion);
                writer.Write(MajorSubsystemVersion);
                writer.Write(MinorSubsystemVersion);
                writer.Write(Win32VersionValue);
                writer.Write(SizeOfImage);
                writer.Write(SizeOfHeaders);
                writer.Write(CheckSum);
                writer.Write(Subsystem);
                writer.Write(DllCharacteristics);
                writer.Write(SizeOfStackReserve);
                writer.Write(SizeOfStackCommit);
                writer.Write(SizeOfHeapReserve);
                writer.Write(SizeOfHeapCommit);
                writer.Write(LoaderFlags);
                writer.Write(NumberOfRvaAndSizes);

                foreach (PE64DataDirectory dataDirectory in DataDirectory)
                {
                    dataDirectory.AppendToStream(writer);
                }
            }

            public static PE64OptionalHeader FromNativeStruct(IMAGE_OPTIONAL_HEADER64 nativeStruct)
            {
                PE64DataDirectory[] directories = nativeStruct.DataDirectory.Select(d => PE64DataDirectory.FromNativeStruct(d)).ToArray();

                return new PE64OptionalHeader
                {
                    Magic = nativeStruct.Magic,
                    MajorLinkerVersion = nativeStruct.MajorLinkerVersion,
                    MinorLinkerVersion = nativeStruct.MinorLinkerVersion,
                    SizeOfCode = nativeStruct.SizeOfCode,
                    SizeOfInitializedData = nativeStruct.SizeOfInitializedData,
                    SizeOfUninitializedData = nativeStruct.SizeOfUninitializedData,
                    AddressOfEntryPoint = nativeStruct.AddressOfEntryPoint,
                    BaseOfCode = nativeStruct.BaseOfCode,
#if WIN32
                    BaseOfData = nativeStruct.BaseOfData,
#endif
                    ImageBase = nativeStruct.ImageBase,
                    SectionAlignment = nativeStruct.SectionAlignment,
                    FileAlignment = nativeStruct.FileAlignment,
                    MajorOperatingSystemVersion = nativeStruct.MajorOperatingSystemVersion,
                    MinorOperatingSystemVersion = nativeStruct.MinorOperatingSystemVersion,
                    MajorImageVersion = nativeStruct.MajorImageVersion,
                    MinorImageVersion = nativeStruct.MinorImageVersion,
                    MajorSubsystemVersion = nativeStruct.MajorSubsystemVersion,
                    MinorSubsystemVersion = nativeStruct.MinorSubsystemVersion,
                    Win32VersionValue = nativeStruct.Win32VersionValue,
                    SizeOfImage = nativeStruct.SizeOfImage,
                    SizeOfHeaders = nativeStruct.SizeOfHeaders,
                    CheckSum = nativeStruct.CheckSum,
                    Subsystem = nativeStruct.Subsystem,
                    DllCharacteristics = nativeStruct.DllCharacteristics,
                    SizeOfStackReserve = nativeStruct.SizeOfStackReserve,
                    SizeOfStackCommit = nativeStruct.SizeOfStackCommit,
                    SizeOfHeapReserve = nativeStruct.SizeOfHeapReserve,
                    SizeOfHeapCommit = nativeStruct.SizeOfHeapCommit,
                    LoaderFlags = nativeStruct.LoaderFlags,
                    NumberOfRvaAndSizes = nativeStruct.NumberOfRvaAndSizes,
                    DataDirectory = directories
                };
            }

            public class PE64DataDirectory
            {
                public uint VirtualAddress { get; set; }
                public uint Size { get; set; }


                public void AppendToStream(BinaryWriter writer)
                {
                    writer.Write(VirtualAddress);
                    writer.Write(Size);
                }

                public static PE64DataDirectory FromNativeStruct(IMAGE_DATA_DIRECTORY nativeStruct)
                {
                    return new PE64DataDirectory
                    {
                        VirtualAddress = nativeStruct.VirtualAddress,
                        Size = nativeStruct.Size
                    };
                }
            }
        }           
    }
}

```

`DriverInterface/PE/DOSHeader.cs`:

```cs
using System.IO;

using static KsDumper11.PE.NativePEStructs;

namespace KsDumper11.PE
{
    public class DOSHeader
    {
        public string e_magic { get; set; }
        public ushort e_cblp { get; set; }
        public ushort e_cp { get; set; }
        public ushort e_crlc { get; set; }
        public ushort e_cparhdr { get; set; }
        public ushort e_minalloc { get; set; }
        public ushort e_maxalloc { get; set; }
        public ushort e_ss { get; set; }
        public ushort e_sp { get; set; }
        public ushort e_csum { get; set; }
        public ushort e_ip { get; set; }
        public ushort e_cs { get; set; }
        public ushort e_lfarlc { get; set; }
        public ushort e_ovno { get; set; }
        public ushort[] e_res1 { get; set; }
        public ushort e_oemid { get; set; }
        public ushort e_oeminfo { get; set; }
        public ushort[] e_res2 { get; set; }
        public int e_lfanew { get; set; }

        public void AppendToStream(BinaryWriter writer)
        {
            writer.Write(e_magic.ToCharArray());
            writer.Write(e_cblp);
            writer.Write(e_cp);
            writer.Write(e_crlc);
            writer.Write(e_cparhdr);
            writer.Write(e_minalloc);
            writer.Write(e_maxalloc);
            writer.Write(e_ss);
            writer.Write(e_sp);
            writer.Write(e_csum);
            writer.Write(e_ip);
            writer.Write(e_cs);
            writer.Write(e_lfarlc);
            writer.Write(e_ovno);

            for (int i = 0; i < e_res1.Length; i++)
            {
                writer.Write(e_res1[i]);
            }
            writer.Write(e_oemid);
            writer.Write(e_oeminfo);

            for (int i = 0; i < e_res2.Length; i++)
            {
                writer.Write(e_res2[i]);
            }
            writer.Write(e_lfanew);
        }

        public static DOSHeader FromNativeStruct(IMAGE_DOS_HEADER nativeStruct)
        {
            return new DOSHeader
            {
                e_magic = new string(nativeStruct.e_magic),
                e_cblp = nativeStruct.e_cblp,
                e_cp = nativeStruct.e_cp,
                e_crlc = nativeStruct.e_crlc,
                e_cparhdr = nativeStruct.e_cparhdr,
                e_minalloc = nativeStruct.e_minalloc,
                e_maxalloc = nativeStruct.e_maxalloc,
                e_ss = nativeStruct.e_ss,
                e_sp = nativeStruct.e_sp,
                e_csum = nativeStruct.e_csum,
                e_ip = nativeStruct.e_ip,
                e_cs = nativeStruct.e_cs,
                e_lfarlc = nativeStruct.e_lfarlc,
                e_ovno = nativeStruct.e_ovno,
                e_res1 = nativeStruct.e_res1,
                e_oemid = nativeStruct.e_oemid,
                e_oeminfo = nativeStruct.e_oeminfo,
                e_res2 = nativeStruct.e_res2,
                e_lfanew = nativeStruct.e_lfanew
            };
        }
    }
}

```

`DriverInterface/PE/NativePEStructs.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace KsDumper11.PE
{
    public static class NativePEStructs
    {
        public const uint IMAGE_NT_OPTIONAL_HDR32_MAGIC = 0x10b;
        public const uint IMAGE_NT_OPTIONAL_HDR64_MAGIC = 0x20b;

        public const uint IMAGE_NUMBEROF_DIRECTORY_ENTRIES = 16;

        public const uint IMAGE_DIRECTORY_ENTRY_EXPORT = 0;
        public const uint IMAGE_DIRECTORY_ENTRY_IMPORT = 1;
        public const uint IMAGE_DIRECTORY_ENTRY_RESOURCE = 2;
        public const uint IMAGE_DIRECTORY_ENTRY_EXCEPTION = 3;
        public const uint IMAGE_DIRECTORY_ENTRY_SECURITY = 4;
        public const uint IMAGE_DIRECTORY_ENTRY_BASERELOC = 5;
        public const uint IMAGE_DIRECTORY_ENTRY_DEBUG = 6;
        public const uint IMAGE_DIRECTORY_ENTRY_ARCHITECTURE = 7;
        public const uint IMAGE_DIRECTORY_ENTRY_GLOBALPTR = 8;
        public const uint IMAGE_DIRECTORY_ENTRY_TLS = 9;
        public const uint IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG = 10;
        public const uint IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT = 11;
        public const uint IMAGE_DIRECTORY_ENTRY_IAT = 12;
        public const uint IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT = 13;
        public const uint IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR = 14;

        [StructLayout(LayoutKind.Sequential)]
        public struct IMAGE_DOS_HEADER
        {
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 2)]
            public char[] e_magic;
            public ushort e_cblp;
            public ushort e_cp;
            public ushort e_crlc;
            public ushort e_cparhdr;
            public ushort e_minalloc;
            public ushort e_maxalloc;
            public ushort e_ss;
            public ushort e_sp;
            public ushort e_csum;
            public ushort e_ip;
            public ushort e_cs;
            public ushort e_lfarlc;
            public ushort e_ovno;

            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
            public ushort[] e_res1;
            public ushort e_oemid;
            public ushort e_oeminfo;

            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 10)]
            public ushort[] e_res2;
            public int e_lfanew;

            private string _e_magic
            {
                get { return new string(e_magic); }
            }

            public bool IsValid
            {
                get { return _e_magic == "MZ"; }
            }
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct IMAGE_NT_HEADERS32
        {
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
            public char[] Signature;

            public IMAGE_FILE_HEADER FileHeader;

            public IMAGE_OPTIONAL_HEADER32 OptionalHeader;

            private string _Signature
            {
                get { return new string(Signature); }
            }

            public bool IsValid
            {
                get { return _Signature == "PE\0\0" && OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC; }
            }
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct IMAGE_NT_HEADERS64
        {
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 4)]
            public char[] Signature;

            public IMAGE_FILE_HEADER FileHeader;

            public IMAGE_OPTIONAL_HEADER64 OptionalHeader;

            private string _Signature
            {
                get { return new string(Signature); }
            }

            public bool IsValid
            {
                get { return _Signature == "PE\0\0" && OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC; }
            }
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct IMAGE_FILE_HEADER
        {
            internal ushort Machine;
            internal ushort NumberOfSections;
            internal uint TimeDateStamp;
            internal uint PointerToSymbolTable;
            internal uint NumberOfSymbols;
            internal ushort SizeOfOptionalHeader;
            internal ushort Characteristics;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct IMAGE_OPTIONAL_HEADER32
        {
            internal ushort Magic;
            internal byte MajorLinkerVersion;
            internal byte MinorLinkerVersion;
            internal uint SizeOfCode;
            internal uint SizeOfInitializedData;
            internal uint SizeOfUninitializedData;
            internal uint AddressOfEntryPoint;
            internal uint BaseOfCode;
            internal uint BaseOfData;
            internal uint ImageBase;
            internal uint SectionAlignment;
            internal uint FileAlignment;
            internal ushort MajorOperatingSystemVersion;
            internal ushort MinorOperatingSystemVersion;
            internal ushort MajorImageVersion;
            internal ushort MinorImageVersion;
            internal ushort MajorSubsystemVersion;
            internal ushort MinorSubsystemVersion;
            internal uint Win32VersionValue;
            internal uint SizeOfImage;
            internal uint SizeOfHeaders;
            internal uint CheckSum;
            internal ushort Subsystem;
            internal ushort DllCharacteristics;
            internal uint SizeOfStackReserve;
            internal uint SizeOfStackCommit;
            internal uint SizeOfHeapReserve;
            internal uint SizeOfHeapCommit;
            internal uint LoaderFlags;
            internal uint NumberOfRvaAndSizes;

            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
            internal IMAGE_DATA_DIRECTORY[] DataDirectory;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct IMAGE_OPTIONAL_HEADER64
        {
            internal ushort Magic;
            internal byte MajorLinkerVersion;
            internal byte MinorLinkerVersion;
            internal uint SizeOfCode;
            internal uint SizeOfInitializedData;
            internal uint SizeOfUninitializedData;
            internal uint AddressOfEntryPoint;
            internal uint BaseOfCode;
            internal ulong ImageBase;
            internal uint SectionAlignment;
            internal uint FileAlignment;
            internal ushort MajorOperatingSystemVersion;
            internal ushort MinorOperatingSystemVersion;
            internal ushort MajorImageVersion;
            internal ushort MinorImageVersion;
            internal ushort MajorSubsystemVersion;
            internal ushort MinorSubsystemVersion;
            internal uint Win32VersionValue;
            internal uint SizeOfImage;
            internal uint SizeOfHeaders;
            internal uint CheckSum;
            internal ushort Subsystem;
            internal ushort DllCharacteristics;
            internal ulong SizeOfStackReserve;
            internal ulong SizeOfStackCommit;
            internal ulong SizeOfHeapReserve;
            internal ulong SizeOfHeapCommit;
            internal uint LoaderFlags;
            internal uint NumberOfRvaAndSizes;

            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
            internal IMAGE_DATA_DIRECTORY[] DataDirectory;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct IMAGE_DATA_DIRECTORY
        {
            internal uint VirtualAddress;
            internal uint Size;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct IMAGE_SECTION_HEADER
        {
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
            public char[] Name;

            public uint VirtualSize;

            public uint VirtualAddress;

            public uint SizeOfRawData;

            public uint PointerToRawData;

            public uint PointerToRelocations;

            public uint PointerToLinenumbers;

            public ushort NumberOfRelocations;

            public ushort NumberOfLinenumbers;

            public DataSectionFlags Characteristics;

            public string SectionName
            {
                get { return new string(Name); }
            }
        }

        [Flags]
        public enum DataSectionFlags : uint
        {
            TypeReg = 0x00000000,
            TypeDsect = 0x00000001,
            TypeNoLoad = 0x00000002,
            TypeGroup = 0x00000004,
            TypeNoPadded = 0x00000008,
            TypeCopy = 0x00000010,
            ContentCode = 0x00000020,
            ContentInitializedData = 0x00000040,
            ContentUninitializedData = 0x00000080,
            LinkOther = 0x00000100,
            LinkInfo = 0x00000200,
            TypeOver = 0x00000400,
            LinkRemove = 0x00000800,
            LinkComDat = 0x00001000,
            NoDeferSpecExceptions = 0x00004000,
            RelativeGP = 0x00008000,
            MemPurgeable = 0x00020000,
            Memory16Bit = 0x00020000,
            MemoryLocked = 0x00040000,
            MemoryPreload = 0x00080000,
            Align1Bytes = 0x00100000,
            Align2Bytes = 0x00200000,
            Align4Bytes = 0x00300000,
            Align8Bytes = 0x00400000,
            Align16Bytes = 0x00500000,
            Align32Bytes = 0x00600000,
            Align64Bytes = 0x00700000,
            Align128Bytes = 0x00800000,
            Align256Bytes = 0x00900000,
            Align512Bytes = 0x00A00000,
            Align1024Bytes = 0x00B00000,
            Align2048Bytes = 0x00C00000,
            Align4096Bytes = 0x00D00000,
            Align8192Bytes = 0x00E00000,
            LinkExtendedRelocationOverflow = 0x01000000,
            MemoryDiscardable = 0x02000000,
            MemoryNotCached = 0x04000000,
            MemoryNotPaged = 0x08000000,
            MemoryShared = 0x10000000,
            MemoryExecute = 0x20000000,
            MemoryRead = 0x40000000,
            MemoryWrite = 0x80000000
        }
    }
}

```

`DriverInterface/PE/PEFile.cs`:

```cs
using System;
using System.IO;
using System.Linq;

namespace KsDumper11.PE
{
    public abstract class PEFile
    {
        public PEType Type { get; protected set; }

        public PESection[] Sections { get; protected set; }


        public abstract int GetFirstSectionHeaderOffset();

        public abstract void AlignSectionHeaders();

        public abstract void FixPEHeader();

        public abstract void SaveToDisk(string fileName);

        protected void AppendSections(BinaryWriter writer)
        {
            foreach (var sectionHeader in Sections.Select(s => s.Header))
            {
                sectionHeader.AppendToStream(writer);
            }

            foreach (var section in Sections)
            {
                if (section.Header.PointerToRawData > 0)
                {
                    if (section.Header.PointerToRawData > writer.BaseStream.Position)
                    {
                        long prePaddingSize = section.Header.PointerToRawData - writer.BaseStream.Position;
                        writer.Write(new byte[prePaddingSize]);
                    }

                    if (section.DataSize > 0)
                    {
                        writer.Write(section.Content);

                        if (section.DataSize < section.Header.SizeOfRawData)
                        {
                            long postPaddingSize = section.Header.SizeOfRawData - section.DataSize;
                            writer.Write(new byte[postPaddingSize]);
                        }
                    }
                }
            }
        }

        protected void OrderSectionsBy(Func<PESection, uint> orderFunction)
        {
            Sections = Sections.OrderBy(orderFunction).ToArray();
        }

        public enum PEType
        {
            PE32,
            PE64
        }
    }
}

```

`DriverInterface/PE/PESection.cs`:

```cs
using System.IO;

using static KsDumper11.PE.NativePEStructs;

namespace KsDumper11.PE
{
    public class PESection
    {
        public PESectionHeader Header { get; set; }

        public byte[] Content { get; set; }

        public int InitialSize { get; set; }

        public int DataSize { get; set; }

        public class PESectionHeader
        {
            public string Name { get; set; }

            public uint VirtualSize { get; set; }

            public uint VirtualAddress { get; set; }

            public uint SizeOfRawData { get; set; }

            public uint PointerToRawData { get; set; }

            public uint PointerToRelocations { get; set; }

            public uint PointerToLinenumbers { get; set; }

            public ushort NumberOfRelocations { get; set; }

            public ushort NumberOfLinenumbers { get; set; } 

            public DataSectionFlags Characteristics { get; set; }


            public void AppendToStream(BinaryWriter writer)
            {
                writer.Write(Name.ToCharArray());
                writer.Write(VirtualSize);
                writer.Write(VirtualAddress);
                writer.Write(SizeOfRawData);
                writer.Write(PointerToRawData);
                writer.Write(PointerToRelocations);
                writer.Write(PointerToLinenumbers);
                writer.Write(NumberOfRelocations);
                writer.Write(NumberOfLinenumbers);
                writer.Write((uint)Characteristics);
            }

            public static PESectionHeader FromNativeStruct(IMAGE_SECTION_HEADER nativeStruct)
            {
                return new PESectionHeader
                {
                    Name = nativeStruct.SectionName,
                    VirtualSize = nativeStruct.VirtualSize,
                    VirtualAddress = nativeStruct.VirtualAddress,
                    SizeOfRawData = nativeStruct.SizeOfRawData,
                    PointerToRawData = nativeStruct.PointerToRawData,
                    PointerToRelocations = nativeStruct.PointerToRelocations,
                    PointerToLinenumbers = nativeStruct.PointerToLinenumbers,
                    NumberOfRelocations = nativeStruct.NumberOfRelocations,
                    NumberOfLinenumbers = nativeStruct.NumberOfLinenumbers,
                    Characteristics = nativeStruct.Characteristics
                };
            }
        }
    }   
}

```

`DriverInterface/ProcessDumper.cs`:

```cs
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using KsDumper11.Driver;
using KsDumper11.PE;
using KsDumper11.Utility;

namespace KsDumper11
{
	// Token: 0x02000003 RID: 3
	public class ProcessDumper
	{
		// Token: 0x0600002E RID: 46 RVA: 0x000038AD File Offset: 0x00001AAD
		public ProcessDumper(KsDumperDriverInterface kernelDriver)
		{
			this.kernelDriver = kernelDriver;
		}

		// Token: 0x0600002F RID: 47 RVA: 0x000038C0 File Offset: 0x00001AC0
		private static bool IsWin64Emulator(Process process)
		{
			bool flag = Environment.OSVersion.Version.Major > 5 || (Environment.OSVersion.Version.Major == 5 && Environment.OSVersion.Version.Minor >= 1);
			bool retVal;
			return flag && (ProcessDumper.NativeMethods.IsWow64Process(process.Handle, out retVal) && retVal);
		}

		// Token: 0x06000030 RID: 48 RVA: 0x0000392C File Offset: 0x00001B2C
		public bool DumpProcess(Process processSummary, out PEFile outputFile)
		{
			IntPtr basePointer = processSummary.MainModule.BaseAddress;
			NativePEStructs.IMAGE_DOS_HEADER dosHeader = this.ReadProcessStruct<NativePEStructs.IMAGE_DOS_HEADER>(processSummary.Id, basePointer);
			outputFile = null;
			Logger.SkipLine();
			Logger.Log("Targeting Process: {0} ({1})", new object[] { processSummary.ProcessName, processSummary.Id });
			bool isValid = dosHeader.IsValid;
			if (isValid)
			{
				IntPtr peHeaderPointer = basePointer + dosHeader.e_lfanew;
				Logger.Log("PE Header Found: 0x{0:x8}", new object[] { peHeaderPointer.ToInt64() });
				IntPtr dosStubPointer = basePointer + Marshal.SizeOf<NativePEStructs.IMAGE_DOS_HEADER>();
				byte[] dosStub = this.ReadProcessBytes(processSummary.Id, dosStubPointer, dosHeader.e_lfanew - Marshal.SizeOf<NativePEStructs.IMAGE_DOS_HEADER>());
				bool flag = !ProcessDumper.IsWin64Emulator(processSummary);
				PEFile peFile;
				if (flag)
				{
					peFile = this.Dump64BitPE(processSummary.Id, dosHeader, dosStub, peHeaderPointer);
				}
				else
				{
					peFile = this.Dump32BitPE(processSummary.Id, dosHeader, dosStub, peHeaderPointer);
				}
				bool flag2 = peFile != null;
				if (flag2)
				{
					IntPtr sectionHeaderPointer = peHeaderPointer + peFile.GetFirstSectionHeaderOffset();
					Logger.Log("Header is valid ({0}) !", new object[] { peFile.Type });
					Logger.Log("Parsing {0} Sections...", new object[] { peFile.Sections.Length });
					for (int i = 0; i < peFile.Sections.Length; i++)
					{
						NativePEStructs.IMAGE_SECTION_HEADER sectionHeader = this.ReadProcessStruct<NativePEStructs.IMAGE_SECTION_HEADER>(processSummary.Id, sectionHeaderPointer);
						peFile.Sections[i] = new PESection
						{
							Header = PESection.PESectionHeader.FromNativeStruct(sectionHeader),
							InitialSize = (int)sectionHeader.VirtualSize
						};
						this.ReadSectionContent(processSummary.Id, new IntPtr(basePointer.ToInt64() + (long)((ulong)sectionHeader.VirtualAddress)), peFile.Sections[i]);
						sectionHeaderPointer += Marshal.SizeOf<NativePEStructs.IMAGE_SECTION_HEADER>();
					}
					Logger.Log("Aligning Sections...", Array.Empty<object>());
					peFile.AlignSectionHeaders();
					Logger.Log("Fixing PE Header...", Array.Empty<object>());
					peFile.FixPEHeader();
					Logger.Log("Dump Completed !", Array.Empty<object>());
					outputFile = peFile;
					return true;
				}
				Logger.Log("Bad PE Header !", Array.Empty<object>());
			}
			return false;
		}

		// Token: 0x06000031 RID: 49 RVA: 0x00003B80 File Offset: 0x00001D80
		public bool DumpProcess(ProcessSummary processSummary, out PEFile outputFile)
		{
			IntPtr basePointer = (IntPtr)((long)processSummary.MainModuleBase);
			NativePEStructs.IMAGE_DOS_HEADER dosHeader = this.ReadProcessStruct<NativePEStructs.IMAGE_DOS_HEADER>(processSummary.ProcessId, basePointer);
			outputFile = null;
			Logger.SkipLine();
			Logger.Log("Targeting Process: {0} ({1})", new object[] { processSummary.ProcessName, processSummary.ProcessId });
			bool isValid = dosHeader.IsValid;
			if (isValid)
			{
				IntPtr peHeaderPointer = basePointer + dosHeader.e_lfanew;
				Logger.Log("PE Header Found: 0x{0:x8}", new object[] { peHeaderPointer.ToInt64() });
				IntPtr dosStubPointer = basePointer + Marshal.SizeOf<NativePEStructs.IMAGE_DOS_HEADER>();
				byte[] dosStub = this.ReadProcessBytes(processSummary.ProcessId, dosStubPointer, dosHeader.e_lfanew - Marshal.SizeOf<NativePEStructs.IMAGE_DOS_HEADER>());
				bool flag = !processSummary.IsWOW64;
				PEFile peFile;
				if (flag)
				{
					peFile = this.Dump64BitPE(processSummary.ProcessId, dosHeader, dosStub, peHeaderPointer);
				}
				else
				{
					peFile = this.Dump32BitPE(processSummary.ProcessId, dosHeader, dosStub, peHeaderPointer);
				}
				bool flag2 = peFile != null;
				if (flag2)
				{
					IntPtr sectionHeaderPointer = peHeaderPointer + peFile.GetFirstSectionHeaderOffset();
					Logger.Log("Header is valid ({0}) !", new object[] { peFile.Type });
					Logger.Log("Parsing {0} Sections...", new object[] { peFile.Sections.Length });
					for (int i = 0; i < peFile.Sections.Length; i++)
					{
						NativePEStructs.IMAGE_SECTION_HEADER sectionHeader = this.ReadProcessStruct<NativePEStructs.IMAGE_SECTION_HEADER>(processSummary.ProcessId, sectionHeaderPointer);
						peFile.Sections[i] = new PESection
						{
							Header = PESection.PESectionHeader.FromNativeStruct(sectionHeader),
							InitialSize = (int)sectionHeader.VirtualSize
						};
						this.ReadSectionContent(processSummary.ProcessId, new IntPtr(basePointer.ToInt64() + (long)((ulong)sectionHeader.VirtualAddress)), peFile.Sections[i]);
						sectionHeaderPointer += Marshal.SizeOf<NativePEStructs.IMAGE_SECTION_HEADER>();
					}
					Logger.Log("Aligning Sections...", Array.Empty<object>());
					peFile.AlignSectionHeaders();
					Logger.Log("Fixing PE Header...", Array.Empty<object>());
					peFile.FixPEHeader();
					Logger.Log("Dump Completed !", Array.Empty<object>());
					outputFile = peFile;
					return true;
				}
				Logger.Log("Bad PE Header !", Array.Empty<object>());
			}
			return false;
		}

		// Token: 0x06000032 RID: 50 RVA: 0x00003DD4 File Offset: 0x00001FD4
		private PEFile Dump64BitPE(int processId, NativePEStructs.IMAGE_DOS_HEADER dosHeader, byte[] dosStub, IntPtr peHeaderPointer)
		{
			NativePEStructs.IMAGE_NT_HEADERS64 peHeader = this.ReadProcessStruct<NativePEStructs.IMAGE_NT_HEADERS64>(processId, peHeaderPointer);
			bool isValid = peHeader.IsValid;
			PEFile pefile;
			if (isValid)
			{
				pefile = new PE64File(dosHeader, peHeader, dosStub);
			}
			else
			{
				pefile = null;
			}
			return pefile;
		}

		// Token: 0x06000033 RID: 51 RVA: 0x00003E08 File Offset: 0x00002008
		private PEFile Dump32BitPE(int processId, NativePEStructs.IMAGE_DOS_HEADER dosHeader, byte[] dosStub, IntPtr peHeaderPointer)
		{
			NativePEStructs.IMAGE_NT_HEADERS32 peHeader = this.ReadProcessStruct<NativePEStructs.IMAGE_NT_HEADERS32>(processId, peHeaderPointer);
			bool isValid = peHeader.IsValid;
			PEFile pefile;
			if (isValid)
			{
				pefile = new PE32File(dosHeader, peHeader, dosStub);
			}
			else
			{
				pefile = null;
			}
			return pefile;
		}

		// Token: 0x06000034 RID: 52 RVA: 0x00003E3C File Offset: 0x0000203C
		private T ReadProcessStruct<T>(int processId, IntPtr address) where T : struct
		{
			IntPtr buffer = MarshalUtility.AllocEmptyStruct<T>();
			bool flag = this.kernelDriver.CopyVirtualMemory(processId, address, buffer, Marshal.SizeOf<T>());
			T t;
			if (flag)
			{
				t = MarshalUtility.GetStructFromMemory<T>(buffer, true);
			}
			else
			{
				t = default(T);
			}
			return t;
		}

		// Token: 0x06000035 RID: 53 RVA: 0x00003E80 File Offset: 0x00002080
		private bool ReadSectionContent(int processId, IntPtr sectionPointer, PESection section)
		{
			int readSize = section.InitialSize;
			bool flag = sectionPointer == IntPtr.Zero || readSize == 0;
			bool flag2;
			if (flag)
			{
				flag2 = true;
			}
			else
			{
				bool flag3 = readSize <= 100;
				if (flag3)
				{
					section.DataSize = readSize;
					section.Content = this.ReadProcessBytes(processId, sectionPointer, readSize);
					flag2 = true;
				}
				else
				{
					this.CalculateRealSectionSize(processId, sectionPointer, section);
					bool flag4 = section.DataSize != 0;
					if (flag4)
					{
						section.Content = this.ReadProcessBytes(processId, sectionPointer, section.DataSize);
						flag2 = true;
					}
					else
					{
						flag2 = false;
					}
				}
			}
			return flag2;
		}

		// Token: 0x06000036 RID: 54 RVA: 0x00003F18 File Offset: 0x00002118
		private byte[] ReadProcessBytes(int processId, IntPtr address, int size)
		{
			IntPtr unmanagedBytePointer = MarshalUtility.AllocZeroFilled(size);
			this.kernelDriver.CopyVirtualMemory(processId, address, unmanagedBytePointer, size);
			byte[] buffer = new byte[size];
			Marshal.Copy(unmanagedBytePointer, buffer, 0, size);
			Marshal.FreeHGlobal(unmanagedBytePointer);
			return buffer;
		}

		// Token: 0x06000037 RID: 55 RVA: 0x00003F5C File Offset: 0x0000215C
		private void CalculateRealSectionSize(int processId, IntPtr sectionPointer, PESection section)
		{
			int readSize = section.InitialSize;
			int currentReadSize = readSize % 100;
			bool flag = currentReadSize == 0;
			if (flag)
			{
				currentReadSize = 100;
			}
			IntPtr currentOffset = sectionPointer + readSize - currentReadSize;
			while (currentOffset.ToInt64() >= sectionPointer.ToInt64())
			{
				byte[] buffer = this.ReadProcessBytes(processId, currentOffset, currentReadSize);
				int codeByteCount = this.GetInstructionByteCount(buffer);
				bool flag2 = codeByteCount != 0;
				if (flag2)
				{
					currentOffset += codeByteCount;
					bool flag3 = sectionPointer.ToInt64() < currentOffset.ToInt64();
					if (flag3)
					{
						section.DataSize = (int)(currentOffset.ToInt64() - sectionPointer.ToInt64());
						section.DataSize += 4;
						bool flag4 = section.InitialSize < section.DataSize;
						if (flag4)
						{
							section.DataSize = section.InitialSize;
						}
					}
					break;
				}
				currentReadSize = 100;
				currentOffset -= currentReadSize;
			}
		}

		// Token: 0x06000038 RID: 56 RVA: 0x0000404C File Offset: 0x0000224C
		private int GetInstructionByteCount(byte[] dataBlock)
		{
			for (int i = dataBlock.Length - 1; i >= 0; i--)
			{
				bool flag = dataBlock[i] > 0;
				if (flag)
				{
					return i + 1;
				}
			}
			return 0;
		}

		// Token: 0x0400002B RID: 43
		private KsDumperDriverInterface kernelDriver;

		// Token: 0x02000023 RID: 35
		internal static class NativeMethods
		{
			// Token: 0x060000EF RID: 239
			[DllImport("kernel32.dll", SetLastError = true)]
			[return: MarshalAs(UnmanagedType.Bool)]
			internal static extern bool IsWow64Process([In] IntPtr process, out bool wow64Process);
		}
	}
}

```

`DriverInterface/ProcessSummary.cs`:

```cs
using System;
using System.Diagnostics;
using System.IO;
using System.Runtime.CompilerServices;
using System.Text;
using KsDumper11.Driver;
using KsDumper11.Utility;

namespace KsDumper11
{
	// Token: 0x02000004 RID: 4
	public class ProcessSummary
	{
		// Token: 0x17000002 RID: 2
		// (get) Token: 0x06000039 RID: 57 RVA: 0x00004089 File Offset: 0x00002289
		// (set) Token: 0x0600003A RID: 58 RVA: 0x00004091 File Offset: 0x00002291
		public int ProcessId { get; set; }

        // Token: 0x17000003 RID: 3
        // (get) Token: 0x0600003B RID: 59 RVA: 0x0000409A File Offset: 0x0000229A
        // (set) Token: 0x0600003C RID: 60 RVA: 0x000040A2 File Offset: 0x000022A2
        public string ProcessName { get; set; }

		// Token: 0x17000004 RID: 4
		// (get) Token: 0x0600003D RID: 61 RVA: 0x000040AB File Offset: 0x000022AB
		// (set) Token: 0x0600003E RID: 62 RVA: 0x000040B3 File Offset: 0x000022B3
		public ulong MainModuleBase  { get; set; }

        // Token: 0x17000005 RID: 5
        // (get) Token: 0x0600003F RID: 63 RVA: 0x000040BC File Offset: 0x000022BC
        // (set) Token: 0x06000040 RID: 64 RVA: 0x000040C4 File Offset: 0x000022C4
        public string MainModuleFileName { get; set; }

        // Token: 0x17000006 RID: 6
        // (get) Token: 0x06000041 RID: 65 RVA: 0x000040CD File Offset: 0x000022CD
        // (set) Token: 0x06000042 RID: 66 RVA: 0x000040D5 File Offset: 0x000022D5
        public uint MainModuleImageSize { get; set; }

        // Token: 0x17000007 RID: 7
        // (get) Token: 0x06000043 RID: 67 RVA: 0x000040DE File Offset: 0x000022DE
        // (set) Token: 0x06000044 RID: 68 RVA: 0x000040E6 File Offset: 0x000022E6
        public ulong MainModuleEntryPoint { get; set; }

        // Token: 0x17000008 RID: 8
        // (get) Token: 0x06000045 RID: 69 RVA: 0x000040EF File Offset: 0x000022EF
        // (set) Token: 0x06000046 RID: 70 RVA: 0x000040F7 File Offset: 0x000022F7
        public bool IsWOW64 { get; set; }

        // Token: 0x06000047 RID: 71 RVA: 0x00004100 File Offset: 0x00002300
        public static ProcessSummary ProcessSummaryFromID(KsDumperDriverInterface driver, string processName)
		{
			ProcessSummary result = null;
			ProcessSummary[] processes;
			driver.GetProcessSummaryList(out processes);
			bool flag = processes != null;
			if (flag)
			{
				foreach (ProcessSummary process in processes)
				{
					bool flag2 = process.ProcessName.ToLower().Contains(processName.ToLower());
					if (flag2)
					{
						Logger.Log(process.ProcessName + "      " + processName, Array.Empty<object>());
						return process;
					}
				}
			}
			return result;
		}

		// Token: 0x06000048 RID: 72 RVA: 0x0000418C File Offset: 0x0000238C
		private ProcessSummary(int processId, ulong mainModuleBase, string mainModuleFileName, uint mainModuleImageSize, ulong mainModuleEntryPoint, bool isWOW64)
		{
			this.ProcessId = processId;
			this.MainModuleBase = mainModuleBase;
			this.MainModuleFileName = this.FixFileName(mainModuleFileName);
			this.MainModuleImageSize = mainModuleImageSize;
			this.MainModuleEntryPoint = mainModuleEntryPoint;
			this.ProcessName = Path.GetFileName(this.MainModuleFileName);
			this.IsWOW64 = isWOW64;
		}

		// Token: 0x06000049 RID: 73 RVA: 0x000041EC File Offset: 0x000023EC
		private string FixFileName(string fileName)
		{
			bool flag = fileName.StartsWith("\\");
			string text;
			if (flag)
			{
				text = fileName;
			}
			else
			{
				StringBuilder sb = new StringBuilder(256);
				int length = WinApi.GetLongPathName(fileName, sb, sb.Capacity);
				bool flag2 = length > sb.Capacity;
				if (flag2)
				{
					sb.Capacity = length;
					length = WinApi.GetLongPathName(fileName, sb, sb.Capacity);
				}
				text = sb.ToString();
			}
			return text;
		}

		// Token: 0x0600004A RID: 74 RVA: 0x00004258 File Offset: 0x00002458
		public static ProcessSummary FromStream(BinaryReader reader)
		{
			return new ProcessSummary(reader.ReadInt32(), reader.ReadUInt64(), Encoding.Unicode.GetString(reader.ReadBytes(512)).Split(new char[1])[0], reader.ReadUInt32(), reader.ReadUInt64(), reader.ReadBoolean());
		}
	}
}

```

`DriverInterface/Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("DriverInterface")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("DriverInterface")]
[assembly: AssemblyCopyright("Copyright ©  2023")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible
// to COM components.  If you need to access a type in this assembly from
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("6f8b2a35-060d-4eb1-a6ba-a3057179304b")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]

```

`DriverInterface/Properties/Resources.Designer.cs`:

```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace DriverInterface.Properties {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("DriverInterface.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Byte[].
        /// </summary>
        internal static byte[] drv64 {
            get {
                object obj = ResourceManager.GetObject("drv64", resourceCulture);
                return ((byte[])(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Byte[].
        /// </summary>
        internal static byte[] kdu {
            get {
                object obj = ResourceManager.GetObject("kdu", resourceCulture);
                return ((byte[])(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Byte[].
        /// </summary>
        internal static byte[] KsDumperDriver {
            get {
                object obj = ResourceManager.GetObject("KsDumperDriver", resourceCulture);
                return ((byte[])(obj));
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Byte[].
        /// </summary>
        internal static byte[] Taigei64 {
            get {
                object obj = ResourceManager.GetObject("Taigei64", resourceCulture);
                return ((byte[])(obj));
            }
        }
    }
}

```

`DriverInterface/Properties/Resources.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <assembly alias="System.Windows.Forms" name="System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />
  <data name="drv64" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Driver\drv64.dll;System.Byte[], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="kdu" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Driver\kdu.exe;System.Byte[], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="KsDumperDriver" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Driver\KsDumperDriver.sys;System.Byte[], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
  <data name="Taigei64" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Driver\Taigei64.dll;System.Byte[], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </data>
</root>
```

`DriverInterface/Utility/Logger.cs`:

```cs
using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;
using System.Threading;

namespace KsDumper11.Utility
{
	// Token: 0x02000009 RID: 9
	public static class Logger
	{
		// Token: 0x14000001 RID: 1
		// (add) Token: 0x06000059 RID: 89 RVA: 0x00004500 File Offset: 0x00002700
		// (remove) Token: 0x0600005A RID: 90 RVA: 0x00004534 File Offset: 0x00002734
		public static event Action<string> OnLog;

		// Token: 0x0600005B RID: 91 RVA: 0x00004568 File Offset: 0x00002768
		public static void SkipLine()
		{
			bool flag = Logger.OnLog != null;
			if (flag)
			{
				Logger.OnLog("\n");
			}
			else
			{
				Console.WriteLine();
			}
		}

		// Token: 0x0600005C RID: 92 RVA: 0x000045A0 File Offset: 0x000027A0
		public static void Log(string message, params object[] args)
		{
			message = string.Format("[{0}] {1}\n", DateTime.Now.ToLongTimeString(), string.Format(message, args));
			bool flag = Logger.OnLog != null;
			if (flag)
			{
				Logger.OnLog(message);
			}
			else
			{
				Console.WriteLine(message);
			}
		}
	}
}

```

`DriverInterface/Utility/MarshalUtility.cs`:

```cs
using System;
using System.Runtime.InteropServices;

namespace KsDumper11.Utility
{
	// Token: 0x0200000A RID: 10
	public static class MarshalUtility
	{
		// Token: 0x0600005D RID: 93 RVA: 0x000045F4 File Offset: 0x000027F4
		public static IntPtr CopyStructToMemory<T>(T obj) where T : struct
		{
			IntPtr unmanagedAddress = MarshalUtility.AllocEmptyStruct<T>();
			Marshal.StructureToPtr<T>(obj, unmanagedAddress, true);
			return unmanagedAddress;
		}

		// Token: 0x0600005E RID: 94 RVA: 0x00004618 File Offset: 0x00002818
		public static IntPtr AllocEmptyStruct<T>() where T : struct
		{
			int structSize = Marshal.SizeOf<T>();
			return MarshalUtility.AllocZeroFilled(Marshal.SizeOf<T>());
		}

		// Token: 0x0600005F RID: 95 RVA: 0x0000463C File Offset: 0x0000283C
		public static IntPtr AllocZeroFilled(int size)
		{
			IntPtr allocatedPointer = Marshal.AllocHGlobal(size);
			MarshalUtility.ZeroMemory(allocatedPointer, size);
			return allocatedPointer;
		}

		// Token: 0x06000060 RID: 96 RVA: 0x00004660 File Offset: 0x00002860
		public static void ZeroMemory(IntPtr pointer, int size)
		{
			for (int i = 0; i < size; i++)
			{
				Marshal.WriteByte(pointer + i, 0);
			}
		}

		// Token: 0x06000061 RID: 97 RVA: 0x00004690 File Offset: 0x00002890
		public static T GetStructFromMemory<T>(IntPtr unmanagedAddress, bool freeMemory = true) where T : struct
		{
			T structObj = Marshal.PtrToStructure<T>(unmanagedAddress);
			if (freeMemory)
			{
				Marshal.FreeHGlobal(unmanagedAddress);
			}
			return structObj;
		}
	}
}

```

`DriverInterface/Utility/ProcessListView.cs`:

```cs
using System;
using System.Collections;
using System.Diagnostics;
using System.Drawing;
using System.IO;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Windows.Forms;

namespace KsDumper11.Utility
{
	// Token: 0x0200000B RID: 11
	public class ProcessListView : ListView
	{
		// Token: 0x1700000D RID: 13
		// (get) Token: 0x06000062 RID: 98 RVA: 0x000046B8 File Offset: 0x000028B8
		// (set) Token: 0x06000063 RID: 99 RVA: 0x000046C0 File Offset: 0x000028C0
		public bool SystemProcessesHidden { get; set; } = true;

		// Token: 0x06000064 RID: 100 RVA: 0x000046C9 File Offset: 0x000028C9
		public ProcessListView()
		{
			base.OwnerDraw = true;
			this.DoubleBuffered = true;
			base.Sorting = SortOrder.Ascending;
		}

		// Token: 0x06000065 RID: 101 RVA: 0x000046F9 File Offset: 0x000028F9
		public void LoadProcesses(ProcessSummary[] processSummaries)
		{
			this.processCache = processSummaries;
			this.ReloadItems();
		}

		// Token: 0x06000066 RID: 102 RVA: 0x0000470A File Offset: 0x0000290A
		public void ShowSystemProcesses()
		{
			this.SystemProcessesHidden = false;
			this.ReloadItems();
		}

		// Token: 0x06000067 RID: 103 RVA: 0x0000471C File Offset: 0x0000291C
		public void HideSystemProcesses()
		{
			this.SystemProcessesHidden = true;
			this.ReloadItems();
		}

		// Token: 0x06000068 RID: 104 RVA: 0x0000472E File Offset: 0x0000292E
		protected override void OnDrawItem(DrawListViewItemEventArgs e)
		{
			e.DrawDefault = true;
		}

		// Token: 0x06000069 RID: 105 RVA: 0x0000473C File Offset: 0x0000293C
		protected override void OnDrawColumnHeader(DrawListViewColumnHeaderEventArgs e)
		{
			e.DrawBackground();
			using (StringFormat sf = new StringFormat())
			{
				sf.Alignment = StringAlignment.Center;
				using (Font headerFont = new Font("Microsoft Sans Serif", 9f, FontStyle.Bold))
				{
					e.Graphics.FillRectangle(new SolidBrush(this.BackColor), e.Bounds);
					e.Graphics.DrawString(e.Header.Text, headerFont, new SolidBrush(this.ForeColor), e.Bounds, sf);
				}
			}
		}

		// Token: 0x0600006A RID: 106 RVA: 0x000047F8 File Offset: 0x000029F8
		private void ReloadItems()
		{
			base.BeginUpdate();
			int idx = 0;
			bool flag = base.SelectedIndices.Count > 0;
			if (flag)
			{
				idx = base.SelectedIndices[0];
				bool flag2 = idx == -1;
				if (flag2)
				{
					idx = 0;
				}
			}
			base.Items.Clear();
			string systemRootFolder = Environment.GetFolderPath(Environment.SpecialFolder.Windows).ToLower();
			foreach (ProcessSummary processSummary in this.processCache)
			{
				bool flag3 = this.SystemProcessesHidden && (processSummary.MainModuleFileName.ToLower().StartsWith(systemRootFolder) || processSummary.MainModuleFileName.StartsWith("\\"));
				if (!flag3)
				{
					ListViewItem lvi = new ListViewItem(processSummary.ProcessId.ToString());
					lvi.BackColor = this.BackColor;
					lvi.ForeColor = this.ForeColor;
					lvi.SubItems.Add(Path.GetFileName(processSummary.MainModuleFileName));
					lvi.SubItems.Add(processSummary.MainModuleFileName);
					lvi.SubItems.Add(string.Format("0x{0:x8}", processSummary.MainModuleBase));
					lvi.SubItems.Add(string.Format("0x{0:x8}", processSummary.MainModuleEntryPoint));
					lvi.SubItems.Add(string.Format("0x{0:x4}", processSummary.MainModuleImageSize));
					lvi.SubItems.Add(processSummary.IsWOW64 ? "x86" : "x64");
					lvi.Tag = processSummary;
					base.Items.Add(lvi);
				}
			}
			base.ListViewItemSorter = new ProcessListView.ProcessListViewItemComparer(this.sortColumnIndex, base.Sorting);
			base.Sort();
			base.Items[idx].Selected = true;
			base.EndUpdate();
		}

		// Token: 0x0600006B RID: 107 RVA: 0x000049FC File Offset: 0x00002BFC
		protected override void OnColumnClick(ColumnClickEventArgs e)
		{
			bool flag = e.Column != this.sortColumnIndex;
			if (flag)
			{
				this.sortColumnIndex = e.Column;
				base.Sorting = SortOrder.Ascending;
			}
			else
			{
				bool flag2 = base.Sorting == SortOrder.Ascending;
				if (flag2)
				{
					base.Sorting = SortOrder.Descending;
				}
				else
				{
					base.Sorting = SortOrder.Ascending;
				}
			}
			base.ListViewItemSorter = new ProcessListView.ProcessListViewItemComparer(e.Column, base.Sorting);
			base.Sort();
		}

		// Token: 0x0600006C RID: 108 RVA: 0x00004A7C File Offset: 0x00002C7C
		protected override void WndProc(ref Message m)
		{
			bool flag = m.Msg == 1;
			if (flag)
			{
			}
			base.WndProc(ref m);
		}

		// Token: 0x0600006D RID: 109
		[DllImport("uxtheme.dll", CharSet = CharSet.Unicode)]
		private static extern int SetWindowTheme(IntPtr hWnd, string pszSubAppName, string pszSubIdList);

		// Token: 0x0400003C RID: 60
		private int sortColumnIndex = 1;

		// Token: 0x0400003D RID: 61
		private ProcessSummary[] processCache;

		// Token: 0x02000025 RID: 37
		private class ProcessListViewItemComparer : IComparer
		{
			// Token: 0x060000F3 RID: 243 RVA: 0x000063F0 File Offset: 0x000045F0
			public ProcessListViewItemComparer(int columnIndex, SortOrder sortOrder)
			{
				this.columnIndex = columnIndex;
				this.sortOrder = sortOrder;
			}

			// Token: 0x060000F4 RID: 244 RVA: 0x00006408 File Offset: 0x00004608
			public int Compare(object x, object y)
			{
				bool flag = x is ListViewItem && y is ListViewItem;
				if (flag)
				{
					ProcessSummary p = ((ListViewItem)x).Tag as ProcessSummary;
					ProcessSummary p2 = ((ListViewItem)y).Tag as ProcessSummary;
					bool flag2 = p != null && p2 != null;
					if (flag2)
					{
						int result = 0;
						switch (this.columnIndex)
						{
						case 0:
							result = p.ProcessId.CompareTo(p2.ProcessId);
							break;
						case 1:
							result = p.ProcessName.CompareTo(p2.ProcessName);
							break;
						case 2:
							result = p.MainModuleFileName.CompareTo(p2.MainModuleFileName);
							break;
						case 3:
							result = p.MainModuleBase.CompareTo(p2.MainModuleBase);
							break;
						case 4:
							result = p.MainModuleEntryPoint.CompareTo(p2.MainModuleEntryPoint);
							break;
						case 5:
							result = p.MainModuleImageSize.CompareTo(p2.MainModuleImageSize);
							break;
						case 6:
							result = p.IsWOW64.CompareTo(p2.IsWOW64);
							break;
						}
						bool flag3 = this.sortOrder == SortOrder.Descending;
						if (flag3)
						{
							result = -result;
						}
						return result;
					}
				}
				return 0;
			}

			// Token: 0x040000B8 RID: 184
			private readonly int columnIndex;

			// Token: 0x040000B9 RID: 185
			private readonly SortOrder sortOrder;
		}
	}
}

```

`DriverInterface/Utility/WinApi.cs`:

```cs
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;

namespace KsDumper11.Utility
{
	public static class WinApi
	{
        [DllImport("kernel32.dll")]
        public static extern int CloseHandle(IntPtr handle);

        [DllImport("kernel32.dll", CharSet = CharSet.Ansi, SetLastError = true)]
		public static extern IntPtr CreateFileA([MarshalAs(UnmanagedType.LPStr)] string filename, [MarshalAs(UnmanagedType.U4)] FileAccess access, [MarshalAs(UnmanagedType.U4)] FileShare share, IntPtr securityAttributes, [MarshalAs(UnmanagedType.U4)] FileMode creationDisposition, [MarshalAs(UnmanagedType.U4)] FileAttributes flagsAndAttributes, IntPtr templateFile);

		[DllImport("kernel32.dll", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]
		public static extern bool DeviceIoControl(IntPtr hDevice, uint dwIoControlCode, IntPtr lpInBuffer, int nInBufferSize, IntPtr lpOutBuffer, int nOutBufferSize, IntPtr lpBytesReturned, IntPtr lpOverlapped);

		[DllImport("kernel32.dll")]
		public static extern int GetLongPathName(string path, StringBuilder pszPath, int cchPath);

		public static readonly int FILE_DEVICE_UNKNOWN = 34;

		public static readonly int METHOD_BUFFERED = 0;

		public static readonly int FILE_ANY_ACCESS = 0;

		public static readonly IntPtr INVALID_HANDLE_VALUE = new IntPtr(-1);


    }
}

```

`DriverInterface/packages.config`:

```config
<?xml version="1.0" encoding="utf-8"?>
<packages>
  <package id="Newtonsoft.Json" version="13.0.3" targetFramework="net48" />
</packages>
```

`KsDumper11.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.4.33205.214
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "KsDumper11", "KsDumper11\KsDumper11.csproj", "{7881B99D-0B5A-44E7-AF34-80A0ECFFD5DB}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "DarkControls", "DarkControls\DarkControls.csproj", "{66C94ACB-63C7-42A3-9D83-A3801CED4F1C}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Solution Items", "Solution Items", "{79B0AE0A-4D49-4102-9971-04F5375BF272}"
	ProjectSection(SolutionItems) = preProject
		README.md = README.md
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "KsDumperDriver", "KsDumperDriver\KsDumperDriver.vcxproj", "{8EADAB93-F111-43AF-9E10-2376AE515491}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "DriverInterface", "DriverInterface\DriverInterface.csproj", "{6F8B2A35-060D-4EB1-A6BA-A3057179304B}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|Any CPU = Release|Any CPU
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{7881B99D-0B5A-44E7-AF34-80A0ECFFD5DB}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{7881B99D-0B5A-44E7-AF34-80A0ECFFD5DB}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{7881B99D-0B5A-44E7-AF34-80A0ECFFD5DB}.Debug|x64.ActiveCfg = Debug|x64
		{7881B99D-0B5A-44E7-AF34-80A0ECFFD5DB}.Debug|x64.Build.0 = Debug|x64
		{7881B99D-0B5A-44E7-AF34-80A0ECFFD5DB}.Debug|x86.ActiveCfg = Debug|x86
		{7881B99D-0B5A-44E7-AF34-80A0ECFFD5DB}.Debug|x86.Build.0 = Debug|x86
		{7881B99D-0B5A-44E7-AF34-80A0ECFFD5DB}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{7881B99D-0B5A-44E7-AF34-80A0ECFFD5DB}.Release|Any CPU.Build.0 = Release|Any CPU
		{7881B99D-0B5A-44E7-AF34-80A0ECFFD5DB}.Release|x64.ActiveCfg = Release|x64
		{7881B99D-0B5A-44E7-AF34-80A0ECFFD5DB}.Release|x64.Build.0 = Release|x64
		{7881B99D-0B5A-44E7-AF34-80A0ECFFD5DB}.Release|x86.ActiveCfg = Release|x86
		{7881B99D-0B5A-44E7-AF34-80A0ECFFD5DB}.Release|x86.Build.0 = Release|x86
		{66C94ACB-63C7-42A3-9D83-A3801CED4F1C}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{66C94ACB-63C7-42A3-9D83-A3801CED4F1C}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{66C94ACB-63C7-42A3-9D83-A3801CED4F1C}.Debug|x64.ActiveCfg = Debug|x64
		{66C94ACB-63C7-42A3-9D83-A3801CED4F1C}.Debug|x64.Build.0 = Debug|x64
		{66C94ACB-63C7-42A3-9D83-A3801CED4F1C}.Debug|x86.ActiveCfg = Debug|Any CPU
		{66C94ACB-63C7-42A3-9D83-A3801CED4F1C}.Debug|x86.Build.0 = Debug|Any CPU
		{66C94ACB-63C7-42A3-9D83-A3801CED4F1C}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{66C94ACB-63C7-42A3-9D83-A3801CED4F1C}.Release|Any CPU.Build.0 = Release|Any CPU
		{66C94ACB-63C7-42A3-9D83-A3801CED4F1C}.Release|x64.ActiveCfg = Release|x64
		{66C94ACB-63C7-42A3-9D83-A3801CED4F1C}.Release|x64.Build.0 = Release|x64
		{66C94ACB-63C7-42A3-9D83-A3801CED4F1C}.Release|x86.ActiveCfg = Release|x86
		{66C94ACB-63C7-42A3-9D83-A3801CED4F1C}.Release|x86.Build.0 = Release|x86
		{8EADAB93-F111-43AF-9E10-2376AE515491}.Debug|Any CPU.ActiveCfg = Debug|x64
		{8EADAB93-F111-43AF-9E10-2376AE515491}.Debug|Any CPU.Build.0 = Debug|x64
		{8EADAB93-F111-43AF-9E10-2376AE515491}.Debug|x64.ActiveCfg = Debug|x64
		{8EADAB93-F111-43AF-9E10-2376AE515491}.Debug|x64.Build.0 = Debug|x64
		{8EADAB93-F111-43AF-9E10-2376AE515491}.Debug|x86.ActiveCfg = Debug|x64
		{8EADAB93-F111-43AF-9E10-2376AE515491}.Debug|x86.Build.0 = Debug|x64
		{8EADAB93-F111-43AF-9E10-2376AE515491}.Release|Any CPU.ActiveCfg = Release|x64
		{8EADAB93-F111-43AF-9E10-2376AE515491}.Release|Any CPU.Build.0 = Release|x64
		{8EADAB93-F111-43AF-9E10-2376AE515491}.Release|x64.ActiveCfg = Release|x64
		{8EADAB93-F111-43AF-9E10-2376AE515491}.Release|x64.Build.0 = Release|x64
		{8EADAB93-F111-43AF-9E10-2376AE515491}.Release|x86.ActiveCfg = Release|x64
		{8EADAB93-F111-43AF-9E10-2376AE515491}.Release|x86.Build.0 = Release|x64
		{6F8B2A35-060D-4EB1-A6BA-A3057179304B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{6F8B2A35-060D-4EB1-A6BA-A3057179304B}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{6F8B2A35-060D-4EB1-A6BA-A3057179304B}.Debug|x64.ActiveCfg = Debug|Any CPU
		{6F8B2A35-060D-4EB1-A6BA-A3057179304B}.Debug|x64.Build.0 = Debug|Any CPU
		{6F8B2A35-060D-4EB1-A6BA-A3057179304B}.Debug|x86.ActiveCfg = Debug|Any CPU
		{6F8B2A35-060D-4EB1-A6BA-A3057179304B}.Debug|x86.Build.0 = Debug|Any CPU
		{6F8B2A35-060D-4EB1-A6BA-A3057179304B}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{6F8B2A35-060D-4EB1-A6BA-A3057179304B}.Release|Any CPU.Build.0 = Release|Any CPU
		{6F8B2A35-060D-4EB1-A6BA-A3057179304B}.Release|x64.ActiveCfg = Release|Any CPU
		{6F8B2A35-060D-4EB1-A6BA-A3057179304B}.Release|x64.Build.0 = Release|Any CPU
		{6F8B2A35-060D-4EB1-A6BA-A3057179304B}.Release|x86.ActiveCfg = Release|Any CPU
		{6F8B2A35-060D-4EB1-A6BA-A3057179304B}.Release|x86.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {EBFFF900-7478-45AA-95F6-F453BC9C3035}
	EndGlobalSection
EndGlobal

```

`KsDumper11/Driver/ManualLoader.bat`:

```bat
kdu.exe -prv 1 -map KsDumperDriver.sys
pause
```

`KsDumper11/DumperForm.Designer.cs`:

```cs
namespace KsDumper11
{
	public partial class DumperForm : global::System.Windows.Forms.Form
	{
		protected override void Dispose(bool disposing)
		{
			bool flag = disposing && this.components != null;
			if (flag)
			{
				this.components.Dispose();
			}
			base.Dispose(disposing);
		}

		private void InitializeComponent()
		{
            this.components = new System.ComponentModel.Container();
            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(DumperForm));
            this.groupBox1 = new System.Windows.Forms.GroupBox();
            this.logsTextBox = new System.Windows.Forms.RichTextBox();
            this.contextMenuStrip1 = new System.Windows.Forms.ContextMenuStrip(this.components);
            this.dumpMainModuleToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.toolStripSeparator1 = new System.Windows.Forms.ToolStripSeparator();
            this.openInExplorerToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.suspendProcessToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.resumeProcessToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.killProcessToolStripMenuItem = new System.Windows.Forms.ToolStripMenuItem();
            this.fileDumpBtn = new System.Windows.Forms.Button();
            this.titleLbl = new DarkControls.Controls.TransparentLabel();
            this.closeBtn = new DarkControls.Controls.WindowsDefaultTitleBarButton();
            this.refreshBtn = new System.Windows.Forms.Button();
            this.autoRefreshCheckBox = new DarkControls.Controls.DarkCheckBox();
            this.hideSystemProcessBtn = new System.Windows.Forms.Button();
            this.closeDriverOnExitBox = new DarkControls.Controls.DarkCheckBox();
            this.appIcon1 = new DarkControls.Controls.AppIcon();
            this.processList = new KsDumper11.Utility.ProcessListView();
            this.PIDHeader = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
            this.NameHeader = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
            this.PathHeader = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
            this.BaseAddressHeader = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
            this.EntryPointHeader = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
            this.ImageSizeHeader = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
            this.ImageTypeHeader = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
            this.providerBtn = new DarkControls.Controls.DarkButton();
            this.trigger1 = new KsDumper11.Trigger();
            this.debuggerTrigger = new KsDumper11.Trigger();
            this.antiantiDebuggerToolsBox = new DarkControls.Controls.DarkCheckBox();
            this.groupBox1.SuspendLayout();
            this.contextMenuStrip1.SuspendLayout();
            ((System.ComponentModel.ISupportInitialize)(this.appIcon1)).BeginInit();
            this.SuspendLayout();
            // 
            // groupBox1
            // 
            this.groupBox1.Controls.Add(this.logsTextBox);
            this.groupBox1.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
            this.groupBox1.Location = new System.Drawing.Point(12, 512);
            this.groupBox1.Name = "groupBox1";
            this.groupBox1.Size = new System.Drawing.Size(987, 222);
            this.groupBox1.TabIndex = 5;
            this.groupBox1.TabStop = false;
            this.groupBox1.Text = "Logs";
            // 
            // logsTextBox
            // 
            this.logsTextBox.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(33)))), ((int)(((byte)(33)))), ((int)(((byte)(33)))));
            this.logsTextBox.BorderStyle = System.Windows.Forms.BorderStyle.None;
            this.logsTextBox.ForeColor = System.Drawing.Color.Silver;
            this.logsTextBox.Location = new System.Drawing.Point(12, 19);
            this.logsTextBox.Name = "logsTextBox";
            this.logsTextBox.ReadOnly = true;
            this.logsTextBox.ScrollBars = System.Windows.Forms.RichTextBoxScrollBars.Vertical;
            this.logsTextBox.Size = new System.Drawing.Size(967, 197);
            this.logsTextBox.TabIndex = 0;
            this.logsTextBox.Text = "";
            this.logsTextBox.TextChanged += new System.EventHandler(this.logsTextBox_TextChanged);
            // 
            // contextMenuStrip1
            // 
            this.contextMenuStrip1.ImageScalingSize = new System.Drawing.Size(20, 20);
            this.contextMenuStrip1.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
            this.dumpMainModuleToolStripMenuItem,
            this.toolStripSeparator1,
            this.openInExplorerToolStripMenuItem,
            this.suspendProcessToolStripMenuItem,
            this.resumeProcessToolStripMenuItem,
            this.killProcessToolStripMenuItem});
            this.contextMenuStrip1.Name = "contextMenuStrip1";
            this.contextMenuStrip1.Size = new System.Drawing.Size(163, 120);
            this.contextMenuStrip1.Opening += new System.ComponentModel.CancelEventHandler(this.contextMenuStrip1_Opening);
            // 
            // dumpMainModuleToolStripMenuItem
            // 
            this.dumpMainModuleToolStripMenuItem.Name = "dumpMainModuleToolStripMenuItem";
            this.dumpMainModuleToolStripMenuItem.Size = new System.Drawing.Size(162, 22);
            this.dumpMainModuleToolStripMenuItem.Text = "Dump Process";
            this.dumpMainModuleToolStripMenuItem.Click += new System.EventHandler(this.dumpMainModuleToolStripMenuItem_Click);
            // 
            // toolStripSeparator1
            // 
            this.toolStripSeparator1.Name = "toolStripSeparator1";
            this.toolStripSeparator1.Size = new System.Drawing.Size(159, 6);
            // 
            // openInExplorerToolStripMenuItem
            // 
            this.openInExplorerToolStripMenuItem.Name = "openInExplorerToolStripMenuItem";
            this.openInExplorerToolStripMenuItem.Size = new System.Drawing.Size(162, 22);
            this.openInExplorerToolStripMenuItem.Text = "Open In Explorer";
            this.openInExplorerToolStripMenuItem.Click += new System.EventHandler(this.openInExplorerToolStripMenuItem_Click);
            // 
            // suspendProcessToolStripMenuItem
            // 
            this.suspendProcessToolStripMenuItem.Name = "suspendProcessToolStripMenuItem";
            this.suspendProcessToolStripMenuItem.Size = new System.Drawing.Size(162, 22);
            this.suspendProcessToolStripMenuItem.Text = "Suspend process";
            this.suspendProcessToolStripMenuItem.Click += new System.EventHandler(this.suspendProcessToolStripMenuItem_Click);
            // 
            // resumeProcessToolStripMenuItem
            // 
            this.resumeProcessToolStripMenuItem.Name = "resumeProcessToolStripMenuItem";
            this.resumeProcessToolStripMenuItem.Size = new System.Drawing.Size(162, 22);
            this.resumeProcessToolStripMenuItem.Text = "Resume process";
            this.resumeProcessToolStripMenuItem.Click += new System.EventHandler(this.resumeProcessToolStripMenuItem_Click);
            // 
            // killProcessToolStripMenuItem
            // 
            this.killProcessToolStripMenuItem.Name = "killProcessToolStripMenuItem";
            this.killProcessToolStripMenuItem.Size = new System.Drawing.Size(162, 22);
            this.killProcessToolStripMenuItem.Text = "Kill process";
            this.killProcessToolStripMenuItem.Click += new System.EventHandler(this.killProcessToolStripMenuItem_Click);
            // 
            // fileDumpBtn
            // 
            this.fileDumpBtn.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(33)))), ((int)(((byte)(33)))), ((int)(((byte)(33)))));
            this.fileDumpBtn.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
            this.fileDumpBtn.ForeColor = System.Drawing.Color.Silver;
            this.fileDumpBtn.Location = new System.Drawing.Point(227, 49);
            this.fileDumpBtn.Name = "fileDumpBtn";
            this.fileDumpBtn.Size = new System.Drawing.Size(75, 23);
            this.fileDumpBtn.TabIndex = 1;
            this.fileDumpBtn.Text = "Dump File";
            this.fileDumpBtn.UseVisualStyleBackColor = false;
            this.fileDumpBtn.Click += new System.EventHandler(this.fileDumpBtn_Click);
            // 
            // titleLbl
            // 
            this.titleLbl.AutoSize = true;
            this.titleLbl.Font = new System.Drawing.Font("Microsoft Sans Serif", 12F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.titleLbl.Location = new System.Drawing.Point(32, 7);
            this.titleLbl.Name = "titleLbl";
            this.titleLbl.Size = new System.Drawing.Size(106, 20);
            this.titleLbl.TabIndex = 8;
            this.titleLbl.Text = "KsDumper 11";
            // 
            // closeBtn
            // 
            this.closeBtn.ButtonType = DarkControls.Controls.WindowsDefaultTitleBarButton.Type.Close;
            this.closeBtn.ClickColor = System.Drawing.Color.Red;
            this.closeBtn.ClickIconColor = System.Drawing.Color.Black;
            this.closeBtn.HoverColor = System.Drawing.Color.OrangeRed;
            this.closeBtn.HoverIconColor = System.Drawing.Color.Black;
            this.closeBtn.IconColor = System.Drawing.Color.Black;
            this.closeBtn.IconLineThickness = 2;
            this.closeBtn.Location = new System.Drawing.Point(969, 1);
            this.closeBtn.Name = "closeBtn";
            this.closeBtn.Size = new System.Drawing.Size(40, 40);
            this.closeBtn.TabIndex = 7;
            this.closeBtn.Text = "windowsDefaultTitleBarButton1";
            this.closeBtn.UseVisualStyleBackColor = true;
            // 
            // refreshBtn
            // 
            this.refreshBtn.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(33)))), ((int)(((byte)(33)))), ((int)(((byte)(33)))));
            this.refreshBtn.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
            this.refreshBtn.ForeColor = System.Drawing.Color.Silver;
            this.refreshBtn.Location = new System.Drawing.Point(12, 49);
            this.refreshBtn.Name = "refreshBtn";
            this.refreshBtn.Size = new System.Drawing.Size(75, 23);
            this.refreshBtn.TabIndex = 10;
            this.refreshBtn.Text = "Refresh";
            this.refreshBtn.UseVisualStyleBackColor = false;
            this.refreshBtn.Click += new System.EventHandler(this.refreshBtn_Click);
            // 
            // autoRefreshCheckBox
            // 
            this.autoRefreshCheckBox.Appearance = System.Windows.Forms.Appearance.Button;
            this.autoRefreshCheckBox.BoxBorderColor = System.Drawing.Color.DarkSlateBlue;
            this.autoRefreshCheckBox.BoxFillColor = System.Drawing.Color.FromArgb(((int)(((byte)(33)))), ((int)(((byte)(33)))), ((int)(((byte)(33)))));
            this.autoRefreshCheckBox.CheckColor = System.Drawing.Color.CornflowerBlue;
            this.autoRefreshCheckBox.FlatAppearance.BorderSize = 0;
            this.autoRefreshCheckBox.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
            this.autoRefreshCheckBox.Location = new System.Drawing.Point(93, 49);
            this.autoRefreshCheckBox.Name = "autoRefreshCheckBox";
            this.autoRefreshCheckBox.Size = new System.Drawing.Size(98, 23);
            this.autoRefreshCheckBox.TabIndex = 11;
            this.autoRefreshCheckBox.Text = "Auto Refresh";
            this.autoRefreshCheckBox.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
            this.autoRefreshCheckBox.UseVisualStyleBackColor = true;
            this.autoRefreshCheckBox.CheckedChanged += new System.EventHandler(this.autoRefreshCheckBox_CheckedChanged);
            // 
            // hideSystemProcessBtn
            // 
            this.hideSystemProcessBtn.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(33)))), ((int)(((byte)(33)))), ((int)(((byte)(33)))));
            this.hideSystemProcessBtn.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
            this.hideSystemProcessBtn.ForeColor = System.Drawing.Color.Silver;
            this.hideSystemProcessBtn.Location = new System.Drawing.Point(750, 49);
            this.hideSystemProcessBtn.Name = "hideSystemProcessBtn";
            this.hideSystemProcessBtn.Size = new System.Drawing.Size(137, 23);
            this.hideSystemProcessBtn.TabIndex = 12;
            this.hideSystemProcessBtn.Text = "Show System Processes";
            this.hideSystemProcessBtn.UseVisualStyleBackColor = false;
            this.hideSystemProcessBtn.Click += new System.EventHandler(this.hideSystemProcessBtn_Click);
            // 
            // closeDriverOnExitBox
            // 
            this.closeDriverOnExitBox.Appearance = System.Windows.Forms.Appearance.Button;
            this.closeDriverOnExitBox.BoxBorderColor = System.Drawing.Color.DarkSlateBlue;
            this.closeDriverOnExitBox.BoxFillColor = System.Drawing.Color.FromArgb(((int)(((byte)(33)))), ((int)(((byte)(33)))), ((int)(((byte)(33)))));
            this.closeDriverOnExitBox.CheckColor = System.Drawing.Color.CornflowerBlue;
            this.closeDriverOnExitBox.FlatAppearance.BorderSize = 0;
            this.closeDriverOnExitBox.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
            this.closeDriverOnExitBox.Location = new System.Drawing.Point(361, 48);
            this.closeDriverOnExitBox.Name = "closeDriverOnExitBox";
            this.closeDriverOnExitBox.Size = new System.Drawing.Size(133, 23);
            this.closeDriverOnExitBox.TabIndex = 13;
            this.closeDriverOnExitBox.Text = "Close Driver on Exit";
            this.closeDriverOnExitBox.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
            this.closeDriverOnExitBox.UseVisualStyleBackColor = true;
            this.closeDriverOnExitBox.CheckedChanged += new System.EventHandler(this.closeDriverOnExitBox_CheckedChanged);
            // 
            // appIcon1
            // 
            this.appIcon1.AppIconImage = global::KsDumper11.Properties.Resources.icons8_crossed_axes_100;
            this.appIcon1.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(33)))), ((int)(((byte)(33)))), ((int)(((byte)(33)))));
            this.appIcon1.DragForm = this;
            this.appIcon1.Image = ((System.Drawing.Image)(resources.GetObject("appIcon1.Image")));
            this.appIcon1.Location = new System.Drawing.Point(5, 4);
            this.appIcon1.Name = "appIcon1";
            this.appIcon1.Scale = 3.5F;
            this.appIcon1.Size = new System.Drawing.Size(28, 28);
            this.appIcon1.TabIndex = 9;
            this.appIcon1.TabStop = false;
            // 
            // processList
            // 
            this.processList.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(33)))), ((int)(((byte)(33)))), ((int)(((byte)(33)))));
            this.processList.BorderStyle = System.Windows.Forms.BorderStyle.None;
            this.processList.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
            this.PIDHeader,
            this.NameHeader,
            this.PathHeader,
            this.BaseAddressHeader,
            this.EntryPointHeader,
            this.ImageSizeHeader,
            this.ImageTypeHeader});
            this.processList.ContextMenuStrip = this.contextMenuStrip1;
            this.processList.ForeColor = System.Drawing.Color.Silver;
            this.processList.FullRowSelect = true;
            this.processList.HideSelection = false;
            this.processList.Location = new System.Drawing.Point(12, 78);
            this.processList.MultiSelect = false;
            this.processList.Name = "processList";
            this.processList.OwnerDraw = true;
            this.processList.Size = new System.Drawing.Size(987, 428);
            this.processList.Sorting = System.Windows.Forms.SortOrder.Ascending;
            this.processList.SystemProcessesHidden = true;
            this.processList.TabIndex = 2;
            this.processList.UseCompatibleStateImageBehavior = false;
            this.processList.View = System.Windows.Forms.View.Details;
            // 
            // PIDHeader
            // 
            this.PIDHeader.Text = "PID";
            this.PIDHeader.Width = 76;
            // 
            // NameHeader
            // 
            this.NameHeader.Text = "Name";
            this.NameHeader.Width = 143;
            // 
            // PathHeader
            // 
            this.PathHeader.Text = "Path";
            this.PathHeader.Width = 375;
            // 
            // BaseAddressHeader
            // 
            this.BaseAddressHeader.Text = "Base Address";
            this.BaseAddressHeader.Width = 106;
            // 
            // EntryPointHeader
            // 
            this.EntryPointHeader.Text = "Entry Point";
            this.EntryPointHeader.Width = 106;
            // 
            // ImageSizeHeader
            // 
            this.ImageSizeHeader.Text = "Image Size";
            this.ImageSizeHeader.Width = 88;
            // 
            // ImageTypeHeader
            // 
            this.ImageTypeHeader.Text = "Image Type";
            this.ImageTypeHeader.Width = 76;
            // 
            // providerBtn
            // 
            this.providerBtn.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(33)))), ((int)(((byte)(33)))), ((int)(((byte)(33)))));
            this.providerBtn.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
            this.providerBtn.ForeColor = System.Drawing.Color.Silver;
            this.providerBtn.Location = new System.Drawing.Point(893, 49);
            this.providerBtn.Name = "providerBtn";
            this.providerBtn.Size = new System.Drawing.Size(106, 23);
            this.providerBtn.TabIndex = 17;
            this.providerBtn.Text = "Provider Selector";
            this.providerBtn.UseVisualStyleBackColor = true;
            this.providerBtn.Click += new System.EventHandler(this.providerBtn_Click);
            // 
            // trigger1
            // 
            this.trigger1.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(33)))), ((int)(((byte)(33)))), ((int)(((byte)(33)))));
            this.trigger1.Location = new System.Drawing.Point(443, 28);
            this.trigger1.Margin = new System.Windows.Forms.Padding(4);
            this.trigger1.Name = "trigger1";
            this.trigger1.Size = new System.Drawing.Size(35, 24);
            this.trigger1.TabIndex = 16;
            // 
            // debuggerTrigger
            // 
            this.debuggerTrigger.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(33)))), ((int)(((byte)(33)))), ((int)(((byte)(33)))));
            this.debuggerTrigger.Location = new System.Drawing.Point(484, 28);
            this.debuggerTrigger.Margin = new System.Windows.Forms.Padding(4);
            this.debuggerTrigger.Name = "debuggerTrigger";
            this.debuggerTrigger.Size = new System.Drawing.Size(15, 13);
            this.debuggerTrigger.TabIndex = 15;
            // 
            // antiantiDebuggerToolsBox
            // 
            this.antiantiDebuggerToolsBox.Appearance = System.Windows.Forms.Appearance.Button;
            this.antiantiDebuggerToolsBox.BoxBorderColor = System.Drawing.Color.DarkSlateBlue;
            this.antiantiDebuggerToolsBox.BoxFillColor = System.Drawing.Color.FromArgb(((int)(((byte)(33)))), ((int)(((byte)(33)))), ((int)(((byte)(33)))));
            this.antiantiDebuggerToolsBox.CheckColor = System.Drawing.Color.CornflowerBlue;
            this.antiantiDebuggerToolsBox.FlatAppearance.BorderSize = 0;
            this.antiantiDebuggerToolsBox.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
            this.antiantiDebuggerToolsBox.Location = new System.Drawing.Point(500, 48);
            this.antiantiDebuggerToolsBox.Name = "antiantiDebuggerToolsBox";
            this.antiantiDebuggerToolsBox.Size = new System.Drawing.Size(244, 23);
            this.antiantiDebuggerToolsBox.TabIndex = 18;
            this.antiantiDebuggerToolsBox.Text = "Enable Anti Anti Debugger Tools Detection";
            this.antiantiDebuggerToolsBox.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
            this.antiantiDebuggerToolsBox.UseVisualStyleBackColor = true;
            this.antiantiDebuggerToolsBox.CheckedChanged += new System.EventHandler(this.antiantiDebuggerToolsBox_CheckedChanged);
            // 
            // DumperForm
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(33)))), ((int)(((byte)(33)))), ((int)(((byte)(33)))));
            this.ClientSize = new System.Drawing.Size(1009, 746);
            this.Controls.Add(this.antiantiDebuggerToolsBox);
            this.Controls.Add(this.providerBtn);
            this.Controls.Add(this.trigger1);
            this.Controls.Add(this.debuggerTrigger);
            this.Controls.Add(this.closeDriverOnExitBox);
            this.Controls.Add(this.hideSystemProcessBtn);
            this.Controls.Add(this.autoRefreshCheckBox);
            this.Controls.Add(this.refreshBtn);
            this.Controls.Add(this.closeBtn);
            this.Controls.Add(this.fileDumpBtn);
            this.Controls.Add(this.groupBox1);
            this.Controls.Add(this.processList);
            this.Controls.Add(this.appIcon1);
            this.Controls.Add(this.titleLbl);
            this.DoubleBuffered = true;
            this.ForeColor = System.Drawing.Color.Silver;
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.None;
            this.MaximizeBox = false;
            this.Name = "DumperForm";
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
            this.Text = "Actions";
            this.Load += new System.EventHandler(this.Dumper_Load);
            this.groupBox1.ResumeLayout(false);
            this.contextMenuStrip1.ResumeLayout(false);
            ((System.ComponentModel.ISupportInitialize)(this.appIcon1)).EndInit();
            this.ResumeLayout(false);
            this.PerformLayout();

		}

		private System.ComponentModel.IContainer components = null;
		private KsDumper11.Utility.ProcessListView processList;
		private System.Windows.Forms.ColumnHeader PIDHeader;
		private System.Windows.Forms.ColumnHeader NameHeader;
		private System.Windows.Forms.ColumnHeader PathHeader;
		private System.Windows.Forms.ColumnHeader BaseAddressHeader;
		private System.Windows.Forms.ColumnHeader EntryPointHeader;
		private System.Windows.Forms.ColumnHeader ImageSizeHeader;
		private System.Windows.Forms.ColumnHeader ImageTypeHeader;
		private System.Windows.Forms.GroupBox groupBox1;
		private System.Windows.Forms.RichTextBox logsTextBox;
		private System.Windows.Forms.ContextMenuStrip contextMenuStrip1;
		private System.Windows.Forms.ToolStripMenuItem dumpMainModuleToolStripMenuItem;
		private System.Windows.Forms.ToolStripSeparator toolStripSeparator1;
		private System.Windows.Forms.ToolStripMenuItem openInExplorerToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem suspendProcessToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem resumeProcessToolStripMenuItem;
		private System.Windows.Forms.ToolStripMenuItem killProcessToolStripMenuItem;
		private System.Windows.Forms.Button fileDumpBtn;
		private DarkControls.Controls.WindowsDefaultTitleBarButton closeBtn;
		private DarkControls.Controls.TransparentLabel titleLbl;
		private DarkControls.Controls.AppIcon appIcon1;
		private System.Windows.Forms.Button refreshBtn;
		private DarkControls.Controls.DarkCheckBox autoRefreshCheckBox;
		private System.Windows.Forms.Button hideSystemProcessBtn;
        private DarkControls.Controls.DarkCheckBox closeDriverOnExitBox;
        private Trigger debuggerTrigger;
        private Trigger trigger1;
        private DarkControls.Controls.DarkButton providerBtn;
        private DarkControls.Controls.DarkCheckBox antiantiDebuggerToolsBox;
    }
}

```

`KsDumper11/DumperForm.cs`:

```cs
using System;
using System.ComponentModel;
using System.Diagnostics;
using System.Drawing;
using System.IO;
using System.Runtime.InteropServices;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;
using DarkControls;
using KsDumper11.Driver;
using KsDumper11.PE;
using KsDumper11.Utility;
using System.Collections.Generic;
using System.Reflection.Emit;

namespace KsDumper11
{
    public partial class DumperForm : Form
    {
        protected override CreateParams CreateParams
        {
            get
            {
                CreateParams cp = base.CreateParams;
                cp.ExStyle |= 33554432;
                return cp;
            }
        }

        [DllImport("kernel32.dll", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool TerminateProcess(IntPtr hProcess, uint uExitCode);

        [DllImport("advapi32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        private static extern int GetSecurityInfo(int HANDLE, int SE_OBJECT_TYPE, int SECURITY_INFORMATION, int psidOwner, int psidGroup, out IntPtr pDACL, IntPtr pSACL, out IntPtr pSecurityDescriptor);

        [DllImport("advapi32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        private static extern int SetSecurityInfo(int HANDLE, int SE_OBJECT_TYPE, int SECURITY_INFORMATION, int psidOwner, int psidGroup, IntPtr pDACL, IntPtr pSACL);

        [DllImport("ntdll.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool ZwSuspendProcess(IntPtr hProcess);

        [DllImport("ntdll.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool ZwResumeProcess(IntPtr hProcess);

        [DllImport("kernel32.dll")]
        private static extern IntPtr OpenProcess(uint dwDesiredAccess, int bInheritHandle, uint dwProcessId);

        [DllImport("kernel32.dll", SetLastError = true)]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool CloseHandle(IntPtr hObject);

        [StructLayout(LayoutKind.Sequential, Pack = 1)]
        private struct TOKEN_PRIVILEGES
        {
            public int PrivilegeCount;

            public long Luid;

            public int Attributes;
        }

        public struct SYSTEM_INFO
        {
            public uint dwOemId;
            public uint dwPageSize;
            public uint lpMinimumApplicationAddress;
            public uint lpMaximumApplicationAddress;
            public uint dwActiveProcessorMask;
            public uint dwNumberOfProcessors;
            public uint dwProcessorType;
            public uint dwAllocationGranularity;
            public uint dwProcessorLevel;
            public uint dwProcessorRevision;
        }

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
        private struct PROCESSENTRY32
        {
            private const int MAX_PATH = 260;
            internal uint dwSize;
            internal uint cntUsage;
            internal uint th32ProcessID;
            internal IntPtr th32DefaultHeapID;
            internal uint th32ModuleID;
            internal uint cntThreads;
            internal uint th32ParentProcessID;
            internal int pcPriClassBase;
            internal uint dwFlags;

            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 260)]
            internal string szExeFile;
        }

        [StructLayout(LayoutKind.Sequential, Pack = 1)]
        private struct PROCESS_BASIC_INFORMATION
        {
            public int Size
            {
                get
                {
                    return 24;
                }
            }

            public int ExitStatus;
            public int PebBaseAddress;
            public int AffinityMask;
            public int BasePriority;
            public int UniqueProcessId;
            public int InheritedFromUniqueProcessId;
        }

        private readonly KsDumperDriverInterface driver;
        private readonly ProcessDumper dumper;
        private System.Windows.Forms.Timer t;

        bool skip_closeDriverOnExitBox_CheckedChanged_Event = false;
        bool skip_antiantiDebuggerToolsBox_CheckedChanged_Event = false;

        List<LabelInfo> labelInfos = new List<LabelInfo>();

        JsonSettingsManager settingsManager;

        LabelDrawer labelDrawer;

        public DumperForm()
        {
            this.InitializeComponent();

            settingsManager = new JsonSettingsManager();

            skip_closeDriverOnExitBox_CheckedChanged_Event = true;
            closeDriverOnExitBox.Checked = settingsManager.JsonSettings.closeDriverOnExit;

            skip_closeDriverOnExitBox_CheckedChanged_Event = true;
            antiantiDebuggerToolsBox.Checked = settingsManager.JsonSettings.enableAntiAntiDebuggerTools;

            this.FormClosing += Dumper_FormClosing;
            this.Disposed += Dumper_Disposed;
            this.appIcon1.DragForm = this;
            base.FormBorderStyle = FormBorderStyle.None;
            base.Region = Region.FromHrgn(Utils.CreateRoundRectRgn(0, 0, base.Width, base.Height, 10, 10));
            this.closeBtn.Region = Region.FromHrgn(Utils.CreateRoundRectRgn(0, 0, this.closeBtn.Width, this.closeBtn.Height, 10, 10));
            this.groupBox1.ForeColor = Color.Silver;
            foreach (object obj in this.groupBox1.Controls)
            {
                Control c = (Control)obj;
                c.ForeColor = this.groupBox1.ForeColor;
            }
            this.processList.HeaderStyle = ColumnHeaderStyle.Clickable;
            this.processList.ColumnWidthChanging += this.processList_ColumnWidthChanging;
            this.driver = new KsDumperDriverInterface("\\\\.\\KsDumper");
            this.dumper = new ProcessDumper(this.driver);

            this.LoadProcessList();
        }

        private void Dumper_Load(object sender, EventArgs e)
        {
            if (antiantiDebuggerToolsBox.Checked)
            {
                labelDrawer = new LabelDrawer(this);

                SnifferBypass.SelfTitle(this.Handle);

                foreach (Control ctrl in this.Controls)
                {
                    if (ctrl == groupBox1) continue;

                    SnifferBypass.SelfTitle(ctrl.Handle);
                }

                this.Text = SnifferBypass.GenerateRandomString(this.Text.Length);
            }

            Logger.OnLog += this.Logger_OnLog;
            Logger.Log("KsDumper 11 - [By EquiFox] Given Newlife", Array.Empty<object>());
        }

        private void Dumper_Disposed(object sender, EventArgs e)
        {
            if (settingsManager.JsonSettings.closeDriverOnExit)
            {
                driver.UnloadDriver();
            }
        }

        private void closeDriverOnExitBox_CheckedChanged(object sender, EventArgs e)
        {
            if (skip_closeDriverOnExitBox_CheckedChanged_Event)
            {
                skip_closeDriverOnExitBox_CheckedChanged_Event = false;
                return;
            }

            settingsManager.JsonSettings.closeDriverOnExit = closeDriverOnExitBox.Checked;
            settingsManager.Save();
        }

        private void antiantiDebuggerToolsBox_CheckedChanged(object sender, EventArgs e)
        {
            if (skip_antiantiDebuggerToolsBox_CheckedChanged_Event)
            {
                skip_antiantiDebuggerToolsBox_CheckedChanged_Event = false;
                return;
            }

            settingsManager.JsonSettings.enableAntiAntiDebuggerTools = antiantiDebuggerToolsBox.Checked;
            settingsManager.Save();
        }

        private void Dumper_FormClosing(object sender, FormClosingEventArgs e)
        {
            if (closeDriverOnExitBox.Checked)
            {
                driver.UnloadDriver();
            }
        }

        protected override void WndProc(ref Message m)
        {
            base.WndProc(ref m);
            bool flag = m.Msg == Utils.WM_NCHITTEST;
            if (flag)
            {
                m.Result = (IntPtr)Utils.HT_CAPTION;
            }
        }

        private void processList_ColumnWidthChanging(object sender, ColumnWidthChangingEventArgs e)
        {
            Console.Write("Column Resizing");
            e.NewWidth = this.processList.Columns[e.ColumnIndex].Width;
            e.Cancel = true;
        }



        private void LoadProcessList()
        {
            bool flag = this.driver.HasValidHandle();
            if (flag)
            {
                ProcessSummary[] result;
                bool processSummaryList = this.driver.GetProcessSummaryList(out result);
                if (processSummaryList)
                {
                    this.processList.LoadProcesses(result);
                }
                else
                {
                    MessageBox.Show("Unable to retrieve process list !", "Error", MessageBoxButtons.OK, MessageBoxIcon.Hand);
                }
            }
        }

        private bool DumpProcess(ProcessSummary process)
        {
            bool flag = this.driver.HasValidHandle();
            bool flag2;
            if (flag)
            {
                Logger.Log("Valid driver handle open", Array.Empty<object>());
                bool sucess = false;
                Task.Run(delegate ()
                {
                    Logger.Log("Dumping process...", Array.Empty<object>());
                    PEFile peFile;
                    sucess = this.dumper.DumpProcess(process, out peFile);
                    if (sucess)
                    {
                        Logger.Log("Sucess!", Array.Empty<object>());
                        this.Invoke(new Action(delegate ()
                        {
                            using (SaveFileDialog sfd = new SaveFileDialog())
                            {
                                sfd.FileName = process.ProcessName.Replace(".exe", "_dump.exe");
                                sfd.Filter = "Executable File (.exe)|*.exe";
                                bool flag3 = sfd.ShowDialog() == DialogResult.OK;
                                if (flag3)
                                {
                                    peFile.SaveToDisk(sfd.FileName);
                                    Logger.Log("Saved at '{0}' !", new object[] { sfd.FileName });
                                }
                            }
                        }));
                        Logger.Log(process.ProcessName + "  Killed", Array.Empty<object>());
                        this.KillProcess(process.ProcessId);
                    }
                    else
                    {
                        Logger.Log("Failure", Array.Empty<object>());
                        this.Invoke(new Action(delegate ()
                        {
                            MessageBox.Show("Unable to dump target process !", "Error", MessageBoxButtons.OK, MessageBoxIcon.Hand);
                        }));
                    }
                });
                flag2 = sucess;
            }
            else
            {
                MessageBox.Show("Unable to communicate with driver ! Make sure it is loaded.", "Error", MessageBoxButtons.OK, MessageBoxIcon.Hand);
                flag2 = false;
            }
            return flag2;
        }

        private bool DumpProcess(Process process)
        {
            bool flag = this.driver.HasValidHandle();
            bool flag3;
            if (flag)
            {
                Logger.Log("Valid driver handle open", Array.Empty<object>());
                Logger.Log("Dumping process...", Array.Empty<object>());
                PEFile peFile;
                bool sucess = this.dumper.DumpProcess(process, out peFile);
                bool flag2 = sucess;
                if (flag2)
                {
                    Logger.Log("Sucess!", Array.Empty<object>());
                    base.Invoke(new Action(delegate ()
                    {
                        using (SaveFileDialog sfd = new SaveFileDialog())
                        {
                            sfd.FileName = process.ProcessName + "_dump.exe";
                            sfd.Filter = "Executable File (.exe)|*.exe";
                            bool flag4 = sfd.ShowDialog() == DialogResult.OK;
                            if (flag4)
                            {
                                peFile.SaveToDisk(sfd.FileName);
                                Logger.Log("Saved at '{0}' !", new object[] { sfd.FileName });
                            }
                        }
                    }));
                    Logger.Log(process.ProcessName + "  Killed", Array.Empty<object>());
                    this.KillProcess(process.Id);
                }
                else
                {
                    Logger.Log("Failure", Array.Empty<object>());
                    Logger.Log(process.ProcessName + "  Killed", Array.Empty<object>());
                    this.KillProcess(process.Id);
                    base.Invoke(new Action(delegate ()
                    {
                        MessageBox.Show("Unable to dump target process !", "Error", MessageBoxButtons.OK, MessageBoxIcon.Hand);
                    }));
                }
                flag3 = sucess;
            }
            else
            {
                MessageBox.Show("Unable to communicate with driver ! Make sure it is loaded.", "Error", MessageBoxButtons.OK, MessageBoxIcon.Hand);
                Logger.Log(process.ProcessName + "  Killed", Array.Empty<object>());
                this.KillProcess(process.Id);
                flag3 = false;
            }
            return flag3;
        }

        private void dumpMainModuleToolStripMenuItem_Click(object sender, EventArgs e)
        {
            ProcessSummary targetProcess = this.processList.SelectedItems[0].Tag as ProcessSummary;
            this.DumpProcess(targetProcess);
        }

        private void Logger_OnLog(string message)
        {
            this.logsTextBox.Invoke(new Action(delegate ()
            {
                this.logsTextBox.AppendText(message);
                this.logsTextBox.Update();
            }));
        }

        private void refreshMenuBtn_Click(object sender, EventArgs e)
        {
            this.LoadProcessList();
        }

        private void contextMenuStrip1_Opening(object sender, CancelEventArgs e)
        {
            e.Cancel = this.processList.SelectedItems.Count == 0;
        }

        private void logsTextBox_TextChanged(object sender, EventArgs e)
        {
            this.logsTextBox.SelectionStart = this.logsTextBox.Text.Length;
            this.logsTextBox.ScrollToCaret();
        }

        private void openInExplorerToolStripMenuItem_Click(object sender, EventArgs e)
        {
            ProcessSummary targetProcess = this.processList.SelectedItems[0].Tag as ProcessSummary;
            Process.Start("explorer.exe", Path.GetDirectoryName(targetProcess.MainModuleFileName));
        }

        private void suspendProcessToolStripMenuItem_Click(object sender, EventArgs e)
        {
            ProcessSummary targetProcess = this.processList.SelectedItems[0].Tag as ProcessSummary;
            this.SuspendProcess(targetProcess.ProcessId);
        }

        private void KillProcess(int processId)
        {
            IntPtr hProcess = DumperForm.OpenProcess(1081U, 0, (uint)processId);
            bool flag = hProcess == IntPtr.Zero;
            if (flag)
            {
                IntPtr pDACL;
                IntPtr pSecDesc;
                DumperForm.GetSecurityInfo((int)Process.GetCurrentProcess().Handle, 6, 4, 0, 0, out pDACL, IntPtr.Zero, out pSecDesc);
                hProcess = DumperForm.OpenProcess(262144U, 0, (uint)processId);
                DumperForm.SetSecurityInfo((int)hProcess, 6, 536870916, 0, 0, pDACL, IntPtr.Zero);
                DumperForm.CloseHandle(hProcess);
                hProcess = DumperForm.OpenProcess(1080U, 0, (uint)processId);
            }
            try
            {
                DumperForm.TerminateProcess(hProcess, 0U);
            }
            catch
            {
            }
            DumperForm.CloseHandle(hProcess);
        }

        private void SuspendProcess(int processId)
        {
            IntPtr hProcess = DumperForm.OpenProcess(2048U, 0, (uint)processId);
            bool flag = hProcess == IntPtr.Zero;
            if (flag)
            {
                IntPtr pDACL;
                IntPtr pSecDesc;
                DumperForm.GetSecurityInfo((int)Process.GetCurrentProcess().Handle, 6, 4, 0, 0, out pDACL, IntPtr.Zero, out pSecDesc);
                hProcess = DumperForm.OpenProcess(262144U, 0, (uint)processId);
                DumperForm.SetSecurityInfo((int)hProcess, 6, 536870916, 0, 0, pDACL, IntPtr.Zero);
                DumperForm.CloseHandle(hProcess);
                hProcess = DumperForm.OpenProcess(1080U, 0, (uint)processId);
            }
            try
            {
                DumperForm.ZwSuspendProcess(hProcess);
            }
            catch
            {
            }
            DumperForm.CloseHandle(hProcess);
        }

        private void ResumeProcess(int processId)
        {
            IntPtr hProcess = DumperForm.OpenProcess(2048U, 0, (uint)processId);
            bool flag = hProcess == IntPtr.Zero;
            if (flag)
            {
                IntPtr pDACL;
                IntPtr pSecDesc;
                DumperForm.GetSecurityInfo((int)Process.GetCurrentProcess().Handle, 6, 4, 0, 0, out pDACL, IntPtr.Zero, out pSecDesc);
                hProcess = DumperForm.OpenProcess(262144U, 0, (uint)processId);
                DumperForm.SetSecurityInfo((int)hProcess, 6, 536870916, 0, 0, pDACL, IntPtr.Zero);
                DumperForm.CloseHandle(hProcess);
                hProcess = DumperForm.OpenProcess(1080U, 0, (uint)processId);
            }
            try
            {
                DumperForm.ZwResumeProcess(hProcess);
            }
            catch
            {
            }
            DumperForm.CloseHandle(hProcess);
        }

        private void resumeProcessToolStripMenuItem_Click(object sender, EventArgs e)
        {
            ProcessSummary targetProcess = this.processList.SelectedItems[0].Tag as ProcessSummary;
            this.ResumeProcess(targetProcess.ProcessId);
        }

        private void killProcessToolStripMenuItem_Click(object sender, EventArgs e)
        {
            ProcessSummary targetProcess = this.processList.SelectedItems[0].Tag as ProcessSummary;
            this.KillProcess(targetProcess.ProcessId);
        }

        private void T_Tick(object sender, EventArgs e)
        {
            this.LoadProcessList();
        }

        private void ClearLog()
        {
            this.logsTextBox.Clear();
        }

        private void StartAndDumpFile(string dumpFile)
        {
            Logger.Log(Path.GetFileName(dumpFile) + "  Started", Array.Empty<object>());
            Process process = Process.Start(dumpFile);
            Thread.Sleep(4);
            this.SuspendProcess(process.Id);
            Logger.Log("Suspending process...", Array.Empty<object>());
            bool flag = this.DumpProcess(process);
            if (flag)
            {
                Logger.Log(Path.GetFileName(dumpFile) + "  Dumped", Array.Empty<object>());
            }
            else
            {
                Logger.Log("process dump failed", Array.Empty<object>());
            }
        }

        private void fileDumpBtn_Click(object sender, EventArgs e)
        {
            this.ClearLog();
            Logger.Log("KsDumper v1.1 - By EquiFox", Array.Empty<object>());
            OpenFileDialog openFileDialog = new OpenFileDialog();
            openFileDialog.Filter = "Executable File (.exe)|*.exe";
            openFileDialog.Title = "File to dump";
            openFileDialog.RestoreDirectory = true;
            bool flag = openFileDialog.ShowDialog() == DialogResult.OK;
            if (flag)
            {
                string dumpFile = openFileDialog.FileName;
                this.StartAndDumpFile(dumpFile);
            }
        }

        private void hideSystemProcessBtn_Click(object sender, EventArgs e)
        {
            bool flag = !this.processList.SystemProcessesHidden;
            if (flag)
            {
                this.processList.HideSystemProcesses();
                this.hideSystemProcessBtn.Text = "Show System Processes";
            }
            else
            {
                this.processList.ShowSystemProcesses();
                this.hideSystemProcessBtn.Text = "Hide System Processes";
            }
        }

        private void refreshBtn_Click(object sender, EventArgs e)
        {
            this.LoadProcessList();
        }

        private void autoRefreshCheckBox_CheckedChanged(object sender, EventArgs e)
        {
            bool @checked = this.autoRefreshCheckBox.Checked;
            if (@checked)
            {
                bool flag = this.t == null;
                if (flag)
                {
                    this.t = new System.Windows.Forms.Timer();
                    this.t.Tick += this.T_Tick;
                    this.t.Interval = 100;
                    this.t.Start();
                }
                else
                {
                    this.t.Interval = 100;
                    this.t.Start();
                }
            }
            else
            {
                this.t.Stop();
            }
        }

        private void providerBtn_Click(object sender, EventArgs e)
        {
            KsDumperDriverInterface drv = KsDumperDriverInterface.OpenKsDumperDriver();

            drv.UnloadDriver();
            drv.Dispose();

            ProviderSelector prov = new ProviderSelector();

            prov.ShowDialog();

            StartDriver.Start();
        }
    }
}

```

`KsDumper11/DumperForm.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="contextMenuStrip1.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>17, 17</value>
  </metadata>
  <assembly alias="System.Drawing" name="System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
  <data name="appIcon1.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAYAAAByDd+UAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8
        YQUAAAAJcEhZcwAACxIAAAsSAdLdfvwAAASJSURBVEhL7ZVrUJRVGMdfK7WaJhomMvvApQkhLnKHhQV2
        WWFZYDF2YRWWkOW2EkoiQQVoENhFRYRABBHiXojg1BgOiMOUM6iTOCjkNFLhTE3f+NQ0xVD/p3N2jlAw
        CNjUJ39f9jn///95zp5333df6SH/OzYF9LwoV2Qt2SW8+DocHfbgiH0hJuxy0CYRrRPWUpjHMzzrkIOj
        vFc4K2OXSo87Z6PTNZ/IMRvDTrvJ3nE3upyy0e9ioA0iNo9LKW3gniXDs6yH9/IZfJaILY97JrICi4g8
        zBjQ5GKjkCW3DFz0yMBesZyHa26ZuCiWkkaDjbyXz3BPR5aQl2KjoKeC0xAQaMLNQDbAbKb1wpKC0vGC
        PB3T/iYyCGkernGPZ4QkmX1ofSD7gnyWPBUyaw2eFpYkhRnxXowZQyoTfpQbcUeZhhKDy8KlU6SSvTIZ
        42EZ6Gefp/7xW5bSI1xTZaKPZ3hWOBKfoUxFiTwJU9tM+FmbhSG+lxSqR8Oet4hqOkGxabjr7g4n0SOF
        G8g2KhHfRRjJEKmn8OgkzAhrHq5FJSCCZ1h2SptCtsKSnJ2xJS4Td1vbifLeJApme1kMdTSqS0uImjrn
        EJ+CmRAZvLkel4A72h1IM8SRD6vH9IkY1Ceg2dLEiE/Aaa7FGXCDZ2INZNIlYIp7QX7kudOEme5PiA4V
        E0VoUW1puodGhZr32Uk72v9AchKm9RE4YNRhNkWHc0Y9kVGPMJ5L1GMwKQ5VyTo07tRjiGs7mMczlmw8
        fterUfJqMn76tIfoQzZTzWbz3BJ0ClRXFRCd/Xhudt8uol2RKE7VISb9FXyQEYurZgNZ8VzadsyZtmOY
        1xlqWGdocdXEMjzLeoryMon4ySrZLF3IopMtJkmOmgYWrNpHlOALhZClbC0O5ERjMDeaWl+LRi/XzOFk
        lROF0ewYHLSEGEYvhB5h/bXsZClBy5xsMXuVOFmgZj90JDYLyUK+Gt/na/Alr3PZrV4YiR+Y9q3FFBTF
        YhPvzVWIG2S1FKoQVspue7GUDqrQVrwNn/G6VEHPFKtwuURNbzOti3nzNxKxx4b3iuWDURGKk+VKDPCa
        b3ZIgdsVCvx6RqJHuVamxFC5AnW8/tdUylHVEEZUFwi7YzI8URmEycMhKDwcjP3Mu1XD/sqOB5A9zxwL
        wlHR9mDUy9BSK8MvJ0IQ85EcHnUBuFEjwzvCllhdUSej63VyuNYHQ3uCZwPQJOy10eqH9tN++KbRFwU9
        Mlg3++LrJv+Fze7BtIoWX1xr9CGrU74oZD232/zQIuzV0e2B+l5XjHV4UNmIgh7r8sJEuzdKhb2EDm9U
        dHniJkm0rsOLys64YLx7K2qFfX/6XLC/1x/XOqbnlH2BeK7fDRO9Wxees+U464Hyc24Y/9yHnu2Z/E3F
        Zoz1OSNH2MvzhTN6Lvj9+e5g+2zigCsmzzsvvYzLcf5llA+44NZI82zSBR8cZ70rX9pBR/IcccToFVuM
        Dm9BnpBXzbAT3uC9lxxx+ZLTwpvnvlzfTE9eccAmsVwzX70Em8m/vVMf8h8iSX8BwCCUC3RVqvIAAAAA
        SUVORK5CYII=
</value>
  </data>
</root>
```

`KsDumper11/JsonSettings.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace KsDumper11
{
    public class JsonSettings
    {
        public bool closeDriverOnExit { get; set; }

        public bool enableAntiAntiDebuggerTools { get; set; }
    }
}

```

`KsDumper11/JsonSettingsManager.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;
using Newtonsoft.Json;
using Newtonsoft.Json.Bson;

namespace KsDumper11
{
    public class JsonSettingsManager
    {
        public JsonSettings JsonSettings { get; set; }

        private string settingsFilePath;
        public JsonSettingsManager()
        {
            settingsFilePath = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location) + @"\Settings.json";
            CreateOrLoadSettingsJson();
        }

        private void CreateOrLoadSettingsJson()
        {
            if (File.Exists(settingsFilePath))
            {
                // Load settings json
                string settingsJsonText = File.ReadAllText(settingsFilePath);
                JsonSettings = JsonConvert.DeserializeObject<JsonSettings>(settingsJsonText);
            }
            else
            {
                // Populate and save default settings json
                JsonSettings = new JsonSettings();
                JsonSettings.enableAntiAntiDebuggerTools = false;
                JsonSettings.closeDriverOnExit = false;

                string settingsJsonText = JsonConvert.SerializeObject(JsonSettings, Formatting.Indented);
                File.WriteAllText(settingsFilePath, settingsJsonText);
            }
        }

        public void Save()
        {
            string settingsJsonText = JsonConvert.SerializeObject(JsonSettings, Formatting.Indented);
            File.WriteAllText(settingsFilePath, settingsJsonText);
        }
    }
}

```

`KsDumper11/KsDumper11.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{7881B99D-0B5A-44E7-AF34-80A0ECFFD5DB}</ProjectGuid>
    <OutputType>WinExe</OutputType>
    <RootNamespace>KsDumper11</RootNamespace>
    <AssemblyName>KsDumper11</AssemblyName>
    <TargetFrameworkVersion>v4.8</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
    <Deterministic>true</Deterministic>
    <TargetFrameworkProfile />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x64'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\x64\Debug\</OutputPath>
    <DefineConstants>TRACE;DEBUG;WIN64</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <Prefer32Bit>true</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x64'">
    <OutputPath>bin\x64\Release\</OutputPath>
    <DefineConstants>TRACE;WIN64</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>x64</PlatformTarget>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <Prefer32Bit>true</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup>
    <ApplicationManifest>app.manifest</ApplicationManifest>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|AnyCPU'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\x86\Debug\</OutputPath>
    <DefineConstants>TRACE;DEBUG;WIN64</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>AnyCPU</PlatformTarget>
    <LangVersion>7.3</LangVersion>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <Prefer32Bit>true</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|AnyCPU'">
    <OutputPath>bin\x86\Release\</OutputPath>
    <DefineConstants>TRACE;WIN64</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>AnyCPU</PlatformTarget>
    <LangVersion>7.3</LangVersion>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <Prefer32Bit>true</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x86'">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\x86\Debug\</OutputPath>
    <DefineConstants>TRACE;DEBUG;WIN64</DefineConstants>
    <DebugType>full</DebugType>
    <PlatformTarget>x86</PlatformTarget>
    <LangVersion>7.3</LangVersion>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <Prefer32Bit>true</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x86'">
    <OutputPath>bin\x86\Release\</OutputPath>
    <DefineConstants>TRACE;WIN64</DefineConstants>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>x86</PlatformTarget>
    <LangVersion>7.3</LangVersion>
    <ErrorReport>prompt</ErrorReport>
    <CodeAnalysisRuleSet>MinimumRecommendedRules.ruleset</CodeAnalysisRuleSet>
    <Prefer32Bit>true</Prefer32Bit>
  </PropertyGroup>
  <PropertyGroup>
    <ApplicationIcon>Default.ico</ApplicationIcon>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="Newtonsoft.Json, Version=13.0.0.0, Culture=neutral, PublicKeyToken=30ad4fe6b2a6aeed, processorArchitecture=MSIL">
      <HintPath>..\packages\Newtonsoft.Json.13.0.3\lib\net45\Newtonsoft.Json.dll</HintPath>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Deployment" />
    <Reference Include="System.Drawing" />
    <Reference Include="System.Net.Http" />
    <Reference Include="System.Windows.Forms" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="JsonSettings.cs" />
    <Compile Include="JsonSettingsManager.cs" />
    <Compile Include="LabelDrawer.cs" />
    <Compile Include="ProviderSelector.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Include="ProviderSelector.Designer.cs">
      <DependentUpon>ProviderSelector.cs</DependentUpon>
    </Compile>
    <Compile Include="SnifferBypass.cs" />
    <Compile Include="StartDriver.cs" />
    <Compile Include="TriggerForm.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Include="TriggerForm.Designer.cs">
      <DependentUpon>TriggerForm.cs</DependentUpon>
    </Compile>
    <Compile Include="DumperForm.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Include="DumperForm.Designer.cs">
      <DependentUpon>DumperForm.cs</DependentUpon>
    </Compile>
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="Properties\Resources.Designer.cs">
      <AutoGen>True</AutoGen>
      <DesignTime>True</DesignTime>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
    <Compile Include="Trigger.cs">
      <SubType>UserControl</SubType>
    </Compile>
    <Compile Include="Trigger.Designer.cs">
      <DependentUpon>Trigger.cs</DependentUpon>
    </Compile>
    <EmbeddedResource Include="ProviderSelector.resx">
      <DependentUpon>ProviderSelector.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="TriggerForm.resx">
      <DependentUpon>TriggerForm.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="DumperForm.resx">
      <DependentUpon>DumperForm.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="Properties\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
    </EmbeddedResource>
    <EmbeddedResource Include="Trigger.resx">
      <DependentUpon>Trigger.cs</DependentUpon>
    </EmbeddedResource>
    <None Include="app.manifest" />
    <None Include="Driver\KsDumperDriver.sys" />
    <None Include="Driver\ManualLoader.bat" />
    <None Include="packages.config" />
    <None Include="Properties\Settings.settings">
      <Generator>SettingsSingleFileGenerator</Generator>
      <LastGenOutput>Settings.Designer.cs</LastGenOutput>
    </None>
    <Compile Include="Properties\Settings.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Settings.settings</DependentUpon>
      <DesignTimeSharedInput>True</DesignTimeSharedInput>
    </Compile>
  </ItemGroup>
  <ItemGroup>
    <Content Include="Default.ico" />
    <Content Include="Driver\drv64.dll" />
    <Content Include="Driver\kdu.exe" />
    <Content Include="Driver\Taigei64.dll" />
    <None Include="icons8-crossed-axes-100.png" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\DarkControls\DarkControls.csproj">
      <Project>{66c94acb-63c7-42a3-9d83-a3801ced4f1c}</Project>
      <Name>DarkControls</Name>
    </ProjectReference>
    <ProjectReference Include="..\DriverInterface\DriverInterface.csproj">
      <Project>{6f8b2a35-060d-4eb1-a6ba-a3057179304b}</Project>
      <Name>DriverInterface</Name>
    </ProjectReference>
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
</Project>
```

`KsDumper11/LabelDrawer.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using static System.Windows.Forms.VisualStyles.VisualStyleElement.Button;

namespace KsDumper11
{
    public struct LabelInfo
    {
        public Font Font;
        public Point Location;
        public string Text;
        public string Name;
        public bool Visible;
    }

    public class LabelDrawer
    {
        private Form ParentForm;
        public LabelInfo[] labelInfos;

        public LabelDrawer(Form parentFrm)
        {
            ParentForm = parentFrm;
            ParentForm.Paint += ParentForm_Paint;

            List<Control> labelsToRemove = new List<Control>();
            List<LabelInfo> infos = new List<LabelInfo>();

            foreach (Control ctrl in ParentForm.Controls)
            {
                if (ctrl is System.Windows.Forms.Label)
                {
                    LabelInfo labelInfo = new LabelInfo();
                    labelInfo.Text = ctrl.Text;
                    labelInfo.Font = ctrl.Font;
                    labelInfo.Location = ctrl.Location;
                    labelInfo.Name = ctrl.Name;
                    labelInfo.Visible = ctrl.Visible;

                    infos.Add(labelInfo);
                    labelsToRemove.Add(ctrl);
                    continue;
                }
            }

            labelInfos = infos.ToArray();

            foreach (Control ctrl in labelsToRemove)
            {
                ParentForm.Controls.Remove(ctrl);
                ctrl.Dispose();
            }
        }

        private void ParentForm_Paint(object sender, PaintEventArgs e)
        {
            foreach (LabelInfo labelInfo in labelInfos)
            {
                if (labelInfo.Visible)
                {
                    PointF location = new PointF(labelInfo.Location.X, (labelInfo.Location.Y));

                    // Draw the text on the form
                    e.Graphics.DrawString(labelInfo.Text, labelInfo.Font, Brushes.Silver, location);
                }
            }
        }
    }
}

```

`KsDumper11/ProcessDumper.cs`:

```cs
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using KsDumper11.Driver;
using KsDumper11.PE;
using KsDumper11.Utility;

namespace KsDumper11
{
	// Token: 0x02000003 RID: 3
	public class ProcessDumper
	{
		// Token: 0x0600002E RID: 46 RVA: 0x000038AD File Offset: 0x00001AAD
		public ProcessDumper(DriverInterface kernelDriver)
		{
			this.kernelDriver = kernelDriver;
		}

		// Token: 0x0600002F RID: 47 RVA: 0x000038C0 File Offset: 0x00001AC0
		private static bool IsWin64Emulator(Process process)
		{
			bool flag = Environment.OSVersion.Version.Major > 5 || (Environment.OSVersion.Version.Major == 5 && Environment.OSVersion.Version.Minor >= 1);
			bool retVal;
			return flag && (ProcessDumper.NativeMethods.IsWow64Process(process.Handle, out retVal) && retVal);
		}

		// Token: 0x06000030 RID: 48 RVA: 0x0000392C File Offset: 0x00001B2C
		public bool DumpProcess(Process processSummary, out PEFile outputFile)
		{
			IntPtr basePointer = processSummary.MainModule.BaseAddress;
			NativePEStructs.IMAGE_DOS_HEADER dosHeader = this.ReadProcessStruct<NativePEStructs.IMAGE_DOS_HEADER>(processSummary.Id, basePointer);
			outputFile = null;
			Logger.SkipLine();
			Logger.Log("Targeting Process: {0} ({1})", new object[] { processSummary.ProcessName, processSummary.Id });
			bool isValid = dosHeader.IsValid;
			if (isValid)
			{
				IntPtr peHeaderPointer = basePointer + dosHeader.e_lfanew;
				Logger.Log("PE Header Found: 0x{0:x8}", new object[] { peHeaderPointer.ToInt64() });
				IntPtr dosStubPointer = basePointer + Marshal.SizeOf<NativePEStructs.IMAGE_DOS_HEADER>();
				byte[] dosStub = this.ReadProcessBytes(processSummary.Id, dosStubPointer, dosHeader.e_lfanew - Marshal.SizeOf<NativePEStructs.IMAGE_DOS_HEADER>());
				bool flag = !ProcessDumper.IsWin64Emulator(processSummary);
				PEFile peFile;
				if (flag)
				{
					peFile = this.Dump64BitPE(processSummary.Id, dosHeader, dosStub, peHeaderPointer);
				}
				else
				{
					peFile = this.Dump32BitPE(processSummary.Id, dosHeader, dosStub, peHeaderPointer);
				}
				bool flag2 = peFile != null;
				if (flag2)
				{
					IntPtr sectionHeaderPointer = peHeaderPointer + peFile.GetFirstSectionHeaderOffset();
					Logger.Log("Header is valid ({0}) !", new object[] { peFile.Type });
					Logger.Log("Parsing {0} Sections...", new object[] { peFile.Sections.Length });
					for (int i = 0; i < peFile.Sections.Length; i++)
					{
						NativePEStructs.IMAGE_SECTION_HEADER sectionHeader = this.ReadProcessStruct<NativePEStructs.IMAGE_SECTION_HEADER>(processSummary.Id, sectionHeaderPointer);
						peFile.Sections[i] = new PESection
						{
							Header = PESection.PESectionHeader.FromNativeStruct(sectionHeader),
							InitialSize = (int)sectionHeader.VirtualSize
						};
						this.ReadSectionContent(processSummary.Id, new IntPtr(basePointer.ToInt64() + (long)((ulong)sectionHeader.VirtualAddress)), peFile.Sections[i]);
						sectionHeaderPointer += Marshal.SizeOf<NativePEStructs.IMAGE_SECTION_HEADER>();
					}
					Logger.Log("Aligning Sections...", Array.Empty<object>());
					peFile.AlignSectionHeaders();
					Logger.Log("Fixing PE Header...", Array.Empty<object>());
					peFile.FixPEHeader();
					Logger.Log("Dump Completed !", Array.Empty<object>());
					outputFile = peFile;
					return true;
				}
				Logger.Log("Bad PE Header !", Array.Empty<object>());
			}
			return false;
		}

		// Token: 0x06000031 RID: 49 RVA: 0x00003B80 File Offset: 0x00001D80
		public bool DumpProcess(ProcessSummary processSummary, out PEFile outputFile)
		{
			IntPtr basePointer = (IntPtr)((long)processSummary.MainModuleBase);
			NativePEStructs.IMAGE_DOS_HEADER dosHeader = this.ReadProcessStruct<NativePEStructs.IMAGE_DOS_HEADER>(processSummary.ProcessId, basePointer);
			outputFile = null;
			Logger.SkipLine();
			Logger.Log("Targeting Process: {0} ({1})", new object[] { processSummary.ProcessName, processSummary.ProcessId });
			bool isValid = dosHeader.IsValid;
			if (isValid)
			{
				IntPtr peHeaderPointer = basePointer + dosHeader.e_lfanew;
				Logger.Log("PE Header Found: 0x{0:x8}", new object[] { peHeaderPointer.ToInt64() });
				IntPtr dosStubPointer = basePointer + Marshal.SizeOf<NativePEStructs.IMAGE_DOS_HEADER>();
				byte[] dosStub = this.ReadProcessBytes(processSummary.ProcessId, dosStubPointer, dosHeader.e_lfanew - Marshal.SizeOf<NativePEStructs.IMAGE_DOS_HEADER>());
				bool flag = !processSummary.IsWOW64;
				PEFile peFile;
				if (flag)
				{
					peFile = this.Dump64BitPE(processSummary.ProcessId, dosHeader, dosStub, peHeaderPointer);
				}
				else
				{
					peFile = this.Dump32BitPE(processSummary.ProcessId, dosHeader, dosStub, peHeaderPointer);
				}
				bool flag2 = peFile != null;
				if (flag2)
				{
					IntPtr sectionHeaderPointer = peHeaderPointer + peFile.GetFirstSectionHeaderOffset();
					Logger.Log("Header is valid ({0}) !", new object[] { peFile.Type });
					Logger.Log("Parsing {0} Sections...", new object[] { peFile.Sections.Length });
					for (int i = 0; i < peFile.Sections.Length; i++)
					{
						NativePEStructs.IMAGE_SECTION_HEADER sectionHeader = this.ReadProcessStruct<NativePEStructs.IMAGE_SECTION_HEADER>(processSummary.ProcessId, sectionHeaderPointer);
						peFile.Sections[i] = new PESection
						{
							Header = PESection.PESectionHeader.FromNativeStruct(sectionHeader),
							InitialSize = (int)sectionHeader.VirtualSize
						};
						this.ReadSectionContent(processSummary.ProcessId, new IntPtr(basePointer.ToInt64() + (long)((ulong)sectionHeader.VirtualAddress)), peFile.Sections[i]);
						sectionHeaderPointer += Marshal.SizeOf<NativePEStructs.IMAGE_SECTION_HEADER>();
					}
					Logger.Log("Aligning Sections...", Array.Empty<object>());
					peFile.AlignSectionHeaders();
					Logger.Log("Fixing PE Header...", Array.Empty<object>());
					peFile.FixPEHeader();
					Logger.Log("Dump Completed !", Array.Empty<object>());
					outputFile = peFile;
					return true;
				}
				Logger.Log("Bad PE Header !", Array.Empty<object>());
			}
			return false;
		}

		// Token: 0x06000032 RID: 50 RVA: 0x00003DD4 File Offset: 0x00001FD4
		private PEFile Dump64BitPE(int processId, NativePEStructs.IMAGE_DOS_HEADER dosHeader, byte[] dosStub, IntPtr peHeaderPointer)
		{
			NativePEStructs.IMAGE_NT_HEADERS64 peHeader = this.ReadProcessStruct<NativePEStructs.IMAGE_NT_HEADERS64>(processId, peHeaderPointer);
			bool isValid = peHeader.IsValid;
			PEFile pefile;
			if (isValid)
			{
				pefile = new PE64File(dosHeader, peHeader, dosStub);
			}
			else
			{
				pefile = null;
			}
			return pefile;
		}

		// Token: 0x06000033 RID: 51 RVA: 0x00003E08 File Offset: 0x00002008
		private PEFile Dump32BitPE(int processId, NativePEStructs.IMAGE_DOS_HEADER dosHeader, byte[] dosStub, IntPtr peHeaderPointer)
		{
			NativePEStructs.IMAGE_NT_HEADERS32 peHeader = this.ReadProcessStruct<NativePEStructs.IMAGE_NT_HEADERS32>(processId, peHeaderPointer);
			bool isValid = peHeader.IsValid;
			PEFile pefile;
			if (isValid)
			{
				pefile = new PE32File(dosHeader, peHeader, dosStub);
			}
			else
			{
				pefile = null;
			}
			return pefile;
		}

		// Token: 0x06000034 RID: 52 RVA: 0x00003E3C File Offset: 0x0000203C
		private T ReadProcessStruct<T>(int processId, IntPtr address) where T : struct
		{
			IntPtr buffer = MarshalUtility.AllocEmptyStruct<T>();
			bool flag = this.kernelDriver.CopyVirtualMemory(processId, address, buffer, Marshal.SizeOf<T>());
			T t;
			if (flag)
			{
				t = MarshalUtility.GetStructFromMemory<T>(buffer, true);
			}
			else
			{
				t = default(T);
			}
			return t;
		}

		// Token: 0x06000035 RID: 53 RVA: 0x00003E80 File Offset: 0x00002080
		private bool ReadSectionContent(int processId, IntPtr sectionPointer, PESection section)
		{
			int readSize = section.InitialSize;
			bool flag = sectionPointer == IntPtr.Zero || readSize == 0;
			bool flag2;
			if (flag)
			{
				flag2 = true;
			}
			else
			{
				bool flag3 = readSize <= 100;
				if (flag3)
				{
					section.DataSize = readSize;
					section.Content = this.ReadProcessBytes(processId, sectionPointer, readSize);
					flag2 = true;
				}
				else
				{
					this.CalculateRealSectionSize(processId, sectionPointer, section);
					bool flag4 = section.DataSize != 0;
					if (flag4)
					{
						section.Content = this.ReadProcessBytes(processId, sectionPointer, section.DataSize);
						flag2 = true;
					}
					else
					{
						flag2 = false;
					}
				}
			}
			return flag2;
		}

		// Token: 0x06000036 RID: 54 RVA: 0x00003F18 File Offset: 0x00002118
		private byte[] ReadProcessBytes(int processId, IntPtr address, int size)
		{
			IntPtr unmanagedBytePointer = MarshalUtility.AllocZeroFilled(size);
			this.kernelDriver.CopyVirtualMemory(processId, address, unmanagedBytePointer, size);
			byte[] buffer = new byte[size];
			Marshal.Copy(unmanagedBytePointer, buffer, 0, size);
			Marshal.FreeHGlobal(unmanagedBytePointer);
			return buffer;
		}

		// Token: 0x06000037 RID: 55 RVA: 0x00003F5C File Offset: 0x0000215C
		private void CalculateRealSectionSize(int processId, IntPtr sectionPointer, PESection section)
		{
			int readSize = section.InitialSize;
			int currentReadSize = readSize % 100;
			bool flag = currentReadSize == 0;
			if (flag)
			{
				currentReadSize = 100;
			}
			IntPtr currentOffset = sectionPointer + readSize - currentReadSize;
			while (currentOffset.ToInt64() >= sectionPointer.ToInt64())
			{
				byte[] buffer = this.ReadProcessBytes(processId, currentOffset, currentReadSize);
				int codeByteCount = this.GetInstructionByteCount(buffer);
				bool flag2 = codeByteCount != 0;
				if (flag2)
				{
					currentOffset += codeByteCount;
					bool flag3 = sectionPointer.ToInt64() < currentOffset.ToInt64();
					if (flag3)
					{
						section.DataSize = (int)(currentOffset.ToInt64() - sectionPointer.ToInt64());
						section.DataSize += 4;
						bool flag4 = section.InitialSize < section.DataSize;
						if (flag4)
						{
							section.DataSize = section.InitialSize;
						}
					}
					break;
				}
				currentReadSize = 100;
				currentOffset -= currentReadSize;
			}
		}

		// Token: 0x06000038 RID: 56 RVA: 0x0000404C File Offset: 0x0000224C
		private int GetInstructionByteCount(byte[] dataBlock)
		{
			for (int i = dataBlock.Length - 1; i >= 0; i--)
			{
				bool flag = dataBlock[i] > 0;
				if (flag)
				{
					return i + 1;
				}
			}
			return 0;
		}

		// Token: 0x0400002B RID: 43
		private DriverInterface kernelDriver;

		// Token: 0x02000023 RID: 35
		internal static class NativeMethods
		{
			// Token: 0x060000EF RID: 239
			[DllImport("kernel32.dll", SetLastError = true)]
			[return: MarshalAs(UnmanagedType.Bool)]
			internal static extern bool IsWow64Process([In] IntPtr process, out bool wow64Process);
		}
	}
}

```

`KsDumper11/ProcessSummary.cs`:

```cs
using System;
using System.Diagnostics;
using System.IO;
using System.Runtime.CompilerServices;
using System.Text;
using KsDumper11.Driver;
using KsDumper11.Utility;

namespace KsDumper11
{
	// Token: 0x02000004 RID: 4
	public class ProcessSummary
	{
		// Token: 0x17000002 RID: 2
		// (get) Token: 0x06000039 RID: 57 RVA: 0x00004089 File Offset: 0x00002289
		// (set) Token: 0x0600003A RID: 58 RVA: 0x00004091 File Offset: 0x00002291
		public int ProcessId { get; set; }

        // Token: 0x17000003 RID: 3
        // (get) Token: 0x0600003B RID: 59 RVA: 0x0000409A File Offset: 0x0000229A
        // (set) Token: 0x0600003C RID: 60 RVA: 0x000040A2 File Offset: 0x000022A2
        public string ProcessName { get; set; }

		// Token: 0x17000004 RID: 4
		// (get) Token: 0x0600003D RID: 61 RVA: 0x000040AB File Offset: 0x000022AB
		// (set) Token: 0x0600003E RID: 62 RVA: 0x000040B3 File Offset: 0x000022B3
		public ulong MainModuleBase  { get; set; }

        // Token: 0x17000005 RID: 5
        // (get) Token: 0x0600003F RID: 63 RVA: 0x000040BC File Offset: 0x000022BC
        // (set) Token: 0x06000040 RID: 64 RVA: 0x000040C4 File Offset: 0x000022C4
        public string MainModuleFileName { get; set; }

        // Token: 0x17000006 RID: 6
        // (get) Token: 0x06000041 RID: 65 RVA: 0x000040CD File Offset: 0x000022CD
        // (set) Token: 0x06000042 RID: 66 RVA: 0x000040D5 File Offset: 0x000022D5
        public uint MainModuleImageSize { get; set; }

        // Token: 0x17000007 RID: 7
        // (get) Token: 0x06000043 RID: 67 RVA: 0x000040DE File Offset: 0x000022DE
        // (set) Token: 0x06000044 RID: 68 RVA: 0x000040E6 File Offset: 0x000022E6
        public ulong MainModuleEntryPoint { get; set; }

        // Token: 0x17000008 RID: 8
        // (get) Token: 0x06000045 RID: 69 RVA: 0x000040EF File Offset: 0x000022EF
        // (set) Token: 0x06000046 RID: 70 RVA: 0x000040F7 File Offset: 0x000022F7
        public bool IsWOW64 { get; set; }

        // Token: 0x06000047 RID: 71 RVA: 0x00004100 File Offset: 0x00002300
        public static ProcessSummary ProcessSummaryFromID(DriverInterface driver, string processName)
		{
			ProcessSummary result = null;
			ProcessSummary[] processes;
			driver.GetProcessSummaryList(out processes);
			bool flag = processes != null;
			if (flag)
			{
				foreach (ProcessSummary process in processes)
				{
					bool flag2 = process.ProcessName.ToLower().Contains(processName.ToLower());
					if (flag2)
					{
						Logger.Log(process.ProcessName + "      " + processName, Array.Empty<object>());
						return process;
					}
				}
			}
			return result;
		}

		// Token: 0x06000048 RID: 72 RVA: 0x0000418C File Offset: 0x0000238C
		private ProcessSummary(int processId, ulong mainModuleBase, string mainModuleFileName, uint mainModuleImageSize, ulong mainModuleEntryPoint, bool isWOW64)
		{
			this.ProcessId = processId;
			this.MainModuleBase = mainModuleBase;
			this.MainModuleFileName = this.FixFileName(mainModuleFileName);
			this.MainModuleImageSize = mainModuleImageSize;
			this.MainModuleEntryPoint = mainModuleEntryPoint;
			this.ProcessName = Path.GetFileName(this.MainModuleFileName);
			this.IsWOW64 = isWOW64;
		}

		// Token: 0x06000049 RID: 73 RVA: 0x000041EC File Offset: 0x000023EC
		private string FixFileName(string fileName)
		{
			bool flag = fileName.StartsWith("\\");
			string text;
			if (flag)
			{
				text = fileName;
			}
			else
			{
				StringBuilder sb = new StringBuilder(256);
				int length = WinApi.GetLongPathName(fileName, sb, sb.Capacity);
				bool flag2 = length > sb.Capacity;
				if (flag2)
				{
					sb.Capacity = length;
					length = WinApi.GetLongPathName(fileName, sb, sb.Capacity);
				}
				text = sb.ToString();
			}
			return text;
		}

		// Token: 0x0600004A RID: 74 RVA: 0x00004258 File Offset: 0x00002458
		public static ProcessSummary FromStream(BinaryReader reader)
		{
			return new ProcessSummary(reader.ReadInt32(), reader.ReadUInt64(), Encoding.Unicode.GetString(reader.ReadBytes(512)).Split(new char[1])[0], reader.ReadUInt32(), reader.ReadUInt64(), reader.ReadBoolean());
		}
	}
}

```

`KsDumper11/Program.cs`:

```cs
using System;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Windows.Forms;
using KsDumper11.Driver;

namespace KsDumper11
{
	public class Program
	{
		static string exeName = "KsDumper11.exe";

		public static bool ProviderIsClosing = false;

        static JsonSettingsManager settingsManager;

        static void runSnifferBypass()
		{
			string asmPath = Assembly.GetExecutingAssembly().Location;
			string directory = Path.GetDirectoryName(asmPath);

            string fileName = Path.GetFileName(asmPath);
			string newFile = SnifferBypass.GenerateRandomString(12) + ".exe";
			string newFileName = Path.Combine(directory, newFile);
			//Debugger.Break();
			if (fileName == exeName)
			{
                // Rename the current file to the specified new file name and execute it
                ProcessStartInfo renameAndExecuteProcessInfo = new ProcessStartInfo();
                renameAndExecuteProcessInfo.FileName = "cmd.exe";
                renameAndExecuteProcessInfo.Arguments = $"/c timeout 3 > NUL && ren \"{asmPath}\" \"{newFile}\" && \"{newFileName}\"";
                renameAndExecuteProcessInfo.UseShellExecute = true;
				renameAndExecuteProcessInfo.CreateNoWindow = true;
				renameAndExecuteProcessInfo.WindowStyle = ProcessWindowStyle.Hidden;

				Process renameAndExecuteProcess = new Process();
                renameAndExecuteProcess.StartInfo = renameAndExecuteProcessInfo;
                renameAndExecuteProcess.Start();

				Environment.Exit(0);
            }
			else
			{
                Application.ApplicationExit += Application_ApplicationExit;
			}	
		}

        private static void Application_ApplicationExit(object sender, EventArgs e)
        {
			if (!ProviderIsClosing)
			{
				string asmPath = Assembly.GetExecutingAssembly().Location;
				string directory = Path.GetDirectoryName(asmPath);

				string fileName = Path.GetFileName(asmPath);
				string newFile = SnifferBypass.GenerateRandomString(12) + ".exe";
				string newFileName = Path.Combine(directory, exeName);

				if (fileName != exeName)
				{
					ProcessStartInfo renameAndExecuteProcessInfo = new ProcessStartInfo();
					renameAndExecuteProcessInfo.FileName = "cmd.exe";
					renameAndExecuteProcessInfo.Arguments = $"/c timeout 2 > NUL && ren \"{asmPath}\" \"{exeName}\"";
					renameAndExecuteProcessInfo.UseShellExecute = false;
					renameAndExecuteProcessInfo.CreateNoWindow = true;
					renameAndExecuteProcessInfo.WindowStyle = ProcessWindowStyle.Hidden;

					Process renameAndExecuteProcess = new Process();
					renameAndExecuteProcess.StartInfo = renameAndExecuteProcessInfo;
					renameAndExecuteProcess.Start();
				}
			}
			else
			{
				ProviderIsClosing = false;
			}
        }

        [STAThread]
		private static void Main()
		{
            settingsManager = new JsonSettingsManager();

			if (settingsManager.JsonSettings.enableAntiAntiDebuggerTools)
			{
				runSnifferBypass();
			}

            KduSelfExtract.DisableDriverBlockList();

			KduSelfExtract.Extract();

            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);

            bool driverOpen = KsDumperDriverInterface.IsDriverOpen("\\\\.\\KsDumper");
			//Debugger.Break();
            if (!driverOpen)
			{
                if (!File.Exists(KduSelfExtract.AssemblyDirectory + @"\\Providers.json"))
				{
					// Run the selector here to populate the providers and set a default provider. 
					Application.Run(new ProviderSelector());
                    Application.Run(new DumperForm());
                }
				else
				{
					KduWrapper wr = new KduWrapper(KduSelfExtract.AssemblyDirectory + @"\Driver\kdu.exe");
					wr.LoadProviders();

					if (wr.DefaultProvider != -1)
					{
						wr.Start();

						if (KsDumperDriverInterface.IsDriverOpen("\\\\.\\KsDumper"))
						{
							Application.Run(new DumperForm());
						}
						else
						{
							Environment.Exit(0);
						}
					}
					else
					{
                        // Run the selector here to populate the providers and set a default provider. 
                        Application.Run(new ProviderSelector());

						if (KsDumperDriverInterface.IsDriverOpen("\\\\.\\KsDumper"))
						{
							Application.Run(new DumperForm());
						}
						else
						{
							Environment.Exit(0);
						}
                    }
                }
            }
			else
			{
                Application.Run(new DumperForm());
                Environment.Exit(0);
            }
		}
	}
}

```

`KsDumper11/Properties/AssemblyInfo.cs`:

```cs
using System;
using System.Diagnostics;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Versioning;

[assembly: AssemblyVersion("1.3.4")]
[assembly: AssemblyTitle("KsDumper 11")]
[assembly: AssemblyDescription("Dump processes from kernel space!")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("Codeon Inc")]
[assembly: AssemblyProduct("KsDumper")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: ComVisible(false)]
[assembly: Guid("7881b99d-0b5a-44e7-af34-80a0ecffd5db")]
[assembly: AssemblyFileVersion("1.3.4")]

```

`KsDumper11/Properties/Resources.Designer.cs`:

```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace KsDumper11.Properties {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("KsDumper11.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Looks up a localized resource of type System.Drawing.Bitmap.
        /// </summary>
        internal static System.Drawing.Bitmap icons8_crossed_axes_100 {
            get {
                object obj = ResourceManager.GetObject("icons8_crossed_axes_100", resourceCulture);
                return ((System.Drawing.Bitmap)(obj));
            }
        }
    }
}

```

`KsDumper11/Properties/Resources.cs`:

```cs
using System;
using System.CodeDom.Compiler;
using System.ComponentModel;
using System.Diagnostics;
using System.Drawing;
using System.Globalization;
using System.Resources;
using System.Runtime.CompilerServices;

namespace KsDumperClient.Properties
{
	// Token: 0x02000006 RID: 6
	[GeneratedCode("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
	[DebuggerNonUserCode]
	[CompilerGenerated]
	internal class Resources
	{
		// Token: 0x0600004D RID: 77 RVA: 0x00004406 File Offset: 0x00002606
		internal Resources()
		{
		}

		// Token: 0x17000009 RID: 9
		// (get) Token: 0x0600004E RID: 78 RVA: 0x00004410 File Offset: 0x00002610
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		internal static ResourceManager ResourceManager
		{
			get
			{
				bool flag = Resources.resourceMan == null;
				if (flag)
				{
					ResourceManager temp = new ResourceManager("KsDumperClient.Properties.Resources", typeof(Resources).Assembly);
					Resources.resourceMan = temp;
				}
				return Resources.resourceMan;
			}
		}

		// Token: 0x1700000A RID: 10
		// (get) Token: 0x0600004F RID: 79 RVA: 0x00004458 File Offset: 0x00002658
		// (set) Token: 0x06000050 RID: 80 RVA: 0x0000446F File Offset: 0x0000266F
		[EditorBrowsable(EditorBrowsableState.Advanced)]
		internal static CultureInfo Culture
		{
			get
			{
				return Resources.resourceCulture;
			}
			set
			{
				Resources.resourceCulture = value;
			}
		}

		// Token: 0x1700000B RID: 11
		// (get) Token: 0x06000051 RID: 81 RVA: 0x00004478 File Offset: 0x00002678
		internal static Bitmap icons8_crossed_axes_100
		{
			get
			{
				object obj = Resources.ResourceManager.GetObject("icons8_crossed_axes_100", Resources.resourceCulture);
				return (Bitmap)obj;
			}
		}

		// Token: 0x04000033 RID: 51
		private static ResourceManager resourceMan;

		// Token: 0x04000034 RID: 52
		private static CultureInfo resourceCulture;
	}
}

```

`KsDumper11/Properties/Resources.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <assembly alias="System.Windows.Forms" name="System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />
  <data name="icons8_crossed_axes_100" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\icons8-crossed-axes-100.png;System.Drawing.Bitmap, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
</root>
```

`KsDumper11/Properties/Settings.Designer.cs`:

```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace KsDumper11.Properties {
    
    
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "17.8.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase {
        
        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
        
        public static Settings Default {
            get {
                return defaultInstance;
            }
        }
    }
}

```

`KsDumper11/Properties/Settings.settings`:

```settings
<?xml version='1.0' encoding='utf-8'?>
<SettingsFile xmlns="http://schemas.microsoft.com/VisualStudio/2004/01/settings" CurrentProfile="(Default)">
  <Profiles />
  <Settings />
</SettingsFile>
```

`KsDumper11/ProviderSelector.Designer.cs`:

```cs
namespace KsDumper11
{
    partial class ProviderSelector
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.components = new System.ComponentModel.Container();
            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(ProviderSelector));
            this.label1 = new System.Windows.Forms.Label();
            this.label2 = new System.Windows.Forms.Label();
            this.label3 = new System.Windows.Forms.Label();
            this.label4 = new System.Windows.Forms.Label();
            this.label5 = new System.Windows.Forms.Label();
            this.label6 = new System.Windows.Forms.Label();
            this.label7 = new System.Windows.Forms.Label();
            this.driverLoadedLbl = new System.Windows.Forms.Label();
            this.driverLoadedLblTimer = new System.Windows.Forms.Timer(this.components);
            this.label8 = new System.Windows.Forms.Label();
            this.defaultProviderIDBox = new DarkControls.Controls.DarkTextBox();
            this.setDefaultProviderBtn = new DarkControls.Controls.DarkButton();
            this.testProviderBtn = new DarkControls.Controls.DarkButton();
            this.shellcodeMaskBox = new DarkControls.Controls.DarkTextBox();
            this.driverWhqlSignedBox = new DarkControls.Controls.DarkCheckBox();
            this.minWinBuildBox = new DarkControls.Controls.DarkTextBox();
            this.maxWinBuildBox = new DarkControls.Controls.DarkTextBox();
            this.signerNameBox = new DarkControls.Controls.DarkTextBox();
            this.deviceNameBox = new DarkControls.Controls.DarkTextBox();
            this.driverNameBox = new DarkControls.Controls.DarkTextBox();
            this.providerExtraInfoBox = new DarkControls.Controls.DarkTextBox();
            this.providerList = new DarkControls.Controls.DarkListView();
            this.provIdCol = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
            this.provNameCol = ((System.Windows.Forms.ColumnHeader)(new System.Windows.Forms.ColumnHeader()));
            this.appIcon1 = new DarkControls.Controls.AppIcon();
            this.titleLbl = new DarkControls.Controls.TransparentLabel();
            this.closeBtn = new DarkControls.Controls.WindowsDefaultTitleBarButton();
            this.wipeSettingsBtn = new DarkControls.Controls.DarkButton();
            ((System.ComponentModel.ISupportInitialize)(this.appIcon1)).BeginInit();
            this.SuspendLayout();
            // 
            // label1
            // 
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(406, 338);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(94, 13);
            this.label1.TabIndex = 12;
            this.label1.Text = "Provider Extra Info";
            // 
            // label2
            // 
            this.label2.AutoSize = true;
            this.label2.Location = new System.Drawing.Point(406, 33);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(66, 13);
            this.label2.TabIndex = 14;
            this.label2.Text = "Driver Name";
            // 
            // label3
            // 
            this.label3.AutoSize = true;
            this.label3.Location = new System.Drawing.Point(406, 72);
            this.label3.Name = "label3";
            this.label3.Size = new System.Drawing.Size(72, 13);
            this.label3.TabIndex = 16;
            this.label3.Text = "Device Name";
            // 
            // label4
            // 
            this.label4.AutoSize = true;
            this.label4.Location = new System.Drawing.Point(406, 113);
            this.label4.Name = "label4";
            this.label4.Size = new System.Drawing.Size(68, 13);
            this.label4.TabIndex = 18;
            this.label4.Text = "Signer Name";
            // 
            // label5
            // 
            this.label5.AutoSize = true;
            this.label5.Location = new System.Drawing.Point(406, 196);
            this.label5.Name = "label5";
            this.label5.Size = new System.Drawing.Size(120, 13);
            this.label5.TabIndex = 22;
            this.label5.Text = "Minimum Windows build";
            // 
            // label6
            // 
            this.label6.AutoSize = true;
            this.label6.Location = new System.Drawing.Point(406, 155);
            this.label6.Name = "label6";
            this.label6.Size = new System.Drawing.Size(123, 13);
            this.label6.TabIndex = 20;
            this.label6.Text = "Maximum Windows build";
            // 
            // label7
            // 
            this.label7.AutoSize = true;
            this.label7.Location = new System.Drawing.Point(406, 241);
            this.label7.Name = "label7";
            this.label7.Size = new System.Drawing.Size(120, 13);
            this.label7.TabIndex = 25;
            this.label7.Text = "Shellcode support mask";
            // 
            // driverLoadedLbl
            // 
            this.driverLoadedLbl.AutoSize = true;
            this.driverLoadedLbl.Font = new System.Drawing.Font("Microsoft Sans Serif", 14F);
            this.driverLoadedLbl.Location = new System.Drawing.Point(81, 440);
            this.driverLoadedLbl.Name = "driverLoadedLbl";
            this.driverLoadedLbl.Size = new System.Drawing.Size(133, 24);
            this.driverLoadedLbl.TabIndex = 27;
            this.driverLoadedLbl.Text = "Driver Loaded!";
            this.driverLoadedLbl.Visible = false;
            // 
            // driverLoadedLblTimer
            // 
            this.driverLoadedLblTimer.Interval = 2500;
            this.driverLoadedLblTimer.Tick += new System.EventHandler(this.driverLoadedLblTimer_Tick);
            // 
            // label8
            // 
            this.label8.AutoSize = true;
            this.label8.Location = new System.Drawing.Point(406, 284);
            this.label8.Name = "label8";
            this.label8.Size = new System.Drawing.Size(97, 13);
            this.label8.TabIndex = 29;
            this.label8.Text = "Default Provider ID";
            // 
            // defaultProviderIDBox
            // 
            this.defaultProviderIDBox.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(33)))), ((int)(((byte)(33)))), ((int)(((byte)(33)))));
            this.defaultProviderIDBox.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
            this.defaultProviderIDBox.ForeColor = System.Drawing.Color.Silver;
            this.defaultProviderIDBox.Location = new System.Drawing.Point(409, 300);
            this.defaultProviderIDBox.Name = "defaultProviderIDBox";
            this.defaultProviderIDBox.Size = new System.Drawing.Size(394, 20);
            this.defaultProviderIDBox.TabIndex = 30;
            // 
            // setDefaultProviderBtn
            // 
            this.setDefaultProviderBtn.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(33)))), ((int)(((byte)(33)))), ((int)(((byte)(33)))));
            this.setDefaultProviderBtn.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
            this.setDefaultProviderBtn.ForeColor = System.Drawing.Color.Silver;
            this.setDefaultProviderBtn.Location = new System.Drawing.Point(686, 443);
            this.setDefaultProviderBtn.Name = "setDefaultProviderBtn";
            this.setDefaultProviderBtn.Size = new System.Drawing.Size(117, 23);
            this.setDefaultProviderBtn.TabIndex = 28;
            this.setDefaultProviderBtn.Text = "Set Default Provider";
            this.setDefaultProviderBtn.UseVisualStyleBackColor = true;
            this.setDefaultProviderBtn.Click += new System.EventHandler(this.setDefaultProviderBtn_Click);
            // 
            // testProviderBtn
            // 
            this.testProviderBtn.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(33)))), ((int)(((byte)(33)))), ((int)(((byte)(33)))));
            this.testProviderBtn.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
            this.testProviderBtn.ForeColor = System.Drawing.Color.Silver;
            this.testProviderBtn.Location = new System.Drawing.Point(0, 440);
            this.testProviderBtn.Name = "testProviderBtn";
            this.testProviderBtn.Size = new System.Drawing.Size(75, 23);
            this.testProviderBtn.TabIndex = 26;
            this.testProviderBtn.Text = "Test Driver";
            this.testProviderBtn.UseVisualStyleBackColor = true;
            this.testProviderBtn.Click += new System.EventHandler(this.testProviderBtn_Click);
            // 
            // shellcodeMaskBox
            // 
            this.shellcodeMaskBox.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(33)))), ((int)(((byte)(33)))), ((int)(((byte)(33)))));
            this.shellcodeMaskBox.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
            this.shellcodeMaskBox.ForeColor = System.Drawing.Color.Silver;
            this.shellcodeMaskBox.Location = new System.Drawing.Point(409, 257);
            this.shellcodeMaskBox.Name = "shellcodeMaskBox";
            this.shellcodeMaskBox.Size = new System.Drawing.Size(394, 20);
            this.shellcodeMaskBox.TabIndex = 24;
            // 
            // driverWhqlSignedBox
            // 
            this.driverWhqlSignedBox.Appearance = System.Windows.Forms.Appearance.Button;
            this.driverWhqlSignedBox.BoxBorderColor = System.Drawing.Color.DarkSlateBlue;
            this.driverWhqlSignedBox.BoxFillColor = System.Drawing.Color.FromArgb(((int)(((byte)(33)))), ((int)(((byte)(33)))), ((int)(((byte)(33)))));
            this.driverWhqlSignedBox.CheckColor = System.Drawing.Color.CornflowerBlue;
            this.driverWhqlSignedBox.FlatAppearance.BorderSize = 0;
            this.driverWhqlSignedBox.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
            this.driverWhqlSignedBox.Location = new System.Drawing.Point(653, 324);
            this.driverWhqlSignedBox.Name = "driverWhqlSignedBox";
            this.driverWhqlSignedBox.Size = new System.Drawing.Size(150, 27);
            this.driverWhqlSignedBox.TabIndex = 23;
            this.driverWhqlSignedBox.Text = "Driver is WHQL Signed";
            this.driverWhqlSignedBox.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
            this.driverWhqlSignedBox.UseVisualStyleBackColor = true;
            // 
            // minWinBuildBox
            // 
            this.minWinBuildBox.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(33)))), ((int)(((byte)(33)))), ((int)(((byte)(33)))));
            this.minWinBuildBox.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
            this.minWinBuildBox.ForeColor = System.Drawing.Color.Silver;
            this.minWinBuildBox.Location = new System.Drawing.Point(409, 212);
            this.minWinBuildBox.Name = "minWinBuildBox";
            this.minWinBuildBox.Size = new System.Drawing.Size(394, 20);
            this.minWinBuildBox.TabIndex = 21;
            // 
            // maxWinBuildBox
            // 
            this.maxWinBuildBox.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(33)))), ((int)(((byte)(33)))), ((int)(((byte)(33)))));
            this.maxWinBuildBox.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
            this.maxWinBuildBox.ForeColor = System.Drawing.Color.Silver;
            this.maxWinBuildBox.Location = new System.Drawing.Point(409, 171);
            this.maxWinBuildBox.Name = "maxWinBuildBox";
            this.maxWinBuildBox.Size = new System.Drawing.Size(394, 20);
            this.maxWinBuildBox.TabIndex = 19;
            // 
            // signerNameBox
            // 
            this.signerNameBox.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(33)))), ((int)(((byte)(33)))), ((int)(((byte)(33)))));
            this.signerNameBox.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
            this.signerNameBox.ForeColor = System.Drawing.Color.Silver;
            this.signerNameBox.Location = new System.Drawing.Point(409, 129);
            this.signerNameBox.Name = "signerNameBox";
            this.signerNameBox.Size = new System.Drawing.Size(394, 20);
            this.signerNameBox.TabIndex = 17;
            // 
            // deviceNameBox
            // 
            this.deviceNameBox.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(33)))), ((int)(((byte)(33)))), ((int)(((byte)(33)))));
            this.deviceNameBox.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
            this.deviceNameBox.ForeColor = System.Drawing.Color.Silver;
            this.deviceNameBox.Location = new System.Drawing.Point(409, 88);
            this.deviceNameBox.Name = "deviceNameBox";
            this.deviceNameBox.Size = new System.Drawing.Size(394, 20);
            this.deviceNameBox.TabIndex = 15;
            // 
            // driverNameBox
            // 
            this.driverNameBox.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(33)))), ((int)(((byte)(33)))), ((int)(((byte)(33)))));
            this.driverNameBox.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
            this.driverNameBox.ForeColor = System.Drawing.Color.Silver;
            this.driverNameBox.Location = new System.Drawing.Point(409, 49);
            this.driverNameBox.Name = "driverNameBox";
            this.driverNameBox.Size = new System.Drawing.Size(394, 20);
            this.driverNameBox.TabIndex = 13;
            // 
            // providerExtraInfoBox
            // 
            this.providerExtraInfoBox.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(33)))), ((int)(((byte)(33)))), ((int)(((byte)(33)))));
            this.providerExtraInfoBox.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
            this.providerExtraInfoBox.ForeColor = System.Drawing.Color.Silver;
            this.providerExtraInfoBox.Location = new System.Drawing.Point(406, 354);
            this.providerExtraInfoBox.Multiline = true;
            this.providerExtraInfoBox.Name = "providerExtraInfoBox";
            this.providerExtraInfoBox.Size = new System.Drawing.Size(397, 80);
            this.providerExtraInfoBox.TabIndex = 11;
            // 
            // providerList
            // 
            this.providerList.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(33)))), ((int)(((byte)(33)))), ((int)(((byte)(33)))));
            this.providerList.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
            this.provIdCol,
            this.provNameCol});
            this.providerList.ForeColor = System.Drawing.Color.Silver;
            this.providerList.FullRowSelect = true;
            this.providerList.HideSelection = false;
            this.providerList.Location = new System.Drawing.Point(0, 35);
            this.providerList.Name = "providerList";
            this.providerList.OwnerDraw = true;
            this.providerList.Size = new System.Drawing.Size(400, 399);
            this.providerList.TabIndex = 10;
            this.providerList.UseCompatibleStateImageBehavior = false;
            this.providerList.View = System.Windows.Forms.View.Details;
            this.providerList.SelectedIndexChanged += new System.EventHandler(this.providerList_SelectedIndexChanged);
            // 
            // provIdCol
            // 
            this.provIdCol.Text = "ID";
            // 
            // provNameCol
            // 
            this.provNameCol.Text = "Provider Name";
            this.provNameCol.Width = 396;
            // 
            // appIcon1
            // 
            this.appIcon1.AppIconImage = ((System.Drawing.Image)(resources.GetObject("appIcon1.AppIconImage")));
            this.appIcon1.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(33)))), ((int)(((byte)(33)))), ((int)(((byte)(33)))));
            this.appIcon1.DragForm = null;
            this.appIcon1.Image = ((System.Drawing.Image)(resources.GetObject("appIcon1.Image")));
            this.appIcon1.Location = new System.Drawing.Point(0, 1);
            this.appIcon1.Name = "appIcon1";
            this.appIcon1.Scale = 3.5F;
            this.appIcon1.Size = new System.Drawing.Size(28, 28);
            this.appIcon1.TabIndex = 9;
            this.appIcon1.TabStop = false;
            // 
            // titleLbl
            // 
            this.titleLbl.AutoSize = true;
            this.titleLbl.Font = new System.Drawing.Font("Microsoft Sans Serif", 12F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.titleLbl.Location = new System.Drawing.Point(32, 4);
            this.titleLbl.Name = "titleLbl";
            this.titleLbl.Size = new System.Drawing.Size(237, 20);
            this.titleLbl.TabIndex = 8;
            this.titleLbl.Text = "KsDumper 11 Provider Selection";
            // 
            // closeBtn
            // 
            this.closeBtn.ButtonType = DarkControls.Controls.WindowsDefaultTitleBarButton.Type.Close;
            this.closeBtn.ClickColor = System.Drawing.Color.Red;
            this.closeBtn.ClickIconColor = System.Drawing.Color.Black;
            this.closeBtn.HoverColor = System.Drawing.Color.OrangeRed;
            this.closeBtn.HoverIconColor = System.Drawing.Color.Black;
            this.closeBtn.IconColor = System.Drawing.Color.Black;
            this.closeBtn.IconLineThickness = 2;
            this.closeBtn.Location = new System.Drawing.Point(773, 0);
            this.closeBtn.Name = "closeBtn";
            this.closeBtn.Size = new System.Drawing.Size(40, 40);
            this.closeBtn.TabIndex = 7;
            this.closeBtn.Text = "windowsDefaultTitleBarButton1";
            this.closeBtn.UseVisualStyleBackColor = true;
            this.closeBtn.Click += new System.EventHandler(this.closeBtn_Click);
            // 
            // wipeSettingsBtn
            // 
            this.wipeSettingsBtn.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(33)))), ((int)(((byte)(33)))), ((int)(((byte)(33)))));
            this.wipeSettingsBtn.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
            this.wipeSettingsBtn.ForeColor = System.Drawing.Color.Silver;
            this.wipeSettingsBtn.Location = new System.Drawing.Point(597, 443);
            this.wipeSettingsBtn.Margin = new System.Windows.Forms.Padding(2, 2, 2, 2);
            this.wipeSettingsBtn.Name = "wipeSettingsBtn";
            this.wipeSettingsBtn.Size = new System.Drawing.Size(84, 23);
            this.wipeSettingsBtn.TabIndex = 31;
            this.wipeSettingsBtn.Text = "Wipe Settings";
            this.wipeSettingsBtn.UseVisualStyleBackColor = true;
            this.wipeSettingsBtn.Click += new System.EventHandler(this.wipeSettingsBtn_Click);
            // 
            // ProviderSelector
            // 
            this.AllowDrop = true;
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(33)))), ((int)(((byte)(33)))), ((int)(((byte)(33)))));
            this.ClientSize = new System.Drawing.Size(813, 471);
            this.Controls.Add(this.wipeSettingsBtn);
            this.Controls.Add(this.defaultProviderIDBox);
            this.Controls.Add(this.label8);
            this.Controls.Add(this.setDefaultProviderBtn);
            this.Controls.Add(this.driverLoadedLbl);
            this.Controls.Add(this.testProviderBtn);
            this.Controls.Add(this.label7);
            this.Controls.Add(this.shellcodeMaskBox);
            this.Controls.Add(this.driverWhqlSignedBox);
            this.Controls.Add(this.label5);
            this.Controls.Add(this.minWinBuildBox);
            this.Controls.Add(this.label6);
            this.Controls.Add(this.maxWinBuildBox);
            this.Controls.Add(this.label4);
            this.Controls.Add(this.signerNameBox);
            this.Controls.Add(this.label3);
            this.Controls.Add(this.deviceNameBox);
            this.Controls.Add(this.label2);
            this.Controls.Add(this.driverNameBox);
            this.Controls.Add(this.label1);
            this.Controls.Add(this.providerExtraInfoBox);
            this.Controls.Add(this.providerList);
            this.Controls.Add(this.appIcon1);
            this.Controls.Add(this.titleLbl);
            this.Controls.Add(this.closeBtn);
            this.DoubleBuffered = true;
            this.ForeColor = System.Drawing.Color.Silver;
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.None;
            this.Name = "ProviderSelector";
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
            this.Text = "KsDumper 11 Provider Selection";
            this.Load += new System.EventHandler(this.ProviderSelector_Load);
            ((System.ComponentModel.ISupportInitialize)(this.appIcon1)).EndInit();
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion
        private DarkControls.Controls.WindowsDefaultTitleBarButton closeBtn;
        private DarkControls.Controls.TransparentLabel titleLbl;
        private DarkControls.Controls.AppIcon appIcon1;
        private DarkControls.Controls.DarkListView providerList;
        private System.Windows.Forms.ColumnHeader provNameCol;
        private DarkControls.Controls.DarkTextBox providerExtraInfoBox;
        private System.Windows.Forms.Label label1;
        private DarkControls.Controls.DarkTextBox driverNameBox;
        private System.Windows.Forms.Label label2;
        private System.Windows.Forms.Label label3;
        private DarkControls.Controls.DarkTextBox deviceNameBox;
        private System.Windows.Forms.Label label4;
        private DarkControls.Controls.DarkTextBox signerNameBox;
        private System.Windows.Forms.Label label5;
        private DarkControls.Controls.DarkTextBox minWinBuildBox;
        private System.Windows.Forms.Label label6;
        private DarkControls.Controls.DarkTextBox maxWinBuildBox;
        private DarkControls.Controls.DarkCheckBox driverWhqlSignedBox;
        private System.Windows.Forms.ColumnHeader provIdCol;
        private System.Windows.Forms.Label label7;
        private DarkControls.Controls.DarkTextBox shellcodeMaskBox;
        private DarkControls.Controls.DarkButton testProviderBtn;
        private System.Windows.Forms.Label driverLoadedLbl;
        private System.Windows.Forms.Timer driverLoadedLblTimer;
        private DarkControls.Controls.DarkButton setDefaultProviderBtn;
        private System.Windows.Forms.Label label8;
        private DarkControls.Controls.DarkTextBox defaultProviderIDBox;
        private DarkControls.Controls.DarkButton wipeSettingsBtn;
    }
}


```

`KsDumper11/ProviderSelector.cs`:

```cs
using DarkControls;
using KsDumper11.Driver;
using Newtonsoft.Json;
using System;
using System.IO;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using static System.Windows.Forms.VisualStyles.VisualStyleElement;
using static System.Windows.Forms.VisualStyles.VisualStyleElement.Button;

namespace KsDumper11
{
    public partial class ProviderSelector : Form
    {
        protected override CreateParams CreateParams
        {
            get
            {
                // Activate double buffering at the form level.  All child controls will be double buffered as well.
                CreateParams cp = base.CreateParams;
                cp.ExStyle |= 0x02000000;  // Turn on WS_EX_COMPOSITED
                return cp;
            }
        }

        KduWrapper wrapper;

        JsonSettingsManager settingsManager;
        LabelDrawer labelDrawer;

        public ProviderSelector()
        {
            InitializeComponent();

            settingsManager = new JsonSettingsManager();

            this.FormBorderStyle = FormBorderStyle.None;
            this.Region = Region.FromHrgn(Utils.CreateRoundRectRgn(0, 0, Width, Height, 10, 10));
            this.closeBtn.Region = Region.FromHrgn(Utils.CreateRoundRectRgn(0, 0, closeBtn.Width, closeBtn.Height, 10, 10));

            this.appIcon1.DragForm = this;

            KduSelfExtract.Extract();

            wrapper = new KduWrapper(KduSelfExtract.KduPath);
            wrapper.DriverLoaded += Wrapper_DriverLoaded;
            wrapper.ProvidersLoaded += Wrapper_ProvidersLoaded;
            //wrapper.IsDirtyChanged += Wrapper_IsDirtyChanged;

            wrapper.LoadProviders();
        }

        private void setdriverLoadedLblVisible(bool visible)
        {
            for (int i = 0; i < labelDrawer.labelInfos.Length; i++)
            {
                if (labelDrawer.labelInfos[i].Name == "driverLoadedLbl")
                {
                    labelDrawer.labelInfos[i].Visible = visible;
                }
            }

            this.Invalidate();
        }

        private void Wrapper_IsDirtyChanged(object sender, EventArgs e)
        {
            
        }

        private void Wrapper_ProvidersLoaded(object sender, EventArgs e)
        {
            foreach (KduProvider p in wrapper.providers)
            {
                ListViewItem item = new ListViewItem(p.ProviderIndex.ToString());
                item.SubItems.Add(p.ProviderName);

                if (p.ProviderName.Contains("[NOT WORKING]"))
                {
                    item.ForeColor = Color.Red;
                }

                if (p.ProviderName.Contains("[WORKING]"))
                {
                    item.ForeColor = Color.Green;
                }

                providerList.Items.Add(item);
            }

            if (wrapper.DefaultProvider != -1)
            {
                providerList.SelectedIndices.Add(wrapper.DefaultProvider);
            }
            else
            {
                providerList.SelectedIndices.Add(0);
            }
        }

        private void Wrapper_DriverLoaded(object sender, object[] e)
        {
            if (this.InvokeRequired)
            {
                this.Invoke(new EventHandler<object[]>(Wrapper_DriverLoaded), new object[] { sender, e });
            }
            else
            {
                bool res = (bool)e[0];

                int idx = (int)e[1];

                ListViewItem item = providerList.Items[idx];

                for (int i = 0; i < wrapper.providers.Count; i++)
                {
                    string non_W = "[NOT WORKING] ";
                    string W_ = "[WORKING] ";

                    if (wrapper.providers[i].ProviderName == item.SubItems[1].Text)
                    {
                        if (res)
                        {
                            wrapper.providers[i].ProviderName = W_ + wrapper.providers[i].ProviderName;

                            if (wrapper.IsDirty == false)
                            {
                                wrapper.IsDirty = true;
                            }
                        }
                        else
                        {
                            wrapper.providers[i].ProviderName = non_W + wrapper.providers[i].ProviderName;

                            if (wrapper.IsDirty == false)
                            {
                                wrapper.IsDirty = true;
                            }
                        }

                        
                        break;
                    }
                }
                this.wipeSettingsBtn.Enabled = wrapper.IsDirty;
                if (res)
                {
                    driverLoadedLbl.ForeColor = Color.Green;
                    driverLoadedLbl.Text = "Driver Loaded!";

                    item.SubItems[1].Text = "[WORKING] " + item.SubItems[1].Text;

                    if (providerList.SelectedIndices.Count > 0 && providerList.SelectedIndices[0] == idx)
                    {
                        setDefaultProviderBtn.Enabled = true;
                    }

                    item.ForeColor = Color.Green;
                }
                else
                {
                    driverLoadedLbl.ForeColor = Color.Red;
                    driverLoadedLbl.Text = "Driver failed to load!";

                    item.SubItems[1].Text = "[NOT WORKING] " + item.SubItems[1].Text;

                    if (providerList.SelectedIndices.Count > 0 && providerList.SelectedIndices[0] == idx)
                    {
                        setDefaultProviderBtn.Enabled = false;
                    }

                    item.ForeColor = Color.Red;
                }

                if (settingsManager.JsonSettings.enableAntiAntiDebuggerTools)
                {
                    setdriverLoadedLblVisible(true);
                }
                else
                {
                    driverLoadedLbl.Visible = true;
                }
                driverLoadedLblTimer.Start();
            }
        }

        protected override void WndProc(ref Message m)
        {
            base.WndProc(ref m);
            if (m.Msg == Utils.WM_NCHITTEST)
                m.Result = (IntPtr)(Utils.HT_CAPTION);
        }

        private void providerList_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (providerList.SelectedIndices.Count > 0)
            {
                int idx = providerList.SelectedIndices[0];

                KduProvider p = wrapper.providers[idx];

                if (p.ProviderName.Contains("[NOT WORKING]") || p.ProviderName.Contains("[WORKING]"))
                {
                    testProviderBtn.Enabled = false;

                }
                else
                {
                    testProviderBtn.Enabled = true;
                }

                if (p.ProviderName.Contains("[NOT WORKING]"))
                {
                    setDefaultProviderBtn.Enabled = false;
                }
                else if (p.ProviderName.Contains("[WORKING]"))
                {
                    setDefaultProviderBtn.Enabled = true;
                }
                else
                {
                    setDefaultProviderBtn.Enabled = false;
                }

                driverNameBox.Text = p.DriverName;
                deviceNameBox.Text = p.DeviceName;
                signerNameBox.Text = p.SignerName;
                minWinBuildBox.Text = p.MinWindowsBuild;
                maxWinBuildBox.Text = p.MaxWindowsBuild;
                driverWhqlSignedBox.Checked = p.IsWHQL_Signed;
                shellcodeMaskBox.Text = p.ShellcodeSupportMask;

                defaultProviderIDBox.Text = wrapper.DefaultProvider.ToString();

                if (p.ExtraInfo.Length > 0)
                {
                    providerExtraInfoBox.Clear();
                    for (int i = 0; i < p.ExtraInfo.Length; i++)
                    {
                        providerExtraInfoBox.AppendText(p.ExtraInfo[i] + Environment.NewLine);
                    }
                }
            }
        }

        private void testProviderBtn_Click(object sender, EventArgs e)
        {
            if (providerList.SelectedIndices.Count > 0)
            {
                testProviderBtn.Enabled = false;

                int idx = providerList.SelectedIndices[0];

                KduProvider p = wrapper.providers[idx];

                wrapper.tryLoad(p.ProviderIndex);
            }
        }

        private void driverLoadedLblTimer_Tick(object sender, EventArgs e)
        {
            testProviderBtn.Enabled = true;

            if (settingsManager.JsonSettings.enableAntiAntiDebuggerTools)
            {
                setdriverLoadedLblVisible(false);
            }
            else
            {
                driverLoadedLbl.Visible = false;
            }
                
            driverLoadedLblTimer.Stop();
        }

        private void setDefaultProviderBtn_Click(object sender, EventArgs e)
        {
            if (providerList.SelectedIndices.Count > 0)
            {
                testProviderBtn.Enabled = false;

                int idx = providerList.SelectedIndices[0];

                wrapper.SetDefaultProvider(idx);

                defaultProviderIDBox.Text = wrapper.DefaultProvider.ToString();

                wrapper.Start();

                Program.ProviderIsClosing = true;

                this.Close();
            }
        }

        private void wipeSettingsBtn_Click(object sender, EventArgs e)
        {
            wrapper.ResetProviders();

            providerList.Items.Clear();

            Wrapper_ProvidersLoaded(sender, e);

            this.wipeSettingsBtn.Enabled = false;
        }

        private void ProviderSelector_Load(object sender, EventArgs e)
        {
            this.wipeSettingsBtn.Enabled = wrapper.IsDirty;

            if (settingsManager.JsonSettings.enableAntiAntiDebuggerTools)
            {
                labelDrawer = new LabelDrawer(this);
                setdriverLoadedLblVisible(false);

                SnifferBypass.SelfTitle(this.Handle);

                foreach (Control ctrl in this.Controls)
                {
                    if (ctrl is System.Windows.Forms.TextBox) continue;
                    SnifferBypass.SelfTitle(ctrl.Handle);
                }

                this.Text = SnifferBypass.GenerateRandomString(this.Text.Length);
            }
        }

        private void closeBtn_Click(object sender, EventArgs e)
        {
            DialogResult = DialogResult.OK;
        }
    }
}

```

`KsDumper11/ProviderSelector.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <metadata name="driverLoadedLblTimer.TrayLocation" type="System.Drawing.Point, System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a">
    <value>17, 17</value>
  </metadata>
  <assembly alias="System.Drawing" name="System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
  <data name="appIcon1.AppIconImage" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        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
</value>
  </data>
  <data name="appIcon1.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAYAAAByDd+UAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8
        YQUAAAAJcEhZcwAACwwAAAsMAT9AIsgAAASJSURBVEhL7ZVrUJRVGMdfK7WaJhomMvvApQkhLnKHhQV2
        WWFZYDF2YRWWkOW2EkoiQQVoENhFRYRABBHiXojg1BgOiMOUM6iTOCjkNFLhTE3f+NQ0xVD/p3N2jlAw
        CNjUJ39f9jn///95zp5333df6SH/OzYF9LwoV2Qt2SW8+DocHfbgiH0hJuxy0CYRrRPWUpjHMzzrkIOj
        vFc4K2OXSo87Z6PTNZ/IMRvDTrvJ3nE3upyy0e9ioA0iNo9LKW3gniXDs6yH9/IZfJaILY97JrICi4g8
        zBjQ5GKjkCW3DFz0yMBesZyHa26ZuCiWkkaDjbyXz3BPR5aQl2KjoKeC0xAQaMLNQDbAbKb1wpKC0vGC
        PB3T/iYyCGkernGPZ4QkmX1ofSD7gnyWPBUyaw2eFpYkhRnxXowZQyoTfpQbcUeZhhKDy8KlU6SSvTIZ
        42EZ6Gefp/7xW5bSI1xTZaKPZ3hWOBKfoUxFiTwJU9tM+FmbhSG+lxSqR8Oet4hqOkGxabjr7g4n0SOF
        G8g2KhHfRRjJEKmn8OgkzAhrHq5FJSCCZ1h2SptCtsKSnJ2xJS4Td1vbifLeJApme1kMdTSqS0uImjrn
        EJ+CmRAZvLkel4A72h1IM8SRD6vH9IkY1Ceg2dLEiE/Aaa7FGXCDZ2INZNIlYIp7QX7kudOEme5PiA4V
        E0VoUW1puodGhZr32Uk72v9AchKm9RE4YNRhNkWHc0Y9kVGPMJ5L1GMwKQ5VyTo07tRjiGs7mMczlmw8
        fterUfJqMn76tIfoQzZTzWbz3BJ0ClRXFRCd/Xhudt8uol2RKE7VISb9FXyQEYurZgNZ8VzadsyZtmOY
        1xlqWGdocdXEMjzLeoryMon4ySrZLF3IopMtJkmOmgYWrNpHlOALhZClbC0O5ERjMDeaWl+LRi/XzOFk
        lROF0ewYHLSEGEYvhB5h/bXsZClBy5xsMXuVOFmgZj90JDYLyUK+Gt/na/Alr3PZrV4YiR+Y9q3FFBTF
        YhPvzVWIG2S1FKoQVspue7GUDqrQVrwNn/G6VEHPFKtwuURNbzOti3nzNxKxx4b3iuWDURGKk+VKDPCa
        b3ZIgdsVCvx6RqJHuVamxFC5AnW8/tdUylHVEEZUFwi7YzI8URmEycMhKDwcjP3Mu1XD/sqOB5A9zxwL
        wlHR9mDUy9BSK8MvJ0IQ85EcHnUBuFEjwzvCllhdUSej63VyuNYHQ3uCZwPQJOy10eqH9tN++KbRFwU9
        Mlg3++LrJv+Fze7BtIoWX1xr9CGrU74oZD232/zQIuzV0e2B+l5XjHV4UNmIgh7r8sJEuzdKhb2EDm9U
        dHniJkm0rsOLys64YLx7K2qFfX/6XLC/1x/XOqbnlH2BeK7fDRO9Wxees+U464Hyc24Y/9yHnu2Z/E3F
        Zoz1OSNH2MvzhTN6Lvj9+e5g+2zigCsmzzsvvYzLcf5llA+44NZI82zSBR8cZ70rX9pBR/IcccToFVuM
        Dm9BnpBXzbAT3uC9lxxx+ZLTwpvnvlzfTE9eccAmsVwzX70Em8m/vVMf8h8iSX8BwCCUC3RVqvIAAAAA
        SUVORK5CYII=
</value>
  </data>
</root>
```

`KsDumper11/SnifferBypass.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;

namespace KsDumper11
{
    public class SnifferBypass
    {
        [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
        private static extern bool SetWindowText(IntPtr hWnd, string lpString);

        [DllImport("user32.dll", SetLastError = true)]
        private static extern IntPtr FindWindow(string lpClassName, string lpWindowName);

        public string FilePath { get; set; }
        private string renamedPath = "";

        public static void SelfTitle(IntPtr hWnd)
        {
            bool result = SetWindowText(hWnd, GenerateRandomString(12));
        }

        public SnifferBypass(string filePath)
        {
            FilePath = filePath;
        }

        public static string GenerateRandomString(int length)
        {
            const string chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
            Random random = new Random();
            return new string(Enumerable.Repeat(chars, length).Select(s => s[random.Next(s.Length)]).ToArray());
        }
    }
}

```

`KsDumper11/StartDriver.cs`:

```cs
using KsDumper11.Driver;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.IO;

namespace KsDumper11
{
    public class StartDriver
    {
        public static void Start()
        {
            bool driverOpen = KsDumperDriverInterface.IsDriverOpen("\\\\.\\KsDumper");

            if (!driverOpen)
            {
                if (File.Exists(KduSelfExtract.AssemblyDirectory + @"\\Providers.json"))
                {
                    KduWrapper wr = new KduWrapper(KduSelfExtract.AssemblyDirectory + @"\Driver\kdu.exe");
                    wr.LoadProviders();
                    wr.Start();
                }
            }
        }
    }
}

```

`KsDumper11/Trigger.Designer.cs`:

```cs
namespace KsDumper11
{
    partial class Trigger
    {
        /// <summary> 
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary> 
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Component Designer generated code

        /// <summary> 
        /// Required method for Designer support - do not modify 
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.SuspendLayout();
            // 
            // Trigger
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(192)))), ((int)(((byte)(0)))), ((int)(((byte)(0)))));
            this.Name = "Trigger";
            this.Size = new System.Drawing.Size(35, 24);
            this.ResumeLayout(false);

        }

        #endregion
    }
}

```

`KsDumper11/Trigger.cs`:

```cs
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace KsDumper11
{
    public partial class Trigger : UserControl
    {
        TriggerForm triggerFrm;
        public Trigger()
        {
            InitializeComponent();
            triggerFrm = new TriggerForm();
            this.Click += Trigger_Click;
        }

        private void Trigger_Click(object sender, EventArgs e)
        {
            if (triggerFrm == null)
            {
                triggerFrm = new TriggerForm();
            }
            else
            {
                if (triggerFrm.IsDisposed)
                {
                    triggerFrm = new TriggerForm();
                }
            }

            if (!triggerFrm.Visible)
            {
                triggerFrm.ShowDialog();
            }
        }
    }
}

```

`KsDumper11/Trigger.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`KsDumper11/TriggerForm.Designer.cs`:

```cs
namespace KsDumper11
{
    partial class TriggerForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(TriggerForm));
            this.textBox1 = new System.Windows.Forms.TextBox();
            this.appIcon1 = new DarkControls.Controls.AppIcon();
            this.transparentLabel1 = new DarkControls.Controls.TransparentLabel();
            this.closeBtn = new DarkControls.Controls.WindowsDefaultTitleBarButton();
            ((System.ComponentModel.ISupportInitialize)(this.appIcon1)).BeginInit();
            this.SuspendLayout();
            // 
            // textBox1
            // 
            this.textBox1.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(33)))), ((int)(((byte)(33)))), ((int)(((byte)(33)))));
            this.textBox1.BorderStyle = System.Windows.Forms.BorderStyle.FixedSingle;
            this.textBox1.ForeColor = System.Drawing.Color.Silver;
            this.textBox1.Location = new System.Drawing.Point(12, 47);
            this.textBox1.Multiline = true;
            this.textBox1.Name = "textBox1";
            this.textBox1.Size = new System.Drawing.Size(405, 139);
            this.textBox1.TabIndex = 10;
            this.textBox1.Text = resources.GetString("textBox1.Text");
            // 
            // appIcon1
            // 
            this.appIcon1.AppIconImage = ((System.Drawing.Image)(resources.GetObject("appIcon1.AppIconImage")));
            this.appIcon1.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(33)))), ((int)(((byte)(33)))), ((int)(((byte)(33)))));
            this.appIcon1.DragForm = null;
            this.appIcon1.Image = ((System.Drawing.Image)(resources.GetObject("appIcon1.Image")));
            this.appIcon1.Location = new System.Drawing.Point(0, 1);
            this.appIcon1.Name = "appIcon1";
            this.appIcon1.Scale = 3.5F;
            this.appIcon1.Size = new System.Drawing.Size(28, 28);
            this.appIcon1.TabIndex = 9;
            this.appIcon1.TabStop = false;
            // 
            // transparentLabel1
            // 
            this.transparentLabel1.Font = new System.Drawing.Font("Microsoft Sans Serif", 12F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.transparentLabel1.Location = new System.Drawing.Point(32, 4);
            this.transparentLabel1.Name = "transparentLabel1";
            this.transparentLabel1.Size = new System.Drawing.Size(108, 20);
            this.transparentLabel1.TabIndex = 8;
            this.transparentLabel1.Text = "Easter egg";
            // 
            // closeBtn
            // 
            this.closeBtn.ButtonType = DarkControls.Controls.WindowsDefaultTitleBarButton.Type.Close;
            this.closeBtn.ClickColor = System.Drawing.Color.Red;
            this.closeBtn.ClickIconColor = System.Drawing.Color.Black;
            this.closeBtn.HoverColor = System.Drawing.Color.OrangeRed;
            this.closeBtn.HoverIconColor = System.Drawing.Color.Black;
            this.closeBtn.IconColor = System.Drawing.Color.Black;
            this.closeBtn.IconLineThickness = 2;
            this.closeBtn.Location = new System.Drawing.Point(389, 1);
            this.closeBtn.Name = "closeBtn";
            this.closeBtn.Size = new System.Drawing.Size(40, 40);
            this.closeBtn.TabIndex = 7;
            this.closeBtn.Text = "windowsDefaultTitleBarButton1";
            this.closeBtn.UseVisualStyleBackColor = true;
            this.closeBtn.Click += new System.EventHandler(this.closeBtn_Click);
            // 
            // TriggerForm
            // 
            this.AllowDrop = true;
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(33)))), ((int)(((byte)(33)))), ((int)(((byte)(33)))));
            this.ClientSize = new System.Drawing.Size(429, 198);
            this.Controls.Add(this.textBox1);
            this.Controls.Add(this.appIcon1);
            this.Controls.Add(this.transparentLabel1);
            this.Controls.Add(this.closeBtn);
            this.DoubleBuffered = true;
            this.ForeColor = System.Drawing.Color.Silver;
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.None;
            this.Name = "TriggerForm";
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
            this.Load += new System.EventHandler(this.TriggerForm_Load);
            ((System.ComponentModel.ISupportInitialize)(this.appIcon1)).EndInit();
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion
        private DarkControls.Controls.WindowsDefaultTitleBarButton closeBtn;
        private DarkControls.Controls.TransparentLabel transparentLabel1;
        private DarkControls.Controls.AppIcon appIcon1;
        private System.Windows.Forms.TextBox textBox1;
    }
}


```

`KsDumper11/TriggerForm.cs`:

```cs
using System;
using System.IO;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.Runtime.InteropServices;
using System.Diagnostics;
using DarkControls;
using static System.Windows.Forms.VisualStyles.VisualStyleElement.Button;

namespace KsDumper11
{
    public partial class TriggerForm : Form
    {
        protected override CreateParams CreateParams
        {
            get
            {
                // Activate double buffering at the form level.  All child controls will be double buffered as well.
                CreateParams cp = base.CreateParams;
                cp.ExStyle |= 0x02000000;  // Turn on WS_EX_COMPOSITED
                return cp;
            }
        }

        JsonSettingsManager settingsManager;
        LabelDrawer labelDrawer;

        public TriggerForm()
        {
            InitializeComponent();

            settingsManager = new JsonSettingsManager();

            this.appIcon1.DragForm = this;
            this.FormBorderStyle = FormBorderStyle.None;
            this.Region = Region.FromHrgn(Utils.CreateRoundRectRgn(0, 0, Width, Height, 10, 10));
            this.closeBtn.Region = Region.FromHrgn(Utils.CreateRoundRectRgn(0, 0, closeBtn.Width, closeBtn.Height, 10, 10));
        }

        protected override void WndProc(ref Message m)
        {
            base.WndProc(ref m);
            if (m.Msg == Utils.WM_NCHITTEST)
                m.Result = (IntPtr)(Utils.HT_CAPTION);
        }

        private void closeBtn_Click(object sender, EventArgs e)
        {
            this.DialogResult = DialogResult.OK;
            this.Close();
        }

        private void TriggerForm_Load(object sender, EventArgs e)
        {
            if (settingsManager.JsonSettings.enableAntiAntiDebuggerTools)
            {
                labelDrawer = new LabelDrawer(this);

                SnifferBypass.SelfTitle(this.Handle);

                foreach (Control ctrl in this.Controls)
                {
                    if (ctrl is System.Windows.Forms.TextBox) continue;
                    SnifferBypass.SelfTitle(ctrl.Handle);
                }

                this.Text = SnifferBypass.GenerateRandomString(this.Text.Length);
            }
        }
    }
}

```

`KsDumper11/TriggerForm.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="textBox1.Text" xml:space="preserve">
    <value>This is a fix for the infinite animation of giraffes in the quantum matrix issue that was presented as an issue on the githib repo.
We still need to address the portal and space time separation issues.
As of this moment, theres ongoing investigation into that topic. 
For now, put your head between your legs and hold on to your butt, cause we're off in flight!</value>
  </data>
  <assembly alias="System.Drawing" name="System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
  <data name="appIcon1.AppIconImage" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        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
</value>
  </data>
  <data name="appIcon1.Image" type="System.Drawing.Bitmap, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        iVBORw0KGgoAAAANSUhEUgAAABwAAAAcCAYAAAByDd+UAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8
        YQUAAAAJcEhZcwAACwwAAAsMAT9AIsgAAASJSURBVEhL7ZVrUJRVGMdfK7WaJhomMvvApQkhLnKHhQV2
        WWFZYDF2YRWWkOW2EkoiQQVoENhFRYRABBHiXojg1BgOiMOUM6iTOCjkNFLhTE3f+NQ0xVD/p3N2jlAw
        CNjUJ39f9jn///95zp5333df6SH/OzYF9LwoV2Qt2SW8+DocHfbgiH0hJuxy0CYRrRPWUpjHMzzrkIOj
        vFc4K2OXSo87Z6PTNZ/IMRvDTrvJ3nE3upyy0e9ioA0iNo9LKW3gniXDs6yH9/IZfJaILY97JrICi4g8
        zBjQ5GKjkCW3DFz0yMBesZyHa26ZuCiWkkaDjbyXz3BPR5aQl2KjoKeC0xAQaMLNQDbAbKb1wpKC0vGC
        PB3T/iYyCGkernGPZ4QkmX1ofSD7gnyWPBUyaw2eFpYkhRnxXowZQyoTfpQbcUeZhhKDy8KlU6SSvTIZ
        42EZ6Gefp/7xW5bSI1xTZaKPZ3hWOBKfoUxFiTwJU9tM+FmbhSG+lxSqR8Oet4hqOkGxabjr7g4n0SOF
        G8g2KhHfRRjJEKmn8OgkzAhrHq5FJSCCZ1h2SptCtsKSnJ2xJS4Td1vbifLeJApme1kMdTSqS0uImjrn
        EJ+CmRAZvLkel4A72h1IM8SRD6vH9IkY1Ceg2dLEiE/Aaa7FGXCDZ2INZNIlYIp7QX7kudOEme5PiA4V
        E0VoUW1puodGhZr32Uk72v9AchKm9RE4YNRhNkWHc0Y9kVGPMJ5L1GMwKQ5VyTo07tRjiGs7mMczlmw8
        fterUfJqMn76tIfoQzZTzWbz3BJ0ClRXFRCd/Xhudt8uol2RKE7VISb9FXyQEYurZgNZ8VzadsyZtmOY
        1xlqWGdocdXEMjzLeoryMon4ySrZLF3IopMtJkmOmgYWrNpHlOALhZClbC0O5ERjMDeaWl+LRi/XzOFk
        lROF0ewYHLSEGEYvhB5h/bXsZClBy5xsMXuVOFmgZj90JDYLyUK+Gt/na/Alr3PZrV4YiR+Y9q3FFBTF
        YhPvzVWIG2S1FKoQVspue7GUDqrQVrwNn/G6VEHPFKtwuURNbzOti3nzNxKxx4b3iuWDURGKk+VKDPCa
        b3ZIgdsVCvx6RqJHuVamxFC5AnW8/tdUylHVEEZUFwi7YzI8URmEycMhKDwcjP3Mu1XD/sqOB5A9zxwL
        wlHR9mDUy9BSK8MvJ0IQ85EcHnUBuFEjwzvCllhdUSej63VyuNYHQ3uCZwPQJOy10eqH9tN++KbRFwU9
        Mlg3++LrJv+Fze7BtIoWX1xr9CGrU74oZD232/zQIuzV0e2B+l5XjHV4UNmIgh7r8sJEuzdKhb2EDm9U
        dHniJkm0rsOLys64YLx7K2qFfX/6XLC/1x/XOqbnlH2BeK7fDRO9Wxees+U464Hyc24Y/9yHnu2Z/E3F
        Zoz1OSNH2MvzhTN6Lvj9+e5g+2zigCsmzzsvvYzLcf5llA+44NZI82zSBR8cZ70rX9pBR/IcccToFVuM
        Dm9BnpBXzbAT3uC9lxxx+ZLTwpvnvlzfTE9eccAmsVwzX70Em8m/vVMf8h8iSX8BwCCUC3RVqvIAAAAA
        SUVORK5CYII=
</value>
  </data>
</root>
```

`KsDumper11/Turn_OFF_Microsoft_Vulnerable_Driver_Blocklist.reg`:

```reg
Windows Registry Editor Version 5.00

[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\CI\Config]
"VulnerableDriverBlocklistEnable"=dword:00000000
```

`KsDumper11/Turn_ON_Microsoft_Vulnerable_Driver_Blocklist.reg`:

```reg
Windows Registry Editor Version 5.00

; Created by: Shawn Brink
; Created on: October 26, 2022
; Tutorial: https://www.elevenforum.com/t/enable-or-disable-microsoft-vulnerable-driver-blocklist-in-windows-11.10031/


[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\CI\Config]
"VulnerableDriverBlocklistEnable"=dword:00000001


```

`KsDumper11/app.manifest`:

```manifest
<?xml version="1.0" encoding="utf-8"?>
<assembly manifestVersion="1.0" xmlns="urn:schemas-microsoft-com:asm.v1">
  <assemblyIdentity version="1.0.0.0" name="KsDumperClient.app"/>
  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v2">
    <security>
      <requestedPrivileges xmlns="urn:schemas-microsoft-com:asm.v3">
        <requestedExecutionLevel level="requireAdministrator" uiAccess="false" />
      </requestedPrivileges>
    </security>
  </trustInfo>
</assembly>

```

`KsDumper11/packages.config`:

```config
<?xml version="1.0" encoding="utf-8"?>
<packages>
  <package id="Newtonsoft.Json" version="13.0.3" targetFramework="net48" />
</packages>
```

`KsDumperDriver/Driver.c`:

```c
#include "NTUndocumented.h"
#include "ProcessLister.h"
#include "UserModeBridge.h"
#include <wdf.h>

DRIVER_INITIALIZE DriverEntry;
#pragma alloc_text(INIT, DriverEntry)

UNICODE_STRING deviceName, symLink;
PDEVICE_OBJECT deviceObject;

NTSTATUS CopyVirtualMemory(PEPROCESS targetProcess, PVOID sourceAddress, PVOID targetAddress, SIZE_T size)
{
	PSIZE_T readBytes;
	return MmCopyVirtualMemory(targetProcess, sourceAddress, PsGetCurrentProcess(), targetAddress, size, UserMode, &readBytes);
}

NTSTATUS UnsupportedDispatch(_In_ PDEVICE_OBJECT DeviceObject, _Inout_ PIRP Irp)
{
	UNREFERENCED_PARAMETER(DeviceObject);

	Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
	IoCompleteRequest(Irp, IO_NO_INCREMENT);
	return Irp->IoStatus.Status;
}

NTSTATUS CreateDispatch(_In_ PDEVICE_OBJECT DeviceObject, _Inout_ PIRP Irp)
{
	UNREFERENCED_PARAMETER(DeviceObject);

	IoCompleteRequest(Irp, IO_NO_INCREMENT);
	return Irp->IoStatus.Status;
}

NTSTATUS CloseDispatch(_In_ PDEVICE_OBJECT DeviceObject, _Inout_ PIRP Irp)
{
	UNREFERENCED_PARAMETER(DeviceObject);

	IoCompleteRequest(Irp, IO_NO_INCREMENT);
	return Irp->IoStatus.Status;
}

//NTSTATUS Unload(IN PDRIVER_OBJECT DriverObject)
//{
//	IoDeleteSymbolicLink(&symLink);
//	IoDeleteDevice(DriverObject->DeviceObject);
//}

NTSTATUS Unload(IN PDRIVER_OBJECT DriverObject)
{
	IoDeleteSymbolicLink(&symLink);
	IoDeleteSymbolicLink(&deviceName);
	IoDeleteDevice(deviceObject);
	return ZwUnloadDriver(&deviceName);
}

NTSTATUS IoControl(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
	NTSTATUS status;
	ULONG bytesIO = 0;
	PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(Irp);
	ULONG controlCode = stack->Parameters.DeviceIoControl.IoControlCode;

	if (controlCode == IO_COPY_MEMORY)
	{
		if (stack->Parameters.DeviceIoControl.InputBufferLength == sizeof(KERNEL_COPY_MEMORY_OPERATION))
		{
			PKERNEL_COPY_MEMORY_OPERATION request = (PKERNEL_COPY_MEMORY_OPERATION)Irp->AssociatedIrp.SystemBuffer;
			PEPROCESS targetProcess;

			if (NT_SUCCESS(PsLookupProcessByProcessId(request->targetProcessId, &targetProcess)))
			{
				CopyVirtualMemory(targetProcess, request->targetAddress, request->bufferAddress, request->bufferSize);
				ObDereferenceObject(targetProcess);
			}

			status = STATUS_SUCCESS;
			bytesIO = sizeof(KERNEL_COPY_MEMORY_OPERATION);
		}
		else
		{
			status = STATUS_INFO_LENGTH_MISMATCH;
			bytesIO = 0;
		}
	}
	else if (controlCode == IO_GET_PROCESS_LIST)
	{
		if (stack->Parameters.DeviceIoControl.InputBufferLength == sizeof(KERNEL_PROCESS_LIST_OPERATION) &&
			stack->Parameters.DeviceIoControl.OutputBufferLength == sizeof(KERNEL_PROCESS_LIST_OPERATION))
		{
			PKERNEL_PROCESS_LIST_OPERATION request = (PKERNEL_PROCESS_LIST_OPERATION)Irp->AssociatedIrp.SystemBuffer;

			GetProcessList(request->bufferAddress, request->bufferSize, &request->bufferSize, &request->processCount);

			status = STATUS_SUCCESS;
			bytesIO = sizeof(KERNEL_PROCESS_LIST_OPERATION);
		}
		else
		{
			status = STATUS_INFO_LENGTH_MISMATCH;
			bytesIO = 0;
		}
	}
	else if (controlCode == IO_UNLOAD_DRIVER)
	{
		Unload(NULL);
		bytesIO = 0;
		status = STATUS_SUCCESS;
	}
	else
	{
		status = STATUS_INVALID_PARAMETER;
		bytesIO = 0;
	}

	Irp->IoStatus.Status = status;
	Irp->IoStatus.Information = bytesIO;
	IoCompleteRequest(Irp, IO_NO_INCREMENT);

	return status;
}

NTSTATUS DriverInitialize(_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath)
{
	NTSTATUS status;
	

	UNREFERENCED_PARAMETER(RegistryPath);

	RtlInitUnicodeString(&deviceName, L"\\Device\\KsDumper");
	RtlInitUnicodeString(&symLink, L"\\DosDevices\\KsDumper");

	status = IoCreateDevice(DriverObject, 0, &deviceName, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &deviceObject);

	if (!NT_SUCCESS(status))
	{
		return status;
	}
	status = IoCreateSymbolicLink(&symLink, &deviceName);

	if (!NT_SUCCESS(status))
	{
		IoDeleteDevice(deviceObject);
		return status;
	}
	deviceObject->Flags |= DO_BUFFERED_IO;

	for (ULONG t = 0; t <= IRP_MJ_MAXIMUM_FUNCTION; t++)
		DriverObject->MajorFunction[t] = &UnsupportedDispatch;

	DriverObject->MajorFunction[IRP_MJ_CREATE] = &CreateDispatch;
	DriverObject->MajorFunction[IRP_MJ_CLOSE] = &CloseDispatch;
	DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = &IoControl;
	DriverObject->DriverUnload = &Unload;
	deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

	return status;
}



NTSTATUS DriverEntry(_In_ PDRIVER_OBJECT DriverObject, _In_ PUNICODE_STRING RegistryPath)
{
	UNREFERENCED_PARAMETER(DriverObject);
	UNREFERENCED_PARAMETER(RegistryPath);

	return IoCreateDriver(NULL, &DriverInitialize);
}

```

`KsDumperDriver/KsDumperDriver.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{8EADAB93-F111-43AF-9E10-2376AE515491}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>TestDriver</RootNamespace>
    <ProjectName>KsDumperDriver</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <TimeStampServer />
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <SuppressStartupBanner>false</SuppressStartupBanner>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ExpandAttributedSource>true</ExpandAttributedSource>
      <AssemblerOutput>All</AssemblerOutput>
      <BrowseInformation>true</BrowseInformation>
      <CompileAs>CompileAsC</CompileAs>
      <EnablePREfast>false</EnablePREfast>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
    <Link>
      <SuppressStartupBanner>false</SuppressStartupBanner>
      <LargeAddressAware>true</LargeAddressAware>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
      <Profile>false</Profile>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <SuppressStartupBanner>false</SuppressStartupBanner>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ExpandAttributedSource>true</ExpandAttributedSource>
      <AssemblerOutput>All</AssemblerOutput>
      <BrowseInformation>true</BrowseInformation>
      <CompileAs>CompileAsC</CompileAs>
      <EnablePREfast>false</EnablePREfast>
      <TreatWarningAsError>false</TreatWarningAsError>
    </ClCompile>
    <Link>
      <SuppressStartupBanner>false</SuppressStartupBanner>
      <LargeAddressAware>true</LargeAddressAware>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <DataExecutionPrevention>true</DataExecutionPrevention>
      <Profile>false</Profile>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="ProcessLister.c" />
    <ClCompile Include="Driver.c" />
    <ClCompile Include="Utility.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="UserModeBridge.h" />
    <ClInclude Include="ProcessLister.h" />
    <ClInclude Include="NTUndocumented.h" />
    <ClInclude Include="Utility.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`KsDumperDriver/KsDumperDriver.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="ProcessLister.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Driver.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Utility.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="ProcessLister.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="UserModeBridge.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="NTUndocumented.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Utility.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`KsDumperDriver/NTUndocumented.h`:

```h
#pragma once
#include <ntddk.h>

typedef struct _KAPC_STATE {
	LIST_ENTRY ApcListHead[MaximumMode];
	struct _KPROCESS *Process;
	BOOLEAN KernelApcInProgress;
	BOOLEAN KernelApcPending;
	BOOLEAN UserApcPending;
} KAPC_STATE, *PKAPC_STATE, *PRKAPC_STATE;

typedef enum _SYSTEM_INFORMATION_CLASS
{
	SystemProcessInformation = 5
} SYSTEM_INFORMATION_CLASS;

typedef enum _MEMORY_INFORMATION_CLASS
{
	MemoryBasicInformation,
	MemoryWorkingSetInformation,
	MemoryMappedFilenameInformation,
	MemoryRegionInformation,
	MemoryWorkingSetExInformation

} MEMORY_INFORMATION_CLASS;


typedef struct _MEMORY_BASIC_INFORMATION {
	PVOID  BaseAddress;
	PVOID  AllocationBase;
	INT32  AllocationProtect;
	SIZE_T RegionSize;
	INT32  State;
	INT32  Protect;
	INT32  Type;
} MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION;

NTKERNELAPI NTSTATUS IoCreateDriver(IN PUNICODE_STRING DriverName, OPTIONAL IN PDRIVER_INITIALIZE InitializationFunction);

NTKERNELAPI VOID KeStackAttachProcess(__inout struct _KPROCESS * PROCESS, __out PRKAPC_STATE ApcState);
NTKERNELAPI VOID KeUnstackDetachProcess(__in PRKAPC_STATE ApcState);

NTKERNELAPI NTSTATUS NTAPI MmCopyVirtualMemory(IN PEPROCESS FromProcess, IN PVOID FromAddress, IN PEPROCESS ToProcess, OUT PVOID ToAddress, IN SIZE_T BufferSize, IN KPROCESSOR_MODE PreviousMode, OUT PSIZE_T NumberOfBytesCopied);

NTSYSAPI NTSTATUS NTAPI ZwQuerySystemInformation(IN SYSTEM_INFORMATION_CLASS SystemInformationClass, OUT PVOID SystemInformation, IN ULONG SystemInformationLength, OUT PULONG ReturnLength OPTIONAL);
NTSYSAPI NTSTATUS NTAPI ZwQueryVirtualMemory(IN HANDLE ProcessHandle, IN PVOID BaseAddress, IN MEMORY_INFORMATION_CLASS MemoryInformationClass, OUT PVOID MemoryInformation, IN SIZE_T MemoryInformationLength, OUT PSIZE_T ReturnLength OPTIONAL);

NTKERNELAPI NTSTATUS PsLookupProcessByProcessId(IN HANDLE ProcessId, OUT PEPROCESS *Process);
NTKERNELAPI PVOID PsGetProcessSectionBaseAddress(__in PEPROCESS Process);
NTKERNELAPI PPEB NTAPI PsGetProcessPeb(IN PEPROCESS Process);
```

`KsDumperDriver/ProcessLister.c`:

```c
#include "NTUndocumented.h"
#include "ProcessLister.h"
#include "Utility.h"

static PSYSTEM_PROCESS_INFORMATION GetRawProcessList()
{
	ULONG bufferSize = 0;
	PVOID bufferPtr = NULL;

	if (ZwQuerySystemInformation(SystemProcessInformation, 0, bufferSize, &bufferSize) == STATUS_INFO_LENGTH_MISMATCH)
	{
		bufferPtr = ExAllocatePool(NonPagedPool, bufferSize);

		if (bufferPtr != NULL)
		{
			ZwQuerySystemInformation(SystemProcessInformation, bufferPtr, bufferSize, &bufferSize);
		}
	}
	return (PSYSTEM_PROCESS_INFORMATION)bufferPtr;
}

static ULONG CalculateProcessListOutputSize(PSYSTEM_PROCESS_INFORMATION rawProcessList)
{
	int size = 0;

	while (rawProcessList->NextEntryOffset)
	{
		size += sizeof(PROCESS_SUMMARY);
		rawProcessList = (PSYSTEM_PROCESS_INFORMATION)(((CHAR*)rawProcessList) + rawProcessList->NextEntryOffset);
	}
	return size;
}

static PLDR_DATA_TABLE_ENTRY GetMainModuleDataTableEntry(PPEB64 peb)
{
	if (SanitizeUserPointer(peb, sizeof(PEB64)))
	{
		if (peb->Ldr)
		{
			if (SanitizeUserPointer(peb->Ldr, sizeof(PEB_LDR_DATA)))
			{
				if (!peb->Ldr->Initialized)
				{
					int initLoadCount = 0;

					while (!peb->Ldr->Initialized && initLoadCount++ < 4)
					{
						DriverSleep(250);
					}
				}

				if (peb->Ldr->Initialized)
				{
					return CONTAINING_RECORD(peb->Ldr->InLoadOrderModuleList.Flink, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
				}
			}
		}
	}
	return NULL;
}

NTSTATUS GetProcessList(PVOID listedProcessBuffer, INT32 bufferSize, PINT32 requiredBufferSize, PINT32 processCount)
{
	PPROCESS_SUMMARY processSummary = (PPROCESS_SUMMARY)listedProcessBuffer;
	PSYSTEM_PROCESS_INFORMATION rawProcessList = GetRawProcessList();
	PVOID listHeadPointer = rawProcessList;
	*processCount = 0;

	if (rawProcessList)
	{
		int expectedBufferSize = CalculateProcessListOutputSize(rawProcessList);

		if (!listedProcessBuffer || bufferSize < expectedBufferSize)
		{
			*requiredBufferSize = expectedBufferSize;
			return STATUS_INFO_LENGTH_MISMATCH;
		}

		while (rawProcessList->NextEntryOffset)
		{
			PEPROCESS targetProcess;
			PKAPC_STATE state = NULL;

			if (NT_SUCCESS(PsLookupProcessByProcessId(rawProcessList->UniqueProcessId, &targetProcess)))
			{
				PVOID mainModuleBase = NULL;
				PVOID mainModuleEntryPoint = NULL;
				UINT32 mainModuleImageSize = 0;
				PWCHAR mainModuleFileName = NULL;
				BOOLEAN isWow64 = 0;

				__try
				{
					KeStackAttachProcess(targetProcess, &state);

					__try
					{
						mainModuleBase = PsGetProcessSectionBaseAddress(targetProcess);

						if (mainModuleBase)
						{
							PPEB64 peb = (PPEB64)PsGetProcessPeb(targetProcess);

							if (peb)
							{
								PLDR_DATA_TABLE_ENTRY mainModuleEntry = GetMainModuleDataTableEntry(peb);
								mainModuleEntry = SanitizeUserPointer(mainModuleEntry, sizeof(LDR_DATA_TABLE_ENTRY));

								if (mainModuleEntry)
								{
									mainModuleEntryPoint = mainModuleEntry->EntryPoint;
									mainModuleImageSize = mainModuleEntry->SizeOfImage;
									isWow64 = IS_WOW64_PE(mainModuleBase);

									mainModuleFileName = ExAllocatePool(NonPagedPool, 256 * sizeof(WCHAR));
									RtlZeroMemory(mainModuleFileName, 256 * sizeof(WCHAR));
									RtlCopyMemory(mainModuleFileName, mainModuleEntry->FullDllName.Buffer, 256 * sizeof(WCHAR));
								}
							}
						}
					}
					__except (GetExceptionCode())
					{
						DbgPrintEx(0, 0, "Peb Interaction Failed.\n");
					}
				}
				__finally
				{
					KeUnstackDetachProcess(&state);
				}

				if (mainModuleFileName)
				{
					RtlCopyMemory(processSummary->MainModuleFileName, mainModuleFileName, 256 * sizeof(WCHAR));
					ExFreePool(mainModuleFileName);

					processSummary->ProcessId = rawProcessList->UniqueProcessId;
					processSummary->MainModuleBase = mainModuleBase;
					processSummary->MainModuleEntryPoint = mainModuleEntryPoint;
					processSummary->MainModuleImageSize = mainModuleImageSize;
					processSummary->WOW64 = isWow64;

					processSummary++;
					(*processCount)++;
				}

				ObDereferenceObject(targetProcess);
			}

			rawProcessList = (PSYSTEM_PROCESS_INFORMATION)(((CHAR*)rawProcessList) + rawProcessList->NextEntryOffset);
		}

		ExFreePool(listHeadPointer);
		return STATUS_SUCCESS;
	}
}
```

`KsDumperDriver/ProcessLister.h`:

```h
#pragma once
#include <ntddk.h>

#pragma pack(push, 1)
typedef struct _PROCESS_SUMMARY
{
	INT32 ProcessId;
	PVOID MainModuleBase;
	WCHAR MainModuleFileName[256];
	UINT32 MainModuleImageSize;
	PVOID MainModuleEntryPoint;
	BOOLEAN WOW64;
} PROCESS_SUMMARY, *PPROCESS_SUMMARY;
#pragma pack(pop)

typedef struct _SYSTEM_PROCESS_INFORMATION
{
	ULONG NextEntryOffset;
	ULONG NumberOfThreads;
	LARGE_INTEGER SpareLi1;
	LARGE_INTEGER SpareLi2;
	LARGE_INTEGER SpareLi3;
	LARGE_INTEGER CreateTime;
	LARGE_INTEGER UserTime;
	LARGE_INTEGER KernelTime;
	UNICODE_STRING ImageName;
	KPRIORITY BasePriority;
	HANDLE UniqueProcessId;
	HANDLE InheritedFromUniqueProcessId;
	ULONG HandleCount;
	ULONG SessionId;
	ULONG_PTR PageDirectoryBase;
	SIZE_T PeakVirtualSize;
	SIZE_T VirtualSize;
	ULONG PageFaultCount;
	SIZE_T PeakWorkingSetSize;
	SIZE_T WorkingSetSize;
	SIZE_T QuotaPeakPagedPoolUsage;
	SIZE_T QuotaPagedPoolUsage;
	SIZE_T QuotaPeakNonPagedPoolUsage;
	SIZE_T QuotaNonPagedPoolUsage;
	SIZE_T PagefileUsage;
	SIZE_T PeakPagefileUsage;
	SIZE_T PrivatePageCount;
	LARGE_INTEGER ReadOperationCount;
	LARGE_INTEGER WriteOperationCount;
	LARGE_INTEGER OtherOperationCount;
	LARGE_INTEGER ReadTransferCount;
	LARGE_INTEGER WriteTransferCount;
	LARGE_INTEGER OtherTransferCount;
} SYSTEM_PROCESS_INFORMATION, *PSYSTEM_PROCESS_INFORMATION;

typedef struct _LDR_DATA_TABLE_ENTRY
{
	LIST_ENTRY InLoadOrderLinks;
	LIST_ENTRY InMemoryOrderLinks;
	CHAR Reserved0[0x10];
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;

typedef struct _PEB_LDR_DATA
{
	ULONG Length;
	BOOLEAN Initialized;
	PVOID SsHandler;
	LIST_ENTRY InLoadOrderModuleList;
	LIST_ENTRY InMemoryOrderModuleList;
	LIST_ENTRY InInitializationOrderModuleList;
	PVOID EntryInProgress;
} PEB_LDR_DATA, *PPEB_LDR_DATA;

typedef struct _PEB64 {
	CHAR Reserved[0x10];
	PVOID ImageBaseAddress;
	PPEB_LDR_DATA Ldr;
} PEB64, *PPEB64;

typedef struct _IMAGE_DOS_HEADER {
	USHORT   e_magic;
	USHORT   e_cblp;
	USHORT   e_cp;
	USHORT   e_crlc;
	USHORT   e_cparhdr;
	USHORT   e_minalloc;
	USHORT   e_maxalloc;
	USHORT   e_ss;
	USHORT   e_sp;
	USHORT   e_csum;
	USHORT   e_ip;
	USHORT   e_cs;
	USHORT   e_lfarlc;
	USHORT   e_ovno;
	USHORT   e_res[4];
	USHORT   e_oemid;
	USHORT   e_oeminfo;
	USHORT   e_res2[10];
	LONG   e_lfanew;
} IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;

typedef struct _PE_HEADER {
	CHAR Signature[4];
	USHORT Machine;
	USHORT NumberOfSections;
	UINT32 TimeDateStamp;
	UINT32 PointerToSymbolTable;
	UINT32 NumberOfSymbols;
	USHORT SizeOfOptionalHeader;
	USHORT Characteristics;
	USHORT Magic;
} PE_HEADER, *PPE_HEADER;

#define PE_HEADER_MAGIC_OFFSET 0x18
#define IMAGE_NT_OPTIONAL_HDR32_MAGIC 0x10b

#define IS_WOW64_PE( baseAddress ) (*((USHORT*)((CHAR *)baseAddress + \
								((PIMAGE_DOS_HEADER)baseAddress)->e_lfanew + PE_HEADER_MAGIC_OFFSET)) \
								== IMAGE_NT_OPTIONAL_HDR32_MAGIC)

NTSTATUS GetProcessList(PVOID listedProcessBuffer, INT32 bufferSize, PINT32 requiredBufferSize, PINT32 processCount);
```

`KsDumperDriver/UserModeBridge.h`:

```h
#pragma once
#include <ntddk.h>

#define IO_GET_PROCESS_LIST CTL_CODE(FILE_DEVICE_UNKNOWN, 0x1724, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)

#define IO_COPY_MEMORY CTL_CODE(FILE_DEVICE_UNKNOWN, 0x1725, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)

#define IO_UNLOAD_DRIVER CTL_CODE(FILE_DEVICE_UNKNOWN, 0x1726, METHOD_BUFFERED, FILE_SPECIAL_ACCESS)

typedef struct _KERNEL_PROCESS_LIST_OPERATION
{
	PVOID bufferAddress;
	INT32 bufferSize;
	INT32 processCount;
} KERNEL_PROCESS_LIST_OPERATION, *PKERNEL_PROCESS_LIST_OPERATION;

typedef struct _KERNEL_COPY_MEMORY_OPERATION
{
	INT32 targetProcessId;
	PVOID targetAddress;
	PVOID bufferAddress;
	INT32 bufferSize;
} KERNEL_COPY_MEMORY_OPERATION, *PKERNEL_COPY_MEMORY_OPERATION;
```

`KsDumperDriver/Utility.c`:

```c
#include "NTUndocumented.h"
#include "Utility.h"

NTSTATUS DriverSleep(int ms)
{
	LARGE_INTEGER li;
	li.QuadPart = -10000;

	for (int i = 0; i < ms; i++)
	{
		KeDelayExecutionThread(KernelMode, FALSE, &li);
		return STATUS_SUCCESS;
	}
	return STATUS_UNSUCCESSFUL;
}

PVOID SanitizeUserPointer(PVOID pointer, SIZE_T size)
{
	MEMORY_BASIC_INFORMATION memInfo;

	if (NT_SUCCESS(ZwQueryVirtualMemory(ZwCurrentProcess(), pointer, MemoryBasicInformation, &memInfo, sizeof(MEMORY_BASIC_INFORMATION), NULL)))
	{
		if (!(((uintptr_t)memInfo.BaseAddress + memInfo.RegionSize) < (((uintptr_t)pointer + size))))
		{
			if (memInfo.State & MEM_COMMIT || !(memInfo.Protect & (PAGE_GUARD | PAGE_NOACCESS)))
			{
				if (memInfo.Protect & PAGE_EXECUTE_READWRITE || memInfo.Protect & PAGE_EXECUTE_WRITECOPY || memInfo.Protect & PAGE_READWRITE || memInfo.Protect & PAGE_WRITECOPY)
				{
					return pointer;
				}
			}
		}
	}
	return NULL;
}

```

`KsDumperDriver/Utility.h`:

```h
#pragma once
#include <ntddk.h>

NTSTATUS DriverSleep(int ms);

PVOID SanitizeUserPointer(PVOID pointer, SIZE_T size);
```

`README.md`:

```md
# KsDumper-11
https://github.com/mastercodeon314/KsDumper-11/assets/78676320/9452970c-27cf-44df-b091-0d18a07937e5

## Whats new v1.3.4
+ Added new feature Anti Anti Debugging Tools Detection
    + Randomized MainWindow Title, most Control Titles, and the exe file name during runtime
    + The process name is reverted to KsDumper11.exe upon program closing
    + Enable Anti Anti Debugging Tools Detection check box setting added
    + This feature was added in hopes to make KsDumper 11 more stealthy when trying to dump programs that have more rudimentary Anti Debugging techniques implemented
+ Lots of source code cleanup
+ Fixed Easter Egg window that would not close upon clicking of the close button
+ Changed all labels in every form to be manually drawn to get around label text being changed when Anti Anti Debugging Tools Detection feature is enabled
+ Migrated from Application Settings to custom Settings.json for saving and loading of settings

## Whats new v1.3.3
+ Updated KDU to v1.4.1
	New providers were added, see KDU patch notes on latest release.

## Whats new v1.3.2
+ Provider selction window now has a button to reset or wipe provider settings.
	This means that all the providers will be reset to needing to be tested, and the default provider will be reset.
+ Fixed a bug in the provider selection window that would prevent it from being closed when opened from the main Dumper window.
![image](https://github.com/mastercodeon314/KsDumper-11/assets/78676320/9ffeb3a7-86c6-40ef-95f7-cd140b20143d)

## Whats new v1.3.1
+ Updated KDU to v1.4.0! Provider count is now 44

## Whats new v1.3
+ Updated KDU to KDU V1.3.4! Over 40 different providers are now available!
+ Removed the old auto detection of working providers and replaced it with a new provider selector. Users can now select which provider they want to use to load the driver. As well as test providers to see if they work on your system!
+ Testing some Providers may BSOD crash the system, KsDumper now has support for being ran again after a crash and will mark the last checked provider as non-working!
+ Anytime kdu loads and it detects a saved providers list, it will try to load the KsDumper driver using the default provider
+ Providers list and selected default provider are now saved as JSON files!
+ Updated to .NET Framework v4.8

![KsDumper v1.3 Provider Selector window](https://github.com/mastercodeon314/KsDumper-11/assets/78676320/c683b753-774b-49f0-81ca-76ed2f4dd09b)

## Whats new v1.2
+ KsDumper will now try and start the driver using the default kdu exploit provider #1 (RTCore64.sys)
+ If the default provider does not work, KsDumper will scan all kdu providers and save each one that works into a list.
+ Anytime kdu loads and it detects a saved providers list, it will try to load the KsDumper driver using each saved provider until one works.
+ This technique should increase the amount of systems that the driver will be able to be loaded on. 

## Support
You can join the official KsDumper 11 discord server where I will be managing ongoing issues. 
For those of you who find that ksDumper won't start on their system, please join the server and post your logs in the support channel. 
Please keep in mind that until others volunteer to help in development of this tool, I am only one person with a finite amount of knowledge. 
https://discord.gg/6kfWU3Ckya

## Features
- Selection of working kdu exploit providers.
- Auto dumping of selected exe.
- Unloading the KsDumper kernel driver is now supported! An option was added to unload on program exit, or system shutdown/restart.
- Splash screen for when driver is being loaded
- Auto Refresh (every 100ms)
- Suspend, resume, kill process
- Dump any process main module using a kernel driver (both x86 and x64)
- Rebuild PE32/PE64 header and sections
- ^ This can be defeated by stripping pe headers. Once pe headers are stripped, it cant dump.
- Works on protected system processes & processes with stripped handles (anti-cheats)
- Works on Windows 11, it doesnt crash anymore!
![Canary Channel Insider Build Win 11 Ksdumper](https://github.com/mastercodeon314/KsDumper-11/assets/78676320/12b05290-8856-48c6-ae03-90733c8db392)

**Note**: Import table isn't rebuilt.

## Usage
The old way of loading the unsigned ksDumper.sys kernel driver was to use the capcom exploit to map it, this got patched in windows 11.
This one loads the driver with Kernel Driver Utility, or KDU for short. 

Loading of the driver is handled by the Provider Selector now. Simply select a provider from the list, click Test Driver, and if it works, then you can click Set Default provider and it will use the selected provider to load the KsDumper driver with. 

**Note2**: Even though it can dump both x86 & x64 processes, this has to run on x64 Windows.

## Disclaimer
The new kdu provider selector can and WILL crash windows if a bad provider is tested. As such, I have implimented functionality to allow KsDumper to be ran again after a crash, and it will mark the last tested provider as non-working. This way, users will be prevented from testing that provider again and less crashes should result from general usage of KsDumper 11.
Please do beware that it can sometimes crash the OS even still. I do not take any responsibility for any damage that may occur to your system from using this tool.

Due to the nature of how KDU works to map the kernel driver, it is unknown if the system you run this on 
will have a exploitable driver according to kdu providers.
If you try to boot KsDumper 11 and it fails to start the driver, trying again as administrator.
If it still fails post the log. There is a manualloader.bat you can try as well to see the output directly.
You MUST run KsDumper at least once for the kdu.exe file and its dlls to be self extracted for the ManualLoader.bat to work.

This project has been made available for informational and educational purposes only.
Considering the nature of this project, it is highly recommended to run it in a `Virtual Environment`. I am not responsible for any crash or damage that could happen to your system.

**Important**: This tool makes no attempt at hiding itself. If you target protected games, the anti-cheat might flag this as a cheat and ban you after a while. Use a `Virtual Environment` !

## Donation links
Anything is super helpful! Anything donated helps me keep developing this program and others!
- https://www.paypal.com/paypalme/lifeline42
- https://cash.app/$Mastercodeon3142

## References
- https://github.com/EquiFox/KsDumper
- https://github.com/hfiref0x/KDU
- https://github.com/not-wlan/drvmap
- https://github.com/Zer0Mem0ry/KernelBhop
- https://github.com/NtQuery/Scylla/
- http://terminus.rewolf.pl/terminus/
- https://www.unknowncheats.me/

## Compile Yourself
- Requires Visual Studio 2022 (must use 2019 for compiling the driver, and 2019 wdk)
- Requires .NET 4.8
- Window Driver Framework (WDK)
```

`Version.json`:

```json
{
    "version": "1.3.5",
    "url": "https://github.com/mastercodeon314/KsDumper-11/releases/download/1.3.4/KsDumper11.v1.3.4.zip",
    "changelog": "https://github.com/mastercodeon314/KsDumper-11/releases/tag/1.3.4"
}

```