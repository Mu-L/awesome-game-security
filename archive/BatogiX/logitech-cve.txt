Project Path: arc_BatogiX_logitech-cve_3qtcvpx6

Source Tree:

```txt
arc_BatogiX_logitech-cve_3qtcvpx6
├── Cargo.lock
├── Cargo.toml
├── LICENSE-APACHE
├── LICENSE-MIT
├── README.md
├── rustfmt.toml
├── src
│   ├── device.rs
│   ├── keyboard.rs
│   ├── lib.rs
│   ├── mouse.rs
│   └── util.rs
└── tests
    ├── common
    │   └── mod.rs
    ├── keyboard_tests.rs
    └── mouse_tests.rs

```

`Cargo.lock`:

```lock
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 4

[[package]]
name = "logitech-cve"
version = "1.5.3"
dependencies = [
 "windows-sys",
]

[[package]]
name = "windows-link"
version = "0.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "5e6ad25900d524eaabdbbb96d20b4311e1e7ae1699af4fb28c17ae66c80d798a"

[[package]]
name = "windows-sys"
version = "0.60.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f2f500e4d28234f72040990ec9d39e3a6b950f9f22d3dba18416c35882612bcb"
dependencies = [
 "windows-targets",
]

[[package]]
name = "windows-targets"
version = "0.53.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d5fe6031c4041849d7c496a8ded650796e7b6ecc19df1a431c1a363342e5dc91"
dependencies = [
 "windows-link",
 "windows_aarch64_gnullvm",
 "windows_aarch64_msvc",
 "windows_i686_gnu",
 "windows_i686_gnullvm",
 "windows_i686_msvc",
 "windows_x86_64_gnu",
 "windows_x86_64_gnullvm",
 "windows_x86_64_msvc",
]

[[package]]
name = "windows_aarch64_gnullvm"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "86b8d5f90ddd19cb4a147a5fa63ca848db3df085e25fee3cc10b39b6eebae764"

[[package]]
name = "windows_aarch64_msvc"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c7651a1f62a11b8cbd5e0d42526e55f2c99886c77e007179efff86c2b137e66c"

[[package]]
name = "windows_i686_gnu"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c1dc67659d35f387f5f6c479dc4e28f1d4bb90ddd1a5d3da2e5d97b42d6272c3"

[[package]]
name = "windows_i686_gnullvm"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ce6ccbdedbf6d6354471319e781c0dfef054c81fbc7cf83f338a4296c0cae11"

[[package]]
name = "windows_i686_msvc"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "581fee95406bb13382d2f65cd4a908ca7b1e4c2f1917f143ba16efe98a589b5d"

[[package]]
name = "windows_x86_64_gnu"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2e55b5ac9ea33f2fc1716d1742db15574fd6fc8dadc51caab1c16a3d3b4190ba"

[[package]]
name = "windows_x86_64_gnullvm"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0a6e035dd0599267ce1ee132e51c27dd29437f63325753051e71dd9e42406c57"

[[package]]
name = "windows_x86_64_msvc"
version = "0.53.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "271414315aff87387382ec3d271b52d7ae78726f5d44ac98b4f4030c91880486"

```

`Cargo.toml`:

```toml
[package]
name = "logitech-cve"
version = "1.5.3"
edition = "2024"
description = "A Rust library for interacting with Logitech virtual driver."
license = "MIT OR Apache-2.0"
repository = "https://github.com/BatogiX/logitech-cve"
homepage = "https://github.com/BatogiX/logitech-cve"
documentation = "https://docs.rs/logitech-cve"
keywords = ["logitech", "rust", "windows", "library"]
categories = ["os::windows-apis", "api-bindings"]
readme = "README.md"

[dependencies]
windows-sys = { version = "0.60.2", default-features = false, features = [
    'Wdk_Foundation',
    'Wdk_Storage_FileSystem',
    'Wdk_System_IO',
    "Wdk_System_SystemServices",
    'Win32_Foundation',
    'Win32_Security',
    'Win32_Storage_FileSystem',
    'Win32_System_IO',
    'Win32_System_WindowsProgramming',
    "Win32_UI_WindowsAndMessaging",
] }

[dev-dependencies]
windows-sys = { version = "0.60.2", default-features = false, features = [
    "Win32_System_LibraryLoader",
    "Win32_UI_Input_KeyboardAndMouse",
] }

```

`LICENSE-APACHE`:

```
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright 2025 BatogiX

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

```

`LICENSE-MIT`:

```
MIT License

Copyright (c) 2025 BatogiX

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

`README.md`:

```md
# logitech-cve

A Rust library for interacting with Logitech virtual driver.

# Usage
## Mouse
### Example
```rust
use logitech_cve::{
    device::Device,
    mouse::{Mouse, MouseButton}
};

fn main() {
	let device = Device::try_new().expect("Logitech G HUB 2021.11.1775 is not installed"); // Req for Driver Handling
	let mouse = Mouse::new(&device); // Init Mouse

	mouse.move_relative(MouseButtons::Release, 100, 100); // (x,y) relative
    mouse.move_absolute(MouseButtons::Left, 100, 100, 30); // (x,y) absolute and 30ms between each step

	mouse.wheel(1); // Scroll up
	mouse.wheel(-1); // Scroll down

	mouse.click(MouseButtons::Left, 120); // Press and sleeps for 120ms before release

	// OR

	mouse.press(MouseButtons::Left); // Press
	std::thread::sleep(std::time::Duration(100)); // Custom sleep
	mouse.release(); // Release
}
```

## Keyboard
### Example
```rust
use logitech_cve::{
    device::Device,
    keyboard::{Keyboard, Key}
};

fn main() {
	let device = Device::try_new().expect("Logitech G HUB 2021.11.1775 is not installed"); // Req for Driver Handling
	let keyboard = Keyboard::new(&device); // Init Keyboard

	keyboard.press_and_release(Key::A, 120); // Press and sleeps for 120ms before release

    // Press multiple buttons
	keyboard.multi_press(Key::A, Key::B, Key::C, Key::Release, Key::Release, Key::Release);
	std::thread::sleep(std::time::Duration(100)); // Custom sleep
	keyboard.release(); // Release all buttons

	// Types "Hello, World!" with 50ms before release each button
	keyboard.type_string("Hello, World!", 50).expect("Should be OK");
}
```

## Requirements

- Logitech G HUB 2021.11.1775

## Credits

- [ekknod/logitech-cve](https://github.com/ekknod/logitech-cve)

```

`rustfmt.toml`:

```toml
max_width = 120
```

`src/device.rs`:

```rs
use core::{mem, ptr};

use windows_sys::{
    Wdk::{
        Foundation::OBJECT_ATTRIBUTES,
        Storage::FileSystem::{FILE_NON_DIRECTORY_FILE, FILE_OPEN_IF, FILE_SYNCHRONOUS_IO_NONALERT, NtCreateFile},
        System::{IO::NtDeviceIoControlFile, SystemServices::ZwClose},
    },
    Win32::{
        Foundation::{GENERIC_WRITE, HANDLE, NTSTATUS, STATUS_SUCCESS, UNICODE_STRING},
        Storage::FileSystem::{FILE_ATTRIBUTE_NORMAL, FILE_SHARE_NONE, SYNCHRONIZE},
        System::{IO::IO_STATUS_BLOCK, WindowsProgramming::RtlInitUnicodeString},
    },
    core::PCWSTR,
};

use crate::{keyboard::Key, mouse::MouseButton, util::InitializeObjectAttributes};

/// I/O structure used to communicate mouse actions to the device driver.
#[repr(C)]
struct MouseIO {
    /// The mouse button state/action to perform.
    button: u8,
    /// The X-axis movement delta.
    x: i8,
    /// The Y-axis movement delta.
    y: i8,
    /// The mouse wheel movement delta.
    wheel: i8,
    /// Unknown field, always set to 0.
    unk1: i8,
}

impl MouseIO {
    /// Creates a new `MouseIO` instance with the specified parameters.
    ///
    /// # Arguments
    /// * `button` - The mouse button state/action to perform
    /// * `x` - The X-axis movement delta
    /// * `y` - The Y-axis movement delta
    /// * `wheel` - The mouse wheel movement delta
    ///
    /// # Returns
    /// A new `MouseIO` instance with `unk1` set to 0
    #[inline]
    const fn new(button: u8, x: i8, y: i8, wheel: i8) -> Self {
        let unk1 = 0;
        Self {
            button,
            x,
            y,
            wheel,
            unk1,
        }
    }
}

/// I/O structure used to communicate keyboard button states to the device driver.
#[repr(C)]
struct KeyboardIO {
    /// Unknown field, always set to 0.
    unknown1: u8,
    /// Unknown field, always set to 0.
    unknown2: u8,
    /// State of keyboard button 1.
    button1: u8,
    /// State of keyboard button 2.
    button2: u8,
    /// State of keyboard button 3.
    button3: u8,
    /// State of keyboard button 4.
    button4: u8,
    /// State of keyboard button 5.
    button5: u8,
    /// State of keyboard button 6.
    button6: u8,
}

impl KeyboardIO {
    /// Creates a new `KeyboardIO` instance with the specified button states.
    ///
    /// # Arguments
    /// * `button1` through `button6` - The states of keyboard buttons 1-6
    ///
    /// # Returns
    /// A new `KeyboardIO` instance with unknown fields set to 0
    #[inline]
    const fn new(button1: u8, button2: u8, button3: u8, button4: u8, button5: u8, button6: u8) -> Self {
        let unknown1 = 0;
        let unknown2 = 0;
        Self {
            unknown1,
            unknown2,
            button1,
            button2,
            button3,
            button4,
            button5,
            button6,
        }
    }
}

/// Represents a handle to the virtual input device.
pub struct Device {
    /// Handle to the device file.
    filehandle: HANDLE,
}

impl Drop for Device {
    #[inline]
    fn drop(&mut self) {
        self.close();
    }
}

impl Device {
    /// Attempts to open the device and return a [`Device`] instance.
    ///
    /// # Errors
    /// Returns an error if the device cannot be opened (e.g., G HUB not installed or incompatible version).
    #[inline]
    pub fn try_new() -> Result<Self, &'static str> {
        let filehandle = HANDLE::default();

        let mut device = Self { filehandle };

        if !device.open() {
            return Err("Device not found. Consider to download Logitech G HUB 2021.11.1775");
        }

        Ok(device)
    }

    /// Calls the device IOCTL.
    ///
    /// # Arguments
    /// * `button` - The mouse button action to perform (e.g., left click, right click, release)
    /// * `x` - Horizontal movement delta in pixels. Positive values move right, negative values move left
    /// * `y` - Vertical movement delta in pixels. Positive values move down, negative values move up
    /// * `wheel` - Mouse wheel scroll delta. Positive values scroll up, negative values scroll down
    ///
    /// # Warning
    /// The value `-128` for `x`, `y` or `wheel` is treated as `0`.
    /// To avoid unexpected behavior, use `-127` instead.
    ///
    /// # Returns
    /// `true` if the IOCTL call was successful, `false` otherwise.
    #[expect(
        clippy::must_use_candidate,
        reason = "This function is used to send mouse input commands"
    )]
    #[inline]
    pub fn call_mouse(&self, button: MouseButton, x: i8, y: i8, wheel: i8) -> bool {
        #[expect(clippy::cast_possible_truncation, reason = "MouseIO is only 5 bytes")]
        const INPUTBUFFERLENGTH: u32 = mem::size_of::<MouseIO>() as u32;
        let mut iostatusblock = IO_STATUS_BLOCK::default();
        let inputbuffer = MouseIO::new(button.into(), x, y, wheel);

        // SAFETY: All pointers passed to NtDeviceIoControlFile are either valid, null, or point to properly initialized structures as required by the API.
        let status = unsafe {
            NtDeviceIoControlFile(
                self.filehandle,
                ptr::null_mut(),
                None,
                ptr::null(),
                &raw mut iostatusblock,
                0x002A_2010,
                (&raw const inputbuffer).cast(),
                INPUTBUFFERLENGTH,
                ptr::null_mut(),
                0,
            )
        };
        status == STATUS_SUCCESS
    }

    /// Calls the device IOCTL.
    ///
    /// # Arguments
    /// * `button1` through `button6` - The states of keyboard buttons 1-6. Each parameter represents
    ///   the desired state of a specific key position. Use `Key::None`
    ///   for keys that should not be pressed.
    ///
    /// # Returns
    /// `true` if the IOCTL call was successful, `false` otherwise.
    #[expect(
        clippy::must_use_candidate,
        reason = "This function is used to send keyboard input commands"
    )]
    #[inline]
    pub fn call_keyboard(
        &self,
        button1: Key,
        button2: Key,
        button3: Key,
        button4: Key,
        button5: Key,
        button6: Key,
    ) -> bool {
        #[expect(clippy::cast_possible_truncation, reason = "KeyboardIO is only 8 bytes")]
        const INPUTBUFFERLENGTH: u32 = mem::size_of::<KeyboardIO>() as u32;
        let mut iostatusblock = IO_STATUS_BLOCK::default();
        let inputbuffer = KeyboardIO::new(
            button1.into(),
            button2.into(),
            button3.into(),
            button4.into(),
            button5.into(),
            button6.into(),
        );

        // SAFETY: All pointers passed to NtDeviceIoControlFile are either valid, null, or point to properly initialized structures as required by the API.
        let status = unsafe {
            NtDeviceIoControlFile(
                self.filehandle,
                ptr::null_mut(),
                None,
                ptr::null(),
                &raw mut iostatusblock,
                0x002A_200C,
                (&raw const inputbuffer).cast(),
                INPUTBUFFERLENGTH,
                ptr::null_mut(),
                0,
            )
        };
        status == STATUS_SUCCESS
    }

    /// Tries to open the device by testing multiple known device paths.
    ///
    /// # Returns
    /// `true` if a device was successfully opened, `false` otherwise.
    fn open(&mut self) -> bool {
        const BUFFERS: [*const u16; 2] = [
            windows_sys::w!("\\??\\ROOT#SYSTEM#0001#{1abc05c0-c378-41b9-9cef-df1aba82b015}"),
            windows_sys::w!("\\??\\ROOT#SYSTEM#0002#{1abc05c0-c378-41b9-9cef-df1aba82b015}"),
        ];

        for buffer in BUFFERS {
            if self.device_initialize(buffer) == STATUS_SUCCESS {
                return true;
            }
        }

        false
    }

    /// Initializes the device by opening a handle to it.
    ///
    /// # Arguments
    /// * `device_name` - A `PCWSTR` representing the path to the device.
    ///
    /// # Returns
    /// An `NTSTATUS` indicating the success or failure of the operation.
    fn device_initialize(&mut self, device_name: PCWSTR) -> NTSTATUS {
        let mut name = UNICODE_STRING::default();
        let mut attr = OBJECT_ATTRIBUTES::default();
        let mut iostatusblock = IO_STATUS_BLOCK::default();

        // SAFETY: RtlInitUnicodeString requires a valid pointer to a UNICODE_STRING and a valid PCWSTR.
        unsafe {
            RtlInitUnicodeString(&raw mut name, device_name);
        };
        InitializeObjectAttributes(&mut attr, &raw const name, 0, ptr::null_mut(), ptr::null());

        // SAFETY: NtCreateFile requires properly initialized pointers and structures as per API contract.
        unsafe {
            NtCreateFile(
                &raw mut self.filehandle,
                GENERIC_WRITE | SYNCHRONIZE,
                &raw const attr,
                &raw mut iostatusblock,
                ptr::null::<i64>(), // AllocationSize (optional)
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_NONE,
                FILE_OPEN_IF, // CreateDisposition (OPEN_EXISTING)
                FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                ptr::null(),
                0,
            )
        }
    }

    /// Closes the handle to the device.
    ///
    /// This method safely closes the device handle if it's currently open,
    /// and sets the handle to null to prevent double-closing.
    fn close(&mut self) {
        if !self.filehandle.is_null() {
            // SAFETY: ZwClose is only called if filehandle is not null, and filehandle is set to null after closing to prevent double-closing.
            unsafe {
                ZwClose(self.filehandle);
            };
            self.filehandle = ptr::null_mut();
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn open_close() {
        let mut device = Device {
            filehandle: HANDLE::default(),
        };

        assert!(device.open());
        device.close();
        assert!(device.filehandle.is_null());
    }
}

```

`src/keyboard.rs`:

```rs
use crate::device::Device;
use core::time::Duration;
use std::thread;

#[repr(u8)]
#[derive(Copy, Clone)]
/// Represents keyboard keys with their corresponding scan codes.
///
/// This enum maps keyboard keys to their usage codes, which are used
/// for sending keyboard input to device. Each variant corresponds to a specific
/// physical key on a standard keyboard layout.
pub enum Key {
    /// The 'A' key
    A = 0x4,
    /// The 'B' key
    B = 0x5,
    /// The 'C' key
    C = 0x6,
    /// The 'D' key
    D = 0x7,
    /// The 'E' key
    E = 0x8,
    /// The 'F' key
    F = 0x9,
    /// The 'G' key
    G = 0xA,
    /// The 'H' key
    H = 0xB,
    /// The 'I' key
    I = 0xC,
    /// The 'J' key
    J = 0xD,
    /// The 'K' key
    K = 0xE,
    /// The 'L' key
    L = 0xF,
    /// The 'M' key
    M = 0x10,
    /// The 'N' key
    N = 0x11,
    /// The 'O' key
    O = 0x12,
    /// The 'P' key
    P = 0x13,
    /// The 'Q' key
    Q = 0x14,
    /// The 'R' key
    R = 0x15,
    /// The 'S' key
    S = 0x16,
    /// The 'T' key
    T = 0x17,
    /// The 'U' key
    U = 0x18,
    /// The 'V' key
    V = 0x19,
    /// The 'W' key
    W = 0x1A,
    /// The 'X' key
    X = 0x1B,
    /// The 'Y' key
    Y = 0x1C,
    /// The 'Z' key
    Z = 0x1D,
    /// The '1' number key
    N1 = 0x1E,
    /// The '2' number key
    N2 = 0x1F,
    /// The '3' number key
    N3 = 0x20,
    /// The '4' number key
    N4 = 0x21,
    /// The '5' number key
    N5 = 0x22,
    /// The '6' number key
    N6 = 0x23,
    /// The '7' number key
    N7 = 0x24,
    /// The '8' number key
    N8 = 0x25,
    /// The '9' number key
    N9 = 0x26,
    /// The '0' number key
    N0 = 0x27,
    /// The Enter/Return key
    Enter = 0x28,
    /// The Escape key
    Esc = 0x29,
    /// The Backspace key
    BackSpace = 0x2A,
    /// The Tab key
    Tab = 0x2B,
    /// The Space bar
    Space = 0x2C,
    /// The minus/hyphen key (-)
    Minus = 0x2D,
    /// The equals key (=)
    Equal = 0x2E,
    /// The left square bracket key ([)
    SquareBracketLeft = 0x2F,
    /// The right square bracket key (])
    SquareBracketRight = 0x30,
    /// The backslash key (\)
    BackSlash = 0x31,
    /// Alternative backslash key
    BackSlash_ = 0x32,
    /// The semicolon/colon key (;)
    Column = 0x33,
    /// The single quote/apostrophe key (')
    Quote = 0x34,
    /// The backtick/grave accent key (\`)
    BackTick = 0x35,
    /// The comma key (,)
    Comma = 0x36,
    /// The period/dot key (.)
    Period = 0x37,
    /// The forward slash key (/)
    Slash = 0x38,
    /// The Caps Lock key
    Cap = 0x39,
    /// Function key F1
    F1 = 0x3A,
    /// Function key F2
    F2 = 0x3B,
    /// Function key F3
    F3 = 0x3C,
    /// Function key F4
    F4 = 0x3D,
    /// Function key F5
    F5 = 0x3E,
    /// Function key F6
    F6 = 0x3F,
    /// Function key F7
    F7 = 0x40,
    /// Function key F8
    F8 = 0x41,
    /// Function key F9
    F9 = 0x42,
    /// Function key F10
    F10 = 0x43,
    /// Function key F11
    F11 = 0x44,
    /// Function key F12
    F12 = 0x45,
    /// Print Screen/Snapshot key
    Snapshot = 0x46,
    /// Scroll Lock key
    ScrollLock = 0x47,
    /// Pause/Break key
    Pause = 0x48,
    /// Insert key
    Insert = 0x49,
    /// Home key
    Home = 0x4A,
    /// Page Up key
    PageUp = 0x4B,
    /// Delete key
    Del = 0x4C,
    /// End key
    End = 0x4D,
    /// Page Down key
    PageDown = 0x4E,
    /// Right arrow key
    Right = 0x4F,
    /// Left arrow key
    Left = 0x50,
    /// Down arrow key
    Down = 0x51,
    /// Up arrow key
    Up = 0x52,
    /// Num Lock key
    Numlock = 0x53,
    /// Numeric keypad division key (/)
    NumpadDiv = 0x54,
    /// Numeric keypad multiplication key (*)
    NumpadMul = 0x55,
    /// Numeric keypad minus key (-)
    NumpadMinus = 0x56,
    /// Numeric keypad plus key (+)
    NumpadPlus = 0x57,
    /// Numeric keypad Enter key
    NumpadEnter = 0x58,
    /// Numeric keypad 1 key
    Numpad1 = 0x59,
    /// Numeric keypad 2 key
    Numpad2 = 0x5A,
    /// Numeric keypad 3 key
    Numpad3 = 0x5B,
    /// Numeric keypad 4 key
    Numpad4 = 0x5C,
    /// Numeric keypad 5 key
    Numpad5 = 0x5D,
    /// Numeric keypad 6 key
    Numpad6 = 0x5E,
    /// Numeric keypad 7 key
    Numpad7 = 0x5F,
    /// Numeric keypad 8 key
    Numpad8 = 0x60,
    /// Numeric keypad 9 key
    Numpad9 = 0x61,
    /// Numeric keypad 0 key
    Numpad0 = 0x62,
    /// Numeric keypad decimal point key (.)
    NumpadDec = 0x63,
    /// Application/Menu key
    Apps = 0x65,
    /// Function key F13
    F13 = 0x68,
    /// Function key F14
    F14 = 0x69,
    /// Function key F15
    F15 = 0x6A,
    /// Function key F16
    F16 = 0x6B,
    /// Function key F17
    F17 = 0x6C,
    /// Function key F18
    F18 = 0x6D,
    /// Function key F19
    F19 = 0x6E,
    /// Function key F20
    F20 = 0x6F,
    /// Function key F21
    F21 = 0x70,
    /// Function key F22
    F22 = 0x71,
    /// Function key F23
    F23 = 0x72,
    /// Function key F24
    F24 = 0x73,
    /// Right Windows key
    Rwin = 0x8C,
    /// Alternative F24 key
    F24_ = 0x94,
    /// Left Control key
    Lctrl = 0xE0,
    /// Left Shift key
    Lshift = 0xE1,
    /// Left Alt key
    Lalt = 0xE2,
    /// Left Windows key
    Lwin = 0xE3,
    /// Right Control key
    Rctrl = 0xE4,
    /// Right Shift key
    Rshift = 0xE5,
    /// Right Alt key
    Ralt = 0xE6,
    /// Alternative Right Windows key
    Rwin_ = 0xE7,
    /// No key pressed (release state)
    Release = 0x0,
}

impl From<Key> for u8 {
    #[inline]
    fn from(button: Key) -> Self {
        button as Self
    }
}

impl TryFrom<char> for Key {
    type Error = String;

    fn try_from(c: char) -> Result<Self, Self::Error> {
        match c.to_ascii_uppercase() {
            'A' => Ok(Self::A),
            'B' => Ok(Self::B),
            'C' => Ok(Self::C),
            'D' => Ok(Self::D),
            'E' => Ok(Self::E),
            'F' => Ok(Self::F),
            'G' => Ok(Self::G),
            'H' => Ok(Self::H),
            'I' => Ok(Self::I),
            'J' => Ok(Self::J),
            'K' => Ok(Self::K),
            'L' => Ok(Self::L),
            'M' => Ok(Self::M),
            'N' => Ok(Self::N),
            'O' => Ok(Self::O),
            'P' => Ok(Self::P),
            'Q' => Ok(Self::Q),
            'R' => Ok(Self::R),
            'S' => Ok(Self::S),
            'T' => Ok(Self::T),
            'U' => Ok(Self::U),
            'V' => Ok(Self::V),
            'W' => Ok(Self::W),
            'X' => Ok(Self::X),
            'Y' => Ok(Self::Y),
            'Z' => Ok(Self::Z),
            '\n' => Ok(Self::Enter),
            '\t' => Ok(Self::Tab),
            ' ' => Ok(Self::Space),
            '1' | '!' => Ok(Self::N1),                 // ! for Shift + 1
            '2' | '@' => Ok(Self::N2),                 // @ for Shift + 2
            '3' | '#' => Ok(Self::N3),                 // # for Shift + 3
            '4' | '$' => Ok(Self::N4),                 // $ for Shift + 4
            '5' | '%' => Ok(Self::N5),                 // % for Shift + 5
            '6' | '^' => Ok(Self::N6),                 // ^ for Shift + 6
            '7' | '&' => Ok(Self::N7),                 // & for Shift + 7
            '8' | '*' => Ok(Self::N8),                 // * for Shift + 8
            '9' | '(' => Ok(Self::N9),                 // ( for Shift + 9
            '0' | ')' => Ok(Self::N0),                 // ) for Shift + 0
            '-' | '_' => Ok(Self::Minus),              // _ for Shift + -
            '=' => Ok(Self::Equal),                    // + for Shift + =
            '[' | '{' => Ok(Self::SquareBracketLeft),  // { for Shift + [
            ']' | '}' => Ok(Self::SquareBracketRight), // } for Shift + ]
            ';' | ':' => Ok(Self::Column),             // : for Shift + ;
            '\'' | '"' => Ok(Self::Quote),             // " for Shift + '
            '\\' | '|' => Ok(Self::BackSlash),         // | for Shift + \
            ',' | '<' => Ok(Self::Comma),              // < for Shift + ,
            '.' | '>' => Ok(Self::Period),             // > for Shift + .
            '/' | '?' => Ok(Self::Slash),              // ? for Shift + /
            '`' | '~' => Ok(Self::BackTick),           // ~ for Shift + `
            _ => Err(format!("Unsupported character: {c}")),
        }
    }
}

/// A struct for controlling a virtual keyboard.
///
/// It holds a reference to a `Device` which is used to send the keyboard commands.
pub struct Keyboard<'a> {
    /// A reference to the device used to send keyboard commands.
    device: &'a Device,
}

impl<'a> Keyboard<'a> {
    /// Creates a new [`Keyboard`].
    #[must_use]
    pub const fn new(device: &'a Device) -> Self {
        Self { device }
    }

    /// Presses a single keyboard button.
    ///
    /// The button is held down until a `release()` or `multi_press()` with `Key::NONE` is called.
    ///
    /// # Arguments
    ///
    /// * `button` - The `Key` to press.
    #[inline]
    pub fn press(&self, button: Key) {
        self.device.call_keyboard(
            button,
            Key::Release,
            Key::Release,
            Key::Release,
            Key::Release,
            Key::Release,
        );
    }

    /// Releases all currently pressed keyboard buttons.
    ///
    /// This effectively sends a "no keys pressed" command to the device.
    #[inline]
    pub fn release(&self) {
        self.device.call_keyboard(
            Key::Release,
            Key::Release,
            Key::Release,
            Key::Release,
            Key::Release,
            Key::Release,
        );
    }

    /// Presses and releases a single keyboard button.
    ///
    /// The button is pressed down, held for the specified duration, then released.
    ///
    /// # Arguments
    ///
    /// * `button` - The `Key` to press and release.
    /// * `millis` - The duration in milliseconds to hold the button down before releasing it.
    pub fn press_and_release(&self, button: Key, millis: u64) {
        self.device.call_keyboard(
            button,
            Key::Release,
            Key::Release,
            Key::Release,
            Key::Release,
            Key::Release,
        );
        thread::sleep(Duration::from_millis(millis));
        self.device.call_keyboard(
            Key::Release,
            Key::Release,
            Key::Release,
            Key::Release,
            Key::Release,
            Key::Release,
        );
    }

    /// Presses up to six keyboard buttons simultaneously.
    ///
    /// This can be used for pressing modifier keys and other keys at the same time.
    ///
    /// # Arguments
    ///
    /// * `button1` - The first `Key` to press.
    /// * `button2` - The second `Key` to press.
    /// * `button3` - The third `Key` to press.
    /// * `button4` - The fourth `Key` to press.
    /// * `button5` - The fifth `Key` to press.
    /// * `button6` - The sixth `Key` to press.
    #[inline]
    pub fn multi_press(&self, button1: Key, button2: Key, button3: Key, button4: Key, button5: Key, button6: Key) {
        self.device
            .call_keyboard(button1, button2, button3, button4, button5, button6);
    }

    /// Types a string by simulating individual key presses for each character.
    ///
    /// # Arguments
    ///
    /// * `string` - The string to be typed.
    /// * `millis` - The duration in milliseconds to hold the button down before releasing it.
    ///
    /// # Errors
    ///
    /// This function will return an error if a character in the input string
    /// cannot be converted into a valid `Key` enum variant.
    pub fn type_string(&self, string: &str, millis: u64) -> Result<(), String> {
        for c in string.chars() {
            let key = Key::try_from(c)?;
            match c {
                'a'..='z'
                | '0'..='9'
                | '\n'
                | '\t'
                | ' '
                | '-'
                | '='
                | '['
                | ']'
                | '\\'
                | ';'
                | '\''
                | '`'
                | ','
                | '.'
                | '/' => self.press_and_release(key, millis),

                'A'..='Z'
                | '!'
                | '@'
                | '#'
                | '$'
                | '%'
                | '^'
                | '&'
                | '*'
                | '('
                | ')'
                | '_'
                | '+'
                | '{'
                | '}'
                | ':'
                | '"'
                | '|'
                | '<'
                | '>'
                | '?'
                | '~' => {
                    self.multi_press(Key::Lshift, key, Key::Release, Key::Release, Key::Release, Key::Release);
                    thread::sleep(Duration::from_millis(millis));
                    self.release();
                }
                _ => {}
            }
        }

        Ok(())
    }
}

```

`src/lib.rs`:

```rs
//! # Logitech CVE library.
//! `logitech-cve` provides modules `device`, `keyboard` and `mouse`.

#![deny(
    clippy::pedantic,
    clippy::cargo,
    clippy::nursery,
    missing_docs,
    rustdoc::missing_crate_level_docs,
    unused_imports
)]

/// Core functionality.
pub mod device;
/// Keyboard-related functionality.
pub mod keyboard;
/// Mouse-related functionality.
pub mod mouse;

/// Utility functions for the Logitech CVE library.
mod util;

```

`src/mouse.rs`:

```rs
use core::{cmp::Ordering, time::Duration};
use std::thread;

use windows_sys::Win32::{Foundation::POINT, UI::WindowsAndMessaging::GetCursorPos};

use crate::device::Device;

#[repr(u8)]
#[derive(Copy, Clone)]
/// Represents mouse button states and combinations.
///
/// This enum defines individual mouse buttons and their combinations,
/// with values that can be used as bitmasks for mouse operations.
pub enum MouseButton {
    /// Left mouse button.
    Left = 1,
    /// Right mouse button.
    Right = 2,
    /// Middle mouse button (wheel click).
    Middle = 4,
    /// Left and right mouse buttons pressed simultaneously.
    LeftRight = 3,
    /// Left and middle mouse buttons pressed simultaneously.
    LeftMiddle = 5,
    /// Right and middle mouse buttons pressed simultaneously.
    RightMiddle = 6,
    /// All mouse buttons pressed simultaneously.
    All = 7,
    /// No mouse buttons pressed (release state).
    Release = 0,
}

impl From<MouseButton> for u8 {
    #[inline]
    fn from(button: MouseButton) -> Self {
        button as Self
    }
}

/// A struct for controlling a virtual mouse.
///
/// It holds a reference to a `Device` which is used to send the mouse commands.
pub struct Mouse<'a> {
    /// Reference to the device used for sending mouse commands.
    device: &'a Device,
}

impl<'a> Mouse<'a> {
    /// Creates a new [`Mouse`].
    #[must_use]
    pub const fn new(device: &'a Device) -> Self {
        Self { device }
    }

    /// Performs a click and release action with a specified button.
    ///
    /// The button is pressed, held for `millis` milliseconds, and then released.
    ///
    /// # Arguments
    ///
    /// * `button` - The `MouseButton` to click.
    /// * `millis` - The duration, in milliseconds, to hold the button down.
    pub fn click(&self, button: MouseButton, millis: u64) {
        self.device.call_mouse(button, 0, 0, 0);
        thread::sleep(Duration::from_millis(millis));
        self.device.call_mouse(MouseButton::Release, 0, 0, 0);
    }

    /// Moves the mouse cursor to an absolute screen coordinate (x, y) with a simulated smooth movement.
    ///
    /// The movement is broken down into smaller steps, with a delay between each step.
    ///
    /// # Arguments
    ///
    /// * `button` - The `MouseButton` to hold down during the movement (e.g., for dragging). Use `MouseButton::Release` for no buttons.
    /// * `x` - The target horizontal coordinate.
    /// * `y` - The target vertical coordinate.
    /// * `millis` - The delay, in milliseconds, between each small movement step.
    #[expect(
        clippy::cast_possible_truncation,
        reason = "Casting is safe here because mouse movement steps are always within i8 range."
    )]
    pub fn move_absolute(&self, button: MouseButton, x: u16, y: u16, millis: u64) {
        const MIN_STEP_SIZE: i8 = -127; // -128 Does not work for some reason
        const MAX_STEP_SIZE: i8 = 127;

        #[inline]
        fn calculate_steps_and_size(delta: i32) -> (i32, i8) {
            if delta < 0 {
                return (delta / i32::from(MIN_STEP_SIZE), MIN_STEP_SIZE);
            }
            (delta / i32::from(MAX_STEP_SIZE), MAX_STEP_SIZE)
        }

        // Get current mouse position
        let mut current_point = POINT::default();
        // SAFETY: `current_point` is a valid pointer to a POINT struct, as required by GetCursorPos.
        unsafe {
            GetCursorPos(&raw mut current_point);
        };

        // Calculate deltas
        let delta_x = i32::from(x) - current_point.x;
        let delta_y = i32::from(y) - current_point.y;

        // Calculate the number of steps and step sizes for both X and Y
        let (steps_x, mut x_step) = calculate_steps_and_size(delta_x);
        let (steps_y, mut y_step) = calculate_steps_and_size(delta_y);

        let (final_step_x, final_step_y);
        if steps_x > 0 || steps_y > 0 {
            // Determine which axis takes more steps
            let steps;
            match steps_x.cmp(&steps_y) {
                Ordering::Greater => {
                    steps = steps_x;
                    y_step = (delta_y / steps) as i8;
                }
                Ordering::Less => {
                    steps = steps_y;
                    x_step = (delta_x / steps) as i8;
                }
                Ordering::Equal => {
                    steps = steps_x; // or steps_y, they are equal
                }
            }

            final_step_x = (delta_x - (i32::from(x_step) * steps)) as i8;
            final_step_y = (delta_y - (i32::from(y_step) * steps)) as i8;
            // Perform the movement in steps
            for _ in 0..steps {
                self.move_relative(button, x_step, y_step);
                thread::sleep(Duration::from_millis(millis));
            }
        } else {
            final_step_x = delta_x as i8;
            final_step_y = delta_y as i8;
        }

        // Ensure the final move reaches the target
        self.move_relative(button, final_step_x, final_step_y);
    }

    /// Moves the mouse cursor by a relative offset from its current position.
    ///
    /// # Arguments
    ///
    /// * `button` - The `MouseButton` to hold down during the movement.
    /// * `x` - The horizontal offset. Positive values move right, negative move left.
    /// * `y` - The vertical offset. Positive values move down, negative move up.
    #[inline]
    pub fn move_relative(&self, button: MouseButton, x: i8, y: i8) {
        self.device.call_mouse(button, x, y, 0);
    }

    /// Presses and holds a specified mouse button.
    ///
    /// This method only presses the button; you must call `release()` to release it.
    ///
    /// # Arguments
    ///
    /// * `button` - The `MouseButton` to press.
    #[inline]
    pub fn press(&self, button: MouseButton) {
        self.device.call_mouse(button, 0, 0, 0);
    }

    /// Releases any currently pressed mouse buttons.
    ///
    /// This should be called after a `press()` action to release the button.
    #[inline]
    pub fn release(&self) {
        self.device.call_mouse(MouseButton::Release, 0, 0, 0);
    }

    /// Scrolls the mouse wheel.
    ///
    /// # Arguments
    ///
    /// * `button` - The `MouseButton` to hold down during the scroll.
    /// * `wheel` - The scroll amount. Positive values scroll up, negative values scroll down.
    #[inline]
    pub fn wheel(&self, button: MouseButton, wheel: i8) {
        self.device.call_mouse(button, 0, 0, wheel);
    }
}

```

`src/util.rs`:

```rs
use core::{mem, ptr};

use windows_sys::{
    Wdk::Foundation::OBJECT_ATTRIBUTES,
    Win32::{
        Foundation::{HANDLE, OBJECT_ATTRIBUTE_FLAGS, UNICODE_STRING},
        Security::SECURITY_DESCRIPTOR,
    },
};

/// Initializes an `OBJECT_ATTRIBUTES` structure for use with Windows API calls.
#[expect(clippy::many_single_char_names, non_snake_case, reason = "Windows API style")]
pub const fn InitializeObjectAttributes(
    p: &mut OBJECT_ATTRIBUTES,
    n: *const UNICODE_STRING,
    a: OBJECT_ATTRIBUTE_FLAGS,
    r: HANDLE,
    s: *const SECURITY_DESCRIPTOR,
) {
    #[expect(clippy::cast_possible_truncation, reason = "OBJECT_ATTRIBUTES is only 48 bytes")]
    const LENGTH: u32 = mem::size_of::<OBJECT_ATTRIBUTES>() as u32;

    p.Length = LENGTH;
    p.RootDirectory = r;
    p.ObjectName = n;
    p.Attributes = a;
    p.SecurityDescriptor = s;
    p.SecurityQualityOfService = ptr::null();
}

```

`tests/common/mod.rs`:

```rs
use core::{
    ptr,
    sync::atomic::{AtomicBool, Ordering},
};
use std::sync::{LazyLock, Mutex};
extern crate alloc;
use alloc::sync::Arc;

use windows_sys::Win32::{
    Foundation::{LPARAM, WPARAM},
    System::LibraryLoader::GetModuleHandleW,
    UI::WindowsAndMessaging::{
        CallNextHookEx, GetMessageW, HHOOK, KBDLLHOOKSTRUCT, MSG, MSLLHOOKSTRUCT, SetWindowsHookExW,
        UnhookWindowsHookEx, WH_MOUSE_LL, WINDOWS_HOOK_ID, WM_KEYDOWN, WM_KEYUP, WM_LBUTTONDOWN, WM_LBUTTONUP,
        WM_MOUSEWHEEL, WM_SYSKEYDOWN, WM_SYSKEYUP,
    },
};

#[expect(non_snake_case, reason = "Windows API style")]
const fn GET_WHEEL_DELTA_WPARAM(wParam: u32) -> i16 {
    ((wParam >> 16) & 0xFFFF) as i16
}

static mut HOOK_HANDLE: HHOOK = ptr::null_mut();
static RUNNING: LazyLock<Arc<AtomicBool>> = LazyLock::new(|| Arc::new(AtomicBool::new(false)));
static RESULT: LazyLock<Mutex<Vec<String>>> = LazyLock::new(|| Mutex::new(vec![]));

#[expect(non_snake_case, reason = "Windows API style")]
extern "system" fn LowLevelMouseProc(nCode: i32, wParam: WPARAM, lParam: LPARAM) -> isize {
    if nCode >= 0 {
        #[expect(clippy::cast_possible_truncation, reason = "Windows API uses u32 for wParam")]
        match wParam as u32 {
            WM_LBUTTONUP => {
                RESULT.lock().unwrap().push("LBUTTON UP".to_owned());
            }
            WM_LBUTTONDOWN => {
                RESULT.lock().unwrap().push("LBUTTON DOWN".to_owned());
            }
            WM_MOUSEWHEEL => {
                // SAFETY: lParam is guaranteed by Windows to be a valid pointer to MSLLHOOKSTRUCT.
                let pMouseStruct = unsafe { *(lParam as *const MSLLHOOKSTRUCT) };
                let wheelDelta = GET_WHEEL_DELTA_WPARAM(pMouseStruct.mouseData);

                if wheelDelta > 0 {
                    RESULT.lock().unwrap().push("WHEEL UP".to_owned());
                } else {
                    RESULT.lock().unwrap().push("WHEEL DOWN".to_owned());
                }
            }
            _ => {}
        }
    }

    // SAFETY: CallNextHookEx is called with the same parameters received by the hook procedure, as required by the Windows API.
    unsafe { CallNextHookEx(ptr::null_mut(), nCode, wParam, lParam) }
}

#[expect(non_snake_case, reason = "Windows API style")]
extern "system" fn LowLevelKeyboardProc(nCode: i32, wParam: WPARAM, lParam: LPARAM) -> isize {
    if nCode >= 0 {
        // SAFETY: lParam is guaranteed by Windows to be a valid pointer to KBDLLHOOKSTRUCT.
        let kb_struct = unsafe { &*(lParam as *const KBDLLHOOKSTRUCT) };

        #[expect(clippy::cast_possible_truncation, reason = "Windows API uses u32 for wParam")]
        match wParam as u32 {
            WM_KEYDOWN | WM_SYSKEYDOWN => {
                RESULT.lock().unwrap().push(format!("{} DOWN", kb_struct.vkCode));
            }
            WM_KEYUP | WM_SYSKEYUP => {
                RESULT.lock().unwrap().push(format!("{} UP", kb_struct.vkCode));
            }
            _ => {}
        }
    }

    // SAFETY: CallNextHookEx is called with the same parameters received by the hook procedure, as required by the Windows API.
    unsafe { CallNextHookEx(ptr::null_mut(), nCode, wParam, lParam) }
}

pub fn start(idhook: WINDOWS_HOOK_ID) {
    // SAFETY: GetModuleHandleW is called with a null pointer to get a handle to the current process's module, which is safe here.
    let lpmodulename = unsafe { GetModuleHandleW(ptr::null()) };
    let hook_handle = if idhook == WH_MOUSE_LL {
        // SAFETY: SetWindowsHookExW and GetModuleHandleW are FFI calls, and HOOK_HANDLE is a static mut.
        unsafe { SetWindowsHookExW(idhook, Some(LowLevelMouseProc), lpmodulename, 0) }
    } else {
        // SAFETY: SetWindowsHookExW and GetModuleHandleW are FFI calls, and HOOK_HANDLE is a static mut.
        unsafe { SetWindowsHookExW(idhook, Some(LowLevelKeyboardProc), lpmodulename, 0) }
    };

    // SAFETY: Writing to static mut HOOK_HANDLE. This is safe assuming single-threaded access or proper synchronization.
    unsafe {
        HOOK_HANDLE = hook_handle;
    };

    RUNNING.store(true, Ordering::SeqCst);

    // Message loop
    let mut msg = MSG::default();
    while RUNNING.load(Ordering::SeqCst) {
        // SAFETY: GetMessageW is an FFI call and requires a mutable pointer to MSG.
        let result = unsafe { GetMessageW(&raw mut msg, ptr::null_mut(), 0, 0) };
        if result == -1 {
            break;
        }
    }
}

pub fn stop() -> Vec<String> {
    RUNNING.store(false, Ordering::SeqCst);

    // SAFETY: Accessing HOOK_HANDLE is safe here because stop() is only called from a single thread and HOOK_HANDLE is only modified here and in start().
    let hook_handle_is_not_null = unsafe { !HOOK_HANDLE.is_null() };
    if hook_handle_is_not_null {
        // SAFETY: Accessing HOOK_HANDLE is safe here because stop() is only called from a single thread and HOOK_HANDLE is only modified here and in start().
        let hook_handle = unsafe { HOOK_HANDLE };
        // SAFETY: UnhookWindowsHookEx is called with a valid hook handle, as ensured by the previous check.
        unsafe {
            UnhookWindowsHookEx(hook_handle);
        };
        // SAFETY: Resetting HOOK_HANDLE to null is safe as we have just unhooked it.
        unsafe {
            HOOK_HANDLE = ptr::null_mut();
        };
    }

    let result = RESULT.lock().unwrap().clone();
    RESULT.lock().unwrap().clear();
    result
}

```

`tests/keyboard_tests.rs`:

```rs
use core::time::Duration;
use logitech_cve::{
    device::Device,
    keyboard::{Key, Keyboard},
};
use std::thread;
use windows_sys::Win32::UI::{
    Input::KeyboardAndMouse::{
        VK_1, VK_A, VK_B, VK_C, VK_D, VK_E, VK_F, VK_H, VK_L, VK_LSHIFT, VK_O, VK_OEM_COMMA, VK_R, VK_SPACE, VK_W,
    },
    WindowsAndMessaging::WH_KEYBOARD_LL,
};

mod common;

#[test]
fn press_and_release() {
    let device = Device::try_new().unwrap();
    let keyboard = Keyboard::new(&device);

    thread::spawn(|| common::start(WH_KEYBOARD_LL));
    thread::sleep(Duration::from_millis(100));
    keyboard.press(Key::A);
    keyboard.release();
    thread::sleep(Duration::from_millis(100));
    assert_eq!(vec![format!("{VK_A} DOWN"), format!("{VK_A} UP")], common::stop());
}

#[test]
fn multi_press() {
    let device = Device::try_new().unwrap();
    let keyboard = Keyboard::new(&device);

    thread::spawn(|| common::start(WH_KEYBOARD_LL));
    thread::sleep(Duration::from_millis(100));
    keyboard.multi_press(Key::A, Key::B, Key::C, Key::D, Key::E, Key::F);
    thread::sleep(Duration::from_millis(100));
    assert_eq!(
        vec![
            format!("{VK_A} DOWN"),
            format!("{VK_B} DOWN"),
            format!("{VK_C} DOWN"),
            format!("{VK_D} DOWN"),
            format!("{VK_E} DOWN"),
            format!("{VK_F} DOWN"),
        ],
        common::stop()
    );
    keyboard.release();
}

#[test]
fn type_string() {
    let device = Device::try_new().unwrap();
    let keyboard = Keyboard::new(&device);

    thread::spawn(|| common::start(WH_KEYBOARD_LL));
    thread::sleep(Duration::from_millis(100));
    keyboard.type_string("Hello, World!", 50).expect("Should be OK");
    thread::sleep(Duration::from_millis(100));
    assert_eq!(
        vec![
            format!("{VK_LSHIFT} DOWN"),
            format!("{VK_H} DOWN"),
            format!("{VK_LSHIFT} UP"),
            format!("{VK_H} UP"),
            format!("{VK_E} DOWN"),
            format!("{VK_E} UP"),
            format!("{VK_L} DOWN"),
            format!("{VK_L} UP"),
            format!("{VK_L} DOWN"),
            format!("{VK_L} UP"),
            format!("{VK_O} DOWN"),
            format!("{VK_O} UP"),
            format!("{VK_OEM_COMMA} DOWN"),
            format!("{VK_OEM_COMMA} UP"),
            format!("{VK_SPACE} DOWN"),
            format!("{VK_SPACE} UP"),
            format!("{VK_LSHIFT} DOWN"),
            format!("{VK_W} DOWN"),
            format!("{VK_LSHIFT} UP"),
            format!("{VK_W} UP"),
            format!("{VK_O} DOWN"),
            format!("{VK_O} UP"),
            format!("{VK_R} DOWN"),
            format!("{VK_R} UP"),
            format!("{VK_L} DOWN"),
            format!("{VK_L} UP"),
            format!("{VK_D} DOWN"),
            format!("{VK_D} UP"),
            format!("{VK_LSHIFT} DOWN"),
            format!("{VK_1} DOWN"),
            format!("{VK_LSHIFT} UP"),
            format!("{VK_1} UP")
        ],
        common::stop()
    );
    keyboard.release();
}

```

`tests/mouse_tests.rs`:

```rs
use core::time::Duration;
use std::thread;

use logitech_cve::{
    device::Device,
    mouse::{Mouse, MouseButton},
};
use windows_sys::Win32::{
    Foundation::POINT,
    UI::WindowsAndMessaging::{GetCursorPos, WH_MOUSE_LL},
};

mod common;

#[test]
fn press_and_release() {
    let device = Device::try_new().unwrap();
    let mouse = Mouse::new(&device);

    thread::spawn(|| common::start(WH_MOUSE_LL));
    thread::sleep(Duration::from_millis(100));
    mouse.press(MouseButton::Left);
    mouse.release();
    thread::sleep(Duration::from_millis(100));

    assert_eq!(vec!["LBUTTON DOWN", "LBUTTON UP"], common::stop());
}

#[test]
fn wheel() {
    let device = Device::try_new().unwrap();
    let mouse = Mouse::new(&device);

    thread::spawn(|| common::start(WH_MOUSE_LL));
    thread::sleep(Duration::from_millis(100));
    mouse.wheel(MouseButton::Release, 1);
    mouse.wheel(MouseButton::Release, -1);
    thread::sleep(Duration::from_millis(100));

    assert_eq!(vec!["WHEEL UP", "WHEEL DOWN"], common::stop());
}

#[test]
fn move_relative() {
    let device = Device::try_new().unwrap();
    let mouse = Mouse::new(&device);

    let mut start_point = POINT::default();
    let mut current_point = POINT::default();
    // SAFETY: `start_point` is a valid pointer to a POINT struct, as required by GetCursorPos.
    unsafe {
        GetCursorPos(&raw mut start_point);
    };
    mouse.move_relative(MouseButton::Release, 1, 1);
    thread::sleep(Duration::from_millis(100));
    // SAFETY: `current_point` is a valid pointer to a POINT struct, as required by GetCursorPos.
    unsafe {
        GetCursorPos(&raw mut current_point);
    };

    assert_eq!(start_point.x + 1, current_point.x);
    assert_eq!(start_point.y + 1, current_point.y);
}

#[test]
fn move_absolute() {
    let device = Device::try_new().unwrap();
    let mouse = Mouse::new(&device);
    let mut current_point = POINT::default();

    mouse.move_absolute(MouseButton::Release, 500, 500, 10);
    thread::sleep(Duration::from_millis(10));
    // SAFETY: `current_point` is a valid pointer to a POINT struct, as required by GetCursorPos.
    unsafe {
        GetCursorPos(&raw mut current_point);
    };
    assert_eq!(500, current_point.x);
    assert_eq!(500, current_point.y);

    mouse.move_absolute(MouseButton::Release, 600, 600, 10);
    thread::sleep(Duration::from_millis(10));
    // SAFETY: `current_point` is a valid pointer to a POINT struct, as required by GetCursorPos.
    unsafe {
        GetCursorPos(&raw mut current_point);
    };
    assert_eq!(600, current_point.x);
    assert_eq!(600, current_point.y);

    mouse.move_absolute(MouseButton::Release, 750, 750, 10);
    thread::sleep(Duration::from_millis(10));
    // SAFETY: `current_point` is a valid pointer to a POINT struct, as required by GetCursorPos.
    unsafe {
        GetCursorPos(&raw mut current_point);
    };
    assert_eq!(750, current_point.x);
    assert_eq!(750, current_point.y);

    mouse.move_absolute(MouseButton::Release, 1, 1, 10);
    thread::sleep(Duration::from_millis(10));
    // SAFETY: `current_point` is a valid pointer to a POINT struct, as required by GetCursorPos.
    unsafe {
        GetCursorPos(&raw mut current_point);
    };
    assert_eq!(1, current_point.x);
    assert_eq!(1, current_point.y);
}

```