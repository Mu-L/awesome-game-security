Project Path: arc_EvelynSchwab_ComponentFuseMechanic_r28gpjfe

Source Tree:

```txt
arc_EvelynSchwab_ComponentFuseMechanic_r28gpjfe
├── Config
│   ├── DefaultEditor.ini
│   ├── DefaultEditorPerProjectUserSettings.ini
│   ├── DefaultEngine.ini
│   ├── DefaultGame.ini
│   └── DefaultInput.ini
├── Content
│   ├── Characters
│   │   └── Mannequins
│   │       ├── Animations
│   │       │   ├── ABP_Manny.uasset
│   │       │   ├── Manny
│   │       │   │   ├── MM_Fall_Loop.uasset
│   │       │   │   ├── MM_Jump.uasset
│   │       │   │   ├── MM_Land.uasset
│   │       │   │   └── MM_Walk_InPlace.uasset
│   │       │   └── Quinn
│   │       │       ├── BS_MF_Unarmed_WalkRun.uasset
│   │       │       ├── MF_Idle.uasset
│   │       │       ├── MF_Run_Fwd.uasset
│   │       │       └── MF_Walk_Fwd.uasset
│   │       ├── Meshes
│   │       │   ├── Mannequin_LODSettings.uasset
│   │       │   ├── SKM_Quinn_Simple.uasset
│   │       │   └── SK_Mannequin.uasset
│   │       └── Rigs
│   │           ├── CR_Mannequin_BasicFootIK.uasset
│   │           └── PA_Mannequin.uasset
│   ├── Fuse
│   │   ├── ALS_Anims
│   │   │   ├── ALS_N_Run_B.uasset
│   │   │   ├── ALS_N_Run_F.uasset
│   │   │   ├── ALS_N_Run_LB.uasset
│   │   │   ├── ALS_N_Run_LF.uasset
│   │   │   ├── ALS_N_Run_RB.uasset
│   │   │   ├── ALS_N_Run_RF.uasset
│   │   │   ├── ALS_N_Walk_B.uasset
│   │   │   ├── ALS_N_Walk_F.uasset
│   │   │   ├── ALS_N_Walk_LB.uasset
│   │   │   ├── ALS_N_Walk_LF.uasset
│   │   │   ├── ALS_N_Walk_RB.uasset
│   │   │   ├── ALS_N_Walk_RF.uasset
│   │   │   └── BS_FuseChar_Locomotion.uasset
│   │   ├── BP_Character_Fuse.uasset
│   │   ├── BP_Fuse_GM.uasset
│   │   ├── BP_Fuse_OrthoProjection.uasset
│   │   ├── BP_Fuse_PhysicsConstraintActor.uasset
│   │   ├── Data
│   │   │   └── FFusableSocketData.uasset
│   │   ├── Effect
│   │   │   ├── M_FuseDecal_Gradient.uasset
│   │   │   ├── M_FuseDecal_Rings.uasset
│   │   │   └── NS_FuseDecals.uasset
│   │   ├── Input
│   │   │   ├── IA_Fuse_Detach.uasset
│   │   │   ├── IA_Fuse_Distance.uasset
│   │   │   ├── IA_Fuse_Height.uasset
│   │   │   ├── IA_Fuse_Pickup.uasset
│   │   │   ├── IA_Fuse_Rotate.uasset
│   │   │   ├── IA_Fuse_Toggle.uasset
│   │   │   └── IMC_Fuse_Character.uasset
│   │   ├── L_Fuse_TestMap.umap
│   │   ├── MaterialLibrary
│   │   │   ├── MF_GenerateRadialUVs.uasset
│   │   │   ├── MI_FusableProp_Blue.uasset
│   │   │   ├── MI_FuseCapture_Right.uasset
│   │   │   ├── MI_FuseCapture_Top.uasset
│   │   │   ├── MPC_Fuse.uasset
│   │   │   ├── M_FusableProp.uasset
│   │   │   ├── M_FuseCapture_PP.uasset
│   │   │   ├── M_Fuse_Character.uasset
│   │   │   ├── M_Fuse_HUD.uasset
│   │   │   ├── M_Fuse_ProjectionDecal.uasset
│   │   │   ├── RT_FuseFront.uasset
│   │   │   ├── RT_FuseRight.uasset
│   │   │   └── RT_FuseTop.uasset
│   │   ├── Props
│   │   │   ├── ABP_Fan.uasset
│   │   │   ├── A_Fan_Spin.uasset
│   │   │   ├── BP_Fan.uasset
│   │   │   ├── BP_TestActivatable.uasset
│   │   │   ├── M_Fan_Wind.uasset
│   │   │   ├── PA_Fan.uasset
│   │   │   ├── PA_WheelPowered.uasset
│   │   │   ├── SKM_Fan.uasset
│   │   │   ├── SKM_WheelPowered.uasset
│   │   │   ├── SK_Fan.uasset
│   │   │   ├── SK_WheelPowered_Skeleton.uasset
│   │   │   ├── SM_Fan_Wind.uasset
│   │   │   ├── SM_Prop_Log.uasset
│   │   │   └── SM_Prop_Planks.uasset
│   │   └── WBP_Fuse_HUD.uasset
│   ├── LevelPrototyping
│   │   ├── Materials
│   │   │   ├── MF_ProcGrid.uasset
│   │   │   ├── MI_PrototypeGrid_Gray.uasset
│   │   │   ├── MI_PrototypeGrid_Gray_02.uasset
│   │   │   ├── MI_PrototypeGrid_TopDark.uasset
│   │   │   ├── MI_Solid_Blue.uasset
│   │   │   ├── M_PrototypeGrid.uasset
│   │   │   └── M_Solid.uasset
│   │   ├── Meshes
│   │   │   ├── SM_ChamferCube.uasset
│   │   │   ├── SM_Cube.uasset
│   │   │   ├── SM_Cylinder.uasset
│   │   │   ├── SM_QuarterCylinder.uasset
│   │   │   └── SM_Ramp.uasset
│   │   └── Textures
│   │       └── T_GridChecker_A.uasset
│   ├── ThirdPerson
│   │   └── Input
│   │       ├── Actions
│   │       │   ├── IA_Jump.uasset
│   │       │   ├── IA_Look.uasset
│   │       │   └── IA_Move.uasset
│   │       └── IMC_Default.uasset
│   ├── __ExternalActors__
│   │   ├── Fuse
│   │   │   └── L_Fuse_TestMap
│   │   │       ├── 0
│   │   │       │   ├── 1F
│   │   │       │   │   └── KXT4F2X1LSVJ5HWBYM2SJ1.uasset
│   │   │       │   ├── 3W
│   │   │       │   │   └── 9NUGWNVB5ZCPMB372C5X0R.uasset
│   │   │       │   ├── AL
│   │   │       │   │   └── 28BR86TDMHZD9E4T92XOX7.uasset
│   │   │       │   ├── AO
│   │   │       │   │   └── 039QLUXAD3TIEP0M63C6OK.uasset
│   │   │       │   ├── AZ
│   │   │       │   │   └── 43MUBSTC2HH0LJG1D4CND7.uasset
│   │   │       │   ├── SJ
│   │   │       │   │   └── 63F44LTKYSTBOYH9CG50NO.uasset
│   │   │       │   ├── UJ
│   │   │       │   │   └── WCQIPFPQH144YZI9QZKZBN.uasset
│   │   │       │   ├── WM
│   │   │       │   │   └── H81DCLLK3VG20BKAMPXC52.uasset
│   │   │       │   ├── X0
│   │   │       │   │   └── OY6UPMOWSLJ2T95JI82R5J.uasset
│   │   │       │   └── YW
│   │   │       │       └── YYXFR3DZVK7OXO5X6SUNRM.uasset
│   │   │       ├── 1
│   │   │       │   ├── 28
│   │   │       │   │   └── 3NFS10XXV8ODCJMVYFK0CX.uasset
│   │   │       │   ├── 2I
│   │   │       │   │   └── 4JVBZYY748P5N4C5ZKQYBK.uasset
│   │   │       │   ├── 3E
│   │   │       │   │   └── NKZ3VMBKQUO2Y6XNMKU3VK.uasset
│   │   │       │   ├── 4F
│   │   │       │   │   └── O5WJAZTHAM9RKP8P55D69E.uasset
│   │   │       │   ├── 6Q
│   │   │       │   │   └── RBWGY6I1CVZLM4OOYD7T9F.uasset
│   │   │       │   ├── Q6
│   │   │       │   │   └── A09EGRVHHK48RZLQGAIP3S.uasset
│   │   │       │   └── RW
│   │   │       │       └── 0HJCALA29SPGO8ANACY8FD.uasset
│   │   │       ├── 2
│   │   │       │   ├── 2W
│   │   │       │   │   └── WSGFOANJ23B224ZR6LU4KJ.uasset
│   │   │       │   ├── 4L
│   │   │       │   │   └── IXJR58FA6XGBXEBN4IHQ8C.uasset
│   │   │       │   ├── CH
│   │   │       │   │   └── JL2FAAMLV6H2BALE6KR4ZA.uasset
│   │   │       │   ├── NS
│   │   │       │   │   └── 71TNFT37XE6SZBWATJ8W0L.uasset
│   │   │       │   ├── SQ
│   │   │       │   │   └── 15RORHP4MEQ1XJC2J6JZL8.uasset
│   │   │       │   └── ZO
│   │   │       │       └── C76QI8JX2DH8A42OE5FMGD.uasset
│   │   │       ├── 3
│   │   │       │   ├── 81
│   │   │       │   │   └── K6MXXASFLGDXEBO4R5KAUF.uasset
│   │   │       │   ├── 8U
│   │   │       │   │   └── RA5QC3PZNEE6EL4GBA9B4T.uasset
│   │   │       │   ├── I2
│   │   │       │   │   └── 8C1RWVWMYMIHJEX5IXZJXK.uasset
│   │   │       │   ├── K3
│   │   │       │   │   └── 5E08Z4NSEJNKA5Y1TB9DFZ.uasset
│   │   │       │   └── QR
│   │   │       │       └── 9J143NZNW3U938WNLIMWJH.uasset
│   │   │       ├── 4
│   │   │       │   ├── 0M
│   │   │       │   │   └── ZEOCWJKQ24K7MTI4LYBTOR.uasset
│   │   │       │   ├── 3M
│   │   │       │   │   └── G381XUV84KIZRNGX9KIDQ4.uasset
│   │   │       │   ├── 8O
│   │   │       │   │   └── 8LQIWFSCJFSUX8ADRXPB47.uasset
│   │   │       │   ├── AQ
│   │   │       │   │   └── 6OV2CP0U855CQ166HR4I4F.uasset
│   │   │       │   ├── GA
│   │   │       │   │   └── KMFJQJBRG3ET1FNSX0XBJW.uasset
│   │   │       │   ├── HT
│   │   │       │   │   └── 6DEZTG98PA86QU64QBJJPO.uasset
│   │   │       │   ├── HZ
│   │   │       │   │   └── VOQ9FY46YJ4YC0OQWB891G.uasset
│   │   │       │   ├── JP
│   │   │       │   │   └── 622E6GAXQMZBM1F6J5R2BO.uasset
│   │   │       │   ├── LY
│   │   │       │   │   └── 7WVE9DMQ12G1DBBR0EX8PN.uasset
│   │   │       │   └── O3
│   │   │       │       └── CXYP99ZW9TBU9I8HW28EW2.uasset
│   │   │       ├── 5
│   │   │       │   ├── 8U
│   │   │       │   │   └── 2DIPH7MNT3S3ZEWQAKSQGD.uasset
│   │   │       │   ├── DE
│   │   │       │   │   └── VZSIKZE7K0KQDE4R7PYGAD.uasset
│   │   │       │   ├── KV
│   │   │       │   │   └── FP3Y8ICKHMJO3UPHGRVFNJ.uasset
│   │   │       │   ├── OZ
│   │   │       │   │   └── NVVEQLX58ZT1JQXX2F5BIY.uasset
│   │   │       │   └── P9
│   │   │       │       └── IMYHRL86DXAMHGDMXIPKZ2.uasset
│   │   │       ├── 6
│   │   │       │   ├── 1F
│   │   │       │   │   └── VUDR36D4NMRNM8KC8CULMT.uasset
│   │   │       │   ├── 2D
│   │   │       │   │   └── SLVJ6IMEFM01WO23D878H7.uasset
│   │   │       │   ├── 2M
│   │   │       │   │   └── 6DV433Y77ZSKX48W115VYD.uasset
│   │   │       │   ├── 7K
│   │   │       │   │   └── S3QZVPXWFZFAARTYHSWALE.uasset
│   │   │       │   ├── 8Y
│   │   │       │   │   └── 4MQYSNC4RI29QOGW544K60.uasset
│   │   │       │   ├── EL
│   │   │       │   │   └── B24C68HY4EBSA0F8MX32BO.uasset
│   │   │       │   ├── GB
│   │   │       │   │   └── 8VZMN5QF4GQSSNFU5A80IK.uasset
│   │   │       │   ├── IO
│   │   │       │   │   └── 4TK6LMHT12TE2VG4KMJ8M9.uasset
│   │   │       │   └── WK
│   │   │       │       └── 2D9QU9OGUS2J96MNJLBN3Z.uasset
│   │   │       ├── 7
│   │   │       │   ├── 3A
│   │   │       │   │   └── QAJTBZ5GTY1SR78FYSE49P.uasset
│   │   │       │   ├── 5J
│   │   │       │   │   └── Z27WDOAU8BFJ4ZO4YEWBI9.uasset
│   │   │       │   ├── 7L
│   │   │       │   │   └── I06ISS9MF4DJW52WBS63JF.uasset
│   │   │       │   ├── DG
│   │   │       │   │   └── 8YYBYZFS038UH5QCPGJYF8.uasset
│   │   │       │   ├── IS
│   │   │       │   │   └── 618I2956V1UWYBBQ4MMXGN.uasset
│   │   │       │   ├── NW
│   │   │       │   │   └── VLY7XG10SX0B431V7V8O13.uasset
│   │   │       │   ├── TF
│   │   │       │   │   └── 1IGVV9UH1IIIF49GMZW5JG.uasset
│   │   │       │   └── WZ
│   │   │       │       └── 9VA91LZLJZR4QX31GYIHBF.uasset
│   │   │       ├── 8
│   │   │       │   ├── 1A
│   │   │       │   │   └── F9QODP9G78YLI1XB7PKZ5X.uasset
│   │   │       │   ├── 2C
│   │   │       │   │   └── WMZ8D4ZNTMDY1LV5CSEXG7.uasset
│   │   │       │   ├── 2J
│   │   │       │   │   └── URPEQSM3O50N5LK31N6YPA.uasset
│   │   │       │   ├── HL
│   │   │       │   │   └── X2BX29OXUTTIEETK0K02TX.uasset
│   │   │       │   ├── HX
│   │   │       │   │   └── R58XST5PO6RCMN7AO3M5HE.uasset
│   │   │       │   ├── PZ
│   │   │       │   │   └── 068UMEUR6ZN5JSKXBV33LO.uasset
│   │   │       │   └── XA
│   │   │       │       └── SWFLA5B0BNGKHL0V9XQSPF.uasset
│   │   │       ├── 9
│   │   │       │   ├── 5A
│   │   │       │   │   └── CGUKMXT6ZSUN4U1N59CBME.uasset
│   │   │       │   ├── 99
│   │   │       │   │   └── IEMW0KKK0EO54I85T0HLQM.uasset
│   │   │       │   ├── 9R
│   │   │       │   │   └── E3YG83GGL699NPIKY0RQA4.uasset
│   │   │       │   ├── A3
│   │   │       │   │   └── 09FTX5FPOYADQK75M614UW.uasset
│   │   │       │   ├── AY
│   │   │       │   │   └── C03ADMN4J2FHPGC8YW5614.uasset
│   │   │       │   ├── B9
│   │   │       │   │   └── W34N0BKKQVQ80OCYEB2GR7.uasset
│   │   │       │   ├── G4
│   │   │       │   │   └── 0BG816LCB4UFXTY6CKM7KF.uasset
│   │   │       │   ├── N3
│   │   │       │   │   └── OVXKHKFNT1D1S3GZHB8NHR.uasset
│   │   │       │   ├── QV
│   │   │       │   │   └── V7T150DOBGXMRI1AXUEO7S.uasset
│   │   │       │   ├── UC
│   │   │       │   │   └── WG2IANTHPVHYUUUYLL961W.uasset
│   │   │       │   └── ZD
│   │   │       │       └── C5WZ8PQ22DOYVEH3438WYF.uasset
│   │   │       ├── A
│   │   │       │   ├── 7Q
│   │   │       │   │   └── QAFI9K9MD9SIYKCQEG1PPJ.uasset
│   │   │       │   └── PM
│   │   │       │       └── GZL5D4RJI2CEGB5WT90H13.uasset
│   │   │       ├── B
│   │   │       │   ├── 8S
│   │   │       │   │   └── 0XH416ZJY9ZGGHBJSUPWF3.uasset
│   │   │       │   ├── 9T
│   │   │       │   │   ├── 2XX4161K1N7XO24L8HJ4JN.uasset
│   │   │       │   │   └── XKHQRDL2WVOCT3V3ODVH0E.uasset
│   │   │       │   ├── BN
│   │   │       │   │   └── K6C3N3R7VWGJ0X9K25LYIW.uasset
│   │   │       │   ├── CJ
│   │   │       │   │   └── U7LAKXRBWBQK065VCG1H5K.uasset
│   │   │       │   ├── F0
│   │   │       │   │   └── 79QA3AGD3LCF9JNV0TKHMV.uasset
│   │   │       │   ├── J4
│   │   │       │   │   └── 1MWIPI3V85ZGAQHOWO47S3.uasset
│   │   │       │   ├── MC
│   │   │       │   │   └── R7GEDE7O00MN3K8CF7581C.uasset
│   │   │       │   ├── QB
│   │   │       │   │   └── 98VS0LE4OFG3HOLH8OCZDY.uasset
│   │   │       │   └── XO
│   │   │       │       └── UHIKKEJ3W8C3CQ0O9636VN.uasset
│   │   │       ├── C
│   │   │       │   ├── 1V
│   │   │       │   │   └── CSDQ3UDWXE88WCHUQ5C1HL.uasset
│   │   │       │   ├── 6V
│   │   │       │   │   └── 7TEQER7HRORZRJ5A2HU66P.uasset
│   │   │       │   ├── 8N
│   │   │       │   │   └── 33V8Z24VVGZXYCHBTMXDTN.uasset
│   │   │       │   ├── 95
│   │   │       │   │   └── OTNN3DLGR4M85Z3L72XMN3.uasset
│   │   │       │   ├── 9E
│   │   │       │   │   └── Y6WHQC908VKDGS8H3LOTWW.uasset
│   │   │       │   ├── E3
│   │   │       │   │   └── 487SQ2AG98CV60O8KQGEMB.uasset
│   │   │       │   ├── H4
│   │   │       │   │   └── 2457I2NJUTZIFWLL7SXHDX.uasset
│   │   │       │   ├── I5
│   │   │       │   │   └── 3LBOFCIGR9MS2AKNVC0HND.uasset
│   │   │       │   ├── JT
│   │   │       │   │   └── HLH7HVOMJJ85P2WJ7Y8VYS.uasset
│   │   │       │   ├── UX
│   │   │       │   │   └── 87IJXVAS0AV23WO4V9LQE4.uasset
│   │   │       │   └── WG
│   │   │       │       └── 0YS8NQQPCMBYCHH9OGMX0T.uasset
│   │   │       ├── D
│   │   │       │   ├── 3U
│   │   │       │   │   └── 4PLBFUVII9WOHOOZH8R8T0.uasset
│   │   │       │   ├── AA
│   │   │       │   │   └── E0OWH51SBUM57KH2GRDVX9.uasset
│   │   │       │   ├── EK
│   │   │       │   │   └── 1MIEZ1G2T2BC2KXYVD9P2H.uasset
│   │   │       │   ├── HR
│   │   │       │   │   └── XG8ZQ5OVRHA7QV4OOCYA7Z.uasset
│   │   │       │   ├── U2
│   │   │       │   │   └── EZW1D28HWZ1DPG2W0VCY9Q.uasset
│   │   │       │   ├── VR
│   │   │       │   │   └── 162OV6BDSC7WNTRYS6EI0F.uasset
│   │   │       │   └── X3
│   │   │       │       └── G1N35LZ6746VHHL9HWTCIP.uasset
│   │   │       └── E
│   │   │           ├── 6O
│   │   │           │   └── ZN56GU48SVBNL52SR4M2OS.uasset
│   │   │           ├── 7T
│   │   │           │   └── RJ5WKG737G85TG4WCR520T.uasset
│   │   │           ├── 8F
│   │   │           │   └── 1NLK4C7EJF0ZVQS03HWMTW.uasset
│   │   │           ├── 9Y
│   │   │           │   └── 7TSVG30WHTWDS0TBSXQTQ1.uasset
│   │   │           ├── BK
│   │   │           │   └── YIAMVZV6JNUKGKUG6JXWQI.uasset
│   │   │           ├── FO
│   │   │           │   └── LGHDDAFR65C4ZPEOOFEGWZ.uasset
│   │   │           ├── O2
│   │   │           │   └── YELIVHE83TSHGKBUOP5QWB.uasset
│   │   │           ├── P9
│   │   │           │   └── DQQ4V8W0D9AF9H6UJSER93.uasset
│   │   │           ├── PA
│   │   │           │   └── 2IFK58IMACS4FHB2DCVE31.uasset
│   │   │           ├── Q4
│   │   │           │   └── JJKMF03CRH85Y06HVIW9L3.uasset
│   │   │           └── WX
│   │   │               └── G11XLAKTCGVUTPDND7YLXN.uasset
│   │   └── ThirdPerson
│   │       └── Maps
│   │           └── ThirdPersonMap
│   │               └── D
│   │                   └── SY
│   │                       └── Z4CTQ4LG3YV10EKPD0UE8Q.uasset
│   └── __ExternalObjects__
│       └── Fuse
│           └── L_Fuse_TestMap
│               ├── 7
│               │   ├── CS
│               │   │   └── D0WVWGU0HDKXTVXKLTDLG1.uasset
│               │   └── RY
│               │       └── CJGYHTLFHFJ56Y6268F18M.uasset
│               ├── 8
│               │   └── NP
│               │       └── FULJ4TG1BEVQYYY7JSR3CP.uasset
│               └── C
│                   └── 50
│                       └── 4O524092ADLRG42ZYE58KX.uasset
├── Fuse.uproject
├── LICENSE
├── README.md
└── Source
    ├── Fuse
    │   ├── FFuseComponent.cpp
    │   ├── FFuseComponent.h
    │   ├── FFuseOrthoProjectionActor.cpp
    │   ├── FFuseOrthoProjectionActor.h
    │   ├── Fuse.Build.cs
    │   ├── Fuse.cpp
    │   ├── Fuse.h
    │   ├── FuseCharacter.cpp
    │   └── FuseCharacter.h
    ├── Fuse.Target.cs
    └── FuseEditor.Target.cs

```

`Config/DefaultEditor.ini`:

```ini
[UnrealEd.SimpleMap]
SimpleMapName=/Game/ThirdPersonCPP/Maps/ThirdPersonExampleMap

[EditoronlyBP]
bAllowClassAndBlueprintPinMatching=true
bReplaceBlueprintWithClass= true
bDontLoadBlueprintOutsideEditor= true
bBlueprintIsNotBlueprintType= true

[/Script/AdvancedPreviewScene.SharedProfiles]


```

`Config/DefaultEditorPerProjectUserSettings.ini`:

```ini
[ContentBrowser]
ContentBrowserTab1.SelectedPaths=/Game/ThirdPersonCPP
```

`Config/DefaultEngine.ini`:

```ini
[/Script/EngineSettings.GameMapsSettings]
GameDefaultMap=/Game/Fuse/L_Fuse_TestMap.L_Fuse_TestMap
EditorStartupMap=/Game/Fuse/L_Fuse_TestMap.L_Fuse_TestMap
GlobalDefaultGameMode=/Game/Fuse/BP_Fuse_GM.BP_Fuse_GM_C

[/Script/Engine.RendererSettings]
r.ReflectionMethod=1
r.GenerateMeshDistanceFields=True
r.DynamicGlobalIlluminationMethod=1
r.Lumen.TraceMeshSDFs=0
r.Shadow.Virtual.Enable=1
r.Mobile.EnableNoPrecomputedLightingCSMShader=1
r.DefaultFeature.AutoExposure.ExtendDefaultLuminanceRange=True
r.DefaultFeature.AutoExposure.ExtendDefaultLuminanceRange=true
r.CustomDepth=3
r.SkinCache.CompileShaders=True
r.RayTracing=True
r.Lumen.HardwareRayTracing=False
r.Lumen.TranslucencyReflections.FrontLayer.EnableForProject=True
r.AllowStaticLighting=False
r.VirtualTextures=True

[/Script/WindowsTargetPlatform.WindowsTargetSettings]
DefaultGraphicsRHI=DefaultGraphicsRHI_DX12
-D3D12TargetedShaderFormats=PCD3D_SM5
+D3D12TargetedShaderFormats=PCD3D_SM6
-D3D11TargetedShaderFormats=PCD3D_SM5
+D3D11TargetedShaderFormats=PCD3D_SM5
Compiler=Default
AudioSampleRate=48000
AudioCallbackBufferFrameSize=1024
AudioNumBuffersToEnqueue=1
AudioMaxChannels=0
AudioNumSourceWorkers=4
SpatializationPlugin=
SourceDataOverridePlugin=
ReverbPlugin=
OcclusionPlugin=
CompressionOverrides=(bOverrideCompressionTimes=False,DurationThreshold=5.000000,MaxNumRandomBranches=0,SoundCueQualityIndex=0)
CacheSizeKB=65536
MaxChunkSizeOverrideKB=0
bResampleForDevice=False
MaxSampleRate=48000.000000
HighSampleRate=32000.000000
MedSampleRate=24000.000000
LowSampleRate=12000.000000
MinSampleRate=8000.000000
CompressionQualityModifier=1.000000
AutoStreamingThreshold=0.000000
SoundCueCookQualityIndex=-1

[/Script/HardwareTargeting.HardwareTargetingSettings]
TargetedHardwareClass=Desktop
AppliedTargetedHardwareClass=Desktop
DefaultGraphicsPerformance=Maximum
AppliedDefaultGraphicsPerformance=Maximum

[/Script/Engine.Engine]
+ActiveGameNameRedirects=(OldGameName="TP_ThirdPerson",NewGameName="/Script/Fuse")
+ActiveGameNameRedirects=(OldGameName="/Script/TP_ThirdPerson",NewGameName="/Script/Fuse")
+ActiveClassRedirects=(OldClassName="TP_ThirdPersonGameMode",NewClassName="FuseGameMode")
+ActiveClassRedirects=(OldClassName="TP_ThirdPersonCharacter",NewClassName="FuseCharacter")

[/Script/AndroidFileServerEditor.AndroidFileServerRuntimeSettings]
bEnablePlugin=True
bAllowNetworkConnection=True
SecurityToken=244CDD04475AC2ECB7C08589555DBF1F
bIncludeInShipping=False
bAllowExternalStartInShipping=False
bCompileAFSProject=False
bUseCompression=False
bLogFiles=False
bReportStats=False
ConnectionType=USBOnly
bUseManualIPAddress=False
ManualIPAddress=

[/Script/Engine.PhysicsSettings]
SolverOptions=(PositionIterations=16,VelocityIterations=1,ProjectionIterations=1,CollisionMarginFraction=0.050000,CollisionMarginMax=10.000000,CollisionCullDistance=3.000000,CollisionMaxPushOutVelocity=1000.000000,ClusterConnectionFactor=1.000000,ClusterUnionConnectionType=DelaunayTriangulation,bGenerateCollisionData=False,CollisionFilterSettings=(FilterEnabled=False,MinMass=0.000000,MinSpeed=0.000000,MinImpulse=0.000000),bGenerateBreakData=False,BreakingFilterSettings=(FilterEnabled=False,MinMass=0.000000,MinSpeed=0.000000,MinVolume=0.000000),bGenerateTrailingData=False,TrailingFilterSettings=(FilterEnabled=False,MinMass=0.000000,MinSpeed=0.000000,MinVolume=0.000000))

[/Script/Engine.CollisionProfile]
-Profiles=(Name="NoCollision",CollisionEnabled=NoCollision,ObjectTypeName="WorldStatic",CustomResponses=((Channel="Visibility",Response=ECR_Ignore),(Channel="Camera",Response=ECR_Ignore)),HelpMessage="No collision",bCanModify=False)
-Profiles=(Name="BlockAll",CollisionEnabled=QueryAndPhysics,ObjectTypeName="WorldStatic",CustomResponses=,HelpMessage="WorldStatic object that blocks all actors by default. All new custom channels will use its own default response. ",bCanModify=False)
-Profiles=(Name="OverlapAll",CollisionEnabled=QueryOnly,ObjectTypeName="WorldStatic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility",Response=ECR_Overlap),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldStatic object that overlaps all actors by default. All new custom channels will use its own default response. ",bCanModify=False)
-Profiles=(Name="BlockAllDynamic",CollisionEnabled=QueryAndPhysics,ObjectTypeName="WorldDynamic",CustomResponses=,HelpMessage="WorldDynamic object that blocks all actors by default. All new custom channels will use its own default response. ",bCanModify=False)
-Profiles=(Name="OverlapAllDynamic",CollisionEnabled=QueryOnly,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility",Response=ECR_Overlap),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldDynamic object that overlaps all actors by default. All new custom channels will use its own default response. ",bCanModify=False)
-Profiles=(Name="IgnoreOnlyPawn",CollisionEnabled=QueryOnly,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="Pawn",Response=ECR_Ignore),(Channel="Vehicle",Response=ECR_Ignore)),HelpMessage="WorldDynamic object that ignores Pawn and Vehicle. All other channels will be set to default.",bCanModify=False)
-Profiles=(Name="OverlapOnlyPawn",CollisionEnabled=QueryOnly,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="Pawn",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Ignore)),HelpMessage="WorldDynamic object that overlaps Pawn, Camera, and Vehicle. All other channels will be set to default. ",bCanModify=False)
-Profiles=(Name="Pawn",CollisionEnabled=QueryAndPhysics,ObjectTypeName="Pawn",CustomResponses=((Channel="Visibility",Response=ECR_Ignore)),HelpMessage="Pawn object. Can be used for capsule of any playerable character or AI. ",bCanModify=False)
-Profiles=(Name="Spectator",CollisionEnabled=QueryOnly,ObjectTypeName="Pawn",CustomResponses=((Channel="WorldStatic",Response=ECR_Block),(Channel="Pawn",Response=ECR_Ignore),(Channel="Visibility",Response=ECR_Ignore),(Channel="WorldDynamic",Response=ECR_Ignore),(Channel="Camera",Response=ECR_Ignore),(Channel="PhysicsBody",Response=ECR_Ignore),(Channel="Vehicle",Response=ECR_Ignore),(Channel="Destructible",Response=ECR_Ignore)),HelpMessage="Pawn object that ignores all other actors except WorldStatic.",bCanModify=False)
-Profiles=(Name="CharacterMesh",CollisionEnabled=QueryOnly,ObjectTypeName="Pawn",CustomResponses=((Channel="Pawn",Response=ECR_Ignore),(Channel="Vehicle",Response=ECR_Ignore),(Channel="Visibility",Response=ECR_Ignore)),HelpMessage="Pawn object that is used for Character Mesh. All other channels will be set to default.",bCanModify=False)
-Profiles=(Name="PhysicsActor",CollisionEnabled=QueryAndPhysics,ObjectTypeName="PhysicsBody",CustomResponses=,HelpMessage="Simulating actors",bCanModify=False)
-Profiles=(Name="Destructible",CollisionEnabled=QueryAndPhysics,ObjectTypeName="Destructible",CustomResponses=,HelpMessage="Destructible actors",bCanModify=False)
-Profiles=(Name="InvisibleWall",CollisionEnabled=QueryAndPhysics,ObjectTypeName="WorldStatic",CustomResponses=((Channel="Visibility",Response=ECR_Ignore)),HelpMessage="WorldStatic object that is invisible.",bCanModify=False)
-Profiles=(Name="InvisibleWallDynamic",CollisionEnabled=QueryAndPhysics,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="Visibility",Response=ECR_Ignore)),HelpMessage="WorldDynamic object that is invisible.",bCanModify=False)
-Profiles=(Name="Trigger",CollisionEnabled=QueryOnly,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility",Response=ECR_Ignore),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldDynamic object that is used for trigger. All other channels will be set to default.",bCanModify=False)
-Profiles=(Name="Ragdoll",CollisionEnabled=QueryAndPhysics,ObjectTypeName="PhysicsBody",CustomResponses=((Channel="Pawn",Response=ECR_Ignore),(Channel="Visibility",Response=ECR_Ignore)),HelpMessage="Simulating Skeletal Mesh Component. All other channels will be set to default.",bCanModify=False)
-Profiles=(Name="Vehicle",CollisionEnabled=QueryAndPhysics,ObjectTypeName="Vehicle",CustomResponses=,HelpMessage="Vehicle object that blocks Vehicle, WorldStatic, and WorldDynamic. All other channels will be set to default.",bCanModify=False)
-Profiles=(Name="UI",CollisionEnabled=QueryOnly,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility",Response=ECR_Block),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldStatic object that overlaps all actors by default. All new custom channels will use its own default response. ",bCanModify=False)
+Profiles=(Name="NoCollision",CollisionEnabled=NoCollision,bCanModify=False,ObjectTypeName="WorldStatic",CustomResponses=((Channel="Visibility",Response=ECR_Ignore),(Channel="Camera",Response=ECR_Ignore)),HelpMessage="No collision")
+Profiles=(Name="BlockAll",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="WorldStatic",CustomResponses=,HelpMessage="WorldStatic object that blocks all actors by default. All new custom channels will use its own default response. ")
+Profiles=(Name="OverlapAll",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="WorldStatic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility",Response=ECR_Overlap),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldStatic object that overlaps all actors by default. All new custom channels will use its own default response. ")
+Profiles=(Name="BlockAllDynamic",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="WorldDynamic",CustomResponses=,HelpMessage="WorldDynamic object that blocks all actors by default. All new custom channels will use its own default response. ")
+Profiles=(Name="OverlapAllDynamic",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility",Response=ECR_Overlap),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldDynamic object that overlaps all actors by default. All new custom channels will use its own default response. ")
+Profiles=(Name="IgnoreOnlyPawn",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="Pawn",Response=ECR_Ignore),(Channel="Vehicle",Response=ECR_Ignore)),HelpMessage="WorldDynamic object that ignores Pawn and Vehicle. All other channels will be set to default.")
+Profiles=(Name="OverlapOnlyPawn",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="Pawn",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Ignore)),HelpMessage="WorldDynamic object that overlaps Pawn, Camera, and Vehicle. All other channels will be set to default. ")
+Profiles=(Name="Pawn",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="Pawn",CustomResponses=((Channel="Visibility",Response=ECR_Ignore)),HelpMessage="Pawn object. Can be used for capsule of any playerable character or AI. ")
+Profiles=(Name="Spectator",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="Pawn",CustomResponses=((Channel="WorldStatic"),(Channel="Pawn",Response=ECR_Ignore),(Channel="Visibility",Response=ECR_Ignore),(Channel="WorldDynamic",Response=ECR_Ignore),(Channel="Camera",Response=ECR_Ignore),(Channel="PhysicsBody",Response=ECR_Ignore),(Channel="Vehicle",Response=ECR_Ignore),(Channel="Destructible",Response=ECR_Ignore)),HelpMessage="Pawn object that ignores all other actors except WorldStatic.")
+Profiles=(Name="CharacterMesh",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="Pawn",CustomResponses=((Channel="Pawn",Response=ECR_Ignore),(Channel="Vehicle",Response=ECR_Ignore),(Channel="Visibility",Response=ECR_Ignore)),HelpMessage="Pawn object that is used for Character Mesh. All other channels will be set to default.")
+Profiles=(Name="PhysicsActor",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="PhysicsBody",CustomResponses=,HelpMessage="Simulating actors")
+Profiles=(Name="Destructible",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="Destructible",CustomResponses=,HelpMessage="Destructible actors")
+Profiles=(Name="InvisibleWall",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="WorldStatic",CustomResponses=((Channel="Visibility",Response=ECR_Ignore)),HelpMessage="WorldStatic object that is invisible.")
+Profiles=(Name="InvisibleWallDynamic",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="Visibility",Response=ECR_Ignore)),HelpMessage="WorldDynamic object that is invisible.")
+Profiles=(Name="Trigger",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility",Response=ECR_Ignore),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldDynamic object that is used for trigger. All other channels will be set to default.")
+Profiles=(Name="Ragdoll",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="PhysicsBody",CustomResponses=((Channel="Pawn",Response=ECR_Ignore),(Channel="Visibility",Response=ECR_Ignore)),HelpMessage="Simulating Skeletal Mesh Component. All other channels will be set to default.")
+Profiles=(Name="Vehicle",CollisionEnabled=QueryAndPhysics,bCanModify=False,ObjectTypeName="Vehicle",CustomResponses=,HelpMessage="Vehicle object that blocks Vehicle, WorldStatic, and WorldDynamic. All other channels will be set to default.")
+Profiles=(Name="UI",CollisionEnabled=QueryOnly,bCanModify=False,ObjectTypeName="WorldDynamic",CustomResponses=((Channel="WorldStatic",Response=ECR_Overlap),(Channel="Pawn",Response=ECR_Overlap),(Channel="Visibility"),(Channel="WorldDynamic",Response=ECR_Overlap),(Channel="Camera",Response=ECR_Overlap),(Channel="PhysicsBody",Response=ECR_Overlap),(Channel="Vehicle",Response=ECR_Overlap),(Channel="Destructible",Response=ECR_Overlap)),HelpMessage="WorldStatic object that overlaps all actors by default. All new custom channels will use its own default response. ")
+Profiles=(Name="FusablePhysicsObject",CollisionEnabled=QueryAndPhysics,bCanModify=True,ObjectTypeName="PhysicsBody",CustomResponses=((Channel="Camera",Response=ECR_Ignore)),HelpMessage="Needs description")
-ProfileRedirects=(OldName="BlockingVolume",NewName="InvisibleWall")
-ProfileRedirects=(OldName="InterpActor",NewName="IgnoreOnlyPawn")
-ProfileRedirects=(OldName="StaticMeshComponent",NewName="BlockAllDynamic")
-ProfileRedirects=(OldName="SkeletalMeshActor",NewName="PhysicsActor")
-ProfileRedirects=(OldName="InvisibleActor",NewName="InvisibleWallDynamic")
+ProfileRedirects=(OldName="BlockingVolume",NewName="InvisibleWall")
+ProfileRedirects=(OldName="InterpActor",NewName="IgnoreOnlyPawn")
+ProfileRedirects=(OldName="StaticMeshComponent",NewName="BlockAllDynamic")
+ProfileRedirects=(OldName="SkeletalMeshActor",NewName="PhysicsActor")
+ProfileRedirects=(OldName="InvisibleActor",NewName="InvisibleWallDynamic")
-CollisionChannelRedirects=(OldName="Static",NewName="WorldStatic")
-CollisionChannelRedirects=(OldName="Dynamic",NewName="WorldDynamic")
-CollisionChannelRedirects=(OldName="VehicleMovement",NewName="Vehicle")
-CollisionChannelRedirects=(OldName="PawnMovement",NewName="Pawn")
+CollisionChannelRedirects=(OldName="Static",NewName="WorldStatic")
+CollisionChannelRedirects=(OldName="Dynamic",NewName="WorldDynamic")
+CollisionChannelRedirects=(OldName="VehicleMovement",NewName="Vehicle")
+CollisionChannelRedirects=(OldName="PawnMovement",NewName="Pawn")


```

`Config/DefaultGame.ini`:

```ini
[/Script/EngineSettings.GeneralProjectSettings]
ProjectID=83B316704B22BD3FDBDDC7AA2DD6A6D8
ProjectName=Third Person Game Template

```

`Config/DefaultInput.ini`:

```ini


[/Script/Engine.InputSettings]
-AxisConfig=(AxisKeyName="Gamepad_LeftX",AxisProperties=(DeadZone=0.25,Exponent=1.f,Sensitivity=1.f))
-AxisConfig=(AxisKeyName="Gamepad_LeftY",AxisProperties=(DeadZone=0.25,Exponent=1.f,Sensitivity=1.f))
-AxisConfig=(AxisKeyName="Gamepad_RightX",AxisProperties=(DeadZone=0.25,Exponent=1.f,Sensitivity=1.f))
-AxisConfig=(AxisKeyName="Gamepad_RightY",AxisProperties=(DeadZone=0.25,Exponent=1.f,Sensitivity=1.f))
-AxisConfig=(AxisKeyName="MouseX",AxisProperties=(DeadZone=0.f,Exponent=1.f,Sensitivity=0.07f))
-AxisConfig=(AxisKeyName="MouseY",AxisProperties=(DeadZone=0.f,Exponent=1.f,Sensitivity=0.07f))
-AxisConfig=(AxisKeyName="Mouse2D",AxisProperties=(DeadZone=0.f,Exponent=1.f,Sensitivity=0.07f))
+AxisConfig=(AxisKeyName="MouseY",AxisProperties=(DeadZone=0.000000,Sensitivity=0.070000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MouseWheelAxis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_LeftTriggerAxis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_RightTriggerAxis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_Special_Left_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_Special_Left_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Mouse2D",AxisProperties=(DeadZone=0.000000,Sensitivity=0.070000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_LeftX",AxisProperties=(DeadZone=0.250000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_LeftY",AxisProperties=(DeadZone=0.250000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_RightX",AxisProperties=(DeadZone=0.250000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Gamepad_RightY",AxisProperties=(DeadZone=0.250000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MouseX",AxisProperties=(DeadZone=0.000000,Sensitivity=0.070000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Vive_Left_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Vive_Left_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Vive_Left_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Vive_Right_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Vive_Right_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="Vive_Right_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Left_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Left_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Left_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Left_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Left_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Right_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Right_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Right_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Right_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="MixedReality_Right_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Left_Grip_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Left_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Left_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Left_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Right_Grip_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Right_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Right_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="OculusTouch_Right_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Grip_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Grip_Force",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Left_Trackpad_Force",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Grip_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Grip_Force",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Trigger_Axis",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Thumbstick_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Thumbstick_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Trackpad_X",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Trackpad_Y",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
+AxisConfig=(AxisKeyName="ValveIndex_Right_Trackpad_Force",AxisProperties=(DeadZone=0.000000,Sensitivity=1.000000,Exponent=1.000000,bInvert=False))
bAltEnterTogglesFullscreen=True
bF11TogglesFullscreen=True
bUseMouseForTouch=False
bEnableMouseSmoothing=True
bEnableFOVScaling=True
bCaptureMouseOnLaunch=True
bEnableLegacyInputScales=True
bEnableMotionControls=True
bFilterInputByPlatformUser=False
bShouldFlushPressedKeysOnViewportFocusLost=True
bAlwaysShowTouchInterface=False
bShowConsoleOnFourFingerTap=True
bEnableGestureRecognizer=False
bUseAutocorrect=False
DefaultViewportMouseCaptureMode=CapturePermanently_IncludingInitialMouseDown
DefaultViewportMouseLockMode=LockOnCapture
FOVScale=0.011110
DoubleClickTime=0.200000
DefaultPlayerInputClass=/Script/EnhancedInput.EnhancedPlayerInput
DefaultInputComponentClass=/Script/EnhancedInput.EnhancedInputComponent
DefaultTouchInterface=/Engine/MobileResources/HUD/DefaultVirtualJoysticks.DefaultVirtualJoysticks
-ConsoleKeys=Tilde
+ConsoleKeys=Tilde


```

`Fuse.uproject`:

```uproject
{
	"FileVersion": 3,
	"EngineAssociation": "5.2",
	"Category": "",
	"Description": "",
	"Modules": [
		{
			"Name": "Fuse",
			"Type": "Runtime",
			"LoadingPhase": "Default",
			"AdditionalDependencies": [
				"Engine"
			]
		}
	],
	"Plugins": [
		{
			"Name": "ModelingToolsEditorMode",
			"Enabled": true,
			"TargetAllowList": [
				"Editor"
			]
		}
	]
}
```

`LICENSE`:

```
MIT License

Copyright (c) 2024 Evelyn Schwab

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# Component Fuse Mechanic

## Overview

This repo features an actor component that adds a "fuse" mechanic to the player, inspired by the _Ultrahand_ mechanic in _The Legend of Zelda: Tears of the Kingdom_. This is not a production-ready system, and was developed as more of a programming exercise and experiment with Chaos.

The project is developed in **Unreal Engine 5.2**, meaning that is the earliest version it supports. This decision was made due to some stability improvements for Chaos physics introduced in 5.2, but the code should work fine in earlier versions.

The following mechanics are included:

* Pick up and translate/rotate objects in the world by rounded values, relative to the player.
* Draw orthographic projections of grabbed fusible objects (uses 3 scene captures + render targets, not ideal)
* Search through sockets on meshes that contain "Attach" in the name, and find the closest sockets between two objects as well as supplementary sockets that would be very close.
* Detect potential clipping issues and prevent constraints that would cause them.
* Snap objects together at the socket and constrain them at the closest sockets, and the supplementary sockets, with a physics-based interp.
* Detach objects from other "fused" objects (rudimentary)

## Video Showcase
[![ProjectClip](https://img.youtube.com/vi/eO0NQ3Egu48/maxresdefault.jpg)](https://youtu.be/eO0NQ3Egu48)


| Keybind             | Action                                                  |
| ------------------- | ------------------------------------------------------- |
| Right Mouse Button  | Enter searching mode                                    |
| F                   | Pick up targeted fusible/try fuse grabbed fusible       |
| Mouse Wheel         | Adjust grabbed fusible target XY distance               |
| Arrow keys          | Rotate grabbed fusible                                  |
| Q                   | Break constraints on grabbed fusible                    |
| R                   | Interact with interactable objects.                     |


| Asset               | Source                            |
| ------------------- | --------------------------------- |
| Props               | Evelyn Schwab                     |
| Character           | Epic Games, third person template |
| Movement anims      | Caleb Longmire, ALS               |

Use _**f.showdebugfuser 1**_ to draw debug information (including detected fuse operations)

```

`Source/Fuse.Target.cs`:

```cs
// Copyright Epic Games, Inc. All Rights Reserved.

using UnrealBuildTool;
using System.Collections.Generic;

public class FuseTarget : TargetRules
{
	public FuseTarget(TargetInfo Target) : base(Target)
	{
		Type = TargetType.Game;
		DefaultBuildSettings = BuildSettingsVersion.V2;
		IncludeOrderVersion = EngineIncludeOrderVersion.Unreal5_1;
		ExtraModuleNames.Add("Fuse");
	}
}

```

`Source/Fuse/FFuseComponent.cpp`:

```cpp

#include "FFuseComponent.h"
#include "PhysicsEngine/PhysicsConstraintComponent.h"


static TAutoConsoleVariable<bool> CVarDrawDebugFuser(
	TEXT("f.drawdebugfuser"), true, TEXT("Display debug information from a fuse component"), ECVF_Cheat);

void UFFuseComponent::BeginPlay()
{
	Super::BeginPlay();

	// Set owning character controller reference, for getting the camera in SearchForFusable()
	// If the owning character is not of type actor, do not start fuse tick
	if (const APawn* OwningPawn = Cast<APawn>(GetOwner()))
	{
		OwningCharacterController = Cast<APlayerController>(OwningPawn->GetController());
	}
	
	if (OwningCharacterController == nullptr)
	{
		UE_LOG(LogTemp, Error, TEXT("Owner %s of fuse component %s does not have a valid character controller"),
		       *GetOwner()->GetName(), *this->GetName());
		return;
	}
	
	// Start looping timer for updating fuse functions
	GetWorld()->GetTimerManager().SetTimer(FuseTickTimerHandle, this, &UFFuseComponent::FuseTick,
	                                       1.0f / ComponentUpdateRate, true);
}

void UFFuseComponent::TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction)
{
	Super::TickComponent(DeltaTime, TickType, ThisTickFunction);
	if (CurrentFuserState == FSTATE_ACTIVEFUSING)
	{
		FuseObjects(DeltaTime);
	}
}

void UFFuseComponent::ReleaseComponent()
{
	GetGrabbedComponent()->SetRenderCustomDepth(false);
	GetGrabbedComponent()->SetReceivesDecals(true);
	GetGrabbedComponent()->SetCustomPrimitiveDataFloat(0, 0.0f);
	
	if (LastSpawnedOrthoProjectionActor) { LastSpawnedOrthoProjectionActor->Destroy(); }
	
	Super::ReleaseComponent();
}

bool UFFuseComponent::UpdateFuserState(EFuserState NewState)
{
	if (CurrentFuserState != NewState)
	{
		const EFuserState PreviousState = GetCurrentFuseState();
		CurrentFuserState = NewState;
		OnFuserStateChanged.Broadcast(GetCurrentFuseState(), PreviousState);
		return true;
	}
	return false;
}

void UFFuseComponent::FuseTick()
{
	switch (GetCurrentFuseState())
	{
	case FSTATE_SEARCHING:
		SearchForFusable();
		break;
	case FSTATE_FUSING:
		UpdateHeldFusable();
		break;
	default:
		break;
	}
}

bool UFFuseComponent::TryStartSearching()
{
	if (CurrentFuserState == FSTATE_NONE)
	{
		UpdateFuserState(FSTATE_SEARCHING);
		return true;
	}
	return false;
}

bool UFFuseComponent::TryStopSearching()
{
	if (CurrentFuserState == FSTATE_NONE) { return false; }
	if (GetGrabbedComponent()) { ReleaseComponent(); }
	UpdateFuserState(FSTATE_NONE);
	return true;
}

void UFFuseComponent::SearchForFusable()
{
	FVector CameraLoc;
	FRotator CameraRot;
	OwningCharacterController->GetPlayerViewPoint(CameraLoc, CameraRot);
	
    FCollisionObjectQueryParams ObjectQueryParams;
    FCollisionQueryParams CollisionParams;
    ObjectQueryParams.AddObjectTypesToQuery(ECC_PhysicsBody);
	FCollisionShape CollisionShape;
	CollisionShape.SetSphere(SearchTraceRadius);
	// This won't ignore attached actors, but it's only looking for physics bodies so that won't usually be an issue
	CollisionParams.AddIgnoredActor(GetOwner());

	bool bTraceResult = GetWorld()->SweepSingleByObjectType(
			LastSearchHitResult,
			CameraLoc,
			CameraLoc + CameraRot.Vector() * SearchTraceDistance,
			FQuat::Identity,
			ObjectQueryParams,
			CollisionShape,
			CollisionParams);
	
	// Draw debug info if debug is enabled
	if (CVarDrawDebugFuser.GetValueOnGameThread())
	{
		DrawDebugLine(GetWorld(), CameraLoc, LastSearchHitResult.TraceEnd, FColor::Silver, false, GetDeltaFuseTickTime());
		if (bTraceResult && IsComponentFusable(LastSearchHitResult))
		{
			DrawDebugSphere(GetWorld(), LastSearchHitResult.Location, 10.0f, 8, FColor::Green, false, GetDeltaFuseTickTime());
		}
	}
}

bool UFFuseComponent::IsComponentFusable(FHitResult InHitResult)
{
	if (InHitResult.Component.IsValid())
	{
		for (FName SocketName : InHitResult.Component->GetAllSocketNames())
        {
        	if (SocketName.ToString().Contains("Attach")) { return true; }
        }
	}
	return false;
}

bool UFFuseComponent::TryGrabTargetedFusable()
{
	// Early return if there is no hit component, or we already have a component grabbed
	if (GetGrabbedComponent() || !IsComponentFusable(LastSearchHitResult)) { return false; }

	// Find the target location distance (modified by the inverse of the params that drive the target distance in UpdateHeldFusable())
	FVector CameraLocation;
	FRotator CameraRotation;
	OwningCharacterController->GetPlayerViewPoint(CameraLocation, CameraRotation);
	FVector OwnerXYLocation = GetOwner()->GetActorLocation();
	const float OwnerZHeight = OwnerXYLocation.Z;
	OwnerXYLocation.Z = 0.0f;
	FVector CameraXYLocation = CameraLocation;
	CameraXYLocation.Z = 0.0f;
	FVector ComponentXYLocation = LastSearchHitResult.Component->GetComponentLocation();
	const float ComponentZHeight = ComponentXYLocation.Z;
	ComponentXYLocation.Z = 0.0f;
	GrabbedComponentTargetDistance = FVector::Distance(CameraXYLocation, ComponentXYLocation) - FVector::Distance(OwnerXYLocation, CameraXYLocation);
	GrabbedComponentTargetHeight = ComponentZHeight - OwnerZHeight;
	
	// Derive target local quaternion from world rotation, rounded to nearest ComponentRotationMultiplier
	GrabbedComponentLocalTargetRotator = RoundRotatorToNearestMultiple(InverseRotateRotator(GetOwnerControlRotationYaw(), LastSearchHitResult.Component->GetComponentRotation()), ComponentRotationMultiplier);
	
	GrabComponentAtLocationWithRotation(LastSearchHitResult.GetComponent(), "None",
	                                    LastSearchHitResult.GetComponent()->GetComponentLocation(),
	                                    LastSearchHitResult.GetComponent()->GetComponentRotation());
	UpdateFuserState(FSTATE_FUSING);

	GetGrabbedComponent()->SetRenderCustomDepth(true);
	GetGrabbedComponent()->SetCustomDepthStencilValue(1);
	GetGrabbedComponent()->SetCustomPrimitiveDataFloat(0, 1.0f);
	if (OrthographicProjectionActor)
	{
		LastSpawnedOrthoProjectionActor = GetWorld()->SpawnActor<AActor>(OrthographicProjectionActor, GetGrabbedComponent()->GetComponentLocation(), GetOwnerControlRotationYaw());
		GetGrabbedComponent()->SetReceivesDecals(false);
	}
	
	return true;
}

void UFFuseComponent::AdjustGrabbedComponentTargetDistance(float Delta)
{
	const float NewTargetDistance = GrabbedComponentTargetDistance + Delta;
	GrabbedComponentTargetDistance = FMath::Clamp(NewTargetDistance, MinGrabbedComponentTargetDistance, MaxGrabbedComponentTargetDistance);
}

void UFFuseComponent::AdjustGrabbedComponentTargetRotation(float YawInput, float PitchInput)
{
	YawInput *= ComponentRotationMultiplier;
	PitchInput *= ComponentRotationMultiplier;
	
	FQuat NewRelativeQuat = FQuat(FRotator(PitchInput, YawInput, 0.0f));
	
	GrabbedComponentLocalTargetRotator = FRotator(NewRelativeQuat * FQuat(GrabbedComponentLocalTargetRotator));
}

void UFFuseComponent::AdjustGrabbedComponentTargetHeight(float Delta)
{
	// This doesn't need to be clamped as it's being naturally clamped in UpdateHeldFusable()
	GrabbedComponentTargetHeight += Delta;
}

void UFFuseComponent::UpdateHeldFusable()
{
	if (!GetGrabbedComponent()) { return; }

	/* Target location */
	
	// Sphere trace with same params as search to find the target location for the held object
	// Trace ignores the currently grabbed component
	FVector TargetLocation;
	FHitResult TargetUpLocationHit;
	FHitResult TargetDownLocationHit;
	FHitResult TargetLocationHit;
	
	FVector CameraLoc;
	FRotator CameraRot;
	OwningCharacterController->GetPlayerViewPoint(CameraLoc, CameraRot);
	FVector TraceXYStartLocation = CameraLoc;
	FVector OwnerXYLocation = GetOwner()->GetActorLocation();
	const float OwnerLocationZ = OwnerXYLocation.Z;
	OwnerXYLocation.Z = 0.0f;
	FVector CameraXYLocation = CameraLoc;
	CameraXYLocation.Z = 0.0f;
	float GrabbedComponentRadius = GetGrabbedComponent()->GetLocalBounds().SphereRadius;
	FVector TraceEndLocation = TraceXYStartLocation + (GetOwnerControlRotationYaw().Vector() * (FMath::Max(GrabbedComponentRadius + 100.0f, GrabbedComponentTargetDistance) + FVector::Distance(OwnerXYLocation, CameraXYLocation)));
	TraceEndLocation.Z = GetOwner()->GetActorLocation().Z;

	// Get trace locations for Z target traces from pre-offset value

	
	FCollisionQueryParams CollisionParams;
	// Ignore the current held component
    if (GetGrabbedComponent()) { CollisionParams.AddIgnoredComponent(GetGrabbedComponent()); }
	// This won't ignore attached actors, but it's only looking for physics bodies so that won't usually be an issue
	CollisionParams.AddIgnoredActor(GetOwner());
	
	FCollisionShape CollisionShape;
	CollisionShape.SetSphere(SearchTraceRadius);

	// Trace forward to find the forward max location
	bool bTraceResult = GetWorld()->SweepSingleByChannel(
		TargetLocationHit,
		CameraLoc,
		TraceEndLocation,
		FQuat::Identity, FusableIgnoredTraceChannel, CollisionShape, CollisionParams);

	// Set XY target location
	TargetLocation = bTraceResult && TargetLocationHit.Distance > 0.0f ? TargetLocationHit.Location : TargetLocationHit.TraceEnd;
	
	const FVector TraceZStartLocation = TargetLocation;
    FVector TraceZUpEndLocation = TraceZStartLocation;
    TraceZUpEndLocation.Z += MaxGrabbedComponentTargetHeight;
    FVector TraceZDownEndLocation = TraceZStartLocation;
    TraceZDownEndLocation.Z -= MaxGrabbedComponentTargetHeight;
		
	// Trace up and down from the non-Z-offset target location to find the real min and max values
	float MaxGrabbedComponentHeight = TargetLocation.Z + MaxGrabbedComponentTargetHeight;
    float MinGrabbedComponentHeight = TargetLocation.Z - MaxGrabbedComponentTargetHeight;
	// Trace up
	if (GetWorld()->SweepSingleByChannel(
		TargetUpLocationHit,
		TraceZStartLocation,
		TraceZUpEndLocation,
		FQuat::Identity, FusableIgnoredTraceChannel, CollisionShape, CollisionParams))
	{
		MaxGrabbedComponentHeight = TargetUpLocationHit.Location.Z;
	}
	
	// Trace down
	if (GetWorld()->SweepSingleByChannel(
	TargetDownLocationHit,
	TraceZStartLocation,
	TraceZDownEndLocation,
	FQuat::Identity, FusableIgnoredTraceChannel, CollisionShape, CollisionParams))
	{
		MinGrabbedComponentHeight = TargetDownLocationHit.Location.Z;
	}

	// Draw debug for up and down traces
	if (CVarDrawDebugFuser.GetValueOnGameThread())
	{
		// Up trace
		DrawDebugLine(GetWorld(), TraceZStartLocation, TargetUpLocationHit.TraceEnd, FColor::Black, false, GetDeltaFuseTickTime());
		DrawDebugSphere(GetWorld(), TargetUpLocationHit.Location, 10.0f, 16, FColor::Black, false, GetDeltaFuseTickTime());
		// Down trace
		DrawDebugLine(GetWorld(), TraceZStartLocation, TargetDownLocationHit.TraceEnd, FColor::Black, false, GetDeltaFuseTickTime());
		DrawDebugSphere(GetWorld(), TargetDownLocationHit.Location, 10.0f, 16, FColor::Black, false, GetDeltaFuseTickTime());
	}
	
	// Set Z target location
	GrabbedComponentTargetHeight = FMath::Clamp(GrabbedComponentTargetHeight, MinGrabbedComponentHeight - OwnerLocationZ,  MaxGrabbedComponentHeight - OwnerLocationZ);
	TargetLocation.Z = OwnerLocationZ + GrabbedComponentTargetHeight;
	
	
	// Draw debug info if debug is enabled
	if (CVarDrawDebugFuser.GetValueOnGameThread())
	{
		DrawDebugLine(GetWorld(), CameraLoc, TargetLocationHit.TraceEnd, FColor::Cyan, false, GetDeltaFuseTickTime());
		if (bTraceResult)
		{
			DrawDebugSphere(GetWorld(), TargetLocationHit.Location, 10.0f, 16, FColor::Green, false, GetDeltaFuseTickTime());
		}
	}
	
	/* Target rotation */
	
	// Transform local target quaternion to global rotator, rounded to nearest ComponentRotationMultiplier
	FRotator TargetRotation = FRotator(RotateRotator(GetOwnerControlRotationYaw(), FRotator(RoundRotatorToNearestMultiple(GrabbedComponentLocalTargetRotator, ComponentRotationMultiplier))));

	// Apply location and rotation to held fusable target
	SetTargetLocationAndRotation(TargetLocation, TargetRotation);
	
	// Update location and rotation of orthographic projection actor
	if (LastSpawnedOrthoProjectionActor)
	{
		LastSpawnedOrthoProjectionActor->SetActorLocationAndRotation(GetGrabbedComponent()->GetComponentLocation(), GetOwnerControlRotationYaw());
	}

	// Try and find a pair of fuse sockets for the current held fusable
	// Only run this if the control rotation is significantly different to the last tick rotation
	if (!CameraRot.Equals(OwnerCameraRotCached, 2.0f))
    {
		ClearFuseOperationData();
		TryFindIdealFuseSockets(LastFuseOperationData);
    }
    OwnerCameraRotCached = GetOwnerControlRotation();
}

bool UFFuseComponent::TryFindIdealFuseSockets(FFuseOperationData& FuseOperationData)
{
	/*
	 * Finds nearby fusable actors, and loops through all the sockets to find the nearest pair of sockets on the held
	 * fusable and nearby fusables
	 */
	
	if (GetGrabbedComponent() == nullptr) { return false; }

	// Init the socket distance to MaxFuseDistance before starting distance checks
	FuseOperationData.DistanceBetweenSockets = MaxFuseDistance;
	
	// Trace for potential fusables within held fusable bounds + Max fusable distance radius
	TArray<FHitResult> HitResults;
	const FVector TraceLocation =  GetGrabbedComponent()->GetComponentLocation();
	FCollisionObjectQueryParams ObjectQueryParams;
	ObjectQueryParams.AddObjectTypesToQuery(ECC_PhysicsBody);
	FCollisionQueryParams CollisionParams;
	CollisionParams.AddIgnoredComponent(GetGrabbedComponent());
	FCollisionShape CollisionShape;
	const float TraceRadius = GetGrabbedComponent()->GetLocalBounds().SphereRadius + MaxFuseDistance;
	CollisionShape.SetSphere(TraceRadius);

	bool bTraceHit = GetWorld()->SweepMultiByObjectType(
                        HitResults,
                        TraceLocation,
                        TraceLocation,
                        FQuat::Identity,
                        ObjectQueryParams,
                        CollisionShape,
                        CollisionParams);

	if (CVarDrawDebugFuser.GetValueOnGameThread())
    {
    	DrawDebugSphere(GetWorld(), TraceLocation, TraceRadius, 16, FColor::Green, false, GetDeltaFuseTickTime());
    }
	
	if (bTraceHit)
	{
		for (FHitResult HitResult : HitResults)
		{
			// Check that the active hit result hit a fusable component
			if (!IsComponentFusable(HitResult)) { continue; }
			
            // Find the nearest two sockets of the two fusables within a max distance
            // Might be a better way to do this than a nested for each loop
            for (FName SourceSocketName : GetGrabbedComponent()->GetAllSocketNames())
            {
                if (SourceSocketName.ToString().Contains(FusableSocketSubName))
                {
                    for (FName TargetSocketName : HitResult.GetComponent()->GetAllSocketNames())
                    {
                        if (TargetSocketName.ToString().Contains(FusableSocketSubName))
                        {
                        	// Check that the latest socket distance is shorter than any previous checks this tick
                        	if (const float SocketDistance = FVector::Distance(
		                            GetGrabbedComponent()->GetSocketLocation(SourceSocketName),
		                            HitResult.GetComponent()->GetSocketLocation(TargetSocketName)) < FuseOperationData.
	                            DistanceBetweenSockets)
                        	{
                        		// Check if the source would collide with the target if transformed to the relevant socket
                        		TArray<FOverlapResult> ComponentOverlapResults;
                        		
                        		FTransform SourceTargetTransform = FindSourceFusableTargetTransform(GetGrabbedComponent(), SourceSocketName, HitResult.GetComponent(), TargetSocketName);
                        		FVector SourceTargetLocation = SourceTargetTransform.GetLocation();
                        		FRotator SourceTargetRotation = FRotator(SourceTargetTransform.GetRotation());
                        		
                        		FComponentQueryParams ComponentQueryParams;
                        		ComponentQueryParams.AddIgnoredComponent(GetGrabbedComponent());
                        		FCollisionObjectQueryParams ComponentObjectQueryParams;
                        		ComponentObjectQueryParams.AddObjectTypesToQuery(ECC_PhysicsBody);
                        		
                        		bool bCollidesOtherFusable = GetWorld()->ComponentOverlapMulti(ComponentOverlapResults, GetGrabbedComponent(),
                                                                  SourceTargetLocation, SourceTargetRotation,
                                                                  ComponentQueryParams, ComponentObjectQueryParams);
								
                        		/*// Loop through source hits to check if any are fusable objects
                        		// If any are, then this will be considered an invalid operation due to a likely collision
                        		bool bCollidesOtherFusable;
                        		for (FOverlapResult OverlapResult : ComponentOverlapResults)
                        		{
                        			TArray<FName> OverlappedCompSocketNames = OverlapResult.Component->GetAllSocketNames();
                        			for (FName SocketName : OverlappedCompSocketNames)
                        			{
	                                    if (SocketName.ToString().Contains("Attach"))
	                                    {
		                                    bCollidesOtherFusable = true;
	                                    	break;
	                                    }
                        			}
                                    if (bCollidesOtherFusable) { break; }
                        		}*/

                        		// Draw coloured debug capsules to represent possible locations and their collision validity
                        		if (CVarDrawDebugFuser.GetValueOnGameThread())
                        		{
                        			DrawDebugCapsule(GetWorld(), SourceTargetLocation, 30.0f, 10.0f,
	                                                 FQuat(SourceTargetRotation),
	                                                 bCollidesOtherFusable ? FColor::Red : FColor::Blue, false, GetDeltaFuseTickTime(), 1, 5);
                        		}
                        		
                        		// If all checks have passed, promote this loop's sockets as the best operation data
                                if (!bCollidesOtherFusable)
                                {
                                	FuseOperationData.bHasValidFuse = true;
                                	FuseOperationData.DistanceBetweenSockets = SocketDistance;
                                	FuseOperationData.IdealSoureObjectSocket = SourceSocketName;
                                	FuseOperationData.IdealTargetComponent = HitResult.GetComponent();
                                	FuseOperationData.IdealTargetObjectSocket = TargetSocketName;
                                }
                        	}
                        }
                    }
                }
            }
		}
	}
	
	// Get all the socket pairs that are very close together where the fused objects would be, to spawn constraints at those too
	if (FuseOperationData.bHasValidFuse)
	{
		FTransform SourceTargetTransform = FindSourceFusableTargetTransform(GetGrabbedComponent(), FuseOperationData.IdealSoureObjectSocket, FuseOperationData.IdealTargetComponent, FuseOperationData.IdealTargetObjectSocket);
		for (FName SourceSocket : GetGrabbedComponent()->GetAllSocketNames())
		{
			if (SourceSocket != FuseOperationData.IdealSoureObjectSocket)
			{
				for (FName TargetSocket : FuseOperationData.IdealTargetComponent->GetAllSocketNames())
				{
					if (TargetSocket != FuseOperationData.IdealTargetObjectSocket)
					{
						// Get the location of the socket at the target location of the source component
						const FVector SourceSocketLocation = GetGrabbedComponent()->GetSocketLocation(SourceSocket);
						const FVector SourceSocketRelativeLocation = GetGrabbedComponent()->GetComponentTransform().InverseTransformPosition(SourceSocketLocation);
						const FVector SourceSocketTargetLocation = SourceTargetTransform.TransformPosition(SourceSocketRelativeLocation);

						// Check if the distance between the sockets is within a threshold
                        // if the sockets are in that threshold, add them as supplimentary sockets
						if (FuseOperationData.IdealTargetComponent->GetSocketLocation(TargetSocket).Equals(SourceSocketTargetLocation, 5.0f))
						{
							FSupplementalFuseSocketPairs SocketPair;
							SocketPair.SourceSocket = SourceSocket;
							SocketPair.TargetSocket = TargetSocket;
							FuseOperationData.SupplementalSocketPairs.Add(SocketPair);
						}
					}
				}
			}
		}
		
		// draw debug line if debug is enabled
		if (CVarDrawDebugFuser.GetValueOnGameThread())
		{
			const FVector DebugLineStartLoc = GetGrabbedComponent()->GetSocketLocation(FuseOperationData.IdealSoureObjectSocket);
            const FVector DebugLineEndLoc = FuseOperationData.IdealTargetComponent->GetSocketLocation(FuseOperationData.IdealTargetObjectSocket);
            DrawDebugDirectionalArrow(GetWorld(), DebugLineStartLoc, DebugLineEndLoc, 10.0f, FColor::Orange, false, 0.05f, 1, 5.0f);
			for (FSupplementalFuseSocketPairs SocketPair : FuseOperationData.SupplementalSocketPairs)
			{
				const FVector SuppLineStart = GetGrabbedComponent()->GetSocketLocation(SocketPair.SourceSocket);
				const FVector SuppLineEnd = FuseOperationData.IdealTargetComponent->GetSocketLocation(SocketPair.TargetSocket);
				DrawDebugLine(GetWorld(), SuppLineStart, SuppLineEnd, FColor::Emerald, false, 0.05f, 1, 4.0f);
			}
		}
		return true;
	}
	return false;
}

FTransform UFFuseComponent::FindSourceFusableTargetTransform(UPrimitiveComponent* SourceComponent,
	FName SourceSocketName, UPrimitiveComponent* TargetComponent, FName TargetSocketName)
{
	const FRotator SourceSocketRotation = SourceComponent->GetSocketRotation(SourceSocketName);
                        		
	const FRotator TargetComponentRotation = TargetComponent->GetComponentRotation();
	const FRotator SourceTargetRotation = RotateRotator(
		TargetComponentRotation,
		RoundRotatorToNearestMultiple(
			InverseRotateRotator(TargetComponentRotation, SourceSocketRotation),
			ComponentRotationMultiplier));
                        		
	// Get current location of socket
	const FVector TargetSocketLocation = TargetComponent->GetSocketLocation(TargetSocketName);
	const FVector SourceCurrentSocketLocation = SourceComponent->GetSocketLocation(SourceSocketName);
                        		
	// Convert current location to relative location
	const FVector SourceCurrentRelativeSocketLocation = SourceComponent->GetComponentLocation() - SourceCurrentSocketLocation;
	const FVector SourceTargetZeroedSocketLocation = SourceComponent->GetComponentRotation().UnrotateVector(SourceCurrentRelativeSocketLocation);
                        		
	// Rotate socket by current component rotation
	const FVector SourceTargetRelativeSocketLocation = SourceTargetRotation.RotateVector(SourceTargetZeroedSocketLocation);
                        		
	// Rotate by target component rotation
	const FVector SourceTargetLocation = SourceTargetRelativeSocketLocation + TargetSocketLocation;

	FTransform SourceTargetTransform;
	SourceTargetTransform.SetLocation(SourceTargetLocation);
	SourceTargetTransform.SetRotation(FQuat(SourceTargetRotation));
	return SourceTargetTransform;
}

bool UFFuseComponent::TryFuseObjects()
{
	if (LastFuseOperationData.bHasValidFuse && LastFuseOperationData.IdealTargetComponent)
	{
		// Spawn constraint actor
		LastSpawnedConstraintActor = GetWorld()->SpawnActor<APhysicsConstraintActor>(PhysicsConstraintActor, LastFuseOperationData.IdealTargetComponent->GetComponentLocation(), LastFuseOperationData.IdealTargetComponent->GetComponentRotation());
		
		if (LastSpawnedConstraintActor)
		{
			LastFuseOperationData.IdealSourceComponent = GetGrabbedComponent();
			
			LastSpawnedConstraintActor->GetConstraintComp()->AttachToComponent(LastFuseOperationData.IdealTargetComponent, FAttachmentTransformRules::SnapToTargetNotIncludingScale, LastFuseOperationData.IdealTargetObjectSocket);
			LastSpawnedConstraintActor->GetConstraintComp()->SetAngularTwistLimit(ACM_Locked, 1.0f);
			LastSpawnedConstraintActor->GetConstraintComp()->SetAngularSwing1Limit(ACM_Locked, 1.0f);
			LastSpawnedConstraintActor->GetConstraintComp()->SetAngularSwing2Limit(ACM_Locked, 1.0f);
			
        	ReleaseComponent();
        	
        	UpdateFuserState(FSTATE_ACTIVEFUSING);
            return true;	
		}
	}
	ReleaseComponent();
	UpdateFuserState(FSTATE_NONE);
	return false;
}

void UFFuseComponent::FuseObjects(const float DeltaTime)
{
	/*
	 * This is a fairly unpleasant solution, but it only runs while something is being actively fused so it's not a big hit performance wise
	 * Other solutions caused various issues, mainly clipping or incorrect final locations for constrained objects
	 *
	 * This could be replaced with cleaner logic in a custom UPhysicsConstraintComponent extension, eventually
	 */
	if (LastSpawnedConstraintActor && LastFuseOperationData.IdealSourceComponent && LastFuseOperationData.IdealTargetComponent && LastFuseOperationData.DistanceBetweenSockets < MaxFuseDistance)
	{
		const FTransform SourceTargetTransform = FindSourceFusableTargetTransform(
			LastFuseOperationData.IdealSourceComponent, LastFuseOperationData.IdealSoureObjectSocket,
			LastFuseOperationData.IdealTargetComponent, LastFuseOperationData.IdealTargetObjectSocket);

		// If the total fuse time has exceeded the max before snap, set the location directly
		if (FuseOperationTime > FuseMaxTimeBeforeSnap)
		{
			LastFuseOperationData.IdealSourceComponent->SetWorldLocationAndRotation(SourceTargetTransform.GetLocation(), SourceTargetTransform.GetRotation(), false, nullptr, ETeleportType::ResetPhysics);
		}
		
		// Check if the interp is done
        if (SourceTargetTransform.GetLocation().Equals(LastFuseOperationData.IdealSourceComponent->GetComponentLocation(),0.5f) &&
	        SourceTargetTransform.GetRotation().Equals(FQuat(LastFuseOperationData.IdealSourceComponent->GetComponentRotation()), 0.2f))
        {
        	// Ensure that the constraint and physics are set up if we had to interp it without physics
            if (FuseOperationTime > FuseInterpOperationMaxTime)
            {
	            LastSpawnedConstraintActor->GetConstraintComp()->SetConstrainedComponents(LastFuseOperationData.IdealTargetComponent, "None", LastFuseOperationData.IdealSourceComponent, "None");
                LastFuseOperationData.IdealSourceComponent->SetSimulatePhysics(true);
            	LastFuseOperationData.IdealTargetComponent->SetSimulatePhysics(true);
            }
        	LastSpawnedConstraintActor->GetConstraintComp()->SetAngularTwistLimit(ACM_Limited, 1.0f);
        	LastSpawnedConstraintActor->GetConstraintComp()->SetAngularSwing1Limit(ACM_Limited, 1.0f);
        	LastSpawnedConstraintActor->GetConstraintComp()->SetAngularSwing2Limit(ACM_Limited, 1.0f);
			FuseOperationTime = 0.0f;
        	EndFuseObjects();
        	return;
        }
		
		// Increment the fuse operation time
		FuseOperationTime += DeltaTime;
		// Break constraint
		LastSpawnedConstraintActor->GetConstraintComp()->BreakConstraint();
		LastFuseOperationData.IdealSourceComponent->SetSimulatePhysics(false);
		// Lerp the target transform
        const FVector InterpSourceTargetLocation = FMath::VInterpTo(LastFuseOperationData.IdealSourceComponent->GetComponentLocation(), SourceTargetTransform.GetLocation(), DeltaTime, FuseInterpSpeed);
        const FRotator InterpSourceTargetRotation = FMath::RInterpTo(LastFuseOperationData.IdealSourceComponent->GetComponentRotation(), SourceTargetTransform.Rotator(), DeltaTime, FuseInterpSpeed);
        // Set the new transform
        LastFuseOperationData.IdealSourceComponent->SetWorldLocationAndRotation(InterpSourceTargetLocation, InterpSourceTargetRotation, false, nullptr, ETeleportType::ResetPhysics);
		
		// If the total time exceeds the max time, don't reenable the constraint or physics until the interp is done
		if (FuseOperationTime <= FuseInterpOperationMaxTime)
		{
			// Re-constrain the objects
        	LastSpawnedConstraintActor->GetConstraintComp()->SetConstrainedComponents(LastFuseOperationData.IdealTargetComponent, "None", LastFuseOperationData.IdealSourceComponent, "None");
        	LastFuseOperationData.IdealSourceComponent->SetSimulatePhysics(true);
			return;
		}
		// If the constraint exceeds the max time, disable physics on the target object too to avoid particularly bad physics clipping issues
		LastFuseOperationData.IdealTargetComponent->SetSimulatePhysics(false); 
	}
}

void UFFuseComponent::EndFuseObjects()
{
	// Spawn additional physics constraints on supplementary sockets
	// This only applies to the target component, but could be applied to other objects in the same construction
	for (const FSupplementalFuseSocketPairs SocketPair : LastFuseOperationData.SupplementalSocketPairs)
	{
		if (const APhysicsConstraintActor* SpawnedConstraintActor = GetWorld()->SpawnActor<APhysicsConstraintActor>(PhysicsConstraintActor, LastFuseOperationData.IdealTargetComponent->GetComponentLocation(), LastFuseOperationData.IdealTargetComponent->GetComponentRotation()))
		{
			SpawnedConstraintActor->GetConstraintComp()->AttachToComponent(LastFuseOperationData.IdealTargetComponent, FAttachmentTransformRules::SnapToTargetNotIncludingScale, SocketPair.TargetSocket);
			SpawnedConstraintActor->GetConstraintComp()->SetConstrainedComponents(LastFuseOperationData.IdealTargetComponent, "None", LastFuseOperationData.IdealSourceComponent, "None");
		}
	}
	ClearFuseOperationData();
    // Reset fuse state
    UpdateFuserState(FSTATE_NONE);
}

bool UFFuseComponent::TryDetachGrabbedComponent()
{
	// Finds the nearby fusable components, gets the attached constraints and searches through them to try find this component in its constraints
	// Not an ideal solution, would be redesigned so that constraints components are part of a large actor so that the components and their relationships could be easily searched through
	if (GetCurrentFuseState() == FSTATE_FUSING && GetGrabbedComponent())
	{
		TArray<AActor*> AttachedActors;
		// Get attached actors for the grabbed comp
		GetGrabbedComponent()->GetOwner()->GetAttachedActors(AttachedActors);
		// Get attached actors for nearby comps
		TArray<FHitResult> HitResults;
		const FVector TraceLocation =  GetGrabbedComponent()->GetComponentLocation();
		FCollisionObjectQueryParams ObjectQueryParams;
		ObjectQueryParams.AddObjectTypesToQuery(ECC_PhysicsBody);
		FCollisionQueryParams CollisionParams;
		CollisionParams.AddIgnoredComponent(GetGrabbedComponent());
		FCollisionShape CollisionShape;
		const float TraceRadius = GetGrabbedComponent()->GetLocalBounds().SphereRadius + 10.0f;
		CollisionShape.SetSphere(TraceRadius);

		if (GetWorld()->SweepMultiByObjectType(
							HitResults,
							TraceLocation,
							TraceLocation,
							FQuat::Identity,
							ObjectQueryParams,
							CollisionShape,
							CollisionParams))
		{
			for (FHitResult HitResult : HitResults)
			{
				
				HitResult.GetActor()->GetAttachedActors(AttachedActors, false, false);

			}
		}
		
		// Find physics constraint actors within the attached actors, break their constraints and destroy them
		for (AActor* AttachedActor : AttachedActors)
		{
			if (APhysicsConstraintActor* ConstraintActor = Cast<APhysicsConstraintActor>(AttachedActor))
			{
				// Get both the constrained components and break the constraint if either match the grabbed component
				UPrimitiveComponent* ConstrainedCompA;
				FName ConstrainedCompASocket;
				UPrimitiveComponent* ConstrainedCompB;
				FName ConstrainedCompBSocket;
				ConstraintActor->GetConstraintComp()->GetConstrainedComponents(ConstrainedCompA, ConstrainedCompASocket, ConstrainedCompB, ConstrainedCompBSocket);
				if (GetGrabbedComponent() == ConstrainedCompA || GetGrabbedComponent() == ConstrainedCompB)
				{
					ConstraintActor->GetConstraintComp()->BreakConstraint();
                	ConstraintActor->Destroy();	
				}

			}
		}
	}
	return false;
}

void UFFuseComponent::ClearFuseOperationData()
{
	FFuseOperationData ClearedOperationData;
	LastFuseOperationData = ClearedOperationData;
}

bool UFFuseComponent::GetFuseComponentDebugState()
{
	return CVarDrawDebugFuser.GetValueOnGameThread();
}



FRotator UFFuseComponent::GetOwnerControlRotation() const
{
	return OwningCharacterController->GetControlRotation();
}

FRotator UFFuseComponent::GetOwnerControlRotationYaw() const
{
	FRotator PlayerXYControlRot = GetOwnerControlRotation();
 	PlayerXYControlRot.Pitch = 0.0f;
 	PlayerXYControlRot.Roll = 0.0f;
 	return PlayerXYControlRot;
}

FRotator UFFuseComponent::RotateRotator(FRotator RotA, FRotator RotB)
{
	return FRotator(FQuat(RotA) * FQuat(RotB));
}

FRotator UFFuseComponent::InverseRotateRotator(FRotator RotA, FRotator RotB)
{
	return FRotator(FQuat(RotA.GetInverse()) * FQuat(RotB));
}

float UFFuseComponent::RoundFloatToNearestMultiple(float Value, float Multiple) const
{
	return FMath::RoundToFloat(Value/Multiple) * Multiple;
}

FRotator UFFuseComponent::RoundRotatorToNearestMultiple(FRotator InRotator, float Multiple) const
{
	const FRotator OldRot = InRotator;
	FRotator NewRot;
	NewRot.Pitch = RoundFloatToNearestMultiple(OldRot.Pitch, Multiple);
	NewRot.Yaw = RoundFloatToNearestMultiple(OldRot.Yaw, Multiple);
	NewRot.Roll = RoundFloatToNearestMultiple(OldRot.Roll, Multiple);
	return NewRot;
}


```

`Source/Fuse/FFuseComponent.h`:

```h

#pragma once

#include "CoreMinimal.h"
#include "PhysicsEngine/PhysicsHandleComponent.h"
#include "PhysicsEngine/PhysicsConstraintActor.h"
#include "FFuseComponent.generated.h"

// Enum for tracking the current state of the fuser (owning character)
UENUM(BlueprintType)
enum EFuserState
{
	FSTATE_NONE			UMETA(DisplayName = "None"),
	FSTATE_SEARCHING	UMETA(DisplayName = "Searching"),
	FSTATE_FUSING		UMETA(DisplayName = "Fusing"),
	FSTATE_ACTIVEFUSING	UMETA(DisplayName = "Active Fusing")
};

// Struct for containing data on supplemental fuse operations
USTRUCT(BlueprintType)
struct FSupplementalFuseSocketPairs
{
	// Supplemental socket on the target component
	GENERATED_BODY()
	UPROPERTY(BlueprintReadOnly, Category = "Fuse")

	// Supplemental socket on the source component
	FName TargetSocket;
	UPROPERTY(BlueprintReadOnly, Category = "Fuse")
	FName SourceSocket;
};

// Struct for containing data on potential fuse operations
USTRUCT(BlueprintType)
struct FFuseOperationData
{
	GENERATED_BODY()

	UPROPERTY(BlueprintReadOnly, Category = "Fuse")
	bool bHasValidFuse = false;
	
	// Distance between the two sockets
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Fuse")
	float DistanceBetweenSockets;

	// Pointer to the source object
	UPROPERTY(BlueprintReadOnly)
	UPrimitiveComponent* IdealSourceComponent;
	
	// Socket on the held object
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Fuse")
	FName IdealSoureObjectSocket;

	// Pointer to the target object
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Fuse")
	UPrimitiveComponent* IdealTargetComponent;
	
	// Socket on the target object
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Fuse")
	FName IdealTargetObjectSocket;

	// Socket on the target object
	UPROPERTY(EditAnywhere, BlueprintReadWrite, Category = "Fuse")
	TArray<FSupplementalFuseSocketPairs> SupplementalSocketPairs;
};

DECLARE_DYNAMIC_MULTICAST_DELEGATE_TwoParams(FOnFuserStateChanged, EFuserState, NewState, EFuserState, PreviousState);

UCLASS( ClassGroup=(Custom), meta=(BlueprintSpawnableComponent) )
class FUSE_API UFFuseComponent : public UPhysicsHandleComponent
{
	GENERATED_BODY()

protected:
	// Called when the game starts
	virtual void BeginPlay() override;

	virtual void TickComponent(float DeltaTime, ELevelTick TickType, FActorComponentTickFunction* ThisTickFunction) override;
public:

	// Overwritten to allow resetting custom depth and tags
	virtual void ReleaseComponent() override;

#pragma region ExposedFunctions
	
	// Manually update the fuser state
	// Generally should be updated through functions like TryStartSearching
	// or TryGrabTargetedFusable
    UFUNCTION(BlueprintCallable, Category = "Fuse")
    bool UpdateFuserState(EFuserState NewState);

	// Try to enter the searching state
	// will fail if the state is fusing or is already searching
	UFUNCTION(BlueprintCallable, Category = "Fuse")
	bool TryStartSearching();

	// Try to exit the searching state
	// Will also exit fusing state and drop held fusables
	// will fail if the state is none
	UFUNCTION(BlueprintCallable, Category = "Fuse")
	bool TryStopSearching();
	
	// Try and grab the targeted fusable component
	// Requires fuser state to be Searching
	// If successful, will change fuser state to Fusing
	UFUNCTION(BlueprintCallable, Category = "Fuse")
	bool TryGrabTargetedFusable();

	// Adjust the target distance of the grabbed component by a delta
	// Value will be reset when a component is grabbed
	UFUNCTION(BlueprintCallable, Category = "Fuse")
	void AdjustGrabbedComponentTargetDistance(float Delta);

	// Add to the held component rotation
	UFUNCTION(BlueprintCallable, Category = "Fuse")
	void AdjustGrabbedComponentTargetRotation(float YawInput, float PitchInput);

	// Adjust the held component height
	UFUNCTION(BlueprintCallable, Category = "Fuse")
	void AdjustGrabbedComponentTargetHeight(float Delta);

	// Try to find and fuse a held object with an adjacent object
	UFUNCTION(BlueprintCallable, Category = "Fuse")
	bool TryFuseObjects();

	// Get the state of cvar f.drawdebugfuser for drawing additional fuse component debug info
	UFUNCTION(BlueprintPure, Category = "Fuse")
	static bool GetFuseComponentDebugState();

	UFUNCTION(BlueprintCallable, Category = "Fuse")
	bool TryDetachGrabbedComponent();
	
#pragma endregion

#pragma region ExposedVars
	
	// Subname included in the socket names of attachable sockets
	// eg. "Attach" for "Attach01", "Attach02" etc.
	UPROPERTY(EditDefaultsOnly, Category = "Fusable")
	FString FusableSocketSubName = "Attach";
	
	// Minimum distance for the grabbed component to be from the component owner
	// Additive to the bounds radius of the grabbed object
	UPROPERTY(EditDefaultsOnly, Category = "Fuse", meta = (ClampMin = 15.0f, ClampMax = 150.0f))
	float MinGrabbedComponentTargetDistance = 50.0f;

	// Maximum distance for the grabbed component to be from the component owner
	// Must be less than the min distance
	UPROPERTY(EditDefaultsOnly, Category = "Fuse", meta = (ClampMin = 200.0f, ClampMax = 2000.0f))
	float MaxGrabbedComponentTargetDistance = 1000.0f;
	
	// Max positive and negative Z offset height for grabbed components, relative to the owning character
	UPROPERTY(EditDefaultsOnly, Category = "Fuse")
	float MaxGrabbedComponentTargetHeight = 500.0f;
	
	// Times the component updates per second
	UPROPERTY(EditDefaultsOnly, Category = "Fuse", meta = (ClampMin = 10, ClampMax = 30))
	int ComponentUpdateRate = 30;

	// Distance to trace when searching for fusable objects
	UPROPERTY(EditDefaultsOnly, Category = "Fuse", meta = (ClampMin = 256.0f, ClampMax = 2000.0f))
	float SearchTraceDistance = 1000.0f;

	// Radius to trace when searching for fusable objects
	UPROPERTY(EditDefaultsOnly, Category = "Fuse", meta = (ClampMin = 1.0f, ClampMax = 50.0f))
	float SearchTraceRadius = 16.0f;

	// Multiplier for rotation values input in AdjustGrabbedComponentTargetRotation
	UPROPERTY(EditDefaultsOnly, Category = "Fuse")
	float ComponentRotationMultiplier = 45.0f;

	// The specific physics constraint actor to spawn when constraining fusables
	UPROPERTY(EditDefaultsOnly, Category = "Fuse")
	TSubclassOf<APhysicsConstraintActor> PhysicsConstraintActor = APhysicsConstraintActor::StaticClass();
	
	// Maximum distance for object fusing
	UPROPERTY(EditDefaultsOnly, Category = "Fuse", meta = (ClampMin = 5.0f, ClampMax = 200.0f))
	float MaxFuseDistance = 75.0f;

	// Speed at which to interpolate fused components together when fusing
	UPROPERTY(EditDefaultsOnly, Category = "Fuse")
	float FuseInterpSpeed = 10.0f;

	// Max time for a physics based interp to take before the fuse object ignores collisions and interps directly
	UPROPERTY(EditDefaultsOnly, Category = "Fuse")
	float FuseInterpOperationMaxTime = 1.5f;

	// Max time for a fuse interp operation before it just sets the location directly
	// In theory the non-physics fuse should prevent this from triggering, but it's here as a failsafe
	UPROPERTY(EditDefaultsOnly, Category = "Fuse")
	float FuseMaxTimeBeforeSnap = 10.0f;

	// Actor responsible for orthographic decal projection
	UPROPERTY(EditDefaultsOnly, Category = "Fuse")
	TSubclassOf<AActor> OrthographicProjectionActor;
	
	// A trace channel that should be ignored by fusables
	// This is to prevent held objects from seeing each other as an
	// obstacle for the target distance
	// Not used for the initial trace to find fusables
	UPROPERTY(EditDefaultsOnly, Category = "Fuse")
	TEnumAsByte<ECollisionChannel> FusableIgnoredTraceChannel = ECC_Camera;

	// Blueprint event for fuser state changed
	UPROPERTY(BlueprintAssignable, Category = "Fuse")
	FOnFuserStateChanged OnFuserStateChanged;

#pragma endregion
	
	/* * Getters */

	// Get the current fuse state
	UFUNCTION(BlueprintPure, Category = "Fuse")
	EFuserState GetCurrentFuseState() const {return CurrentFuserState;}

	// Is the owning pawn of this component currently in a fusing state
	UFUNCTION(BlueprintPure, Category = "Fuse")
	bool IsFusing() const {return !CurrentFuserState == FSTATE_NONE;}

	// Getter for 1 / Increment time, only used for debug drawing since it's not a concrete value
	UFUNCTION(BlueprintPure, Category = "Fuse")
	float GetDeltaFuseTickTime() const {return 1.0f / ComponentUpdateRate;}

	// Getter for the current grabbed component target distance
	UFUNCTION(BlueprintGetter, Category = "Fuse")
	float GetGrabbedComponentTargetDistance() const {return GrabbedComponentTargetDistance;}
	
private:
	UPROPERTY()
	APlayerController* OwningCharacterController;
	EFuserState CurrentFuserState;
	FHitResult LastSearchHitResult;

	// The most recent fuse data
	// May not be valid
	FFuseOperationData LastFuseOperationData;
	void ClearFuseOperationData();
	
	UPROPERTY()
	AActor* LastSpawnedOrthoProjectionActor;
	
	UPROPERTY()
	APhysicsConstraintActor* LastSpawnedConstraintActor;
	
	UPROPERTY(BlueprintGetter = GetGrabbedComponentTargetDistance)
	float GrabbedComponentTargetDistance;

	float GrabbedComponentTargetHeight;
	
	// Rotator that is transformed to the owner's control rotation space for the final target
	FRotator GrabbedComponentLocalTargetRotator;
	
	// Tick function running on a looped timer
	// Not using PrimaryObjectTick.TickInterval as to not mess with the parent
	void FuseTick();
	FTimerHandle FuseTickTimerHandle;
	
	// Trace for a potential fusable object from the owning character's camera viewpoint
	void SearchForFusable();
	bool IsComponentFusable(FHitResult InHitResult);
	// Update location and rotation of held fusable
	void UpdateHeldFusable();

	// Search for nearby fusable objects and loop through sockets to try and find the best fusable sockets
	bool TryFindIdealFuseSockets(FFuseOperationData& FuseOperationData);

	FTransform FindSourceFusableTargetTransform(UPrimitiveComponent* SourceComponent, FName SourceSocketName,
	                                            UPrimitiveComponent* TargetComponent, FName TargetSocketName);	
	
	void FuseObjects(float DeltaTime);
	float FuseOperationTime;

	void EndFuseObjects();
	
	/* Utility */
	
	// Get the owner control rotation, without pitch or roll
	FRotator GetOwnerControlRotation() const;
	FRotator GetOwnerControlRotationYaw() const;
	FRotator OwnerCameraRotCached;

	// Rotate or inverse rotate rotators
	static FRotator RotateRotator(FRotator RotA, FRotator RotB);
	static FRotator InverseRotateRotator(FRotator RotA, FRotator RotB);
	
	float RoundFloatToNearestMultiple(float Value, float Multiple) const;
	FRotator RoundRotatorToNearestMultiple(FRotator InRotator, float Multiple) const;


};


```

`Source/Fuse/FFuseOrthoProjectionActor.cpp`:

```cpp

#include "FFuseOrthoProjectionActor.h"
#include "Components/DecalComponent.h"
#include "Engine/TextureRenderTarget2D.h"

AFFuseOrthoProjectionActor::AFFuseOrthoProjectionActor()
{
 	// Actor ticks at ProjectionUpdateRate per second
	PrimaryActorTick.bCanEverTick = true;
	PrimaryActorTick.TickInterval = 1 / ProjectionUpdateRate;

	USceneComponent* SceneComponent = CreateDefaultSubobject<USceneComponent>("Scene Component");
	SetRootComponent(SceneComponent);
	SceneCaptureComponentForward = InitSceneCaptureComponent(RenderTargetForward, FRotator::ZeroRotator, "Capture Component Forward");
	SceneCaptureComponentRight = InitSceneCaptureComponent(RenderTargetRight, FRotator(0.0f, 90.0f, 0.0f), "Capture Component Right");
	SceneCaptureComponentUp = InitSceneCaptureComponent(RenderTargetUp, FRotator(-90.0f, 0.0f, 0.0f), "Capture Component Up");
	
}

void AFFuseOrthoProjectionActor::BeginPlay()
{
	Super::BeginPlay();

	DecalComponentForward = InitDecalComponent(RenderTargetForward, FRotator(0.0f, 0.0f, 90.0f));
	DecalComponentRight = InitDecalComponent(RenderTargetRight, FRotator(0.0f, 90.0f, 90.0f));
	DecalComponentUp = InitDecalComponent(RenderTargetUp,FRotator(-90.0f, 0.0f, 90.0f));
}

void AFFuseOrthoProjectionActor::Tick(float DeltaTime)
{
	Super::Tick(DeltaTime);

	SceneCaptureComponentForward->CaptureScene();
	SceneCaptureComponentRight->CaptureScene();
	SceneCaptureComponentUp->CaptureScene();
}

USceneCaptureComponent2D* AFFuseOrthoProjectionActor::InitSceneCaptureComponent(UTextureRenderTarget2D* RenderTarget, FRotator CaptureRotation, FName CompName)
{
	USceneCaptureComponent2D* NewCaptureComponent = CreateDefaultSubobject<USceneCaptureComponent2D>(CompName);
	NewCaptureComponent->SetupAttachment(RootComponent);
	NewCaptureComponent->SetRelativeRotation(CaptureRotation);
	NewCaptureComponent->SetRelativeLocation(CaptureRotation.Vector() * -SceneCaptureComponentDistance);
	
	if (RenderTarget) { NewCaptureComponent->TextureTarget = RenderTargetForward; }
	else { UE_LOG(LogTemp, Error, TEXT("Component %s failed to allocate a render target to a SceneCaptureComponent"), *this->GetName()); }
	
	return NewCaptureComponent;
}

UDecalComponent* AFFuseOrthoProjectionActor::InitDecalComponent(UTextureRenderTarget2D* RenderTarget, FRotator DecalRotation)
{
	if (UDecalComponent* NewDecalComponent = NewObject<UDecalComponent>(this, UDecalComponent::StaticClass()))
	{
		NewDecalComponent->RegisterComponent();
		NewDecalComponent->AttachToComponent(RootComponent, FAttachmentTransformRules::KeepRelativeTransform);
		NewDecalComponent->SetRelativeRotation(DecalRotation);
		if (ProjectionDecalMaterial)
		{
			UE_LOG(LogTemp, Error, TEXT("Component %s failed to set an orthographic projection decal material"), *this->GetName());
			UMaterialInstanceDynamic* DynamicDecalMatInstance = UMaterialInstanceDynamic::Create(ProjectionDecalMaterial, NewDecalComponent);
			if (RenderTarget)
			{
				NewDecalComponent->DecalSize = FVector(DecalLength, RenderTarget->SizeX, RenderTarget->SizeY);
				DynamicDecalMatInstance->SetTextureParameterValue(DecalRenderTargetParameterName, RenderTarget);
				NewDecalComponent->SetDecalMaterial(DynamicDecalMatInstance);
			}
			else { UE_LOG(LogTemp, Error, TEXT("Component %s failed to allocate a render target to a decal dynamic material"), *this->GetName()); }
		}
		return NewDecalComponent;
	}
	UE_LOG(LogTemp, Error, TEXT("Component %s failed to spawn a DecalComponent"), *this->GetName());
	return nullptr;
}



```

`Source/Fuse/FFuseOrthoProjectionActor.h`:

```h

#pragma once

#include "CoreMinimal.h"
#include "Components/SceneCaptureComponent2D.h"
#include "GameFramework/Actor.h"
#include "FFuseOrthoProjectionActor.generated.h"

/*
 *
 * Actor spawned while fusing, used to capture and project orthographic views of the currently fused component.
 * This is using 3 scene capture 2d components, the components should only draw the required elements but it
 * is very costly and could do with a better implementation.
 * 
 */

UCLASS()
class FUSE_API AFFuseOrthoProjectionActor : public AActor
{
	GENERATED_BODY()
	
public:

	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Scene Capture", meta = (AllowPrivateAccess = "true"))
	USceneCaptureComponent2D* SceneCaptureComponentForward;

	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Scene Capture", meta = (AllowPrivateAccess = "true"))
	USceneCaptureComponent2D* SceneCaptureComponentRight;

	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = "Scene Capture", meta = (AllowPrivateAccess = "true"))
	USceneCaptureComponent2D* SceneCaptureComponentUp;
	
	// Per second update rate for scene capture components
	UPROPERTY(EditDefaultsOnly, Category = "Orthographic Projection")
	int32 ProjectionUpdateRate = 30;

	// Material used for decal projection
	UPROPERTY(EditDefaultsOnly, Category = "Orthographic Projection|Decal")
	UMaterialInterface* ProjectionDecalMaterial;

	UPROPERTY(EditDefaultsOnly, Category = "Orthographic Projection|Decal")
	FName DecalRenderTargetParameterName = "RenderTarget";
	
	// Total length of the decal projection
	UPROPERTY(EditDefaultsOnly, Category = "Orthographic Projection|Decal")
	float DecalLength = 1000.0f;
	
	// Render target for the scene capture forward
	UPROPERTY(EditDefaultsOnly, Category = "Orthographic Projection|Render Targets")
	UTextureRenderTarget2D* RenderTargetForward;

	// Render target for the scene capture forward
	UPROPERTY(EditDefaultsOnly, Category = "Orthographic Projection|Render Targets")
	UTextureRenderTarget2D* RenderTargetRight;

	// Render target for the scene capture forward
	UPROPERTY(EditDefaultsOnly, Category = "Orthographic Projection|Render Targets")
	UTextureRenderTarget2D* RenderTargetUp;
	
	// Render target for the scene capture forward
	UPROPERTY(EditDefaultsOnly, Category = "Orthographic Projection")
	TSubclassOf<USceneCaptureComponent2D> SceneCaptureComponentClass = USceneCaptureComponent2D::StaticClass();

	// Distance to place the orthographic captures from the grabbed object
	UPROPERTY(EditDefaultsOnly, Category = "Orthographic Projection")
	float SceneCaptureComponentDistance = 1000.0f;
	
	AFFuseOrthoProjectionActor();
	
protected:
	// Called when the game starts or when spawned
	virtual void BeginPlay() override;

public:	
	// Called every frame
	virtual void Tick(float DeltaTime) override;

private:

	// Component pointers

	UPROPERTY() UDecalComponent* DecalComponentForward;
	UPROPERTY() UDecalComponent* DecalComponentRight;
	UPROPERTY() UDecalComponent* DecalComponentUp;

	// Spawn and set required values for a scene capture component 2D
	USceneCaptureComponent2D* InitSceneCaptureComponent(UTextureRenderTarget2D* RenderTarget, FRotator CaptureRotation, FName CompName);

	// Spawn and set required values for a decal component;
	UDecalComponent* InitDecalComponent(UTextureRenderTarget2D* RenderTarget, FRotator DecalRotation);
};

```

`Source/Fuse/Fuse.Build.cs`:

```cs
// Copyright Epic Games, Inc. All Rights Reserved.

using UnrealBuildTool;

public class Fuse : ModuleRules
{
	public Fuse(ReadOnlyTargetRules Target) : base(Target)
	{
		PCHUsage = PCHUsageMode.UseExplicitOrSharedPCHs;

		PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore", "HeadMountedDisplay", "EnhancedInput" });
	}
}

```

`Source/Fuse/Fuse.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "Fuse.h"
#include "Modules/ModuleManager.h"

IMPLEMENT_PRIMARY_GAME_MODULE( FDefaultGameModuleImpl, Fuse, "Fuse" );
 
```

`Source/Fuse/Fuse.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"

```

`Source/Fuse/FuseCharacter.cpp`:

```cpp
// Copyright Epic Games, Inc. All Rights Reserved.

#include "FuseCharacter.h"
#include "Camera/CameraComponent.h"
#include "Components/CapsuleComponent.h"
#include "Components/InputComponent.h"
#include "GameFramework/CharacterMovementComponent.h"
#include "GameFramework/Controller.h"
#include "GameFramework/SpringArmComponent.h"
#include "EnhancedInputComponent.h"
#include "EnhancedInputSubsystems.h"


//////////////////////////////////////////////////////////////////////////
// AFuseCharacter

AFuseCharacter::AFuseCharacter()
{
	// Set size for collision capsule
	GetCapsuleComponent()->InitCapsuleSize(42.f, 96.0f);
		
	// Don't rotate when the controller rotates. Let that just affect the camera.
	bUseControllerRotationPitch = false;
	bUseControllerRotationYaw = false;
	bUseControllerRotationRoll = false;

	// Configure character movement
	GetCharacterMovement()->bOrientRotationToMovement = true; // Character moves in the direction of input...	
	GetCharacterMovement()->RotationRate = FRotator(0.0f, 500.0f, 0.0f); // ...at this rotation rate

	// Note: For faster iteration times these variables, and many more, can be tweaked in the Character Blueprint
	// instead of recompiling to adjust them
	GetCharacterMovement()->JumpZVelocity = 700.f;
	GetCharacterMovement()->AirControl = 0.35f;
	GetCharacterMovement()->MaxWalkSpeed = 500.f;
	GetCharacterMovement()->MinAnalogWalkSpeed = 20.f;
	GetCharacterMovement()->BrakingDecelerationWalking = 2000.f;

	// Create a camera boom (pulls in towards the player if there is a collision)
	CameraBoom = CreateDefaultSubobject<USpringArmComponent>(TEXT("CameraBoom"));
	CameraBoom->SetupAttachment(RootComponent);
	CameraBoom->TargetArmLength = 400.0f; // The camera follows at this distance behind the character	
	CameraBoom->bUsePawnControlRotation = true; // Rotate the arm based on the controller

	// Create a follow camera
	FollowCamera = CreateDefaultSubobject<UCameraComponent>(TEXT("FollowCamera"));
	FollowCamera->SetupAttachment(CameraBoom, USpringArmComponent::SocketName); // Attach the camera to the end of the boom and let the boom adjust to match the controller orientation
	FollowCamera->bUsePawnControlRotation = false; // Camera does not rotate relative to arm

	// Note: The skeletal mesh and anim blueprint references on the Mesh component (inherited from Character) 
	// are set in the derived blueprint asset named ThirdPersonCharacter (to avoid direct content references in C++)
}

void AFuseCharacter::BeginPlay()
{
	// Call the base class  
	Super::BeginPlay();

	//Add Input Mapping Context
	if (APlayerController* PlayerController = Cast<APlayerController>(Controller))
	{
		if (UEnhancedInputLocalPlayerSubsystem* Subsystem = ULocalPlayer::GetSubsystem<UEnhancedInputLocalPlayerSubsystem>(PlayerController->GetLocalPlayer()))
		{
			Subsystem->AddMappingContext(DefaultMappingContext, 0);
		}
	}
}

//////////////////////////////////////////////////////////////////////////
// Input

void AFuseCharacter::SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent)
{
	// Set up action bindings
	if (UEnhancedInputComponent* EnhancedInputComponent = CastChecked<UEnhancedInputComponent>(PlayerInputComponent)) {
		
		//Moving
		EnhancedInputComponent->BindAction(MoveAction, ETriggerEvent::Triggered, this, &AFuseCharacter::Move);

		//Looking
		EnhancedInputComponent->BindAction(LookAction, ETriggerEvent::Triggered, this, &AFuseCharacter::Look);

	}

}

void AFuseCharacter::Move(const FInputActionValue& Value)
{
	// input is a Vector2D
	FVector2D MovementVector = Value.Get<FVector2D>();

	if (Controller != nullptr)
	{
		// find out which way is forward
		const FRotator Rotation = Controller->GetControlRotation();
		const FRotator YawRotation(0, Rotation.Yaw, 0);

		// get forward vector
		const FVector ForwardDirection = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::X);
	
		// get right vector 
		const FVector RightDirection = FRotationMatrix(YawRotation).GetUnitAxis(EAxis::Y);

		// add movement 
		AddMovementInput(ForwardDirection, MovementVector.Y);
		AddMovementInput(RightDirection, MovementVector.X);
	}
}

void AFuseCharacter::Look(const FInputActionValue& Value)
{
	// input is a Vector2D
	FVector2D LookAxisVector = Value.Get<FVector2D>();

	if (Controller != nullptr)
	{
		// add yaw and pitch input to controller
		AddControllerYawInput(LookAxisVector.X);
		AddControllerPitchInput(LookAxisVector.Y);
	}
}

```

`Source/Fuse/FuseCharacter.h`:

```h
// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "CoreMinimal.h"
#include "GameFramework/Character.h"
#include "InputActionValue.h"
#include "FuseCharacter.generated.h"


UCLASS(config=Game)
class AFuseCharacter : public ACharacter
{
	GENERATED_BODY()

	/** Camera boom positioning the camera behind the character */
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Camera, meta = (AllowPrivateAccess = "true"))
	class USpringArmComponent* CameraBoom;

	/** Follow camera */
	UPROPERTY(VisibleAnywhere, BlueprintReadOnly, Category = Camera, meta = (AllowPrivateAccess = "true"))
	class UCameraComponent* FollowCamera;
	
	/** MappingContext */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = Input, meta = (AllowPrivateAccess = "true"))
	class UInputMappingContext* DefaultMappingContext;

	/** Jump Input Action */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = Input, meta = (AllowPrivateAccess = "true"))
	class UInputAction* JumpAction;

	/** Move Input Action */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = Input, meta = (AllowPrivateAccess = "true"))
	class UInputAction* MoveAction;

	/** Look Input Action */
	UPROPERTY(EditAnywhere, BlueprintReadOnly, Category = Input, meta = (AllowPrivateAccess = "true"))
	class UInputAction* LookAction;

public:
	AFuseCharacter();
	

protected:

	/** Called for movement input */
	void Move(const FInputActionValue& Value);

	/** Called for looking input */
	void Look(const FInputActionValue& Value);

protected:
	// APawn interface
	virtual void SetupPlayerInputComponent(class UInputComponent* PlayerInputComponent) override;
	
	// To add mapping context
	virtual void BeginPlay();

public:
	/** Returns CameraBoom subobject **/
	FORCEINLINE class USpringArmComponent* GetCameraBoom() const { return CameraBoom; }
	/** Returns FollowCamera subobject **/
	FORCEINLINE class UCameraComponent* GetFollowCamera() const { return FollowCamera; }
};


```

`Source/FuseEditor.Target.cs`:

```cs
// Copyright Epic Games, Inc. All Rights Reserved.

using UnrealBuildTool;
using System.Collections.Generic;

public class FuseEditorTarget : TargetRules
{
	public FuseEditorTarget(TargetInfo Target) : base(Target)
	{
		Type = TargetType.Editor;
		DefaultBuildSettings = BuildSettingsVersion.V2;
		IncludeOrderVersion = EngineIncludeOrderVersion.Unreal5_1;
		ExtraModuleNames.Add("Fuse");
	}
}

```