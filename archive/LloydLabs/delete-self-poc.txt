Project Path: arc_LloydLabs_delete-self-poc_lwiz6l4z

Source Tree:

```txt
arc_LloydLabs_delete-self-poc_lwiz6l4z
â”œâ”€â”€ LICENSE
â”œâ”€â”€ README.md
â”œâ”€â”€ main.c
â””â”€â”€ main.h

```

`LICENSE`:

```
MIT License

Copyright (c) 2021 Lloyd

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# ðŸ—‘ï¸ delete-self-poc
The `delete-self-poc` is a demonstration of a method to delete a locked executable or currently running file from disk. This concept was initially discovered by Jonas Lykkegaard, and I have created the proof of concept (POC) for it. Additionally, it can be used to delete locked files on disk, provided that the current calling process has the necessary permissions to access and delete them.

How does this work, though - in this POC?
1. Open a HANDLE to the current running process with DELETE access. Note that only DELETE access is required.
2. Use the SetFileInformationByHandle function to rename the primary file stream, :$DATA, to :wtfbbq.
3. Close the HANDLE.
4. Open a HANDLE to the current process and set the DeleteFile flag of the FileDispositionInfo class to TRUE.
5. Close the HANDLE to trigger the file disposition.
6. Voila! The file is now gone.

# Releases
I have included a statically linked release within this repository, if you can't be bothered compiling the original source code.

```

`main.c`:

```c
#include "main.h"

static
HANDLE
ds_open_handle(
	PWCHAR pwPath
)
{
	return CreateFileW(pwPath, DELETE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
}

static
void *
ds_rename_handle(
	HANDLE hHandle
)
{
	LPCWSTR lpwStream = DS_STREAM_RENAME;
	PFILE_RENAME_INFO pfRename = (PFILE_RENAME_INFO)malloc(sizeof(FILE_RENAME_INFO) + sizeof(WCHAR) * wcslen(lpwStream)); // FILE_RENAME_INFO contains space for 1 WCHAR without NULL-byte
	if(pfRename == NULL)
	{
		DS_DEBUG_LOG(L"could not allocate memory");
		return NULL;
	}
	RtlSecureZeroMemory(pfRename, sizeof(FILE_RENAME_INFO) + sizeof(WCHAR) * wcslen(lpwStream));

	// set our FileNameLength and FileName to DS_STREAM_RENAME
	pfRename->FileNameLength = (DWORD)(sizeof(WCHAR) * wcslen(lpwStream));
	RtlCopyMemory(pfRename->FileName, lpwStream, sizeof(WCHAR) * (wcslen(lpwStream) + 1));

	BOOL fRenameOk = SetFileInformationByHandle(hHandle, FileRenameInfo, pfRename, (DWORD)(sizeof(FILE_RENAME_INFO) + sizeof(WCHAR) * wcslen(lpwStream)));
	if(!fRenameOk)
	{
		free(pfRename);
		return NULL;
	}
	return pfRename;
}

static
BOOL 
ds_deposite_handle(
	HANDLE hHandle
)
{
	// Ref: https://cybersecuritynews.com/windows-11-24h2-disrupts-self-delete/
	FILE_DISPOSITION_INFO_EX fDeleteEx;
	RtlSecureZeroMemory(&fDeleteEx, sizeof(fDeleteEx));

	fDeleteEx.Flags = FILE_DISPOSITION_FLAG_DELETE | FILE_DISPOSITION_FLAG_POSIX_SEMANTICS;

	return SetFileInformationByHandle(hHandle, FileDispositionInfoEx, &fDeleteEx, sizeof(fDeleteEx));
}

int
main(
	int argc,
	char** argv
)
{
	WCHAR wcPath[MAX_PATH + 1];
	RtlSecureZeroMemory(wcPath, sizeof(wcPath));

	// get the path to the current running process ctx
	if (GetModuleFileNameW(NULL, wcPath, MAX_PATH) == 0)
	{
		DS_DEBUG_LOG(L"failed to get the current module handle");
		return 0;
	}

	HANDLE hCurrent = ds_open_handle(wcPath);
	if (hCurrent == INVALID_HANDLE_VALUE)
	{
		DS_DEBUG_LOG(L"failed to acquire handle to current running process");
		return 0;
	}

	// rename the associated HANDLE's file name
	DS_DEBUG_LOG(L"attempting to rename file name");
	void *pfRename = ds_rename_handle(hCurrent);
	if (pfRename == NULL)
	{
		DS_DEBUG_LOG(L"failed to rename to stream");
		return 0;
	}

	DS_DEBUG_LOG(L"successfully renamed file primary :$DATA ADS to specified stream, closing initial handle");
	CloseHandle(hCurrent);
	free(pfRename); // free memory allocated in ds_rename_handle
	pfRename = NULL;

	// open another handle, trigger deletion on close
	hCurrent = ds_open_handle(wcPath);
	if (hCurrent == INVALID_HANDLE_VALUE)
	{
		DS_DEBUG_LOG(L"failed to reopen current module");
		return 0;
	}

	if (!ds_deposite_handle(hCurrent))
	{
		DS_DEBUG_LOG(L"failed to set delete deposition");
		return 0;
	}

	// trigger the deletion deposition on hCurrent
	DS_DEBUG_LOG(L"closing handle to trigger deletion deposition");
	CloseHandle(hCurrent);

	// verify we've been deleted
	if (PathFileExistsW(wcPath))
	{
		DS_DEBUG_LOG(L"failed to delete copy, file still exists");
		return 0;
	}

	DS_DEBUG_LOG(L"successfully deleted self from disk");
	return 1;
}

```

`main.h`:

```h
#pragma once

#pragma comment(lib, "Shlwapi.lib")

#include <Windows.h>
#include <shlwapi.h>
#include <stdio.h>
#include <stdlib.h>

#define DS_STREAM_RENAME L":dsl"
#define DS_DEBUG_LOG(msg) wprintf(L"[LOG] - %s\n", msg)
```